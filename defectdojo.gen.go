// Package DefectDojoAPIV2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package DefectDojoAPIV2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"gopkg.in/yaml.v2"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	BasicAuthScopes  = "basicAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
	TokenAuthScopes  = "tokenAuth.Scopes"
)

// Defines values for DojoGroupSocialProvider.
const (
	DojoGroupSocialProviderAzureAD DojoGroupSocialProvider = "AzureAD"

	DojoGroupSocialProviderEmpty DojoGroupSocialProvider = ""

	DojoGroupSocialProviderNil DojoGroupSocialProvider = "<nil>"
)

// Defines values for DojoGroupRequestSocialProvider.
const (
	DojoGroupRequestSocialProviderAzureAD DojoGroupRequestSocialProvider = "AzureAD"

	DojoGroupRequestSocialProviderEmpty DojoGroupRequestSocialProvider = ""

	DojoGroupRequestSocialProviderNil DojoGroupRequestSocialProvider = "<nil>"
)

// Defines values for EngagementEngagementType.
const (
	EngagementEngagementTypeCICD EngagementEngagementType = "CI/CD"

	EngagementEngagementTypeInteractive EngagementEngagementType = "Interactive"

	EngagementEngagementTypeNil EngagementEngagementType = "<nil>"
)

// Defines values for EngagementStatus.
const (
	EngagementStatusBlocked EngagementStatus = "Blocked"

	EngagementStatusCancelled EngagementStatus = "Cancelled"

	EngagementStatusCompleted EngagementStatus = "Completed"

	EngagementStatusInProgress EngagementStatus = "In Progress"

	EngagementStatusNil EngagementStatus = "<nil>"

	EngagementStatusNotStarted EngagementStatus = "Not Started"

	EngagementStatusOnHold EngagementStatus = "On Hold"

	EngagementStatusWaitingForResource EngagementStatus = "Waiting for Resource"
)

// Defines values for EngagementRequestEngagementType.
const (
	EngagementRequestEngagementTypeCICD EngagementRequestEngagementType = "CI/CD"

	EngagementRequestEngagementTypeInteractive EngagementRequestEngagementType = "Interactive"

	EngagementRequestEngagementTypeNil EngagementRequestEngagementType = "<nil>"
)

// Defines values for EngagementRequestStatus.
const (
	EngagementRequestStatusBlocked EngagementRequestStatus = "Blocked"

	EngagementRequestStatusCancelled EngagementRequestStatus = "Cancelled"

	EngagementRequestStatusCompleted EngagementRequestStatus = "Completed"

	EngagementRequestStatusInProgress EngagementRequestStatus = "In Progress"

	EngagementRequestStatusNil EngagementRequestStatus = "<nil>"

	EngagementRequestStatusNotStarted EngagementRequestStatus = "Not Started"

	EngagementRequestStatusOnHold EngagementRequestStatus = "On Hold"

	EngagementRequestStatusWaitingForResource EngagementRequestStatus = "Waiting for Resource"
)

// Defines values for ImportScanGroupBy.
const (
	ImportScanGroupByComponentName ImportScanGroupBy = "component_name"

	ImportScanGroupByComponentNameComponentVersion ImportScanGroupBy = "component_name+component_version"

	ImportScanGroupByFilePath ImportScanGroupBy = "file_path"
)

// Defines values for ImportScanMinimumSeverity.
const (
	ImportScanMinimumSeverityCritical ImportScanMinimumSeverity = "Critical"

	ImportScanMinimumSeverityHigh ImportScanMinimumSeverity = "High"

	ImportScanMinimumSeverityInfo ImportScanMinimumSeverity = "Info"

	ImportScanMinimumSeverityLow ImportScanMinimumSeverity = "Low"

	ImportScanMinimumSeverityMedium ImportScanMinimumSeverity = "Medium"
)

// Defines values for ImportScanScanType.
const (
	ImportScanScanTypeAWSProwlerScan ImportScanScanType = "AWS Prowler Scan"

	ImportScanScanTypeAWSScout2Scan ImportScanScanType = "AWS Scout2 Scan"

	ImportScanScanTypeAWSSecurityHubScan ImportScanScanType = "AWS Security Hub Scan"

	ImportScanScanTypeAcunetix360Scan ImportScanScanType = "Acunetix360 Scan"

	ImportScanScanTypeAcunetixScan ImportScanScanType = "Acunetix Scan"

	ImportScanScanTypeAnchoreCTLPoliciesReport ImportScanScanType = "AnchoreCTL Policies Report"

	ImportScanScanTypeAnchoreCTLVulnReport ImportScanScanType = "AnchoreCTL Vuln Report"

	ImportScanScanTypeAnchoreEngineScan ImportScanScanType = "Anchore Engine Scan"

	ImportScanScanTypeAnchoreEnterprisePolicyCheck ImportScanScanType = "Anchore Enterprise Policy Check"

	ImportScanScanTypeAnchoreGrype ImportScanScanType = "Anchore Grype"

	ImportScanScanTypeAppSpiderScan ImportScanScanType = "AppSpider Scan"

	ImportScanScanTypeAquaScan ImportScanScanType = "Aqua Scan"

	ImportScanScanTypeArachniScan ImportScanScanType = "Arachni Scan"

	ImportScanScanTypeAuditJSScan ImportScanScanType = "AuditJS Scan"

	ImportScanScanTypeAzureSecurityCenterRecommendationsScan ImportScanScanType = "Azure Security Center Recommendations Scan"

	ImportScanScanTypeBanditScan ImportScanScanType = "Bandit Scan"

	ImportScanScanTypeBlackDuckAPI ImportScanScanType = "BlackDuck API"

	ImportScanScanTypeBlackduckComponentRisk ImportScanScanType = "Blackduck Component Risk"

	ImportScanScanTypeBlackduckHubScan ImportScanScanType = "Blackduck Hub Scan"

	ImportScanScanTypeBrakemanScan ImportScanScanType = "Brakeman Scan"

	ImportScanScanTypeBugCrowdScan ImportScanScanType = "BugCrowd Scan"

	ImportScanScanTypeBugcrowdAPIImport ImportScanScanType = "Bugcrowd API Import"

	ImportScanScanTypeBundlerAuditScan ImportScanScanType = "Bundler-Audit Scan"

	ImportScanScanTypeBurpEnterpriseScan ImportScanScanType = "Burp Enterprise Scan"

	ImportScanScanTypeBurpGraphQLAPI ImportScanScanType = "Burp GraphQL API"

	ImportScanScanTypeBurpRESTAPI ImportScanScanType = "Burp REST API"

	ImportScanScanTypeBurpScan ImportScanScanType = "Burp Scan"

	ImportScanScanTypeCargoAuditScan ImportScanScanType = "CargoAudit Scan"

	ImportScanScanTypeCheckmarxOSA ImportScanScanType = "Checkmarx OSA"

	ImportScanScanTypeCheckmarxScan ImportScanScanType = "Checkmarx Scan"

	ImportScanScanTypeCheckmarxScanDetailed ImportScanScanType = "Checkmarx Scan detailed"

	ImportScanScanTypeCheckovScan ImportScanScanType = "Checkov Scan"

	ImportScanScanTypeClairKlarScan ImportScanScanType = "Clair Klar Scan"

	ImportScanScanTypeClairScan ImportScanScanType = "Clair Scan"

	ImportScanScanTypeCloudsploitScan ImportScanScanType = "Cloudsploit Scan"

	ImportScanScanTypeCobaltIoAPIImport ImportScanScanType = "Cobalt.io API Import"

	ImportScanScanTypeCobaltIoScan ImportScanScanType = "Cobalt.io Scan"

	ImportScanScanTypeContrastScan ImportScanScanType = "Contrast Scan"

	ImportScanScanTypeCoverityAPI ImportScanScanType = "Coverity API"

	ImportScanScanTypeCrashtestSecurityJSONFile ImportScanScanType = "Crashtest Security JSON File"

	ImportScanScanTypeCrashtestSecurityXMLFile ImportScanScanType = "Crashtest Security XML File"

	ImportScanScanTypeCredScanScan ImportScanScanType = "CredScan Scan"

	ImportScanScanTypeCycloneDXScan ImportScanScanType = "CycloneDX Scan"

	ImportScanScanTypeDSOPScan ImportScanScanType = "DSOP Scan"

	ImportScanScanTypeDawnScannerScan ImportScanScanType = "DawnScanner Scan"

	ImportScanScanTypeDependencyCheckScan ImportScanScanType = "Dependency Check Scan"

	ImportScanScanTypeDependencyTrackFindingPackagingFormatFPFExport ImportScanScanType = "Dependency Track Finding Packaging Format (FPF) Export"

	ImportScanScanTypeDetectSecretsScan ImportScanScanType = "Detect-secrets Scan"

	ImportScanScanTypeDockerBenchSecurityScan ImportScanScanType = "docker-bench-security Scan"

	ImportScanScanTypeDockleScan ImportScanScanType = "Dockle Scan"

	ImportScanScanTypeDrHeaderJSONImporter ImportScanScanType = "DrHeader JSON Importer"

	ImportScanScanTypeESLintScan ImportScanScanType = "ESLint Scan"

	ImportScanScanTypeEdgescanScan ImportScanScanType = "Edgescan Scan"

	ImportScanScanTypeFortifyScan ImportScanScanType = "Fortify Scan"

	ImportScanScanTypeGenericFindingsImport ImportScanScanType = "Generic Findings Import"

	ImportScanScanTypeGgshieldScan ImportScanScanType = "Ggshield Scan"

	ImportScanScanTypeGitLabAPIFuzzingReportScan ImportScanScanType = "GitLab API Fuzzing Report Scan"

	ImportScanScanTypeGitLabContainerScan ImportScanScanType = "GitLab Container Scan"

	ImportScanScanTypeGitLabDASTReport ImportScanScanType = "GitLab DAST Report"

	ImportScanScanTypeGitLabDependencyScanningReport ImportScanScanType = "GitLab Dependency Scanning Report"

	ImportScanScanTypeGitLabSASTReport ImportScanScanType = "GitLab SAST Report"

	ImportScanScanTypeGitLabSecretDetectionReport ImportScanScanType = "GitLab Secret Detection Report"

	ImportScanScanTypeGithubVulnerabilityScan ImportScanScanType = "Github Vulnerability Scan"

	ImportScanScanTypeGitleaksScan ImportScanScanType = "Gitleaks Scan"

	ImportScanScanTypeGosecScanner ImportScanScanType = "Gosec Scanner"

	ImportScanScanTypeHackerOneCases ImportScanScanType = "HackerOne Cases"

	ImportScanScanTypeHadolintDockerfileCheck ImportScanScanType = "Hadolint Dockerfile check"

	ImportScanScanTypeHarborVulnerabilityScan ImportScanScanType = "Harbor Vulnerability Scan"

	ImportScanScanTypeHorusecScan ImportScanScanType = "Horusec Scan"

	ImportScanScanTypeHuskyCIReport ImportScanScanType = "HuskyCI Report"

	ImportScanScanTypeHydraScan ImportScanScanType = "Hydra Scan"

	ImportScanScanTypeIBMAppScanDAST ImportScanScanType = "IBM AppScan DAST"

	ImportScanScanTypeImmuniwebScan ImportScanScanType = "Immuniweb Scan"

	ImportScanScanTypeIntSightsReport ImportScanScanType = "IntSights Report"

	ImportScanScanTypeJFrogXrayAPISummaryArtifactScan ImportScanScanType = "JFrog Xray API Summary Artifact Scan"

	ImportScanScanTypeJFrogXrayScan ImportScanScanType = "JFrog Xray Scan"

	ImportScanScanTypeJFrogXrayUnifiedScan ImportScanScanType = "JFrog Xray Unified Scan"

	ImportScanScanTypeKICSScan ImportScanScanType = "KICS Scan"

	ImportScanScanTypeKiuwanScan ImportScanScanType = "Kiuwan Scan"

	ImportScanScanTypeKubeBenchScan ImportScanScanType = "kube-bench Scan"

	ImportScanScanTypeMeterianScan ImportScanScanType = "Meterian Scan"

	ImportScanScanTypeMicrofocusWebinspectScan ImportScanScanType = "Microfocus Webinspect Scan"

	ImportScanScanTypeMobSFScan ImportScanScanType = "MobSF Scan"

	ImportScanScanTypeMobsfscanScan ImportScanScanType = "Mobsfscan Scan"

	ImportScanScanTypeMozillaObservatoryScan ImportScanScanType = "Mozilla Observatory Scan"

	ImportScanScanTypeNPMAuditScan ImportScanScanType = "NPM Audit Scan"

	ImportScanScanTypeNessusScan ImportScanScanType = "Nessus Scan"

	ImportScanScanTypeNessusWASScan ImportScanScanType = "Nessus WAS Scan"

	ImportScanScanTypeNetsparkerScan ImportScanScanType = "Netsparker Scan"

	ImportScanScanTypeNeuVectorCompliance ImportScanScanType = "NeuVector (compliance)"

	ImportScanScanTypeNeuVectorREST ImportScanScanType = "NeuVector (REST)"

	ImportScanScanTypeNexposeScan ImportScanScanType = "Nexpose Scan"

	ImportScanScanTypeNiktoScan ImportScanScanType = "Nikto Scan"

	ImportScanScanTypeNmapScan ImportScanScanType = "Nmap Scan"

	ImportScanScanTypeNodeSecurityPlatformScan ImportScanScanType = "Node Security Platform Scan"

	ImportScanScanTypeNucleiScan ImportScanScanType = "Nuclei Scan"

	ImportScanScanTypeORTEvaluatedModelImporter ImportScanScanType = "ORT evaluated model Importer"

	ImportScanScanTypeOpenVASCSV ImportScanScanType = "OpenVAS CSV"

	ImportScanScanTypeOpenscapVulnerabilityScan ImportScanScanType = "Openscap Vulnerability Scan"

	ImportScanScanTypeOssIndexDevauditSCAScanImporter ImportScanScanType = "OssIndex Devaudit SCA Scan Importer"

	ImportScanScanTypeOutpost24Scan ImportScanScanType = "Outpost24 Scan"

	ImportScanScanTypePHPSecurityAuditV2 ImportScanScanType = "PHP Security Audit v2"

	ImportScanScanTypePHPSymfonySecurityCheck ImportScanScanType = "PHP Symfony Security Check"

	ImportScanScanTypePMDScan ImportScanScanType = "PMD Scan"

	ImportScanScanTypePWNSAST ImportScanScanType = "PWN SAST"

	ImportScanScanTypePipAuditScan ImportScanScanType = "pip-audit Scan"

	ImportScanScanTypeQualysInfrastructureScanWebGUIXML ImportScanScanType = "Qualys Infrastructure Scan (WebGUI XML)"

	ImportScanScanTypeQualysScan ImportScanScanType = "Qualys Scan"

	ImportScanScanTypeQualysWebappScan ImportScanScanType = "Qualys Webapp Scan"

	ImportScanScanTypeRetireJsScan ImportScanScanType = "Retire.js Scan"

	ImportScanScanTypeRiskReconAPIImporter ImportScanScanType = "Risk Recon API Importer"

	ImportScanScanTypeRubocopScan ImportScanScanType = "Rubocop Scan"

	ImportScanScanTypeRustyHogScan ImportScanScanType = "Rusty Hog Scan"

	ImportScanScanTypeSARIF ImportScanScanType = "SARIF"

	ImportScanScanTypeSKFScan ImportScanScanType = "SKF Scan"

	ImportScanScanTypeSSLLabsScan ImportScanScanType = "SSL Labs Scan"

	ImportScanScanTypeSSLyzeScanJSON ImportScanScanType = "SSLyze Scan (JSON)"

	ImportScanScanTypeScantistScan ImportScanScanType = "Scantist Scan"

	ImportScanScanTypeScoutSuiteScan ImportScanScanType = "Scout Suite Scan"

	ImportScanScanTypeSemgrepJSONReport ImportScanScanType = "Semgrep JSON Report"

	ImportScanScanTypeSnykScan ImportScanScanType = "Snyk Scan"

	ImportScanScanTypeSolarAppscreenerScan ImportScanScanType = "Solar Appscreener Scan"

	ImportScanScanTypeSonarQubeAPIImport ImportScanScanType = "SonarQube API Import"

	ImportScanScanTypeSonarQubeScan ImportScanScanType = "SonarQube Scan"

	ImportScanScanTypeSonarQubeScanDetailed ImportScanScanType = "SonarQube Scan detailed"

	ImportScanScanTypeSonatypeApplicationScan ImportScanScanType = "Sonatype Application Scan"

	ImportScanScanTypeSpotBugsScan ImportScanScanType = "SpotBugs Scan"

	ImportScanScanTypeSslscan ImportScanScanType = "Sslscan"

	ImportScanScanTypeSslyzeScan ImportScanScanType = "Sslyze Scan"

	ImportScanScanTypeStackHawkHawkScan ImportScanScanType = "StackHawk HawkScan"

	ImportScanScanTypeTFSecScan ImportScanScanType = "TFSec Scan"

	ImportScanScanTypeTerrascanScan ImportScanScanType = "Terrascan Scan"

	ImportScanScanTypeTestsslScan ImportScanScanType = "Testssl Scan"

	ImportScanScanTypeTrivyScan ImportScanScanType = "Trivy Scan"

	ImportScanScanTypeTrufflehog3Scan ImportScanScanType = "Trufflehog3 Scan"

	ImportScanScanTypeTrufflehogScan ImportScanScanType = "Trufflehog Scan"

	ImportScanScanTypeTrustwaveFusionAPIScan ImportScanScanType = "Trustwave Fusion API Scan"

	ImportScanScanTypeTrustwaveScanCSV ImportScanScanType = "Trustwave Scan (CSV)"

	ImportScanScanTypeTwistlockImageScan ImportScanScanType = "Twistlock Image Scan"

	ImportScanScanTypeVCGScan ImportScanScanType = "VCG Scan"

	ImportScanScanTypeVeracodeScan ImportScanScanType = "Veracode Scan"

	ImportScanScanTypeVeracodeSourceClearScan ImportScanScanType = "Veracode SourceClear Scan"

	ImportScanScanTypeVulners ImportScanScanType = "Vulners"

	ImportScanScanTypeWFuzzJSONReport ImportScanScanType = "WFuzz JSON report"

	ImportScanScanTypeWapitiScan ImportScanScanType = "Wapiti Scan"

	ImportScanScanTypeWhispersScan ImportScanScanType = "Whispers Scan"

	ImportScanScanTypeWhiteHatSentinel ImportScanScanType = "WhiteHat Sentinel"

	ImportScanScanTypeWhitesourceScan ImportScanScanType = "Whitesource Scan"

	ImportScanScanTypeWpscan ImportScanScanType = "Wpscan"

	ImportScanScanTypeXanitizerScan ImportScanScanType = "Xanitizer Scan"

	ImportScanScanTypeYarnAuditScan ImportScanScanType = "Yarn Audit Scan"

	ImportScanScanTypeZAPScan ImportScanScanType = "ZAP Scan"
)

// Defines values for ImportScanRequestGroupBy.
const (
	ImportScanRequestGroupByComponentName ImportScanRequestGroupBy = "component_name"

	ImportScanRequestGroupByComponentNameComponentVersion ImportScanRequestGroupBy = "component_name+component_version"

	ImportScanRequestGroupByFilePath ImportScanRequestGroupBy = "file_path"
)

// Defines values for ImportScanRequestMinimumSeverity.
const (
	ImportScanRequestMinimumSeverityCritical ImportScanRequestMinimumSeverity = "Critical"

	ImportScanRequestMinimumSeverityHigh ImportScanRequestMinimumSeverity = "High"

	ImportScanRequestMinimumSeverityInfo ImportScanRequestMinimumSeverity = "Info"

	ImportScanRequestMinimumSeverityLow ImportScanRequestMinimumSeverity = "Low"

	ImportScanRequestMinimumSeverityMedium ImportScanRequestMinimumSeverity = "Medium"
)

// Defines values for ImportScanRequestScanType.
const (
	ImportScanRequestScanTypeAWSProwlerScan ImportScanRequestScanType = "AWS Prowler Scan"

	ImportScanRequestScanTypeAWSScout2Scan ImportScanRequestScanType = "AWS Scout2 Scan"

	ImportScanRequestScanTypeAWSSecurityHubScan ImportScanRequestScanType = "AWS Security Hub Scan"

	ImportScanRequestScanTypeAcunetix360Scan ImportScanRequestScanType = "Acunetix360 Scan"

	ImportScanRequestScanTypeAcunetixScan ImportScanRequestScanType = "Acunetix Scan"

	ImportScanRequestScanTypeAnchoreCTLPoliciesReport ImportScanRequestScanType = "AnchoreCTL Policies Report"

	ImportScanRequestScanTypeAnchoreCTLVulnReport ImportScanRequestScanType = "AnchoreCTL Vuln Report"

	ImportScanRequestScanTypeAnchoreEngineScan ImportScanRequestScanType = "Anchore Engine Scan"

	ImportScanRequestScanTypeAnchoreEnterprisePolicyCheck ImportScanRequestScanType = "Anchore Enterprise Policy Check"

	ImportScanRequestScanTypeAnchoreGrype ImportScanRequestScanType = "Anchore Grype"

	ImportScanRequestScanTypeAppSpiderScan ImportScanRequestScanType = "AppSpider Scan"

	ImportScanRequestScanTypeAquaScan ImportScanRequestScanType = "Aqua Scan"

	ImportScanRequestScanTypeArachniScan ImportScanRequestScanType = "Arachni Scan"

	ImportScanRequestScanTypeAuditJSScan ImportScanRequestScanType = "AuditJS Scan"

	ImportScanRequestScanTypeAzureSecurityCenterRecommendationsScan ImportScanRequestScanType = "Azure Security Center Recommendations Scan"

	ImportScanRequestScanTypeBanditScan ImportScanRequestScanType = "Bandit Scan"

	ImportScanRequestScanTypeBlackDuckAPI ImportScanRequestScanType = "BlackDuck API"

	ImportScanRequestScanTypeBlackduckComponentRisk ImportScanRequestScanType = "Blackduck Component Risk"

	ImportScanRequestScanTypeBlackduckHubScan ImportScanRequestScanType = "Blackduck Hub Scan"

	ImportScanRequestScanTypeBrakemanScan ImportScanRequestScanType = "Brakeman Scan"

	ImportScanRequestScanTypeBugCrowdScan ImportScanRequestScanType = "BugCrowd Scan"

	ImportScanRequestScanTypeBugcrowdAPIImport ImportScanRequestScanType = "Bugcrowd API Import"

	ImportScanRequestScanTypeBundlerAuditScan ImportScanRequestScanType = "Bundler-Audit Scan"

	ImportScanRequestScanTypeBurpEnterpriseScan ImportScanRequestScanType = "Burp Enterprise Scan"

	ImportScanRequestScanTypeBurpGraphQLAPI ImportScanRequestScanType = "Burp GraphQL API"

	ImportScanRequestScanTypeBurpRESTAPI ImportScanRequestScanType = "Burp REST API"

	ImportScanRequestScanTypeBurpScan ImportScanRequestScanType = "Burp Scan"

	ImportScanRequestScanTypeCargoAuditScan ImportScanRequestScanType = "CargoAudit Scan"

	ImportScanRequestScanTypeCheckmarxOSA ImportScanRequestScanType = "Checkmarx OSA"

	ImportScanRequestScanTypeCheckmarxScan ImportScanRequestScanType = "Checkmarx Scan"

	ImportScanRequestScanTypeCheckmarxScanDetailed ImportScanRequestScanType = "Checkmarx Scan detailed"

	ImportScanRequestScanTypeCheckovScan ImportScanRequestScanType = "Checkov Scan"

	ImportScanRequestScanTypeClairKlarScan ImportScanRequestScanType = "Clair Klar Scan"

	ImportScanRequestScanTypeClairScan ImportScanRequestScanType = "Clair Scan"

	ImportScanRequestScanTypeCloudsploitScan ImportScanRequestScanType = "Cloudsploit Scan"

	ImportScanRequestScanTypeCobaltIoAPIImport ImportScanRequestScanType = "Cobalt.io API Import"

	ImportScanRequestScanTypeCobaltIoScan ImportScanRequestScanType = "Cobalt.io Scan"

	ImportScanRequestScanTypeContrastScan ImportScanRequestScanType = "Contrast Scan"

	ImportScanRequestScanTypeCoverityAPI ImportScanRequestScanType = "Coverity API"

	ImportScanRequestScanTypeCrashtestSecurityJSONFile ImportScanRequestScanType = "Crashtest Security JSON File"

	ImportScanRequestScanTypeCrashtestSecurityXMLFile ImportScanRequestScanType = "Crashtest Security XML File"

	ImportScanRequestScanTypeCredScanScan ImportScanRequestScanType = "CredScan Scan"

	ImportScanRequestScanTypeCycloneDXScan ImportScanRequestScanType = "CycloneDX Scan"

	ImportScanRequestScanTypeDSOPScan ImportScanRequestScanType = "DSOP Scan"

	ImportScanRequestScanTypeDawnScannerScan ImportScanRequestScanType = "DawnScanner Scan"

	ImportScanRequestScanTypeDependencyCheckScan ImportScanRequestScanType = "Dependency Check Scan"

	ImportScanRequestScanTypeDependencyTrackFindingPackagingFormatFPFExport ImportScanRequestScanType = "Dependency Track Finding Packaging Format (FPF) Export"

	ImportScanRequestScanTypeDetectSecretsScan ImportScanRequestScanType = "Detect-secrets Scan"

	ImportScanRequestScanTypeDockerBenchSecurityScan ImportScanRequestScanType = "docker-bench-security Scan"

	ImportScanRequestScanTypeDockleScan ImportScanRequestScanType = "Dockle Scan"

	ImportScanRequestScanTypeDrHeaderJSONImporter ImportScanRequestScanType = "DrHeader JSON Importer"

	ImportScanRequestScanTypeESLintScan ImportScanRequestScanType = "ESLint Scan"

	ImportScanRequestScanTypeEdgescanScan ImportScanRequestScanType = "Edgescan Scan"

	ImportScanRequestScanTypeFortifyScan ImportScanRequestScanType = "Fortify Scan"

	ImportScanRequestScanTypeGenericFindingsImport ImportScanRequestScanType = "Generic Findings Import"

	ImportScanRequestScanTypeGgshieldScan ImportScanRequestScanType = "Ggshield Scan"

	ImportScanRequestScanTypeGitLabAPIFuzzingReportScan ImportScanRequestScanType = "GitLab API Fuzzing Report Scan"

	ImportScanRequestScanTypeGitLabContainerScan ImportScanRequestScanType = "GitLab Container Scan"

	ImportScanRequestScanTypeGitLabDASTReport ImportScanRequestScanType = "GitLab DAST Report"

	ImportScanRequestScanTypeGitLabDependencyScanningReport ImportScanRequestScanType = "GitLab Dependency Scanning Report"

	ImportScanRequestScanTypeGitLabSASTReport ImportScanRequestScanType = "GitLab SAST Report"

	ImportScanRequestScanTypeGitLabSecretDetectionReport ImportScanRequestScanType = "GitLab Secret Detection Report"

	ImportScanRequestScanTypeGithubVulnerabilityScan ImportScanRequestScanType = "Github Vulnerability Scan"

	ImportScanRequestScanTypeGitleaksScan ImportScanRequestScanType = "Gitleaks Scan"

	ImportScanRequestScanTypeGosecScanner ImportScanRequestScanType = "Gosec Scanner"

	ImportScanRequestScanTypeHackerOneCases ImportScanRequestScanType = "HackerOne Cases"

	ImportScanRequestScanTypeHadolintDockerfileCheck ImportScanRequestScanType = "Hadolint Dockerfile check"

	ImportScanRequestScanTypeHarborVulnerabilityScan ImportScanRequestScanType = "Harbor Vulnerability Scan"

	ImportScanRequestScanTypeHorusecScan ImportScanRequestScanType = "Horusec Scan"

	ImportScanRequestScanTypeHuskyCIReport ImportScanRequestScanType = "HuskyCI Report"

	ImportScanRequestScanTypeHydraScan ImportScanRequestScanType = "Hydra Scan"

	ImportScanRequestScanTypeIBMAppScanDAST ImportScanRequestScanType = "IBM AppScan DAST"

	ImportScanRequestScanTypeImmuniwebScan ImportScanRequestScanType = "Immuniweb Scan"

	ImportScanRequestScanTypeIntSightsReport ImportScanRequestScanType = "IntSights Report"

	ImportScanRequestScanTypeJFrogXrayAPISummaryArtifactScan ImportScanRequestScanType = "JFrog Xray API Summary Artifact Scan"

	ImportScanRequestScanTypeJFrogXrayScan ImportScanRequestScanType = "JFrog Xray Scan"

	ImportScanRequestScanTypeJFrogXrayUnifiedScan ImportScanRequestScanType = "JFrog Xray Unified Scan"

	ImportScanRequestScanTypeKICSScan ImportScanRequestScanType = "KICS Scan"

	ImportScanRequestScanTypeKiuwanScan ImportScanRequestScanType = "Kiuwan Scan"

	ImportScanRequestScanTypeKubeBenchScan ImportScanRequestScanType = "kube-bench Scan"

	ImportScanRequestScanTypeMeterianScan ImportScanRequestScanType = "Meterian Scan"

	ImportScanRequestScanTypeMicrofocusWebinspectScan ImportScanRequestScanType = "Microfocus Webinspect Scan"

	ImportScanRequestScanTypeMobSFScan ImportScanRequestScanType = "MobSF Scan"

	ImportScanRequestScanTypeMobsfscanScan ImportScanRequestScanType = "Mobsfscan Scan"

	ImportScanRequestScanTypeMozillaObservatoryScan ImportScanRequestScanType = "Mozilla Observatory Scan"

	ImportScanRequestScanTypeNPMAuditScan ImportScanRequestScanType = "NPM Audit Scan"

	ImportScanRequestScanTypeNessusScan ImportScanRequestScanType = "Nessus Scan"

	ImportScanRequestScanTypeNessusWASScan ImportScanRequestScanType = "Nessus WAS Scan"

	ImportScanRequestScanTypeNetsparkerScan ImportScanRequestScanType = "Netsparker Scan"

	ImportScanRequestScanTypeNeuVectorCompliance ImportScanRequestScanType = "NeuVector (compliance)"

	ImportScanRequestScanTypeNeuVectorREST ImportScanRequestScanType = "NeuVector (REST)"

	ImportScanRequestScanTypeNexposeScan ImportScanRequestScanType = "Nexpose Scan"

	ImportScanRequestScanTypeNiktoScan ImportScanRequestScanType = "Nikto Scan"

	ImportScanRequestScanTypeNmapScan ImportScanRequestScanType = "Nmap Scan"

	ImportScanRequestScanTypeNodeSecurityPlatformScan ImportScanRequestScanType = "Node Security Platform Scan"

	ImportScanRequestScanTypeNucleiScan ImportScanRequestScanType = "Nuclei Scan"

	ImportScanRequestScanTypeORTEvaluatedModelImporter ImportScanRequestScanType = "ORT evaluated model Importer"

	ImportScanRequestScanTypeOpenVASCSV ImportScanRequestScanType = "OpenVAS CSV"

	ImportScanRequestScanTypeOpenscapVulnerabilityScan ImportScanRequestScanType = "Openscap Vulnerability Scan"

	ImportScanRequestScanTypeOssIndexDevauditSCAScanImporter ImportScanRequestScanType = "OssIndex Devaudit SCA Scan Importer"

	ImportScanRequestScanTypeOutpost24Scan ImportScanRequestScanType = "Outpost24 Scan"

	ImportScanRequestScanTypePHPSecurityAuditV2 ImportScanRequestScanType = "PHP Security Audit v2"

	ImportScanRequestScanTypePHPSymfonySecurityCheck ImportScanRequestScanType = "PHP Symfony Security Check"

	ImportScanRequestScanTypePMDScan ImportScanRequestScanType = "PMD Scan"

	ImportScanRequestScanTypePWNSAST ImportScanRequestScanType = "PWN SAST"

	ImportScanRequestScanTypePipAuditScan ImportScanRequestScanType = "pip-audit Scan"

	ImportScanRequestScanTypeQualysInfrastructureScanWebGUIXML ImportScanRequestScanType = "Qualys Infrastructure Scan (WebGUI XML)"

	ImportScanRequestScanTypeQualysScan ImportScanRequestScanType = "Qualys Scan"

	ImportScanRequestScanTypeQualysWebappScan ImportScanRequestScanType = "Qualys Webapp Scan"

	ImportScanRequestScanTypeRetireJsScan ImportScanRequestScanType = "Retire.js Scan"

	ImportScanRequestScanTypeRiskReconAPIImporter ImportScanRequestScanType = "Risk Recon API Importer"

	ImportScanRequestScanTypeRubocopScan ImportScanRequestScanType = "Rubocop Scan"

	ImportScanRequestScanTypeRustyHogScan ImportScanRequestScanType = "Rusty Hog Scan"

	ImportScanRequestScanTypeSARIF ImportScanRequestScanType = "SARIF"

	ImportScanRequestScanTypeSKFScan ImportScanRequestScanType = "SKF Scan"

	ImportScanRequestScanTypeSSLLabsScan ImportScanRequestScanType = "SSL Labs Scan"

	ImportScanRequestScanTypeSSLyzeScanJSON ImportScanRequestScanType = "SSLyze Scan (JSON)"

	ImportScanRequestScanTypeScantistScan ImportScanRequestScanType = "Scantist Scan"

	ImportScanRequestScanTypeScoutSuiteScan ImportScanRequestScanType = "Scout Suite Scan"

	ImportScanRequestScanTypeSemgrepJSONReport ImportScanRequestScanType = "Semgrep JSON Report"

	ImportScanRequestScanTypeSnykScan ImportScanRequestScanType = "Snyk Scan"

	ImportScanRequestScanTypeSolarAppscreenerScan ImportScanRequestScanType = "Solar Appscreener Scan"

	ImportScanRequestScanTypeSonarQubeAPIImport ImportScanRequestScanType = "SonarQube API Import"

	ImportScanRequestScanTypeSonarQubeScan ImportScanRequestScanType = "SonarQube Scan"

	ImportScanRequestScanTypeSonarQubeScanDetailed ImportScanRequestScanType = "SonarQube Scan detailed"

	ImportScanRequestScanTypeSonatypeApplicationScan ImportScanRequestScanType = "Sonatype Application Scan"

	ImportScanRequestScanTypeSpotBugsScan ImportScanRequestScanType = "SpotBugs Scan"

	ImportScanRequestScanTypeSslscan ImportScanRequestScanType = "Sslscan"

	ImportScanRequestScanTypeSslyzeScan ImportScanRequestScanType = "Sslyze Scan"

	ImportScanRequestScanTypeStackHawkHawkScan ImportScanRequestScanType = "StackHawk HawkScan"

	ImportScanRequestScanTypeTFSecScan ImportScanRequestScanType = "TFSec Scan"

	ImportScanRequestScanTypeTerrascanScan ImportScanRequestScanType = "Terrascan Scan"

	ImportScanRequestScanTypeTestsslScan ImportScanRequestScanType = "Testssl Scan"

	ImportScanRequestScanTypeTrivyScan ImportScanRequestScanType = "Trivy Scan"

	ImportScanRequestScanTypeTrufflehog3Scan ImportScanRequestScanType = "Trufflehog3 Scan"

	ImportScanRequestScanTypeTrufflehogScan ImportScanRequestScanType = "Trufflehog Scan"

	ImportScanRequestScanTypeTrustwaveFusionAPIScan ImportScanRequestScanType = "Trustwave Fusion API Scan"

	ImportScanRequestScanTypeTrustwaveScanCSV ImportScanRequestScanType = "Trustwave Scan (CSV)"

	ImportScanRequestScanTypeTwistlockImageScan ImportScanRequestScanType = "Twistlock Image Scan"

	ImportScanRequestScanTypeVCGScan ImportScanRequestScanType = "VCG Scan"

	ImportScanRequestScanTypeVeracodeScan ImportScanRequestScanType = "Veracode Scan"

	ImportScanRequestScanTypeVeracodeSourceClearScan ImportScanRequestScanType = "Veracode SourceClear Scan"

	ImportScanRequestScanTypeVulners ImportScanRequestScanType = "Vulners"

	ImportScanRequestScanTypeWFuzzJSONReport ImportScanRequestScanType = "WFuzz JSON report"

	ImportScanRequestScanTypeWapitiScan ImportScanRequestScanType = "Wapiti Scan"

	ImportScanRequestScanTypeWhispersScan ImportScanRequestScanType = "Whispers Scan"

	ImportScanRequestScanTypeWhiteHatSentinel ImportScanRequestScanType = "WhiteHat Sentinel"

	ImportScanRequestScanTypeWhitesourceScan ImportScanRequestScanType = "Whitesource Scan"

	ImportScanRequestScanTypeWpscan ImportScanRequestScanType = "Wpscan"

	ImportScanRequestScanTypeXanitizerScan ImportScanRequestScanType = "Xanitizer Scan"

	ImportScanRequestScanTypeYarnAuditScan ImportScanRequestScanType = "Yarn Audit Scan"

	ImportScanRequestScanTypeZAPScan ImportScanRequestScanType = "ZAP Scan"
)

// Defines values for JIRAInstanceDefaultIssueType.
const (
	JIRAInstanceDefaultIssueTypeBug JIRAInstanceDefaultIssueType = "Bug"

	JIRAInstanceDefaultIssueTypeEpic JIRAInstanceDefaultIssueType = "Epic"

	JIRAInstanceDefaultIssueTypeSecurity JIRAInstanceDefaultIssueType = "Security"

	JIRAInstanceDefaultIssueTypeSpike JIRAInstanceDefaultIssueType = "Spike"

	JIRAInstanceDefaultIssueTypeStory JIRAInstanceDefaultIssueType = "Story"

	JIRAInstanceDefaultIssueTypeTask JIRAInstanceDefaultIssueType = "Task"
)

// Defines values for JIRAInstanceRequestDefaultIssueType.
const (
	JIRAInstanceRequestDefaultIssueTypeBug JIRAInstanceRequestDefaultIssueType = "Bug"

	JIRAInstanceRequestDefaultIssueTypeEpic JIRAInstanceRequestDefaultIssueType = "Epic"

	JIRAInstanceRequestDefaultIssueTypeSecurity JIRAInstanceRequestDefaultIssueType = "Security"

	JIRAInstanceRequestDefaultIssueTypeSpike JIRAInstanceRequestDefaultIssueType = "Spike"

	JIRAInstanceRequestDefaultIssueTypeStory JIRAInstanceRequestDefaultIssueType = "Story"

	JIRAInstanceRequestDefaultIssueTypeTask JIRAInstanceRequestDefaultIssueType = "Task"
)

// Defines values for NotificationsAutoCloseEngagement.
const (
	NotificationsAutoCloseEngagementAlert NotificationsAutoCloseEngagement = "alert"

	NotificationsAutoCloseEngagementMail NotificationsAutoCloseEngagement = "mail"

	NotificationsAutoCloseEngagementMsteams NotificationsAutoCloseEngagement = "msteams"

	NotificationsAutoCloseEngagementSlack NotificationsAutoCloseEngagement = "slack"
)

// Defines values for NotificationsCloseEngagement.
const (
	NotificationsCloseEngagementAlert NotificationsCloseEngagement = "alert"

	NotificationsCloseEngagementMail NotificationsCloseEngagement = "mail"

	NotificationsCloseEngagementMsteams NotificationsCloseEngagement = "msteams"

	NotificationsCloseEngagementSlack NotificationsCloseEngagement = "slack"
)

// Defines values for NotificationsCodeReview.
const (
	NotificationsCodeReviewAlert NotificationsCodeReview = "alert"

	NotificationsCodeReviewMail NotificationsCodeReview = "mail"

	NotificationsCodeReviewMsteams NotificationsCodeReview = "msteams"

	NotificationsCodeReviewSlack NotificationsCodeReview = "slack"
)

// Defines values for NotificationsEngagementAdded.
const (
	NotificationsEngagementAddedAlert NotificationsEngagementAdded = "alert"

	NotificationsEngagementAddedMail NotificationsEngagementAdded = "mail"

	NotificationsEngagementAddedMsteams NotificationsEngagementAdded = "msteams"

	NotificationsEngagementAddedSlack NotificationsEngagementAdded = "slack"
)

// Defines values for NotificationsJiraUpdate.
const (
	NotificationsJiraUpdateAlert NotificationsJiraUpdate = "alert"

	NotificationsJiraUpdateMail NotificationsJiraUpdate = "mail"

	NotificationsJiraUpdateMsteams NotificationsJiraUpdate = "msteams"

	NotificationsJiraUpdateSlack NotificationsJiraUpdate = "slack"
)

// Defines values for NotificationsOther.
const (
	NotificationsOtherAlert NotificationsOther = "alert"

	NotificationsOtherMail NotificationsOther = "mail"

	NotificationsOtherMsteams NotificationsOther = "msteams"

	NotificationsOtherSlack NotificationsOther = "slack"
)

// Defines values for NotificationsProductAdded.
const (
	NotificationsProductAddedAlert NotificationsProductAdded = "alert"

	NotificationsProductAddedMail NotificationsProductAdded = "mail"

	NotificationsProductAddedMsteams NotificationsProductAdded = "msteams"

	NotificationsProductAddedSlack NotificationsProductAdded = "slack"
)

// Defines values for NotificationsProductTypeAdded.
const (
	NotificationsProductTypeAddedAlert NotificationsProductTypeAdded = "alert"

	NotificationsProductTypeAddedMail NotificationsProductTypeAdded = "mail"

	NotificationsProductTypeAddedMsteams NotificationsProductTypeAdded = "msteams"

	NotificationsProductTypeAddedSlack NotificationsProductTypeAdded = "slack"
)

// Defines values for NotificationsReviewRequested.
const (
	NotificationsReviewRequestedAlert NotificationsReviewRequested = "alert"

	NotificationsReviewRequestedMail NotificationsReviewRequested = "mail"

	NotificationsReviewRequestedMsteams NotificationsReviewRequested = "msteams"

	NotificationsReviewRequestedSlack NotificationsReviewRequested = "slack"
)

// Defines values for NotificationsRiskAcceptanceExpiration.
const (
	NotificationsRiskAcceptanceExpirationAlert NotificationsRiskAcceptanceExpiration = "alert"

	NotificationsRiskAcceptanceExpirationMail NotificationsRiskAcceptanceExpiration = "mail"

	NotificationsRiskAcceptanceExpirationMsteams NotificationsRiskAcceptanceExpiration = "msteams"

	NotificationsRiskAcceptanceExpirationSlack NotificationsRiskAcceptanceExpiration = "slack"
)

// Defines values for NotificationsScanAdded.
const (
	NotificationsScanAddedAlert NotificationsScanAdded = "alert"

	NotificationsScanAddedMail NotificationsScanAdded = "mail"

	NotificationsScanAddedMsteams NotificationsScanAdded = "msteams"

	NotificationsScanAddedSlack NotificationsScanAdded = "slack"
)

// Defines values for NotificationsSlaBreach.
const (
	NotificationsSlaBreachAlert NotificationsSlaBreach = "alert"

	NotificationsSlaBreachMail NotificationsSlaBreach = "mail"

	NotificationsSlaBreachMsteams NotificationsSlaBreach = "msteams"

	NotificationsSlaBreachSlack NotificationsSlaBreach = "slack"
)

// Defines values for NotificationsStaleEngagement.
const (
	NotificationsStaleEngagementAlert NotificationsStaleEngagement = "alert"

	NotificationsStaleEngagementMail NotificationsStaleEngagement = "mail"

	NotificationsStaleEngagementMsteams NotificationsStaleEngagement = "msteams"

	NotificationsStaleEngagementSlack NotificationsStaleEngagement = "slack"
)

// Defines values for NotificationsTestAdded.
const (
	NotificationsTestAddedAlert NotificationsTestAdded = "alert"

	NotificationsTestAddedMail NotificationsTestAdded = "mail"

	NotificationsTestAddedMsteams NotificationsTestAdded = "msteams"

	NotificationsTestAddedSlack NotificationsTestAdded = "slack"
)

// Defines values for NotificationsUpcomingEngagement.
const (
	NotificationsUpcomingEngagementAlert NotificationsUpcomingEngagement = "alert"

	NotificationsUpcomingEngagementMail NotificationsUpcomingEngagement = "mail"

	NotificationsUpcomingEngagementMsteams NotificationsUpcomingEngagement = "msteams"

	NotificationsUpcomingEngagementSlack NotificationsUpcomingEngagement = "slack"
)

// Defines values for NotificationsUserMentioned.
const (
	NotificationsUserMentionedAlert NotificationsUserMentioned = "alert"

	NotificationsUserMentionedMail NotificationsUserMentioned = "mail"

	NotificationsUserMentionedMsteams NotificationsUserMentioned = "msteams"

	NotificationsUserMentionedSlack NotificationsUserMentioned = "slack"
)

// Defines values for NotificationsRequestAutoCloseEngagement.
const (
	NotificationsRequestAutoCloseEngagementAlert NotificationsRequestAutoCloseEngagement = "alert"

	NotificationsRequestAutoCloseEngagementMail NotificationsRequestAutoCloseEngagement = "mail"

	NotificationsRequestAutoCloseEngagementMsteams NotificationsRequestAutoCloseEngagement = "msteams"

	NotificationsRequestAutoCloseEngagementSlack NotificationsRequestAutoCloseEngagement = "slack"
)

// Defines values for NotificationsRequestCloseEngagement.
const (
	NotificationsRequestCloseEngagementAlert NotificationsRequestCloseEngagement = "alert"

	NotificationsRequestCloseEngagementMail NotificationsRequestCloseEngagement = "mail"

	NotificationsRequestCloseEngagementMsteams NotificationsRequestCloseEngagement = "msteams"

	NotificationsRequestCloseEngagementSlack NotificationsRequestCloseEngagement = "slack"
)

// Defines values for NotificationsRequestCodeReview.
const (
	NotificationsRequestCodeReviewAlert NotificationsRequestCodeReview = "alert"

	NotificationsRequestCodeReviewMail NotificationsRequestCodeReview = "mail"

	NotificationsRequestCodeReviewMsteams NotificationsRequestCodeReview = "msteams"

	NotificationsRequestCodeReviewSlack NotificationsRequestCodeReview = "slack"
)

// Defines values for NotificationsRequestEngagementAdded.
const (
	NotificationsRequestEngagementAddedAlert NotificationsRequestEngagementAdded = "alert"

	NotificationsRequestEngagementAddedMail NotificationsRequestEngagementAdded = "mail"

	NotificationsRequestEngagementAddedMsteams NotificationsRequestEngagementAdded = "msteams"

	NotificationsRequestEngagementAddedSlack NotificationsRequestEngagementAdded = "slack"
)

// Defines values for NotificationsRequestJiraUpdate.
const (
	NotificationsRequestJiraUpdateAlert NotificationsRequestJiraUpdate = "alert"

	NotificationsRequestJiraUpdateMail NotificationsRequestJiraUpdate = "mail"

	NotificationsRequestJiraUpdateMsteams NotificationsRequestJiraUpdate = "msteams"

	NotificationsRequestJiraUpdateSlack NotificationsRequestJiraUpdate = "slack"
)

// Defines values for NotificationsRequestOther.
const (
	NotificationsRequestOtherAlert NotificationsRequestOther = "alert"

	NotificationsRequestOtherMail NotificationsRequestOther = "mail"

	NotificationsRequestOtherMsteams NotificationsRequestOther = "msteams"

	NotificationsRequestOtherSlack NotificationsRequestOther = "slack"
)

// Defines values for NotificationsRequestProductAdded.
const (
	NotificationsRequestProductAddedAlert NotificationsRequestProductAdded = "alert"

	NotificationsRequestProductAddedMail NotificationsRequestProductAdded = "mail"

	NotificationsRequestProductAddedMsteams NotificationsRequestProductAdded = "msteams"

	NotificationsRequestProductAddedSlack NotificationsRequestProductAdded = "slack"
)

// Defines values for NotificationsRequestProductTypeAdded.
const (
	NotificationsRequestProductTypeAddedAlert NotificationsRequestProductTypeAdded = "alert"

	NotificationsRequestProductTypeAddedMail NotificationsRequestProductTypeAdded = "mail"

	NotificationsRequestProductTypeAddedMsteams NotificationsRequestProductTypeAdded = "msteams"

	NotificationsRequestProductTypeAddedSlack NotificationsRequestProductTypeAdded = "slack"
)

// Defines values for NotificationsRequestReviewRequested.
const (
	NotificationsRequestReviewRequestedAlert NotificationsRequestReviewRequested = "alert"

	NotificationsRequestReviewRequestedMail NotificationsRequestReviewRequested = "mail"

	NotificationsRequestReviewRequestedMsteams NotificationsRequestReviewRequested = "msteams"

	NotificationsRequestReviewRequestedSlack NotificationsRequestReviewRequested = "slack"
)

// Defines values for NotificationsRequestRiskAcceptanceExpiration.
const (
	NotificationsRequestRiskAcceptanceExpirationAlert NotificationsRequestRiskAcceptanceExpiration = "alert"

	NotificationsRequestRiskAcceptanceExpirationMail NotificationsRequestRiskAcceptanceExpiration = "mail"

	NotificationsRequestRiskAcceptanceExpirationMsteams NotificationsRequestRiskAcceptanceExpiration = "msteams"

	NotificationsRequestRiskAcceptanceExpirationSlack NotificationsRequestRiskAcceptanceExpiration = "slack"
)

// Defines values for NotificationsRequestScanAdded.
const (
	NotificationsRequestScanAddedAlert NotificationsRequestScanAdded = "alert"

	NotificationsRequestScanAddedMail NotificationsRequestScanAdded = "mail"

	NotificationsRequestScanAddedMsteams NotificationsRequestScanAdded = "msteams"

	NotificationsRequestScanAddedSlack NotificationsRequestScanAdded = "slack"
)

// Defines values for NotificationsRequestSlaBreach.
const (
	NotificationsRequestSlaBreachAlert NotificationsRequestSlaBreach = "alert"

	NotificationsRequestSlaBreachMail NotificationsRequestSlaBreach = "mail"

	NotificationsRequestSlaBreachMsteams NotificationsRequestSlaBreach = "msteams"

	NotificationsRequestSlaBreachSlack NotificationsRequestSlaBreach = "slack"
)

// Defines values for NotificationsRequestStaleEngagement.
const (
	NotificationsRequestStaleEngagementAlert NotificationsRequestStaleEngagement = "alert"

	NotificationsRequestStaleEngagementMail NotificationsRequestStaleEngagement = "mail"

	NotificationsRequestStaleEngagementMsteams NotificationsRequestStaleEngagement = "msteams"

	NotificationsRequestStaleEngagementSlack NotificationsRequestStaleEngagement = "slack"
)

// Defines values for NotificationsRequestTestAdded.
const (
	NotificationsRequestTestAddedAlert NotificationsRequestTestAdded = "alert"

	NotificationsRequestTestAddedMail NotificationsRequestTestAdded = "mail"

	NotificationsRequestTestAddedMsteams NotificationsRequestTestAdded = "msteams"

	NotificationsRequestTestAddedSlack NotificationsRequestTestAdded = "slack"
)

// Defines values for NotificationsRequestUpcomingEngagement.
const (
	NotificationsRequestUpcomingEngagementAlert NotificationsRequestUpcomingEngagement = "alert"

	NotificationsRequestUpcomingEngagementMail NotificationsRequestUpcomingEngagement = "mail"

	NotificationsRequestUpcomingEngagementMsteams NotificationsRequestUpcomingEngagement = "msteams"

	NotificationsRequestUpcomingEngagementSlack NotificationsRequestUpcomingEngagement = "slack"
)

// Defines values for NotificationsRequestUserMentioned.
const (
	NotificationsRequestUserMentionedAlert NotificationsRequestUserMentioned = "alert"

	NotificationsRequestUserMentionedMail NotificationsRequestUserMentioned = "mail"

	NotificationsRequestUserMentionedMsteams NotificationsRequestUserMentioned = "msteams"

	NotificationsRequestUserMentionedSlack NotificationsRequestUserMentioned = "slack"
)

// Defines values for PatchedDojoGroupRequestSocialProvider.
const (
	PatchedDojoGroupRequestSocialProviderAzureAD PatchedDojoGroupRequestSocialProvider = "AzureAD"

	PatchedDojoGroupRequestSocialProviderEmpty PatchedDojoGroupRequestSocialProvider = ""

	PatchedDojoGroupRequestSocialProviderNil PatchedDojoGroupRequestSocialProvider = "<nil>"
)

// Defines values for PatchedEngagementRequestEngagementType.
const (
	PatchedEngagementRequestEngagementTypeCICD PatchedEngagementRequestEngagementType = "CI/CD"

	PatchedEngagementRequestEngagementTypeInteractive PatchedEngagementRequestEngagementType = "Interactive"

	PatchedEngagementRequestEngagementTypeNil PatchedEngagementRequestEngagementType = "<nil>"
)

// Defines values for PatchedEngagementRequestStatus.
const (
	PatchedEngagementRequestStatusBlocked PatchedEngagementRequestStatus = "Blocked"

	PatchedEngagementRequestStatusCancelled PatchedEngagementRequestStatus = "Cancelled"

	PatchedEngagementRequestStatusCompleted PatchedEngagementRequestStatus = "Completed"

	PatchedEngagementRequestStatusInProgress PatchedEngagementRequestStatus = "In Progress"

	PatchedEngagementRequestStatusNil PatchedEngagementRequestStatus = "<nil>"

	PatchedEngagementRequestStatusNotStarted PatchedEngagementRequestStatus = "Not Started"

	PatchedEngagementRequestStatusOnHold PatchedEngagementRequestStatus = "On Hold"

	PatchedEngagementRequestStatusWaitingForResource PatchedEngagementRequestStatus = "Waiting for Resource"
)

// Defines values for PatchedJIRAInstanceRequestDefaultIssueType.
const (
	PatchedJIRAInstanceRequestDefaultIssueTypeBug PatchedJIRAInstanceRequestDefaultIssueType = "Bug"

	PatchedJIRAInstanceRequestDefaultIssueTypeEpic PatchedJIRAInstanceRequestDefaultIssueType = "Epic"

	PatchedJIRAInstanceRequestDefaultIssueTypeSecurity PatchedJIRAInstanceRequestDefaultIssueType = "Security"

	PatchedJIRAInstanceRequestDefaultIssueTypeSpike PatchedJIRAInstanceRequestDefaultIssueType = "Spike"

	PatchedJIRAInstanceRequestDefaultIssueTypeStory PatchedJIRAInstanceRequestDefaultIssueType = "Story"

	PatchedJIRAInstanceRequestDefaultIssueTypeTask PatchedJIRAInstanceRequestDefaultIssueType = "Task"
)

// Defines values for PatchedNotificationsRequestAutoCloseEngagement.
const (
	PatchedNotificationsRequestAutoCloseEngagementAlert PatchedNotificationsRequestAutoCloseEngagement = "alert"

	PatchedNotificationsRequestAutoCloseEngagementMail PatchedNotificationsRequestAutoCloseEngagement = "mail"

	PatchedNotificationsRequestAutoCloseEngagementMsteams PatchedNotificationsRequestAutoCloseEngagement = "msteams"

	PatchedNotificationsRequestAutoCloseEngagementSlack PatchedNotificationsRequestAutoCloseEngagement = "slack"
)

// Defines values for PatchedNotificationsRequestCloseEngagement.
const (
	PatchedNotificationsRequestCloseEngagementAlert PatchedNotificationsRequestCloseEngagement = "alert"

	PatchedNotificationsRequestCloseEngagementMail PatchedNotificationsRequestCloseEngagement = "mail"

	PatchedNotificationsRequestCloseEngagementMsteams PatchedNotificationsRequestCloseEngagement = "msteams"

	PatchedNotificationsRequestCloseEngagementSlack PatchedNotificationsRequestCloseEngagement = "slack"
)

// Defines values for PatchedNotificationsRequestCodeReview.
const (
	PatchedNotificationsRequestCodeReviewAlert PatchedNotificationsRequestCodeReview = "alert"

	PatchedNotificationsRequestCodeReviewMail PatchedNotificationsRequestCodeReview = "mail"

	PatchedNotificationsRequestCodeReviewMsteams PatchedNotificationsRequestCodeReview = "msteams"

	PatchedNotificationsRequestCodeReviewSlack PatchedNotificationsRequestCodeReview = "slack"
)

// Defines values for PatchedNotificationsRequestEngagementAdded.
const (
	PatchedNotificationsRequestEngagementAddedAlert PatchedNotificationsRequestEngagementAdded = "alert"

	PatchedNotificationsRequestEngagementAddedMail PatchedNotificationsRequestEngagementAdded = "mail"

	PatchedNotificationsRequestEngagementAddedMsteams PatchedNotificationsRequestEngagementAdded = "msteams"

	PatchedNotificationsRequestEngagementAddedSlack PatchedNotificationsRequestEngagementAdded = "slack"
)

// Defines values for PatchedNotificationsRequestJiraUpdate.
const (
	PatchedNotificationsRequestJiraUpdateAlert PatchedNotificationsRequestJiraUpdate = "alert"

	PatchedNotificationsRequestJiraUpdateMail PatchedNotificationsRequestJiraUpdate = "mail"

	PatchedNotificationsRequestJiraUpdateMsteams PatchedNotificationsRequestJiraUpdate = "msteams"

	PatchedNotificationsRequestJiraUpdateSlack PatchedNotificationsRequestJiraUpdate = "slack"
)

// Defines values for PatchedNotificationsRequestOther.
const (
	PatchedNotificationsRequestOtherAlert PatchedNotificationsRequestOther = "alert"

	PatchedNotificationsRequestOtherMail PatchedNotificationsRequestOther = "mail"

	PatchedNotificationsRequestOtherMsteams PatchedNotificationsRequestOther = "msteams"

	PatchedNotificationsRequestOtherSlack PatchedNotificationsRequestOther = "slack"
)

// Defines values for PatchedNotificationsRequestProductAdded.
const (
	PatchedNotificationsRequestProductAddedAlert PatchedNotificationsRequestProductAdded = "alert"

	PatchedNotificationsRequestProductAddedMail PatchedNotificationsRequestProductAdded = "mail"

	PatchedNotificationsRequestProductAddedMsteams PatchedNotificationsRequestProductAdded = "msteams"

	PatchedNotificationsRequestProductAddedSlack PatchedNotificationsRequestProductAdded = "slack"
)

// Defines values for PatchedNotificationsRequestProductTypeAdded.
const (
	PatchedNotificationsRequestProductTypeAddedAlert PatchedNotificationsRequestProductTypeAdded = "alert"

	PatchedNotificationsRequestProductTypeAddedMail PatchedNotificationsRequestProductTypeAdded = "mail"

	PatchedNotificationsRequestProductTypeAddedMsteams PatchedNotificationsRequestProductTypeAdded = "msteams"

	PatchedNotificationsRequestProductTypeAddedSlack PatchedNotificationsRequestProductTypeAdded = "slack"
)

// Defines values for PatchedNotificationsRequestReviewRequested.
const (
	PatchedNotificationsRequestReviewRequestedAlert PatchedNotificationsRequestReviewRequested = "alert"

	PatchedNotificationsRequestReviewRequestedMail PatchedNotificationsRequestReviewRequested = "mail"

	PatchedNotificationsRequestReviewRequestedMsteams PatchedNotificationsRequestReviewRequested = "msteams"

	PatchedNotificationsRequestReviewRequestedSlack PatchedNotificationsRequestReviewRequested = "slack"
)

// Defines values for PatchedNotificationsRequestRiskAcceptanceExpiration.
const (
	PatchedNotificationsRequestRiskAcceptanceExpirationAlert PatchedNotificationsRequestRiskAcceptanceExpiration = "alert"

	PatchedNotificationsRequestRiskAcceptanceExpirationMail PatchedNotificationsRequestRiskAcceptanceExpiration = "mail"

	PatchedNotificationsRequestRiskAcceptanceExpirationMsteams PatchedNotificationsRequestRiskAcceptanceExpiration = "msteams"

	PatchedNotificationsRequestRiskAcceptanceExpirationSlack PatchedNotificationsRequestRiskAcceptanceExpiration = "slack"
)

// Defines values for PatchedNotificationsRequestScanAdded.
const (
	PatchedNotificationsRequestScanAddedAlert PatchedNotificationsRequestScanAdded = "alert"

	PatchedNotificationsRequestScanAddedMail PatchedNotificationsRequestScanAdded = "mail"

	PatchedNotificationsRequestScanAddedMsteams PatchedNotificationsRequestScanAdded = "msteams"

	PatchedNotificationsRequestScanAddedSlack PatchedNotificationsRequestScanAdded = "slack"
)

// Defines values for PatchedNotificationsRequestSlaBreach.
const (
	PatchedNotificationsRequestSlaBreachAlert PatchedNotificationsRequestSlaBreach = "alert"

	PatchedNotificationsRequestSlaBreachMail PatchedNotificationsRequestSlaBreach = "mail"

	PatchedNotificationsRequestSlaBreachMsteams PatchedNotificationsRequestSlaBreach = "msteams"

	PatchedNotificationsRequestSlaBreachSlack PatchedNotificationsRequestSlaBreach = "slack"
)

// Defines values for PatchedNotificationsRequestStaleEngagement.
const (
	PatchedNotificationsRequestStaleEngagementAlert PatchedNotificationsRequestStaleEngagement = "alert"

	PatchedNotificationsRequestStaleEngagementMail PatchedNotificationsRequestStaleEngagement = "mail"

	PatchedNotificationsRequestStaleEngagementMsteams PatchedNotificationsRequestStaleEngagement = "msteams"

	PatchedNotificationsRequestStaleEngagementSlack PatchedNotificationsRequestStaleEngagement = "slack"
)

// Defines values for PatchedNotificationsRequestTestAdded.
const (
	PatchedNotificationsRequestTestAddedAlert PatchedNotificationsRequestTestAdded = "alert"

	PatchedNotificationsRequestTestAddedMail PatchedNotificationsRequestTestAdded = "mail"

	PatchedNotificationsRequestTestAddedMsteams PatchedNotificationsRequestTestAdded = "msteams"

	PatchedNotificationsRequestTestAddedSlack PatchedNotificationsRequestTestAdded = "slack"
)

// Defines values for PatchedNotificationsRequestUpcomingEngagement.
const (
	PatchedNotificationsRequestUpcomingEngagementAlert PatchedNotificationsRequestUpcomingEngagement = "alert"

	PatchedNotificationsRequestUpcomingEngagementMail PatchedNotificationsRequestUpcomingEngagement = "mail"

	PatchedNotificationsRequestUpcomingEngagementMsteams PatchedNotificationsRequestUpcomingEngagement = "msteams"

	PatchedNotificationsRequestUpcomingEngagementSlack PatchedNotificationsRequestUpcomingEngagement = "slack"
)

// Defines values for PatchedNotificationsRequestUserMentioned.
const (
	PatchedNotificationsRequestUserMentionedAlert PatchedNotificationsRequestUserMentioned = "alert"

	PatchedNotificationsRequestUserMentionedMail PatchedNotificationsRequestUserMentioned = "mail"

	PatchedNotificationsRequestUserMentionedMsteams PatchedNotificationsRequestUserMentioned = "msteams"

	PatchedNotificationsRequestUserMentionedSlack PatchedNotificationsRequestUserMentioned = "slack"
)

// Defines values for PatchedProductRequestBusinessCriticality.
const (
	PatchedProductRequestBusinessCriticalityEmpty PatchedProductRequestBusinessCriticality = ""

	PatchedProductRequestBusinessCriticalityHigh PatchedProductRequestBusinessCriticality = "high"

	PatchedProductRequestBusinessCriticalityLow PatchedProductRequestBusinessCriticality = "low"

	PatchedProductRequestBusinessCriticalityMedium PatchedProductRequestBusinessCriticality = "medium"

	PatchedProductRequestBusinessCriticalityNil PatchedProductRequestBusinessCriticality = "<nil>"

	PatchedProductRequestBusinessCriticalityNone PatchedProductRequestBusinessCriticality = "none"

	PatchedProductRequestBusinessCriticalityVeryHigh PatchedProductRequestBusinessCriticality = "very high"

	PatchedProductRequestBusinessCriticalityVeryLow PatchedProductRequestBusinessCriticality = "very low"
)

// Defines values for PatchedProductRequestLifecycle.
const (
	PatchedProductRequestLifecycleConstruction PatchedProductRequestLifecycle = "construction"

	PatchedProductRequestLifecycleEmpty PatchedProductRequestLifecycle = ""

	PatchedProductRequestLifecycleNil PatchedProductRequestLifecycle = "<nil>"

	PatchedProductRequestLifecycleProduction PatchedProductRequestLifecycle = "production"

	PatchedProductRequestLifecycleRetirement PatchedProductRequestLifecycle = "retirement"
)

// Defines values for PatchedProductRequestOrigin.
const (
	PatchedProductRequestOriginContractor PatchedProductRequestOrigin = "contractor"

	PatchedProductRequestOriginEmpty PatchedProductRequestOrigin = ""

	PatchedProductRequestOriginInternal PatchedProductRequestOrigin = "internal"

	PatchedProductRequestOriginNil PatchedProductRequestOrigin = "<nil>"

	PatchedProductRequestOriginOpenSource PatchedProductRequestOrigin = "open source"

	PatchedProductRequestOriginOutsourced PatchedProductRequestOrigin = "outsourced"

	PatchedProductRequestOriginPurchased PatchedProductRequestOrigin = "purchased"

	PatchedProductRequestOriginThirdPartyLibrary PatchedProductRequestOrigin = "third party library"
)

// Defines values for PatchedProductRequestPlatform.
const (
	PatchedProductRequestPlatformDesktop PatchedProductRequestPlatform = "desktop"

	PatchedProductRequestPlatformEmpty PatchedProductRequestPlatform = ""

	PatchedProductRequestPlatformIot PatchedProductRequestPlatform = "iot"

	PatchedProductRequestPlatformMobile PatchedProductRequestPlatform = "mobile"

	PatchedProductRequestPlatformNil PatchedProductRequestPlatform = "<nil>"

	PatchedProductRequestPlatformWeb PatchedProductRequestPlatform = "web"

	PatchedProductRequestPlatformWebService PatchedProductRequestPlatform = "web service"
)

// Defines values for PatchedRegulationRequestCategory.
const (
	PatchedRegulationRequestCategoryCorporate PatchedRegulationRequestCategory = "corporate"

	PatchedRegulationRequestCategoryEducation PatchedRegulationRequestCategory = "education"

	PatchedRegulationRequestCategoryFinance PatchedRegulationRequestCategory = "finance"

	PatchedRegulationRequestCategoryMedical PatchedRegulationRequestCategory = "medical"

	PatchedRegulationRequestCategoryOther PatchedRegulationRequestCategory = "other"

	PatchedRegulationRequestCategoryPrivacy PatchedRegulationRequestCategory = "privacy"
)

// Defines values for PatchedSystemSettingsRequestJiraMinimumSeverity.
const (
	PatchedSystemSettingsRequestJiraMinimumSeverityCritical PatchedSystemSettingsRequestJiraMinimumSeverity = "Critical"

	PatchedSystemSettingsRequestJiraMinimumSeverityEmpty PatchedSystemSettingsRequestJiraMinimumSeverity = ""

	PatchedSystemSettingsRequestJiraMinimumSeverityHigh PatchedSystemSettingsRequestJiraMinimumSeverity = "High"

	PatchedSystemSettingsRequestJiraMinimumSeverityInfo PatchedSystemSettingsRequestJiraMinimumSeverity = "Info"

	PatchedSystemSettingsRequestJiraMinimumSeverityLow PatchedSystemSettingsRequestJiraMinimumSeverity = "Low"

	PatchedSystemSettingsRequestJiraMinimumSeverityMedium PatchedSystemSettingsRequestJiraMinimumSeverity = "Medium"

	PatchedSystemSettingsRequestJiraMinimumSeverityNil PatchedSystemSettingsRequestJiraMinimumSeverity = "<nil>"
)

// Defines values for PatchedSystemSettingsRequestTimeZone.
const (
	PatchedSystemSettingsRequestTimeZoneAfricaAbidjan PatchedSystemSettingsRequestTimeZone = "Africa/Abidjan"

	PatchedSystemSettingsRequestTimeZoneAfricaAccra PatchedSystemSettingsRequestTimeZone = "Africa/Accra"

	PatchedSystemSettingsRequestTimeZoneAfricaAddisAbaba PatchedSystemSettingsRequestTimeZone = "Africa/Addis_Ababa"

	PatchedSystemSettingsRequestTimeZoneAfricaAlgiers PatchedSystemSettingsRequestTimeZone = "Africa/Algiers"

	PatchedSystemSettingsRequestTimeZoneAfricaAsmara PatchedSystemSettingsRequestTimeZone = "Africa/Asmara"

	PatchedSystemSettingsRequestTimeZoneAfricaAsmera PatchedSystemSettingsRequestTimeZone = "Africa/Asmera"

	PatchedSystemSettingsRequestTimeZoneAfricaBamako PatchedSystemSettingsRequestTimeZone = "Africa/Bamako"

	PatchedSystemSettingsRequestTimeZoneAfricaBangui PatchedSystemSettingsRequestTimeZone = "Africa/Bangui"

	PatchedSystemSettingsRequestTimeZoneAfricaBanjul PatchedSystemSettingsRequestTimeZone = "Africa/Banjul"

	PatchedSystemSettingsRequestTimeZoneAfricaBissau PatchedSystemSettingsRequestTimeZone = "Africa/Bissau"

	PatchedSystemSettingsRequestTimeZoneAfricaBlantyre PatchedSystemSettingsRequestTimeZone = "Africa/Blantyre"

	PatchedSystemSettingsRequestTimeZoneAfricaBrazzaville PatchedSystemSettingsRequestTimeZone = "Africa/Brazzaville"

	PatchedSystemSettingsRequestTimeZoneAfricaBujumbura PatchedSystemSettingsRequestTimeZone = "Africa/Bujumbura"

	PatchedSystemSettingsRequestTimeZoneAfricaCairo PatchedSystemSettingsRequestTimeZone = "Africa/Cairo"

	PatchedSystemSettingsRequestTimeZoneAfricaCasablanca PatchedSystemSettingsRequestTimeZone = "Africa/Casablanca"

	PatchedSystemSettingsRequestTimeZoneAfricaCeuta PatchedSystemSettingsRequestTimeZone = "Africa/Ceuta"

	PatchedSystemSettingsRequestTimeZoneAfricaConakry PatchedSystemSettingsRequestTimeZone = "Africa/Conakry"

	PatchedSystemSettingsRequestTimeZoneAfricaDakar PatchedSystemSettingsRequestTimeZone = "Africa/Dakar"

	PatchedSystemSettingsRequestTimeZoneAfricaDarEsSalaam PatchedSystemSettingsRequestTimeZone = "Africa/Dar_es_Salaam"

	PatchedSystemSettingsRequestTimeZoneAfricaDjibouti PatchedSystemSettingsRequestTimeZone = "Africa/Djibouti"

	PatchedSystemSettingsRequestTimeZoneAfricaDouala PatchedSystemSettingsRequestTimeZone = "Africa/Douala"

	PatchedSystemSettingsRequestTimeZoneAfricaElAaiun PatchedSystemSettingsRequestTimeZone = "Africa/El_Aaiun"

	PatchedSystemSettingsRequestTimeZoneAfricaFreetown PatchedSystemSettingsRequestTimeZone = "Africa/Freetown"

	PatchedSystemSettingsRequestTimeZoneAfricaGaborone PatchedSystemSettingsRequestTimeZone = "Africa/Gaborone"

	PatchedSystemSettingsRequestTimeZoneAfricaHarare PatchedSystemSettingsRequestTimeZone = "Africa/Harare"

	PatchedSystemSettingsRequestTimeZoneAfricaJohannesburg PatchedSystemSettingsRequestTimeZone = "Africa/Johannesburg"

	PatchedSystemSettingsRequestTimeZoneAfricaJuba PatchedSystemSettingsRequestTimeZone = "Africa/Juba"

	PatchedSystemSettingsRequestTimeZoneAfricaKampala PatchedSystemSettingsRequestTimeZone = "Africa/Kampala"

	PatchedSystemSettingsRequestTimeZoneAfricaKhartoum PatchedSystemSettingsRequestTimeZone = "Africa/Khartoum"

	PatchedSystemSettingsRequestTimeZoneAfricaKigali PatchedSystemSettingsRequestTimeZone = "Africa/Kigali"

	PatchedSystemSettingsRequestTimeZoneAfricaKinshasa PatchedSystemSettingsRequestTimeZone = "Africa/Kinshasa"

	PatchedSystemSettingsRequestTimeZoneAfricaLagos PatchedSystemSettingsRequestTimeZone = "Africa/Lagos"

	PatchedSystemSettingsRequestTimeZoneAfricaLibreville PatchedSystemSettingsRequestTimeZone = "Africa/Libreville"

	PatchedSystemSettingsRequestTimeZoneAfricaLome PatchedSystemSettingsRequestTimeZone = "Africa/Lome"

	PatchedSystemSettingsRequestTimeZoneAfricaLuanda PatchedSystemSettingsRequestTimeZone = "Africa/Luanda"

	PatchedSystemSettingsRequestTimeZoneAfricaLubumbashi PatchedSystemSettingsRequestTimeZone = "Africa/Lubumbashi"

	PatchedSystemSettingsRequestTimeZoneAfricaLusaka PatchedSystemSettingsRequestTimeZone = "Africa/Lusaka"

	PatchedSystemSettingsRequestTimeZoneAfricaMalabo PatchedSystemSettingsRequestTimeZone = "Africa/Malabo"

	PatchedSystemSettingsRequestTimeZoneAfricaMaputo PatchedSystemSettingsRequestTimeZone = "Africa/Maputo"

	PatchedSystemSettingsRequestTimeZoneAfricaMaseru PatchedSystemSettingsRequestTimeZone = "Africa/Maseru"

	PatchedSystemSettingsRequestTimeZoneAfricaMbabane PatchedSystemSettingsRequestTimeZone = "Africa/Mbabane"

	PatchedSystemSettingsRequestTimeZoneAfricaMogadishu PatchedSystemSettingsRequestTimeZone = "Africa/Mogadishu"

	PatchedSystemSettingsRequestTimeZoneAfricaMonrovia PatchedSystemSettingsRequestTimeZone = "Africa/Monrovia"

	PatchedSystemSettingsRequestTimeZoneAfricaNairobi PatchedSystemSettingsRequestTimeZone = "Africa/Nairobi"

	PatchedSystemSettingsRequestTimeZoneAfricaNdjamena PatchedSystemSettingsRequestTimeZone = "Africa/Ndjamena"

	PatchedSystemSettingsRequestTimeZoneAfricaNiamey PatchedSystemSettingsRequestTimeZone = "Africa/Niamey"

	PatchedSystemSettingsRequestTimeZoneAfricaNouakchott PatchedSystemSettingsRequestTimeZone = "Africa/Nouakchott"

	PatchedSystemSettingsRequestTimeZoneAfricaOuagadougou PatchedSystemSettingsRequestTimeZone = "Africa/Ouagadougou"

	PatchedSystemSettingsRequestTimeZoneAfricaPortoNovo PatchedSystemSettingsRequestTimeZone = "Africa/Porto-Novo"

	PatchedSystemSettingsRequestTimeZoneAfricaSaoTome PatchedSystemSettingsRequestTimeZone = "Africa/Sao_Tome"

	PatchedSystemSettingsRequestTimeZoneAfricaTimbuktu PatchedSystemSettingsRequestTimeZone = "Africa/Timbuktu"

	PatchedSystemSettingsRequestTimeZoneAfricaTripoli PatchedSystemSettingsRequestTimeZone = "Africa/Tripoli"

	PatchedSystemSettingsRequestTimeZoneAfricaTunis PatchedSystemSettingsRequestTimeZone = "Africa/Tunis"

	PatchedSystemSettingsRequestTimeZoneAfricaWindhoek PatchedSystemSettingsRequestTimeZone = "Africa/Windhoek"

	PatchedSystemSettingsRequestTimeZoneAmericaAdak PatchedSystemSettingsRequestTimeZone = "America/Adak"

	PatchedSystemSettingsRequestTimeZoneAmericaAnchorage PatchedSystemSettingsRequestTimeZone = "America/Anchorage"

	PatchedSystemSettingsRequestTimeZoneAmericaAnguilla PatchedSystemSettingsRequestTimeZone = "America/Anguilla"

	PatchedSystemSettingsRequestTimeZoneAmericaAntigua PatchedSystemSettingsRequestTimeZone = "America/Antigua"

	PatchedSystemSettingsRequestTimeZoneAmericaAraguaina PatchedSystemSettingsRequestTimeZone = "America/Araguaina"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaBuenosAires PatchedSystemSettingsRequestTimeZone = "America/Argentina/Buenos_Aires"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaCatamarca PatchedSystemSettingsRequestTimeZone = "America/Argentina/Catamarca"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaComodRivadavia PatchedSystemSettingsRequestTimeZone = "America/Argentina/ComodRivadavia"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaCordoba PatchedSystemSettingsRequestTimeZone = "America/Argentina/Cordoba"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaJujuy PatchedSystemSettingsRequestTimeZone = "America/Argentina/Jujuy"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaLaRioja PatchedSystemSettingsRequestTimeZone = "America/Argentina/La_Rioja"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaMendoza PatchedSystemSettingsRequestTimeZone = "America/Argentina/Mendoza"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaRioGallegos PatchedSystemSettingsRequestTimeZone = "America/Argentina/Rio_Gallegos"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaSalta PatchedSystemSettingsRequestTimeZone = "America/Argentina/Salta"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaSanJuan PatchedSystemSettingsRequestTimeZone = "America/Argentina/San_Juan"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaSanLuis PatchedSystemSettingsRequestTimeZone = "America/Argentina/San_Luis"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaTucuman PatchedSystemSettingsRequestTimeZone = "America/Argentina/Tucuman"

	PatchedSystemSettingsRequestTimeZoneAmericaArgentinaUshuaia PatchedSystemSettingsRequestTimeZone = "America/Argentina/Ushuaia"

	PatchedSystemSettingsRequestTimeZoneAmericaAruba PatchedSystemSettingsRequestTimeZone = "America/Aruba"

	PatchedSystemSettingsRequestTimeZoneAmericaAsuncion PatchedSystemSettingsRequestTimeZone = "America/Asuncion"

	PatchedSystemSettingsRequestTimeZoneAmericaAtikokan PatchedSystemSettingsRequestTimeZone = "America/Atikokan"

	PatchedSystemSettingsRequestTimeZoneAmericaAtka PatchedSystemSettingsRequestTimeZone = "America/Atka"

	PatchedSystemSettingsRequestTimeZoneAmericaBahia PatchedSystemSettingsRequestTimeZone = "America/Bahia"

	PatchedSystemSettingsRequestTimeZoneAmericaBahiaBanderas PatchedSystemSettingsRequestTimeZone = "America/Bahia_Banderas"

	PatchedSystemSettingsRequestTimeZoneAmericaBarbados PatchedSystemSettingsRequestTimeZone = "America/Barbados"

	PatchedSystemSettingsRequestTimeZoneAmericaBelem PatchedSystemSettingsRequestTimeZone = "America/Belem"

	PatchedSystemSettingsRequestTimeZoneAmericaBelize PatchedSystemSettingsRequestTimeZone = "America/Belize"

	PatchedSystemSettingsRequestTimeZoneAmericaBlancSablon PatchedSystemSettingsRequestTimeZone = "America/Blanc-Sablon"

	PatchedSystemSettingsRequestTimeZoneAmericaBoaVista PatchedSystemSettingsRequestTimeZone = "America/Boa_Vista"

	PatchedSystemSettingsRequestTimeZoneAmericaBogota PatchedSystemSettingsRequestTimeZone = "America/Bogota"

	PatchedSystemSettingsRequestTimeZoneAmericaBoise PatchedSystemSettingsRequestTimeZone = "America/Boise"

	PatchedSystemSettingsRequestTimeZoneAmericaBuenosAires PatchedSystemSettingsRequestTimeZone = "America/Buenos_Aires"

	PatchedSystemSettingsRequestTimeZoneAmericaCambridgeBay PatchedSystemSettingsRequestTimeZone = "America/Cambridge_Bay"

	PatchedSystemSettingsRequestTimeZoneAmericaCampoGrande PatchedSystemSettingsRequestTimeZone = "America/Campo_Grande"

	PatchedSystemSettingsRequestTimeZoneAmericaCancun PatchedSystemSettingsRequestTimeZone = "America/Cancun"

	PatchedSystemSettingsRequestTimeZoneAmericaCaracas PatchedSystemSettingsRequestTimeZone = "America/Caracas"

	PatchedSystemSettingsRequestTimeZoneAmericaCatamarca PatchedSystemSettingsRequestTimeZone = "America/Catamarca"

	PatchedSystemSettingsRequestTimeZoneAmericaCayenne PatchedSystemSettingsRequestTimeZone = "America/Cayenne"

	PatchedSystemSettingsRequestTimeZoneAmericaCayman PatchedSystemSettingsRequestTimeZone = "America/Cayman"

	PatchedSystemSettingsRequestTimeZoneAmericaChicago PatchedSystemSettingsRequestTimeZone = "America/Chicago"

	PatchedSystemSettingsRequestTimeZoneAmericaChihuahua PatchedSystemSettingsRequestTimeZone = "America/Chihuahua"

	PatchedSystemSettingsRequestTimeZoneAmericaCoralHarbour PatchedSystemSettingsRequestTimeZone = "America/Coral_Harbour"

	PatchedSystemSettingsRequestTimeZoneAmericaCordoba PatchedSystemSettingsRequestTimeZone = "America/Cordoba"

	PatchedSystemSettingsRequestTimeZoneAmericaCostaRica PatchedSystemSettingsRequestTimeZone = "America/Costa_Rica"

	PatchedSystemSettingsRequestTimeZoneAmericaCreston PatchedSystemSettingsRequestTimeZone = "America/Creston"

	PatchedSystemSettingsRequestTimeZoneAmericaCuiaba PatchedSystemSettingsRequestTimeZone = "America/Cuiaba"

	PatchedSystemSettingsRequestTimeZoneAmericaCuracao PatchedSystemSettingsRequestTimeZone = "America/Curacao"

	PatchedSystemSettingsRequestTimeZoneAmericaDanmarkshavn PatchedSystemSettingsRequestTimeZone = "America/Danmarkshavn"

	PatchedSystemSettingsRequestTimeZoneAmericaDawson PatchedSystemSettingsRequestTimeZone = "America/Dawson"

	PatchedSystemSettingsRequestTimeZoneAmericaDawsonCreek PatchedSystemSettingsRequestTimeZone = "America/Dawson_Creek"

	PatchedSystemSettingsRequestTimeZoneAmericaDenver PatchedSystemSettingsRequestTimeZone = "America/Denver"

	PatchedSystemSettingsRequestTimeZoneAmericaDetroit PatchedSystemSettingsRequestTimeZone = "America/Detroit"

	PatchedSystemSettingsRequestTimeZoneAmericaDominica PatchedSystemSettingsRequestTimeZone = "America/Dominica"

	PatchedSystemSettingsRequestTimeZoneAmericaEdmonton PatchedSystemSettingsRequestTimeZone = "America/Edmonton"

	PatchedSystemSettingsRequestTimeZoneAmericaEirunepe PatchedSystemSettingsRequestTimeZone = "America/Eirunepe"

	PatchedSystemSettingsRequestTimeZoneAmericaElSalvador PatchedSystemSettingsRequestTimeZone = "America/El_Salvador"

	PatchedSystemSettingsRequestTimeZoneAmericaEnsenada PatchedSystemSettingsRequestTimeZone = "America/Ensenada"

	PatchedSystemSettingsRequestTimeZoneAmericaFortNelson PatchedSystemSettingsRequestTimeZone = "America/Fort_Nelson"

	PatchedSystemSettingsRequestTimeZoneAmericaFortWayne PatchedSystemSettingsRequestTimeZone = "America/Fort_Wayne"

	PatchedSystemSettingsRequestTimeZoneAmericaFortaleza PatchedSystemSettingsRequestTimeZone = "America/Fortaleza"

	PatchedSystemSettingsRequestTimeZoneAmericaGlaceBay PatchedSystemSettingsRequestTimeZone = "America/Glace_Bay"

	PatchedSystemSettingsRequestTimeZoneAmericaGodthab PatchedSystemSettingsRequestTimeZone = "America/Godthab"

	PatchedSystemSettingsRequestTimeZoneAmericaGooseBay PatchedSystemSettingsRequestTimeZone = "America/Goose_Bay"

	PatchedSystemSettingsRequestTimeZoneAmericaGrandTurk PatchedSystemSettingsRequestTimeZone = "America/Grand_Turk"

	PatchedSystemSettingsRequestTimeZoneAmericaGrenada PatchedSystemSettingsRequestTimeZone = "America/Grenada"

	PatchedSystemSettingsRequestTimeZoneAmericaGuadeloupe PatchedSystemSettingsRequestTimeZone = "America/Guadeloupe"

	PatchedSystemSettingsRequestTimeZoneAmericaGuatemala PatchedSystemSettingsRequestTimeZone = "America/Guatemala"

	PatchedSystemSettingsRequestTimeZoneAmericaGuayaquil PatchedSystemSettingsRequestTimeZone = "America/Guayaquil"

	PatchedSystemSettingsRequestTimeZoneAmericaGuyana PatchedSystemSettingsRequestTimeZone = "America/Guyana"

	PatchedSystemSettingsRequestTimeZoneAmericaHalifax PatchedSystemSettingsRequestTimeZone = "America/Halifax"

	PatchedSystemSettingsRequestTimeZoneAmericaHavana PatchedSystemSettingsRequestTimeZone = "America/Havana"

	PatchedSystemSettingsRequestTimeZoneAmericaHermosillo PatchedSystemSettingsRequestTimeZone = "America/Hermosillo"

	PatchedSystemSettingsRequestTimeZoneAmericaIndianaIndianapolis PatchedSystemSettingsRequestTimeZone = "America/Indiana/Indianapolis"

	PatchedSystemSettingsRequestTimeZoneAmericaIndianaKnox PatchedSystemSettingsRequestTimeZone = "America/Indiana/Knox"

	PatchedSystemSettingsRequestTimeZoneAmericaIndianaMarengo PatchedSystemSettingsRequestTimeZone = "America/Indiana/Marengo"

	PatchedSystemSettingsRequestTimeZoneAmericaIndianaPetersburg PatchedSystemSettingsRequestTimeZone = "America/Indiana/Petersburg"

	PatchedSystemSettingsRequestTimeZoneAmericaIndianaTellCity PatchedSystemSettingsRequestTimeZone = "America/Indiana/Tell_City"

	PatchedSystemSettingsRequestTimeZoneAmericaIndianaVevay PatchedSystemSettingsRequestTimeZone = "America/Indiana/Vevay"

	PatchedSystemSettingsRequestTimeZoneAmericaIndianaVincennes PatchedSystemSettingsRequestTimeZone = "America/Indiana/Vincennes"

	PatchedSystemSettingsRequestTimeZoneAmericaIndianaWinamac PatchedSystemSettingsRequestTimeZone = "America/Indiana/Winamac"

	PatchedSystemSettingsRequestTimeZoneAmericaIndianapolis PatchedSystemSettingsRequestTimeZone = "America/Indianapolis"

	PatchedSystemSettingsRequestTimeZoneAmericaInuvik PatchedSystemSettingsRequestTimeZone = "America/Inuvik"

	PatchedSystemSettingsRequestTimeZoneAmericaIqaluit PatchedSystemSettingsRequestTimeZone = "America/Iqaluit"

	PatchedSystemSettingsRequestTimeZoneAmericaJamaica PatchedSystemSettingsRequestTimeZone = "America/Jamaica"

	PatchedSystemSettingsRequestTimeZoneAmericaJujuy PatchedSystemSettingsRequestTimeZone = "America/Jujuy"

	PatchedSystemSettingsRequestTimeZoneAmericaJuneau PatchedSystemSettingsRequestTimeZone = "America/Juneau"

	PatchedSystemSettingsRequestTimeZoneAmericaKentuckyLouisville PatchedSystemSettingsRequestTimeZone = "America/Kentucky/Louisville"

	PatchedSystemSettingsRequestTimeZoneAmericaKentuckyMonticello PatchedSystemSettingsRequestTimeZone = "America/Kentucky/Monticello"

	PatchedSystemSettingsRequestTimeZoneAmericaKnoxIN PatchedSystemSettingsRequestTimeZone = "America/Knox_IN"

	PatchedSystemSettingsRequestTimeZoneAmericaKralendijk PatchedSystemSettingsRequestTimeZone = "America/Kralendijk"

	PatchedSystemSettingsRequestTimeZoneAmericaLaPaz PatchedSystemSettingsRequestTimeZone = "America/La_Paz"

	PatchedSystemSettingsRequestTimeZoneAmericaLima PatchedSystemSettingsRequestTimeZone = "America/Lima"

	PatchedSystemSettingsRequestTimeZoneAmericaLosAngeles PatchedSystemSettingsRequestTimeZone = "America/Los_Angeles"

	PatchedSystemSettingsRequestTimeZoneAmericaLouisville PatchedSystemSettingsRequestTimeZone = "America/Louisville"

	PatchedSystemSettingsRequestTimeZoneAmericaLowerPrinces PatchedSystemSettingsRequestTimeZone = "America/Lower_Princes"

	PatchedSystemSettingsRequestTimeZoneAmericaMaceio PatchedSystemSettingsRequestTimeZone = "America/Maceio"

	PatchedSystemSettingsRequestTimeZoneAmericaManagua PatchedSystemSettingsRequestTimeZone = "America/Managua"

	PatchedSystemSettingsRequestTimeZoneAmericaManaus PatchedSystemSettingsRequestTimeZone = "America/Manaus"

	PatchedSystemSettingsRequestTimeZoneAmericaMarigot PatchedSystemSettingsRequestTimeZone = "America/Marigot"

	PatchedSystemSettingsRequestTimeZoneAmericaMartinique PatchedSystemSettingsRequestTimeZone = "America/Martinique"

	PatchedSystemSettingsRequestTimeZoneAmericaMatamoros PatchedSystemSettingsRequestTimeZone = "America/Matamoros"

	PatchedSystemSettingsRequestTimeZoneAmericaMazatlan PatchedSystemSettingsRequestTimeZone = "America/Mazatlan"

	PatchedSystemSettingsRequestTimeZoneAmericaMendoza PatchedSystemSettingsRequestTimeZone = "America/Mendoza"

	PatchedSystemSettingsRequestTimeZoneAmericaMenominee PatchedSystemSettingsRequestTimeZone = "America/Menominee"

	PatchedSystemSettingsRequestTimeZoneAmericaMerida PatchedSystemSettingsRequestTimeZone = "America/Merida"

	PatchedSystemSettingsRequestTimeZoneAmericaMetlakatla PatchedSystemSettingsRequestTimeZone = "America/Metlakatla"

	PatchedSystemSettingsRequestTimeZoneAmericaMexicoCity PatchedSystemSettingsRequestTimeZone = "America/Mexico_City"

	PatchedSystemSettingsRequestTimeZoneAmericaMiquelon PatchedSystemSettingsRequestTimeZone = "America/Miquelon"

	PatchedSystemSettingsRequestTimeZoneAmericaMoncton PatchedSystemSettingsRequestTimeZone = "America/Moncton"

	PatchedSystemSettingsRequestTimeZoneAmericaMonterrey PatchedSystemSettingsRequestTimeZone = "America/Monterrey"

	PatchedSystemSettingsRequestTimeZoneAmericaMontevideo PatchedSystemSettingsRequestTimeZone = "America/Montevideo"

	PatchedSystemSettingsRequestTimeZoneAmericaMontreal PatchedSystemSettingsRequestTimeZone = "America/Montreal"

	PatchedSystemSettingsRequestTimeZoneAmericaMontserrat PatchedSystemSettingsRequestTimeZone = "America/Montserrat"

	PatchedSystemSettingsRequestTimeZoneAmericaNassau PatchedSystemSettingsRequestTimeZone = "America/Nassau"

	PatchedSystemSettingsRequestTimeZoneAmericaNewYork PatchedSystemSettingsRequestTimeZone = "America/New_York"

	PatchedSystemSettingsRequestTimeZoneAmericaNipigon PatchedSystemSettingsRequestTimeZone = "America/Nipigon"

	PatchedSystemSettingsRequestTimeZoneAmericaNome PatchedSystemSettingsRequestTimeZone = "America/Nome"

	PatchedSystemSettingsRequestTimeZoneAmericaNoronha PatchedSystemSettingsRequestTimeZone = "America/Noronha"

	PatchedSystemSettingsRequestTimeZoneAmericaNorthDakotaBeulah PatchedSystemSettingsRequestTimeZone = "America/North_Dakota/Beulah"

	PatchedSystemSettingsRequestTimeZoneAmericaNorthDakotaCenter PatchedSystemSettingsRequestTimeZone = "America/North_Dakota/Center"

	PatchedSystemSettingsRequestTimeZoneAmericaNorthDakotaNewSalem PatchedSystemSettingsRequestTimeZone = "America/North_Dakota/New_Salem"

	PatchedSystemSettingsRequestTimeZoneAmericaNuuk PatchedSystemSettingsRequestTimeZone = "America/Nuuk"

	PatchedSystemSettingsRequestTimeZoneAmericaOjinaga PatchedSystemSettingsRequestTimeZone = "America/Ojinaga"

	PatchedSystemSettingsRequestTimeZoneAmericaPanama PatchedSystemSettingsRequestTimeZone = "America/Panama"

	PatchedSystemSettingsRequestTimeZoneAmericaPangnirtung PatchedSystemSettingsRequestTimeZone = "America/Pangnirtung"

	PatchedSystemSettingsRequestTimeZoneAmericaParamaribo PatchedSystemSettingsRequestTimeZone = "America/Paramaribo"

	PatchedSystemSettingsRequestTimeZoneAmericaPhoenix PatchedSystemSettingsRequestTimeZone = "America/Phoenix"

	PatchedSystemSettingsRequestTimeZoneAmericaPortAuPrince PatchedSystemSettingsRequestTimeZone = "America/Port-au-Prince"

	PatchedSystemSettingsRequestTimeZoneAmericaPortOfSpain PatchedSystemSettingsRequestTimeZone = "America/Port_of_Spain"

	PatchedSystemSettingsRequestTimeZoneAmericaPortoAcre PatchedSystemSettingsRequestTimeZone = "America/Porto_Acre"

	PatchedSystemSettingsRequestTimeZoneAmericaPortoVelho PatchedSystemSettingsRequestTimeZone = "America/Porto_Velho"

	PatchedSystemSettingsRequestTimeZoneAmericaPuertoRico PatchedSystemSettingsRequestTimeZone = "America/Puerto_Rico"

	PatchedSystemSettingsRequestTimeZoneAmericaPuntaArenas PatchedSystemSettingsRequestTimeZone = "America/Punta_Arenas"

	PatchedSystemSettingsRequestTimeZoneAmericaRainyRiver PatchedSystemSettingsRequestTimeZone = "America/Rainy_River"

	PatchedSystemSettingsRequestTimeZoneAmericaRankinInlet PatchedSystemSettingsRequestTimeZone = "America/Rankin_Inlet"

	PatchedSystemSettingsRequestTimeZoneAmericaRecife PatchedSystemSettingsRequestTimeZone = "America/Recife"

	PatchedSystemSettingsRequestTimeZoneAmericaRegina PatchedSystemSettingsRequestTimeZone = "America/Regina"

	PatchedSystemSettingsRequestTimeZoneAmericaResolute PatchedSystemSettingsRequestTimeZone = "America/Resolute"

	PatchedSystemSettingsRequestTimeZoneAmericaRioBranco PatchedSystemSettingsRequestTimeZone = "America/Rio_Branco"

	PatchedSystemSettingsRequestTimeZoneAmericaRosario PatchedSystemSettingsRequestTimeZone = "America/Rosario"

	PatchedSystemSettingsRequestTimeZoneAmericaSantaIsabel PatchedSystemSettingsRequestTimeZone = "America/Santa_Isabel"

	PatchedSystemSettingsRequestTimeZoneAmericaSantarem PatchedSystemSettingsRequestTimeZone = "America/Santarem"

	PatchedSystemSettingsRequestTimeZoneAmericaSantiago PatchedSystemSettingsRequestTimeZone = "America/Santiago"

	PatchedSystemSettingsRequestTimeZoneAmericaSantoDomingo PatchedSystemSettingsRequestTimeZone = "America/Santo_Domingo"

	PatchedSystemSettingsRequestTimeZoneAmericaSaoPaulo PatchedSystemSettingsRequestTimeZone = "America/Sao_Paulo"

	PatchedSystemSettingsRequestTimeZoneAmericaScoresbysund PatchedSystemSettingsRequestTimeZone = "America/Scoresbysund"

	PatchedSystemSettingsRequestTimeZoneAmericaShiprock PatchedSystemSettingsRequestTimeZone = "America/Shiprock"

	PatchedSystemSettingsRequestTimeZoneAmericaSitka PatchedSystemSettingsRequestTimeZone = "America/Sitka"

	PatchedSystemSettingsRequestTimeZoneAmericaStBarthelemy PatchedSystemSettingsRequestTimeZone = "America/St_Barthelemy"

	PatchedSystemSettingsRequestTimeZoneAmericaStJohns PatchedSystemSettingsRequestTimeZone = "America/St_Johns"

	PatchedSystemSettingsRequestTimeZoneAmericaStKitts PatchedSystemSettingsRequestTimeZone = "America/St_Kitts"

	PatchedSystemSettingsRequestTimeZoneAmericaStLucia PatchedSystemSettingsRequestTimeZone = "America/St_Lucia"

	PatchedSystemSettingsRequestTimeZoneAmericaStThomas PatchedSystemSettingsRequestTimeZone = "America/St_Thomas"

	PatchedSystemSettingsRequestTimeZoneAmericaStVincent PatchedSystemSettingsRequestTimeZone = "America/St_Vincent"

	PatchedSystemSettingsRequestTimeZoneAmericaSwiftCurrent PatchedSystemSettingsRequestTimeZone = "America/Swift_Current"

	PatchedSystemSettingsRequestTimeZoneAmericaTegucigalpa PatchedSystemSettingsRequestTimeZone = "America/Tegucigalpa"

	PatchedSystemSettingsRequestTimeZoneAmericaThule PatchedSystemSettingsRequestTimeZone = "America/Thule"

	PatchedSystemSettingsRequestTimeZoneAmericaThunderBay PatchedSystemSettingsRequestTimeZone = "America/Thunder_Bay"

	PatchedSystemSettingsRequestTimeZoneAmericaTijuana PatchedSystemSettingsRequestTimeZone = "America/Tijuana"

	PatchedSystemSettingsRequestTimeZoneAmericaToronto PatchedSystemSettingsRequestTimeZone = "America/Toronto"

	PatchedSystemSettingsRequestTimeZoneAmericaTortola PatchedSystemSettingsRequestTimeZone = "America/Tortola"

	PatchedSystemSettingsRequestTimeZoneAmericaVancouver PatchedSystemSettingsRequestTimeZone = "America/Vancouver"

	PatchedSystemSettingsRequestTimeZoneAmericaVirgin PatchedSystemSettingsRequestTimeZone = "America/Virgin"

	PatchedSystemSettingsRequestTimeZoneAmericaWhitehorse PatchedSystemSettingsRequestTimeZone = "America/Whitehorse"

	PatchedSystemSettingsRequestTimeZoneAmericaWinnipeg PatchedSystemSettingsRequestTimeZone = "America/Winnipeg"

	PatchedSystemSettingsRequestTimeZoneAmericaYakutat PatchedSystemSettingsRequestTimeZone = "America/Yakutat"

	PatchedSystemSettingsRequestTimeZoneAmericaYellowknife PatchedSystemSettingsRequestTimeZone = "America/Yellowknife"

	PatchedSystemSettingsRequestTimeZoneAntarcticaCasey PatchedSystemSettingsRequestTimeZone = "Antarctica/Casey"

	PatchedSystemSettingsRequestTimeZoneAntarcticaDavis PatchedSystemSettingsRequestTimeZone = "Antarctica/Davis"

	PatchedSystemSettingsRequestTimeZoneAntarcticaDumontDUrville PatchedSystemSettingsRequestTimeZone = "Antarctica/DumontDUrville"

	PatchedSystemSettingsRequestTimeZoneAntarcticaMacquarie PatchedSystemSettingsRequestTimeZone = "Antarctica/Macquarie"

	PatchedSystemSettingsRequestTimeZoneAntarcticaMawson PatchedSystemSettingsRequestTimeZone = "Antarctica/Mawson"

	PatchedSystemSettingsRequestTimeZoneAntarcticaMcMurdo PatchedSystemSettingsRequestTimeZone = "Antarctica/McMurdo"

	PatchedSystemSettingsRequestTimeZoneAntarcticaPalmer PatchedSystemSettingsRequestTimeZone = "Antarctica/Palmer"

	PatchedSystemSettingsRequestTimeZoneAntarcticaRothera PatchedSystemSettingsRequestTimeZone = "Antarctica/Rothera"

	PatchedSystemSettingsRequestTimeZoneAntarcticaSouthPole PatchedSystemSettingsRequestTimeZone = "Antarctica/South_Pole"

	PatchedSystemSettingsRequestTimeZoneAntarcticaSyowa PatchedSystemSettingsRequestTimeZone = "Antarctica/Syowa"

	PatchedSystemSettingsRequestTimeZoneAntarcticaTroll PatchedSystemSettingsRequestTimeZone = "Antarctica/Troll"

	PatchedSystemSettingsRequestTimeZoneAntarcticaVostok PatchedSystemSettingsRequestTimeZone = "Antarctica/Vostok"

	PatchedSystemSettingsRequestTimeZoneArcticLongyearbyen PatchedSystemSettingsRequestTimeZone = "Arctic/Longyearbyen"

	PatchedSystemSettingsRequestTimeZoneAsiaAden PatchedSystemSettingsRequestTimeZone = "Asia/Aden"

	PatchedSystemSettingsRequestTimeZoneAsiaAlmaty PatchedSystemSettingsRequestTimeZone = "Asia/Almaty"

	PatchedSystemSettingsRequestTimeZoneAsiaAmman PatchedSystemSettingsRequestTimeZone = "Asia/Amman"

	PatchedSystemSettingsRequestTimeZoneAsiaAnadyr PatchedSystemSettingsRequestTimeZone = "Asia/Anadyr"

	PatchedSystemSettingsRequestTimeZoneAsiaAqtau PatchedSystemSettingsRequestTimeZone = "Asia/Aqtau"

	PatchedSystemSettingsRequestTimeZoneAsiaAqtobe PatchedSystemSettingsRequestTimeZone = "Asia/Aqtobe"

	PatchedSystemSettingsRequestTimeZoneAsiaAshgabat PatchedSystemSettingsRequestTimeZone = "Asia/Ashgabat"

	PatchedSystemSettingsRequestTimeZoneAsiaAshkhabad PatchedSystemSettingsRequestTimeZone = "Asia/Ashkhabad"

	PatchedSystemSettingsRequestTimeZoneAsiaAtyrau PatchedSystemSettingsRequestTimeZone = "Asia/Atyrau"

	PatchedSystemSettingsRequestTimeZoneAsiaBaghdad PatchedSystemSettingsRequestTimeZone = "Asia/Baghdad"

	PatchedSystemSettingsRequestTimeZoneAsiaBahrain PatchedSystemSettingsRequestTimeZone = "Asia/Bahrain"

	PatchedSystemSettingsRequestTimeZoneAsiaBaku PatchedSystemSettingsRequestTimeZone = "Asia/Baku"

	PatchedSystemSettingsRequestTimeZoneAsiaBangkok PatchedSystemSettingsRequestTimeZone = "Asia/Bangkok"

	PatchedSystemSettingsRequestTimeZoneAsiaBarnaul PatchedSystemSettingsRequestTimeZone = "Asia/Barnaul"

	PatchedSystemSettingsRequestTimeZoneAsiaBeirut PatchedSystemSettingsRequestTimeZone = "Asia/Beirut"

	PatchedSystemSettingsRequestTimeZoneAsiaBishkek PatchedSystemSettingsRequestTimeZone = "Asia/Bishkek"

	PatchedSystemSettingsRequestTimeZoneAsiaBrunei PatchedSystemSettingsRequestTimeZone = "Asia/Brunei"

	PatchedSystemSettingsRequestTimeZoneAsiaCalcutta PatchedSystemSettingsRequestTimeZone = "Asia/Calcutta"

	PatchedSystemSettingsRequestTimeZoneAsiaChita PatchedSystemSettingsRequestTimeZone = "Asia/Chita"

	PatchedSystemSettingsRequestTimeZoneAsiaChoibalsan PatchedSystemSettingsRequestTimeZone = "Asia/Choibalsan"

	PatchedSystemSettingsRequestTimeZoneAsiaChongqing PatchedSystemSettingsRequestTimeZone = "Asia/Chongqing"

	PatchedSystemSettingsRequestTimeZoneAsiaChungking PatchedSystemSettingsRequestTimeZone = "Asia/Chungking"

	PatchedSystemSettingsRequestTimeZoneAsiaColombo PatchedSystemSettingsRequestTimeZone = "Asia/Colombo"

	PatchedSystemSettingsRequestTimeZoneAsiaDacca PatchedSystemSettingsRequestTimeZone = "Asia/Dacca"

	PatchedSystemSettingsRequestTimeZoneAsiaDamascus PatchedSystemSettingsRequestTimeZone = "Asia/Damascus"

	PatchedSystemSettingsRequestTimeZoneAsiaDhaka PatchedSystemSettingsRequestTimeZone = "Asia/Dhaka"

	PatchedSystemSettingsRequestTimeZoneAsiaDili PatchedSystemSettingsRequestTimeZone = "Asia/Dili"

	PatchedSystemSettingsRequestTimeZoneAsiaDubai PatchedSystemSettingsRequestTimeZone = "Asia/Dubai"

	PatchedSystemSettingsRequestTimeZoneAsiaDushanbe PatchedSystemSettingsRequestTimeZone = "Asia/Dushanbe"

	PatchedSystemSettingsRequestTimeZoneAsiaFamagusta PatchedSystemSettingsRequestTimeZone = "Asia/Famagusta"

	PatchedSystemSettingsRequestTimeZoneAsiaGaza PatchedSystemSettingsRequestTimeZone = "Asia/Gaza"

	PatchedSystemSettingsRequestTimeZoneAsiaHarbin PatchedSystemSettingsRequestTimeZone = "Asia/Harbin"

	PatchedSystemSettingsRequestTimeZoneAsiaHebron PatchedSystemSettingsRequestTimeZone = "Asia/Hebron"

	PatchedSystemSettingsRequestTimeZoneAsiaHoChiMinh PatchedSystemSettingsRequestTimeZone = "Asia/Ho_Chi_Minh"

	PatchedSystemSettingsRequestTimeZoneAsiaHongKong PatchedSystemSettingsRequestTimeZone = "Asia/Hong_Kong"

	PatchedSystemSettingsRequestTimeZoneAsiaHovd PatchedSystemSettingsRequestTimeZone = "Asia/Hovd"

	PatchedSystemSettingsRequestTimeZoneAsiaIrkutsk PatchedSystemSettingsRequestTimeZone = "Asia/Irkutsk"

	PatchedSystemSettingsRequestTimeZoneAsiaIstanbul PatchedSystemSettingsRequestTimeZone = "Asia/Istanbul"

	PatchedSystemSettingsRequestTimeZoneAsiaJakarta PatchedSystemSettingsRequestTimeZone = "Asia/Jakarta"

	PatchedSystemSettingsRequestTimeZoneAsiaJayapura PatchedSystemSettingsRequestTimeZone = "Asia/Jayapura"

	PatchedSystemSettingsRequestTimeZoneAsiaJerusalem PatchedSystemSettingsRequestTimeZone = "Asia/Jerusalem"

	PatchedSystemSettingsRequestTimeZoneAsiaKabul PatchedSystemSettingsRequestTimeZone = "Asia/Kabul"

	PatchedSystemSettingsRequestTimeZoneAsiaKamchatka PatchedSystemSettingsRequestTimeZone = "Asia/Kamchatka"

	PatchedSystemSettingsRequestTimeZoneAsiaKarachi PatchedSystemSettingsRequestTimeZone = "Asia/Karachi"

	PatchedSystemSettingsRequestTimeZoneAsiaKashgar PatchedSystemSettingsRequestTimeZone = "Asia/Kashgar"

	PatchedSystemSettingsRequestTimeZoneAsiaKathmandu PatchedSystemSettingsRequestTimeZone = "Asia/Kathmandu"

	PatchedSystemSettingsRequestTimeZoneAsiaKatmandu PatchedSystemSettingsRequestTimeZone = "Asia/Katmandu"

	PatchedSystemSettingsRequestTimeZoneAsiaKhandyga PatchedSystemSettingsRequestTimeZone = "Asia/Khandyga"

	PatchedSystemSettingsRequestTimeZoneAsiaKolkata PatchedSystemSettingsRequestTimeZone = "Asia/Kolkata"

	PatchedSystemSettingsRequestTimeZoneAsiaKrasnoyarsk PatchedSystemSettingsRequestTimeZone = "Asia/Krasnoyarsk"

	PatchedSystemSettingsRequestTimeZoneAsiaKualaLumpur PatchedSystemSettingsRequestTimeZone = "Asia/Kuala_Lumpur"

	PatchedSystemSettingsRequestTimeZoneAsiaKuching PatchedSystemSettingsRequestTimeZone = "Asia/Kuching"

	PatchedSystemSettingsRequestTimeZoneAsiaKuwait PatchedSystemSettingsRequestTimeZone = "Asia/Kuwait"

	PatchedSystemSettingsRequestTimeZoneAsiaMacao PatchedSystemSettingsRequestTimeZone = "Asia/Macao"

	PatchedSystemSettingsRequestTimeZoneAsiaMacau PatchedSystemSettingsRequestTimeZone = "Asia/Macau"

	PatchedSystemSettingsRequestTimeZoneAsiaMagadan PatchedSystemSettingsRequestTimeZone = "Asia/Magadan"

	PatchedSystemSettingsRequestTimeZoneAsiaMakassar PatchedSystemSettingsRequestTimeZone = "Asia/Makassar"

	PatchedSystemSettingsRequestTimeZoneAsiaManila PatchedSystemSettingsRequestTimeZone = "Asia/Manila"

	PatchedSystemSettingsRequestTimeZoneAsiaMuscat PatchedSystemSettingsRequestTimeZone = "Asia/Muscat"

	PatchedSystemSettingsRequestTimeZoneAsiaNicosia PatchedSystemSettingsRequestTimeZone = "Asia/Nicosia"

	PatchedSystemSettingsRequestTimeZoneAsiaNovokuznetsk PatchedSystemSettingsRequestTimeZone = "Asia/Novokuznetsk"

	PatchedSystemSettingsRequestTimeZoneAsiaNovosibirsk PatchedSystemSettingsRequestTimeZone = "Asia/Novosibirsk"

	PatchedSystemSettingsRequestTimeZoneAsiaOmsk PatchedSystemSettingsRequestTimeZone = "Asia/Omsk"

	PatchedSystemSettingsRequestTimeZoneAsiaOral PatchedSystemSettingsRequestTimeZone = "Asia/Oral"

	PatchedSystemSettingsRequestTimeZoneAsiaPhnomPenh PatchedSystemSettingsRequestTimeZone = "Asia/Phnom_Penh"

	PatchedSystemSettingsRequestTimeZoneAsiaPontianak PatchedSystemSettingsRequestTimeZone = "Asia/Pontianak"

	PatchedSystemSettingsRequestTimeZoneAsiaPyongyang PatchedSystemSettingsRequestTimeZone = "Asia/Pyongyang"

	PatchedSystemSettingsRequestTimeZoneAsiaQatar PatchedSystemSettingsRequestTimeZone = "Asia/Qatar"

	PatchedSystemSettingsRequestTimeZoneAsiaQostanay PatchedSystemSettingsRequestTimeZone = "Asia/Qostanay"

	PatchedSystemSettingsRequestTimeZoneAsiaQyzylorda PatchedSystemSettingsRequestTimeZone = "Asia/Qyzylorda"

	PatchedSystemSettingsRequestTimeZoneAsiaRangoon PatchedSystemSettingsRequestTimeZone = "Asia/Rangoon"

	PatchedSystemSettingsRequestTimeZoneAsiaRiyadh PatchedSystemSettingsRequestTimeZone = "Asia/Riyadh"

	PatchedSystemSettingsRequestTimeZoneAsiaSaigon PatchedSystemSettingsRequestTimeZone = "Asia/Saigon"

	PatchedSystemSettingsRequestTimeZoneAsiaSakhalin PatchedSystemSettingsRequestTimeZone = "Asia/Sakhalin"

	PatchedSystemSettingsRequestTimeZoneAsiaSamarkand PatchedSystemSettingsRequestTimeZone = "Asia/Samarkand"

	PatchedSystemSettingsRequestTimeZoneAsiaSeoul PatchedSystemSettingsRequestTimeZone = "Asia/Seoul"

	PatchedSystemSettingsRequestTimeZoneAsiaShanghai PatchedSystemSettingsRequestTimeZone = "Asia/Shanghai"

	PatchedSystemSettingsRequestTimeZoneAsiaSingapore PatchedSystemSettingsRequestTimeZone = "Asia/Singapore"

	PatchedSystemSettingsRequestTimeZoneAsiaSrednekolymsk PatchedSystemSettingsRequestTimeZone = "Asia/Srednekolymsk"

	PatchedSystemSettingsRequestTimeZoneAsiaTaipei PatchedSystemSettingsRequestTimeZone = "Asia/Taipei"

	PatchedSystemSettingsRequestTimeZoneAsiaTashkent PatchedSystemSettingsRequestTimeZone = "Asia/Tashkent"

	PatchedSystemSettingsRequestTimeZoneAsiaTbilisi PatchedSystemSettingsRequestTimeZone = "Asia/Tbilisi"

	PatchedSystemSettingsRequestTimeZoneAsiaTehran PatchedSystemSettingsRequestTimeZone = "Asia/Tehran"

	PatchedSystemSettingsRequestTimeZoneAsiaTelAviv PatchedSystemSettingsRequestTimeZone = "Asia/Tel_Aviv"

	PatchedSystemSettingsRequestTimeZoneAsiaThimbu PatchedSystemSettingsRequestTimeZone = "Asia/Thimbu"

	PatchedSystemSettingsRequestTimeZoneAsiaThimphu PatchedSystemSettingsRequestTimeZone = "Asia/Thimphu"

	PatchedSystemSettingsRequestTimeZoneAsiaTokyo PatchedSystemSettingsRequestTimeZone = "Asia/Tokyo"

	PatchedSystemSettingsRequestTimeZoneAsiaTomsk PatchedSystemSettingsRequestTimeZone = "Asia/Tomsk"

	PatchedSystemSettingsRequestTimeZoneAsiaUjungPandang PatchedSystemSettingsRequestTimeZone = "Asia/Ujung_Pandang"

	PatchedSystemSettingsRequestTimeZoneAsiaUlaanbaatar PatchedSystemSettingsRequestTimeZone = "Asia/Ulaanbaatar"

	PatchedSystemSettingsRequestTimeZoneAsiaUlanBator PatchedSystemSettingsRequestTimeZone = "Asia/Ulan_Bator"

	PatchedSystemSettingsRequestTimeZoneAsiaUrumqi PatchedSystemSettingsRequestTimeZone = "Asia/Urumqi"

	PatchedSystemSettingsRequestTimeZoneAsiaUstNera PatchedSystemSettingsRequestTimeZone = "Asia/Ust-Nera"

	PatchedSystemSettingsRequestTimeZoneAsiaVientiane PatchedSystemSettingsRequestTimeZone = "Asia/Vientiane"

	PatchedSystemSettingsRequestTimeZoneAsiaVladivostok PatchedSystemSettingsRequestTimeZone = "Asia/Vladivostok"

	PatchedSystemSettingsRequestTimeZoneAsiaYakutsk PatchedSystemSettingsRequestTimeZone = "Asia/Yakutsk"

	PatchedSystemSettingsRequestTimeZoneAsiaYangon PatchedSystemSettingsRequestTimeZone = "Asia/Yangon"

	PatchedSystemSettingsRequestTimeZoneAsiaYekaterinburg PatchedSystemSettingsRequestTimeZone = "Asia/Yekaterinburg"

	PatchedSystemSettingsRequestTimeZoneAsiaYerevan PatchedSystemSettingsRequestTimeZone = "Asia/Yerevan"

	PatchedSystemSettingsRequestTimeZoneAtlanticAzores PatchedSystemSettingsRequestTimeZone = "Atlantic/Azores"

	PatchedSystemSettingsRequestTimeZoneAtlanticBermuda PatchedSystemSettingsRequestTimeZone = "Atlantic/Bermuda"

	PatchedSystemSettingsRequestTimeZoneAtlanticCanary PatchedSystemSettingsRequestTimeZone = "Atlantic/Canary"

	PatchedSystemSettingsRequestTimeZoneAtlanticCapeVerde PatchedSystemSettingsRequestTimeZone = "Atlantic/Cape_Verde"

	PatchedSystemSettingsRequestTimeZoneAtlanticFaeroe PatchedSystemSettingsRequestTimeZone = "Atlantic/Faeroe"

	PatchedSystemSettingsRequestTimeZoneAtlanticFaroe PatchedSystemSettingsRequestTimeZone = "Atlantic/Faroe"

	PatchedSystemSettingsRequestTimeZoneAtlanticJanMayen PatchedSystemSettingsRequestTimeZone = "Atlantic/Jan_Mayen"

	PatchedSystemSettingsRequestTimeZoneAtlanticMadeira PatchedSystemSettingsRequestTimeZone = "Atlantic/Madeira"

	PatchedSystemSettingsRequestTimeZoneAtlanticReykjavik PatchedSystemSettingsRequestTimeZone = "Atlantic/Reykjavik"

	PatchedSystemSettingsRequestTimeZoneAtlanticSouthGeorgia PatchedSystemSettingsRequestTimeZone = "Atlantic/South_Georgia"

	PatchedSystemSettingsRequestTimeZoneAtlanticStHelena PatchedSystemSettingsRequestTimeZone = "Atlantic/St_Helena"

	PatchedSystemSettingsRequestTimeZoneAtlanticStanley PatchedSystemSettingsRequestTimeZone = "Atlantic/Stanley"

	PatchedSystemSettingsRequestTimeZoneAustraliaACT PatchedSystemSettingsRequestTimeZone = "Australia/ACT"

	PatchedSystemSettingsRequestTimeZoneAustraliaAdelaide PatchedSystemSettingsRequestTimeZone = "Australia/Adelaide"

	PatchedSystemSettingsRequestTimeZoneAustraliaBrisbane PatchedSystemSettingsRequestTimeZone = "Australia/Brisbane"

	PatchedSystemSettingsRequestTimeZoneAustraliaBrokenHill PatchedSystemSettingsRequestTimeZone = "Australia/Broken_Hill"

	PatchedSystemSettingsRequestTimeZoneAustraliaCanberra PatchedSystemSettingsRequestTimeZone = "Australia/Canberra"

	PatchedSystemSettingsRequestTimeZoneAustraliaCurrie PatchedSystemSettingsRequestTimeZone = "Australia/Currie"

	PatchedSystemSettingsRequestTimeZoneAustraliaDarwin PatchedSystemSettingsRequestTimeZone = "Australia/Darwin"

	PatchedSystemSettingsRequestTimeZoneAustraliaEucla PatchedSystemSettingsRequestTimeZone = "Australia/Eucla"

	PatchedSystemSettingsRequestTimeZoneAustraliaHobart PatchedSystemSettingsRequestTimeZone = "Australia/Hobart"

	PatchedSystemSettingsRequestTimeZoneAustraliaLHI PatchedSystemSettingsRequestTimeZone = "Australia/LHI"

	PatchedSystemSettingsRequestTimeZoneAustraliaLindeman PatchedSystemSettingsRequestTimeZone = "Australia/Lindeman"

	PatchedSystemSettingsRequestTimeZoneAustraliaLordHowe PatchedSystemSettingsRequestTimeZone = "Australia/Lord_Howe"

	PatchedSystemSettingsRequestTimeZoneAustraliaMelbourne PatchedSystemSettingsRequestTimeZone = "Australia/Melbourne"

	PatchedSystemSettingsRequestTimeZoneAustraliaNSW PatchedSystemSettingsRequestTimeZone = "Australia/NSW"

	PatchedSystemSettingsRequestTimeZoneAustraliaNorth PatchedSystemSettingsRequestTimeZone = "Australia/North"

	PatchedSystemSettingsRequestTimeZoneAustraliaPerth PatchedSystemSettingsRequestTimeZone = "Australia/Perth"

	PatchedSystemSettingsRequestTimeZoneAustraliaQueensland PatchedSystemSettingsRequestTimeZone = "Australia/Queensland"

	PatchedSystemSettingsRequestTimeZoneAustraliaSouth PatchedSystemSettingsRequestTimeZone = "Australia/South"

	PatchedSystemSettingsRequestTimeZoneAustraliaSydney PatchedSystemSettingsRequestTimeZone = "Australia/Sydney"

	PatchedSystemSettingsRequestTimeZoneAustraliaTasmania PatchedSystemSettingsRequestTimeZone = "Australia/Tasmania"

	PatchedSystemSettingsRequestTimeZoneAustraliaVictoria PatchedSystemSettingsRequestTimeZone = "Australia/Victoria"

	PatchedSystemSettingsRequestTimeZoneAustraliaWest PatchedSystemSettingsRequestTimeZone = "Australia/West"

	PatchedSystemSettingsRequestTimeZoneAustraliaYancowinna PatchedSystemSettingsRequestTimeZone = "Australia/Yancowinna"

	PatchedSystemSettingsRequestTimeZoneBrazilAcre PatchedSystemSettingsRequestTimeZone = "Brazil/Acre"

	PatchedSystemSettingsRequestTimeZoneBrazilDeNoronha PatchedSystemSettingsRequestTimeZone = "Brazil/DeNoronha"

	PatchedSystemSettingsRequestTimeZoneBrazilEast PatchedSystemSettingsRequestTimeZone = "Brazil/East"

	PatchedSystemSettingsRequestTimeZoneBrazilWest PatchedSystemSettingsRequestTimeZone = "Brazil/West"

	PatchedSystemSettingsRequestTimeZoneCET PatchedSystemSettingsRequestTimeZone = "CET"

	PatchedSystemSettingsRequestTimeZoneCST6CDT PatchedSystemSettingsRequestTimeZone = "CST6CDT"

	PatchedSystemSettingsRequestTimeZoneCanadaAtlantic PatchedSystemSettingsRequestTimeZone = "Canada/Atlantic"

	PatchedSystemSettingsRequestTimeZoneCanadaCentral PatchedSystemSettingsRequestTimeZone = "Canada/Central"

	PatchedSystemSettingsRequestTimeZoneCanadaEastern PatchedSystemSettingsRequestTimeZone = "Canada/Eastern"

	PatchedSystemSettingsRequestTimeZoneCanadaMountain PatchedSystemSettingsRequestTimeZone = "Canada/Mountain"

	PatchedSystemSettingsRequestTimeZoneCanadaNewfoundland PatchedSystemSettingsRequestTimeZone = "Canada/Newfoundland"

	PatchedSystemSettingsRequestTimeZoneCanadaPacific PatchedSystemSettingsRequestTimeZone = "Canada/Pacific"

	PatchedSystemSettingsRequestTimeZoneCanadaSaskatchewan PatchedSystemSettingsRequestTimeZone = "Canada/Saskatchewan"

	PatchedSystemSettingsRequestTimeZoneCanadaYukon PatchedSystemSettingsRequestTimeZone = "Canada/Yukon"

	PatchedSystemSettingsRequestTimeZoneChileContinental PatchedSystemSettingsRequestTimeZone = "Chile/Continental"

	PatchedSystemSettingsRequestTimeZoneChileEasterIsland PatchedSystemSettingsRequestTimeZone = "Chile/EasterIsland"

	PatchedSystemSettingsRequestTimeZoneCuba PatchedSystemSettingsRequestTimeZone = "Cuba"

	PatchedSystemSettingsRequestTimeZoneEET PatchedSystemSettingsRequestTimeZone = "EET"

	PatchedSystemSettingsRequestTimeZoneEST PatchedSystemSettingsRequestTimeZone = "EST"

	PatchedSystemSettingsRequestTimeZoneEST5EDT PatchedSystemSettingsRequestTimeZone = "EST5EDT"

	PatchedSystemSettingsRequestTimeZoneEgypt PatchedSystemSettingsRequestTimeZone = "Egypt"

	PatchedSystemSettingsRequestTimeZoneEire PatchedSystemSettingsRequestTimeZone = "Eire"

	PatchedSystemSettingsRequestTimeZoneEtcGMT PatchedSystemSettingsRequestTimeZone = "Etc/GMT"

	PatchedSystemSettingsRequestTimeZoneEtcGMT0 PatchedSystemSettingsRequestTimeZone = "Etc/GMT+0"

	PatchedSystemSettingsRequestTimeZoneEtcGMT01 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-0"

	PatchedSystemSettingsRequestTimeZoneEtcGMT02 PatchedSystemSettingsRequestTimeZone = "Etc/GMT0"

	PatchedSystemSettingsRequestTimeZoneEtcGMT1 PatchedSystemSettingsRequestTimeZone = "Etc/GMT+1"

	PatchedSystemSettingsRequestTimeZoneEtcGMT10 PatchedSystemSettingsRequestTimeZone = "Etc/GMT+10"

	PatchedSystemSettingsRequestTimeZoneEtcGMT101 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-10"

	PatchedSystemSettingsRequestTimeZoneEtcGMT11 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-1"

	PatchedSystemSettingsRequestTimeZoneEtcGMT111 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-11"

	PatchedSystemSettingsRequestTimeZoneEtcGMT12 PatchedSystemSettingsRequestTimeZone = "Etc/GMT+12"

	PatchedSystemSettingsRequestTimeZoneEtcGMT121 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-12"

	PatchedSystemSettingsRequestTimeZoneEtcGMT13 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-13"

	PatchedSystemSettingsRequestTimeZoneEtcGMT14 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-14"

	PatchedSystemSettingsRequestTimeZoneEtcGMT2 PatchedSystemSettingsRequestTimeZone = "Etc/GMT+2"

	PatchedSystemSettingsRequestTimeZoneEtcGMT21 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-2"

	PatchedSystemSettingsRequestTimeZoneEtcGMT3 PatchedSystemSettingsRequestTimeZone = "Etc/GMT+3"

	PatchedSystemSettingsRequestTimeZoneEtcGMT31 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-3"

	PatchedSystemSettingsRequestTimeZoneEtcGMT4 PatchedSystemSettingsRequestTimeZone = "Etc/GMT+4"

	PatchedSystemSettingsRequestTimeZoneEtcGMT41 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-4"

	PatchedSystemSettingsRequestTimeZoneEtcGMT5 PatchedSystemSettingsRequestTimeZone = "Etc/GMT+5"

	PatchedSystemSettingsRequestTimeZoneEtcGMT51 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-5"

	PatchedSystemSettingsRequestTimeZoneEtcGMT6 PatchedSystemSettingsRequestTimeZone = "Etc/GMT+6"

	PatchedSystemSettingsRequestTimeZoneEtcGMT61 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-6"

	PatchedSystemSettingsRequestTimeZoneEtcGMT7 PatchedSystemSettingsRequestTimeZone = "Etc/GMT+7"

	PatchedSystemSettingsRequestTimeZoneEtcGMT71 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-7"

	PatchedSystemSettingsRequestTimeZoneEtcGMT8 PatchedSystemSettingsRequestTimeZone = "Etc/GMT+8"

	PatchedSystemSettingsRequestTimeZoneEtcGMT81 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-8"

	PatchedSystemSettingsRequestTimeZoneEtcGMT9 PatchedSystemSettingsRequestTimeZone = "Etc/GMT+9"

	PatchedSystemSettingsRequestTimeZoneEtcGMT91 PatchedSystemSettingsRequestTimeZone = "Etc/GMT-9"

	PatchedSystemSettingsRequestTimeZoneEtcGreenwich PatchedSystemSettingsRequestTimeZone = "Etc/Greenwich"

	PatchedSystemSettingsRequestTimeZoneEtcUCT PatchedSystemSettingsRequestTimeZone = "Etc/UCT"

	PatchedSystemSettingsRequestTimeZoneEtcUTC PatchedSystemSettingsRequestTimeZone = "Etc/UTC"

	PatchedSystemSettingsRequestTimeZoneEtcUniversal PatchedSystemSettingsRequestTimeZone = "Etc/Universal"

	PatchedSystemSettingsRequestTimeZoneEtcZulu PatchedSystemSettingsRequestTimeZone = "Etc/Zulu"

	PatchedSystemSettingsRequestTimeZoneEuropeAmsterdam PatchedSystemSettingsRequestTimeZone = "Europe/Amsterdam"

	PatchedSystemSettingsRequestTimeZoneEuropeAndorra PatchedSystemSettingsRequestTimeZone = "Europe/Andorra"

	PatchedSystemSettingsRequestTimeZoneEuropeAstrakhan PatchedSystemSettingsRequestTimeZone = "Europe/Astrakhan"

	PatchedSystemSettingsRequestTimeZoneEuropeAthens PatchedSystemSettingsRequestTimeZone = "Europe/Athens"

	PatchedSystemSettingsRequestTimeZoneEuropeBelfast PatchedSystemSettingsRequestTimeZone = "Europe/Belfast"

	PatchedSystemSettingsRequestTimeZoneEuropeBelgrade PatchedSystemSettingsRequestTimeZone = "Europe/Belgrade"

	PatchedSystemSettingsRequestTimeZoneEuropeBerlin PatchedSystemSettingsRequestTimeZone = "Europe/Berlin"

	PatchedSystemSettingsRequestTimeZoneEuropeBratislava PatchedSystemSettingsRequestTimeZone = "Europe/Bratislava"

	PatchedSystemSettingsRequestTimeZoneEuropeBrussels PatchedSystemSettingsRequestTimeZone = "Europe/Brussels"

	PatchedSystemSettingsRequestTimeZoneEuropeBucharest PatchedSystemSettingsRequestTimeZone = "Europe/Bucharest"

	PatchedSystemSettingsRequestTimeZoneEuropeBudapest PatchedSystemSettingsRequestTimeZone = "Europe/Budapest"

	PatchedSystemSettingsRequestTimeZoneEuropeBusingen PatchedSystemSettingsRequestTimeZone = "Europe/Busingen"

	PatchedSystemSettingsRequestTimeZoneEuropeChisinau PatchedSystemSettingsRequestTimeZone = "Europe/Chisinau"

	PatchedSystemSettingsRequestTimeZoneEuropeCopenhagen PatchedSystemSettingsRequestTimeZone = "Europe/Copenhagen"

	PatchedSystemSettingsRequestTimeZoneEuropeDublin PatchedSystemSettingsRequestTimeZone = "Europe/Dublin"

	PatchedSystemSettingsRequestTimeZoneEuropeGibraltar PatchedSystemSettingsRequestTimeZone = "Europe/Gibraltar"

	PatchedSystemSettingsRequestTimeZoneEuropeGuernsey PatchedSystemSettingsRequestTimeZone = "Europe/Guernsey"

	PatchedSystemSettingsRequestTimeZoneEuropeHelsinki PatchedSystemSettingsRequestTimeZone = "Europe/Helsinki"

	PatchedSystemSettingsRequestTimeZoneEuropeIsleOfMan PatchedSystemSettingsRequestTimeZone = "Europe/Isle_of_Man"

	PatchedSystemSettingsRequestTimeZoneEuropeIstanbul PatchedSystemSettingsRequestTimeZone = "Europe/Istanbul"

	PatchedSystemSettingsRequestTimeZoneEuropeJersey PatchedSystemSettingsRequestTimeZone = "Europe/Jersey"

	PatchedSystemSettingsRequestTimeZoneEuropeKaliningrad PatchedSystemSettingsRequestTimeZone = "Europe/Kaliningrad"

	PatchedSystemSettingsRequestTimeZoneEuropeKiev PatchedSystemSettingsRequestTimeZone = "Europe/Kiev"

	PatchedSystemSettingsRequestTimeZoneEuropeKirov PatchedSystemSettingsRequestTimeZone = "Europe/Kirov"

	PatchedSystemSettingsRequestTimeZoneEuropeKyiv PatchedSystemSettingsRequestTimeZone = "Europe/Kyiv"

	PatchedSystemSettingsRequestTimeZoneEuropeLisbon PatchedSystemSettingsRequestTimeZone = "Europe/Lisbon"

	PatchedSystemSettingsRequestTimeZoneEuropeLjubljana PatchedSystemSettingsRequestTimeZone = "Europe/Ljubljana"

	PatchedSystemSettingsRequestTimeZoneEuropeLondon PatchedSystemSettingsRequestTimeZone = "Europe/London"

	PatchedSystemSettingsRequestTimeZoneEuropeLuxembourg PatchedSystemSettingsRequestTimeZone = "Europe/Luxembourg"

	PatchedSystemSettingsRequestTimeZoneEuropeMadrid PatchedSystemSettingsRequestTimeZone = "Europe/Madrid"

	PatchedSystemSettingsRequestTimeZoneEuropeMalta PatchedSystemSettingsRequestTimeZone = "Europe/Malta"

	PatchedSystemSettingsRequestTimeZoneEuropeMariehamn PatchedSystemSettingsRequestTimeZone = "Europe/Mariehamn"

	PatchedSystemSettingsRequestTimeZoneEuropeMinsk PatchedSystemSettingsRequestTimeZone = "Europe/Minsk"

	PatchedSystemSettingsRequestTimeZoneEuropeMonaco PatchedSystemSettingsRequestTimeZone = "Europe/Monaco"

	PatchedSystemSettingsRequestTimeZoneEuropeMoscow PatchedSystemSettingsRequestTimeZone = "Europe/Moscow"

	PatchedSystemSettingsRequestTimeZoneEuropeNicosia PatchedSystemSettingsRequestTimeZone = "Europe/Nicosia"

	PatchedSystemSettingsRequestTimeZoneEuropeOslo PatchedSystemSettingsRequestTimeZone = "Europe/Oslo"

	PatchedSystemSettingsRequestTimeZoneEuropeParis PatchedSystemSettingsRequestTimeZone = "Europe/Paris"

	PatchedSystemSettingsRequestTimeZoneEuropePodgorica PatchedSystemSettingsRequestTimeZone = "Europe/Podgorica"

	PatchedSystemSettingsRequestTimeZoneEuropePrague PatchedSystemSettingsRequestTimeZone = "Europe/Prague"

	PatchedSystemSettingsRequestTimeZoneEuropeRiga PatchedSystemSettingsRequestTimeZone = "Europe/Riga"

	PatchedSystemSettingsRequestTimeZoneEuropeRome PatchedSystemSettingsRequestTimeZone = "Europe/Rome"

	PatchedSystemSettingsRequestTimeZoneEuropeSamara PatchedSystemSettingsRequestTimeZone = "Europe/Samara"

	PatchedSystemSettingsRequestTimeZoneEuropeSanMarino PatchedSystemSettingsRequestTimeZone = "Europe/San_Marino"

	PatchedSystemSettingsRequestTimeZoneEuropeSarajevo PatchedSystemSettingsRequestTimeZone = "Europe/Sarajevo"

	PatchedSystemSettingsRequestTimeZoneEuropeSaratov PatchedSystemSettingsRequestTimeZone = "Europe/Saratov"

	PatchedSystemSettingsRequestTimeZoneEuropeSimferopol PatchedSystemSettingsRequestTimeZone = "Europe/Simferopol"

	PatchedSystemSettingsRequestTimeZoneEuropeSkopje PatchedSystemSettingsRequestTimeZone = "Europe/Skopje"

	PatchedSystemSettingsRequestTimeZoneEuropeSofia PatchedSystemSettingsRequestTimeZone = "Europe/Sofia"

	PatchedSystemSettingsRequestTimeZoneEuropeStockholm PatchedSystemSettingsRequestTimeZone = "Europe/Stockholm"

	PatchedSystemSettingsRequestTimeZoneEuropeTallinn PatchedSystemSettingsRequestTimeZone = "Europe/Tallinn"

	PatchedSystemSettingsRequestTimeZoneEuropeTirane PatchedSystemSettingsRequestTimeZone = "Europe/Tirane"

	PatchedSystemSettingsRequestTimeZoneEuropeTiraspol PatchedSystemSettingsRequestTimeZone = "Europe/Tiraspol"

	PatchedSystemSettingsRequestTimeZoneEuropeUlyanovsk PatchedSystemSettingsRequestTimeZone = "Europe/Ulyanovsk"

	PatchedSystemSettingsRequestTimeZoneEuropeUzhgorod PatchedSystemSettingsRequestTimeZone = "Europe/Uzhgorod"

	PatchedSystemSettingsRequestTimeZoneEuropeVaduz PatchedSystemSettingsRequestTimeZone = "Europe/Vaduz"

	PatchedSystemSettingsRequestTimeZoneEuropeVatican PatchedSystemSettingsRequestTimeZone = "Europe/Vatican"

	PatchedSystemSettingsRequestTimeZoneEuropeVienna PatchedSystemSettingsRequestTimeZone = "Europe/Vienna"

	PatchedSystemSettingsRequestTimeZoneEuropeVilnius PatchedSystemSettingsRequestTimeZone = "Europe/Vilnius"

	PatchedSystemSettingsRequestTimeZoneEuropeVolgograd PatchedSystemSettingsRequestTimeZone = "Europe/Volgograd"

	PatchedSystemSettingsRequestTimeZoneEuropeWarsaw PatchedSystemSettingsRequestTimeZone = "Europe/Warsaw"

	PatchedSystemSettingsRequestTimeZoneEuropeZagreb PatchedSystemSettingsRequestTimeZone = "Europe/Zagreb"

	PatchedSystemSettingsRequestTimeZoneEuropeZaporozhye PatchedSystemSettingsRequestTimeZone = "Europe/Zaporozhye"

	PatchedSystemSettingsRequestTimeZoneEuropeZurich PatchedSystemSettingsRequestTimeZone = "Europe/Zurich"

	PatchedSystemSettingsRequestTimeZoneGB PatchedSystemSettingsRequestTimeZone = "GB"

	PatchedSystemSettingsRequestTimeZoneGBEire PatchedSystemSettingsRequestTimeZone = "GB-Eire"

	PatchedSystemSettingsRequestTimeZoneGMT PatchedSystemSettingsRequestTimeZone = "GMT"

	PatchedSystemSettingsRequestTimeZoneGMT0 PatchedSystemSettingsRequestTimeZone = "GMT+0"

	PatchedSystemSettingsRequestTimeZoneGMT01 PatchedSystemSettingsRequestTimeZone = "GMT-0"

	PatchedSystemSettingsRequestTimeZoneGMT02 PatchedSystemSettingsRequestTimeZone = "GMT0"

	PatchedSystemSettingsRequestTimeZoneGreenwich PatchedSystemSettingsRequestTimeZone = "Greenwich"

	PatchedSystemSettingsRequestTimeZoneHST PatchedSystemSettingsRequestTimeZone = "HST"

	PatchedSystemSettingsRequestTimeZoneHongkong PatchedSystemSettingsRequestTimeZone = "Hongkong"

	PatchedSystemSettingsRequestTimeZoneIceland PatchedSystemSettingsRequestTimeZone = "Iceland"

	PatchedSystemSettingsRequestTimeZoneIndianAntananarivo PatchedSystemSettingsRequestTimeZone = "Indian/Antananarivo"

	PatchedSystemSettingsRequestTimeZoneIndianChagos PatchedSystemSettingsRequestTimeZone = "Indian/Chagos"

	PatchedSystemSettingsRequestTimeZoneIndianChristmas PatchedSystemSettingsRequestTimeZone = "Indian/Christmas"

	PatchedSystemSettingsRequestTimeZoneIndianCocos PatchedSystemSettingsRequestTimeZone = "Indian/Cocos"

	PatchedSystemSettingsRequestTimeZoneIndianComoro PatchedSystemSettingsRequestTimeZone = "Indian/Comoro"

	PatchedSystemSettingsRequestTimeZoneIndianKerguelen PatchedSystemSettingsRequestTimeZone = "Indian/Kerguelen"

	PatchedSystemSettingsRequestTimeZoneIndianMahe PatchedSystemSettingsRequestTimeZone = "Indian/Mahe"

	PatchedSystemSettingsRequestTimeZoneIndianMaldives PatchedSystemSettingsRequestTimeZone = "Indian/Maldives"

	PatchedSystemSettingsRequestTimeZoneIndianMauritius PatchedSystemSettingsRequestTimeZone = "Indian/Mauritius"

	PatchedSystemSettingsRequestTimeZoneIndianMayotte PatchedSystemSettingsRequestTimeZone = "Indian/Mayotte"

	PatchedSystemSettingsRequestTimeZoneIndianReunion PatchedSystemSettingsRequestTimeZone = "Indian/Reunion"

	PatchedSystemSettingsRequestTimeZoneIran PatchedSystemSettingsRequestTimeZone = "Iran"

	PatchedSystemSettingsRequestTimeZoneIsrael PatchedSystemSettingsRequestTimeZone = "Israel"

	PatchedSystemSettingsRequestTimeZoneJamaica PatchedSystemSettingsRequestTimeZone = "Jamaica"

	PatchedSystemSettingsRequestTimeZoneJapan PatchedSystemSettingsRequestTimeZone = "Japan"

	PatchedSystemSettingsRequestTimeZoneKwajalein PatchedSystemSettingsRequestTimeZone = "Kwajalein"

	PatchedSystemSettingsRequestTimeZoneLibya PatchedSystemSettingsRequestTimeZone = "Libya"

	PatchedSystemSettingsRequestTimeZoneMET PatchedSystemSettingsRequestTimeZone = "MET"

	PatchedSystemSettingsRequestTimeZoneMST PatchedSystemSettingsRequestTimeZone = "MST"

	PatchedSystemSettingsRequestTimeZoneMST7MDT PatchedSystemSettingsRequestTimeZone = "MST7MDT"

	PatchedSystemSettingsRequestTimeZoneMexicoBajaNorte PatchedSystemSettingsRequestTimeZone = "Mexico/BajaNorte"

	PatchedSystemSettingsRequestTimeZoneMexicoBajaSur PatchedSystemSettingsRequestTimeZone = "Mexico/BajaSur"

	PatchedSystemSettingsRequestTimeZoneMexicoGeneral PatchedSystemSettingsRequestTimeZone = "Mexico/General"

	PatchedSystemSettingsRequestTimeZoneNZ PatchedSystemSettingsRequestTimeZone = "NZ"

	PatchedSystemSettingsRequestTimeZoneNZCHAT PatchedSystemSettingsRequestTimeZone = "NZ-CHAT"

	PatchedSystemSettingsRequestTimeZoneNavajo PatchedSystemSettingsRequestTimeZone = "Navajo"

	PatchedSystemSettingsRequestTimeZonePRC PatchedSystemSettingsRequestTimeZone = "PRC"

	PatchedSystemSettingsRequestTimeZonePST8PDT PatchedSystemSettingsRequestTimeZone = "PST8PDT"

	PatchedSystemSettingsRequestTimeZonePacificApia PatchedSystemSettingsRequestTimeZone = "Pacific/Apia"

	PatchedSystemSettingsRequestTimeZonePacificAuckland PatchedSystemSettingsRequestTimeZone = "Pacific/Auckland"

	PatchedSystemSettingsRequestTimeZonePacificBougainville PatchedSystemSettingsRequestTimeZone = "Pacific/Bougainville"

	PatchedSystemSettingsRequestTimeZonePacificChatham PatchedSystemSettingsRequestTimeZone = "Pacific/Chatham"

	PatchedSystemSettingsRequestTimeZonePacificChuuk PatchedSystemSettingsRequestTimeZone = "Pacific/Chuuk"

	PatchedSystemSettingsRequestTimeZonePacificEaster PatchedSystemSettingsRequestTimeZone = "Pacific/Easter"

	PatchedSystemSettingsRequestTimeZonePacificEfate PatchedSystemSettingsRequestTimeZone = "Pacific/Efate"

	PatchedSystemSettingsRequestTimeZonePacificEnderbury PatchedSystemSettingsRequestTimeZone = "Pacific/Enderbury"

	PatchedSystemSettingsRequestTimeZonePacificFakaofo PatchedSystemSettingsRequestTimeZone = "Pacific/Fakaofo"

	PatchedSystemSettingsRequestTimeZonePacificFiji PatchedSystemSettingsRequestTimeZone = "Pacific/Fiji"

	PatchedSystemSettingsRequestTimeZonePacificFunafuti PatchedSystemSettingsRequestTimeZone = "Pacific/Funafuti"

	PatchedSystemSettingsRequestTimeZonePacificGalapagos PatchedSystemSettingsRequestTimeZone = "Pacific/Galapagos"

	PatchedSystemSettingsRequestTimeZonePacificGambier PatchedSystemSettingsRequestTimeZone = "Pacific/Gambier"

	PatchedSystemSettingsRequestTimeZonePacificGuadalcanal PatchedSystemSettingsRequestTimeZone = "Pacific/Guadalcanal"

	PatchedSystemSettingsRequestTimeZonePacificGuam PatchedSystemSettingsRequestTimeZone = "Pacific/Guam"

	PatchedSystemSettingsRequestTimeZonePacificHonolulu PatchedSystemSettingsRequestTimeZone = "Pacific/Honolulu"

	PatchedSystemSettingsRequestTimeZonePacificJohnston PatchedSystemSettingsRequestTimeZone = "Pacific/Johnston"

	PatchedSystemSettingsRequestTimeZonePacificKanton PatchedSystemSettingsRequestTimeZone = "Pacific/Kanton"

	PatchedSystemSettingsRequestTimeZonePacificKiritimati PatchedSystemSettingsRequestTimeZone = "Pacific/Kiritimati"

	PatchedSystemSettingsRequestTimeZonePacificKosrae PatchedSystemSettingsRequestTimeZone = "Pacific/Kosrae"

	PatchedSystemSettingsRequestTimeZonePacificKwajalein PatchedSystemSettingsRequestTimeZone = "Pacific/Kwajalein"

	PatchedSystemSettingsRequestTimeZonePacificMajuro PatchedSystemSettingsRequestTimeZone = "Pacific/Majuro"

	PatchedSystemSettingsRequestTimeZonePacificMarquesas PatchedSystemSettingsRequestTimeZone = "Pacific/Marquesas"

	PatchedSystemSettingsRequestTimeZonePacificMidway PatchedSystemSettingsRequestTimeZone = "Pacific/Midway"

	PatchedSystemSettingsRequestTimeZonePacificNauru PatchedSystemSettingsRequestTimeZone = "Pacific/Nauru"

	PatchedSystemSettingsRequestTimeZonePacificNiue PatchedSystemSettingsRequestTimeZone = "Pacific/Niue"

	PatchedSystemSettingsRequestTimeZonePacificNorfolk PatchedSystemSettingsRequestTimeZone = "Pacific/Norfolk"

	PatchedSystemSettingsRequestTimeZonePacificNoumea PatchedSystemSettingsRequestTimeZone = "Pacific/Noumea"

	PatchedSystemSettingsRequestTimeZonePacificPagoPago PatchedSystemSettingsRequestTimeZone = "Pacific/Pago_Pago"

	PatchedSystemSettingsRequestTimeZonePacificPalau PatchedSystemSettingsRequestTimeZone = "Pacific/Palau"

	PatchedSystemSettingsRequestTimeZonePacificPitcairn PatchedSystemSettingsRequestTimeZone = "Pacific/Pitcairn"

	PatchedSystemSettingsRequestTimeZonePacificPohnpei PatchedSystemSettingsRequestTimeZone = "Pacific/Pohnpei"

	PatchedSystemSettingsRequestTimeZonePacificPonape PatchedSystemSettingsRequestTimeZone = "Pacific/Ponape"

	PatchedSystemSettingsRequestTimeZonePacificPortMoresby PatchedSystemSettingsRequestTimeZone = "Pacific/Port_Moresby"

	PatchedSystemSettingsRequestTimeZonePacificRarotonga PatchedSystemSettingsRequestTimeZone = "Pacific/Rarotonga"

	PatchedSystemSettingsRequestTimeZonePacificSaipan PatchedSystemSettingsRequestTimeZone = "Pacific/Saipan"

	PatchedSystemSettingsRequestTimeZonePacificSamoa PatchedSystemSettingsRequestTimeZone = "Pacific/Samoa"

	PatchedSystemSettingsRequestTimeZonePacificTahiti PatchedSystemSettingsRequestTimeZone = "Pacific/Tahiti"

	PatchedSystemSettingsRequestTimeZonePacificTarawa PatchedSystemSettingsRequestTimeZone = "Pacific/Tarawa"

	PatchedSystemSettingsRequestTimeZonePacificTongatapu PatchedSystemSettingsRequestTimeZone = "Pacific/Tongatapu"

	PatchedSystemSettingsRequestTimeZonePacificTruk PatchedSystemSettingsRequestTimeZone = "Pacific/Truk"

	PatchedSystemSettingsRequestTimeZonePacificWake PatchedSystemSettingsRequestTimeZone = "Pacific/Wake"

	PatchedSystemSettingsRequestTimeZonePacificWallis PatchedSystemSettingsRequestTimeZone = "Pacific/Wallis"

	PatchedSystemSettingsRequestTimeZonePacificYap PatchedSystemSettingsRequestTimeZone = "Pacific/Yap"

	PatchedSystemSettingsRequestTimeZonePoland PatchedSystemSettingsRequestTimeZone = "Poland"

	PatchedSystemSettingsRequestTimeZonePortugal PatchedSystemSettingsRequestTimeZone = "Portugal"

	PatchedSystemSettingsRequestTimeZoneROC PatchedSystemSettingsRequestTimeZone = "ROC"

	PatchedSystemSettingsRequestTimeZoneROK PatchedSystemSettingsRequestTimeZone = "ROK"

	PatchedSystemSettingsRequestTimeZoneSingapore PatchedSystemSettingsRequestTimeZone = "Singapore"

	PatchedSystemSettingsRequestTimeZoneTurkey PatchedSystemSettingsRequestTimeZone = "Turkey"

	PatchedSystemSettingsRequestTimeZoneUCT PatchedSystemSettingsRequestTimeZone = "UCT"

	PatchedSystemSettingsRequestTimeZoneUSAlaska PatchedSystemSettingsRequestTimeZone = "US/Alaska"

	PatchedSystemSettingsRequestTimeZoneUSAleutian PatchedSystemSettingsRequestTimeZone = "US/Aleutian"

	PatchedSystemSettingsRequestTimeZoneUSArizona PatchedSystemSettingsRequestTimeZone = "US/Arizona"

	PatchedSystemSettingsRequestTimeZoneUSCentral PatchedSystemSettingsRequestTimeZone = "US/Central"

	PatchedSystemSettingsRequestTimeZoneUSEastIndiana PatchedSystemSettingsRequestTimeZone = "US/East-Indiana"

	PatchedSystemSettingsRequestTimeZoneUSEastern PatchedSystemSettingsRequestTimeZone = "US/Eastern"

	PatchedSystemSettingsRequestTimeZoneUSHawaii PatchedSystemSettingsRequestTimeZone = "US/Hawaii"

	PatchedSystemSettingsRequestTimeZoneUSIndianaStarke PatchedSystemSettingsRequestTimeZone = "US/Indiana-Starke"

	PatchedSystemSettingsRequestTimeZoneUSMichigan PatchedSystemSettingsRequestTimeZone = "US/Michigan"

	PatchedSystemSettingsRequestTimeZoneUSMountain PatchedSystemSettingsRequestTimeZone = "US/Mountain"

	PatchedSystemSettingsRequestTimeZoneUSPacific PatchedSystemSettingsRequestTimeZone = "US/Pacific"

	PatchedSystemSettingsRequestTimeZoneUSSamoa PatchedSystemSettingsRequestTimeZone = "US/Samoa"

	PatchedSystemSettingsRequestTimeZoneUTC PatchedSystemSettingsRequestTimeZone = "UTC"

	PatchedSystemSettingsRequestTimeZoneUniversal PatchedSystemSettingsRequestTimeZone = "Universal"

	PatchedSystemSettingsRequestTimeZoneWET PatchedSystemSettingsRequestTimeZone = "WET"

	PatchedSystemSettingsRequestTimeZoneWSU PatchedSystemSettingsRequestTimeZone = "W-SU"

	PatchedSystemSettingsRequestTimeZoneZulu PatchedSystemSettingsRequestTimeZone = "Zulu"
)

// Defines values for PatchedToolConfigurationRequestAuthenticationType.
const (
	PatchedToolConfigurationRequestAuthenticationTypeAPI PatchedToolConfigurationRequestAuthenticationType = "API"

	PatchedToolConfigurationRequestAuthenticationTypeEmpty PatchedToolConfigurationRequestAuthenticationType = ""

	PatchedToolConfigurationRequestAuthenticationTypeNil PatchedToolConfigurationRequestAuthenticationType = "<nil>"

	PatchedToolConfigurationRequestAuthenticationTypePassword PatchedToolConfigurationRequestAuthenticationType = "Password"

	PatchedToolConfigurationRequestAuthenticationTypeSSH PatchedToolConfigurationRequestAuthenticationType = "SSH"
)

// Defines values for ProductBusinessCriticality.
const (
	ProductBusinessCriticalityEmpty ProductBusinessCriticality = ""

	ProductBusinessCriticalityHigh ProductBusinessCriticality = "high"

	ProductBusinessCriticalityLow ProductBusinessCriticality = "low"

	ProductBusinessCriticalityMedium ProductBusinessCriticality = "medium"

	ProductBusinessCriticalityNil ProductBusinessCriticality = "<nil>"

	ProductBusinessCriticalityNone ProductBusinessCriticality = "none"

	ProductBusinessCriticalityVeryHigh ProductBusinessCriticality = "very high"

	ProductBusinessCriticalityVeryLow ProductBusinessCriticality = "very low"
)

// Defines values for ProductLifecycle.
const (
	ProductLifecycleConstruction ProductLifecycle = "construction"

	ProductLifecycleEmpty ProductLifecycle = ""

	ProductLifecycleNil ProductLifecycle = "<nil>"

	ProductLifecycleProduction ProductLifecycle = "production"

	ProductLifecycleRetirement ProductLifecycle = "retirement"
)

// Defines values for ProductOrigin.
const (
	ProductOriginContractor ProductOrigin = "contractor"

	ProductOriginEmpty ProductOrigin = ""

	ProductOriginInternal ProductOrigin = "internal"

	ProductOriginNil ProductOrigin = "<nil>"

	ProductOriginOpenSource ProductOrigin = "open source"

	ProductOriginOutsourced ProductOrigin = "outsourced"

	ProductOriginPurchased ProductOrigin = "purchased"

	ProductOriginThirdPartyLibrary ProductOrigin = "third party library"
)

// Defines values for ProductPlatform.
const (
	ProductPlatformDesktop ProductPlatform = "desktop"

	ProductPlatformEmpty ProductPlatform = ""

	ProductPlatformIot ProductPlatform = "iot"

	ProductPlatformMobile ProductPlatform = "mobile"

	ProductPlatformNil ProductPlatform = "<nil>"

	ProductPlatformWeb ProductPlatform = "web"

	ProductPlatformWebService ProductPlatform = "web service"
)

// Defines values for ProductRequestBusinessCriticality.
const (
	ProductRequestBusinessCriticalityEmpty ProductRequestBusinessCriticality = ""

	ProductRequestBusinessCriticalityHigh ProductRequestBusinessCriticality = "high"

	ProductRequestBusinessCriticalityLow ProductRequestBusinessCriticality = "low"

	ProductRequestBusinessCriticalityMedium ProductRequestBusinessCriticality = "medium"

	ProductRequestBusinessCriticalityNil ProductRequestBusinessCriticality = "<nil>"

	ProductRequestBusinessCriticalityNone ProductRequestBusinessCriticality = "none"

	ProductRequestBusinessCriticalityVeryHigh ProductRequestBusinessCriticality = "very high"

	ProductRequestBusinessCriticalityVeryLow ProductRequestBusinessCriticality = "very low"
)

// Defines values for ProductRequestLifecycle.
const (
	ProductRequestLifecycleConstruction ProductRequestLifecycle = "construction"

	ProductRequestLifecycleEmpty ProductRequestLifecycle = ""

	ProductRequestLifecycleNil ProductRequestLifecycle = "<nil>"

	ProductRequestLifecycleProduction ProductRequestLifecycle = "production"

	ProductRequestLifecycleRetirement ProductRequestLifecycle = "retirement"
)

// Defines values for ProductRequestOrigin.
const (
	ProductRequestOriginContractor ProductRequestOrigin = "contractor"

	ProductRequestOriginEmpty ProductRequestOrigin = ""

	ProductRequestOriginInternal ProductRequestOrigin = "internal"

	ProductRequestOriginNil ProductRequestOrigin = "<nil>"

	ProductRequestOriginOpenSource ProductRequestOrigin = "open source"

	ProductRequestOriginOutsourced ProductRequestOrigin = "outsourced"

	ProductRequestOriginPurchased ProductRequestOrigin = "purchased"

	ProductRequestOriginThirdPartyLibrary ProductRequestOrigin = "third party library"
)

// Defines values for ProductRequestPlatform.
const (
	ProductRequestPlatformDesktop ProductRequestPlatform = "desktop"

	ProductRequestPlatformEmpty ProductRequestPlatform = ""

	ProductRequestPlatformIot ProductRequestPlatform = "iot"

	ProductRequestPlatformMobile ProductRequestPlatform = "mobile"

	ProductRequestPlatformNil ProductRequestPlatform = "<nil>"

	ProductRequestPlatformWeb ProductRequestPlatform = "web"

	ProductRequestPlatformWebService ProductRequestPlatform = "web service"
)

// Defines values for ReImportScanGroupBy.
const (
	ReImportScanGroupByComponentName ReImportScanGroupBy = "component_name"

	ReImportScanGroupByComponentNameComponentVersion ReImportScanGroupBy = "component_name+component_version"

	ReImportScanGroupByFilePath ReImportScanGroupBy = "file_path"
)

// Defines values for ReImportScanMinimumSeverity.
const (
	ReImportScanMinimumSeverityCritical ReImportScanMinimumSeverity = "Critical"

	ReImportScanMinimumSeverityHigh ReImportScanMinimumSeverity = "High"

	ReImportScanMinimumSeverityInfo ReImportScanMinimumSeverity = "Info"

	ReImportScanMinimumSeverityLow ReImportScanMinimumSeverity = "Low"

	ReImportScanMinimumSeverityMedium ReImportScanMinimumSeverity = "Medium"
)

// Defines values for ReImportScanScanType.
const (
	ReImportScanScanTypeAWSProwlerScan ReImportScanScanType = "AWS Prowler Scan"

	ReImportScanScanTypeAWSScout2Scan ReImportScanScanType = "AWS Scout2 Scan"

	ReImportScanScanTypeAWSSecurityHubScan ReImportScanScanType = "AWS Security Hub Scan"

	ReImportScanScanTypeAcunetix360Scan ReImportScanScanType = "Acunetix360 Scan"

	ReImportScanScanTypeAcunetixScan ReImportScanScanType = "Acunetix Scan"

	ReImportScanScanTypeAnchoreCTLPoliciesReport ReImportScanScanType = "AnchoreCTL Policies Report"

	ReImportScanScanTypeAnchoreCTLVulnReport ReImportScanScanType = "AnchoreCTL Vuln Report"

	ReImportScanScanTypeAnchoreEngineScan ReImportScanScanType = "Anchore Engine Scan"

	ReImportScanScanTypeAnchoreEnterprisePolicyCheck ReImportScanScanType = "Anchore Enterprise Policy Check"

	ReImportScanScanTypeAnchoreGrype ReImportScanScanType = "Anchore Grype"

	ReImportScanScanTypeAppSpiderScan ReImportScanScanType = "AppSpider Scan"

	ReImportScanScanTypeAquaScan ReImportScanScanType = "Aqua Scan"

	ReImportScanScanTypeArachniScan ReImportScanScanType = "Arachni Scan"

	ReImportScanScanTypeAuditJSScan ReImportScanScanType = "AuditJS Scan"

	ReImportScanScanTypeAzureSecurityCenterRecommendationsScan ReImportScanScanType = "Azure Security Center Recommendations Scan"

	ReImportScanScanTypeBanditScan ReImportScanScanType = "Bandit Scan"

	ReImportScanScanTypeBlackDuckAPI ReImportScanScanType = "BlackDuck API"

	ReImportScanScanTypeBlackduckComponentRisk ReImportScanScanType = "Blackduck Component Risk"

	ReImportScanScanTypeBlackduckHubScan ReImportScanScanType = "Blackduck Hub Scan"

	ReImportScanScanTypeBrakemanScan ReImportScanScanType = "Brakeman Scan"

	ReImportScanScanTypeBugCrowdScan ReImportScanScanType = "BugCrowd Scan"

	ReImportScanScanTypeBugcrowdAPIImport ReImportScanScanType = "Bugcrowd API Import"

	ReImportScanScanTypeBundlerAuditScan ReImportScanScanType = "Bundler-Audit Scan"

	ReImportScanScanTypeBurpEnterpriseScan ReImportScanScanType = "Burp Enterprise Scan"

	ReImportScanScanTypeBurpGraphQLAPI ReImportScanScanType = "Burp GraphQL API"

	ReImportScanScanTypeBurpRESTAPI ReImportScanScanType = "Burp REST API"

	ReImportScanScanTypeBurpScan ReImportScanScanType = "Burp Scan"

	ReImportScanScanTypeCargoAuditScan ReImportScanScanType = "CargoAudit Scan"

	ReImportScanScanTypeCheckmarxOSA ReImportScanScanType = "Checkmarx OSA"

	ReImportScanScanTypeCheckmarxScan ReImportScanScanType = "Checkmarx Scan"

	ReImportScanScanTypeCheckmarxScanDetailed ReImportScanScanType = "Checkmarx Scan detailed"

	ReImportScanScanTypeCheckovScan ReImportScanScanType = "Checkov Scan"

	ReImportScanScanTypeClairKlarScan ReImportScanScanType = "Clair Klar Scan"

	ReImportScanScanTypeClairScan ReImportScanScanType = "Clair Scan"

	ReImportScanScanTypeCloudsploitScan ReImportScanScanType = "Cloudsploit Scan"

	ReImportScanScanTypeCobaltIoAPIImport ReImportScanScanType = "Cobalt.io API Import"

	ReImportScanScanTypeCobaltIoScan ReImportScanScanType = "Cobalt.io Scan"

	ReImportScanScanTypeContrastScan ReImportScanScanType = "Contrast Scan"

	ReImportScanScanTypeCoverityAPI ReImportScanScanType = "Coverity API"

	ReImportScanScanTypeCrashtestSecurityJSONFile ReImportScanScanType = "Crashtest Security JSON File"

	ReImportScanScanTypeCrashtestSecurityXMLFile ReImportScanScanType = "Crashtest Security XML File"

	ReImportScanScanTypeCredScanScan ReImportScanScanType = "CredScan Scan"

	ReImportScanScanTypeCycloneDXScan ReImportScanScanType = "CycloneDX Scan"

	ReImportScanScanTypeDSOPScan ReImportScanScanType = "DSOP Scan"

	ReImportScanScanTypeDawnScannerScan ReImportScanScanType = "DawnScanner Scan"

	ReImportScanScanTypeDependencyCheckScan ReImportScanScanType = "Dependency Check Scan"

	ReImportScanScanTypeDependencyTrackFindingPackagingFormatFPFExport ReImportScanScanType = "Dependency Track Finding Packaging Format (FPF) Export"

	ReImportScanScanTypeDetectSecretsScan ReImportScanScanType = "Detect-secrets Scan"

	ReImportScanScanTypeDockerBenchSecurityScan ReImportScanScanType = "docker-bench-security Scan"

	ReImportScanScanTypeDockleScan ReImportScanScanType = "Dockle Scan"

	ReImportScanScanTypeDrHeaderJSONImporter ReImportScanScanType = "DrHeader JSON Importer"

	ReImportScanScanTypeESLintScan ReImportScanScanType = "ESLint Scan"

	ReImportScanScanTypeEdgescanScan ReImportScanScanType = "Edgescan Scan"

	ReImportScanScanTypeFortifyScan ReImportScanScanType = "Fortify Scan"

	ReImportScanScanTypeGenericFindingsImport ReImportScanScanType = "Generic Findings Import"

	ReImportScanScanTypeGgshieldScan ReImportScanScanType = "Ggshield Scan"

	ReImportScanScanTypeGitLabAPIFuzzingReportScan ReImportScanScanType = "GitLab API Fuzzing Report Scan"

	ReImportScanScanTypeGitLabContainerScan ReImportScanScanType = "GitLab Container Scan"

	ReImportScanScanTypeGitLabDASTReport ReImportScanScanType = "GitLab DAST Report"

	ReImportScanScanTypeGitLabDependencyScanningReport ReImportScanScanType = "GitLab Dependency Scanning Report"

	ReImportScanScanTypeGitLabSASTReport ReImportScanScanType = "GitLab SAST Report"

	ReImportScanScanTypeGitLabSecretDetectionReport ReImportScanScanType = "GitLab Secret Detection Report"

	ReImportScanScanTypeGithubVulnerabilityScan ReImportScanScanType = "Github Vulnerability Scan"

	ReImportScanScanTypeGitleaksScan ReImportScanScanType = "Gitleaks Scan"

	ReImportScanScanTypeGosecScanner ReImportScanScanType = "Gosec Scanner"

	ReImportScanScanTypeHackerOneCases ReImportScanScanType = "HackerOne Cases"

	ReImportScanScanTypeHadolintDockerfileCheck ReImportScanScanType = "Hadolint Dockerfile check"

	ReImportScanScanTypeHarborVulnerabilityScan ReImportScanScanType = "Harbor Vulnerability Scan"

	ReImportScanScanTypeHorusecScan ReImportScanScanType = "Horusec Scan"

	ReImportScanScanTypeHuskyCIReport ReImportScanScanType = "HuskyCI Report"

	ReImportScanScanTypeHydraScan ReImportScanScanType = "Hydra Scan"

	ReImportScanScanTypeIBMAppScanDAST ReImportScanScanType = "IBM AppScan DAST"

	ReImportScanScanTypeImmuniwebScan ReImportScanScanType = "Immuniweb Scan"

	ReImportScanScanTypeIntSightsReport ReImportScanScanType = "IntSights Report"

	ReImportScanScanTypeJFrogXrayAPISummaryArtifactScan ReImportScanScanType = "JFrog Xray API Summary Artifact Scan"

	ReImportScanScanTypeJFrogXrayScan ReImportScanScanType = "JFrog Xray Scan"

	ReImportScanScanTypeJFrogXrayUnifiedScan ReImportScanScanType = "JFrog Xray Unified Scan"

	ReImportScanScanTypeKICSScan ReImportScanScanType = "KICS Scan"

	ReImportScanScanTypeKiuwanScan ReImportScanScanType = "Kiuwan Scan"

	ReImportScanScanTypeKubeBenchScan ReImportScanScanType = "kube-bench Scan"

	ReImportScanScanTypeMeterianScan ReImportScanScanType = "Meterian Scan"

	ReImportScanScanTypeMicrofocusWebinspectScan ReImportScanScanType = "Microfocus Webinspect Scan"

	ReImportScanScanTypeMobSFScan ReImportScanScanType = "MobSF Scan"

	ReImportScanScanTypeMobsfscanScan ReImportScanScanType = "Mobsfscan Scan"

	ReImportScanScanTypeMozillaObservatoryScan ReImportScanScanType = "Mozilla Observatory Scan"

	ReImportScanScanTypeNPMAuditScan ReImportScanScanType = "NPM Audit Scan"

	ReImportScanScanTypeNessusScan ReImportScanScanType = "Nessus Scan"

	ReImportScanScanTypeNessusWASScan ReImportScanScanType = "Nessus WAS Scan"

	ReImportScanScanTypeNetsparkerScan ReImportScanScanType = "Netsparker Scan"

	ReImportScanScanTypeNeuVectorCompliance ReImportScanScanType = "NeuVector (compliance)"

	ReImportScanScanTypeNeuVectorREST ReImportScanScanType = "NeuVector (REST)"

	ReImportScanScanTypeNexposeScan ReImportScanScanType = "Nexpose Scan"

	ReImportScanScanTypeNiktoScan ReImportScanScanType = "Nikto Scan"

	ReImportScanScanTypeNmapScan ReImportScanScanType = "Nmap Scan"

	ReImportScanScanTypeNodeSecurityPlatformScan ReImportScanScanType = "Node Security Platform Scan"

	ReImportScanScanTypeNucleiScan ReImportScanScanType = "Nuclei Scan"

	ReImportScanScanTypeORTEvaluatedModelImporter ReImportScanScanType = "ORT evaluated model Importer"

	ReImportScanScanTypeOpenVASCSV ReImportScanScanType = "OpenVAS CSV"

	ReImportScanScanTypeOpenscapVulnerabilityScan ReImportScanScanType = "Openscap Vulnerability Scan"

	ReImportScanScanTypeOssIndexDevauditSCAScanImporter ReImportScanScanType = "OssIndex Devaudit SCA Scan Importer"

	ReImportScanScanTypeOutpost24Scan ReImportScanScanType = "Outpost24 Scan"

	ReImportScanScanTypePHPSecurityAuditV2 ReImportScanScanType = "PHP Security Audit v2"

	ReImportScanScanTypePHPSymfonySecurityCheck ReImportScanScanType = "PHP Symfony Security Check"

	ReImportScanScanTypePMDScan ReImportScanScanType = "PMD Scan"

	ReImportScanScanTypePWNSAST ReImportScanScanType = "PWN SAST"

	ReImportScanScanTypePipAuditScan ReImportScanScanType = "pip-audit Scan"

	ReImportScanScanTypeQualysInfrastructureScanWebGUIXML ReImportScanScanType = "Qualys Infrastructure Scan (WebGUI XML)"

	ReImportScanScanTypeQualysScan ReImportScanScanType = "Qualys Scan"

	ReImportScanScanTypeQualysWebappScan ReImportScanScanType = "Qualys Webapp Scan"

	ReImportScanScanTypeRetireJsScan ReImportScanScanType = "Retire.js Scan"

	ReImportScanScanTypeRiskReconAPIImporter ReImportScanScanType = "Risk Recon API Importer"

	ReImportScanScanTypeRubocopScan ReImportScanScanType = "Rubocop Scan"

	ReImportScanScanTypeRustyHogScan ReImportScanScanType = "Rusty Hog Scan"

	ReImportScanScanTypeSARIF ReImportScanScanType = "SARIF"

	ReImportScanScanTypeSKFScan ReImportScanScanType = "SKF Scan"

	ReImportScanScanTypeSSLLabsScan ReImportScanScanType = "SSL Labs Scan"

	ReImportScanScanTypeSSLyzeScanJSON ReImportScanScanType = "SSLyze Scan (JSON)"

	ReImportScanScanTypeScantistScan ReImportScanScanType = "Scantist Scan"

	ReImportScanScanTypeScoutSuiteScan ReImportScanScanType = "Scout Suite Scan"

	ReImportScanScanTypeSemgrepJSONReport ReImportScanScanType = "Semgrep JSON Report"

	ReImportScanScanTypeSnykScan ReImportScanScanType = "Snyk Scan"

	ReImportScanScanTypeSolarAppscreenerScan ReImportScanScanType = "Solar Appscreener Scan"

	ReImportScanScanTypeSonarQubeAPIImport ReImportScanScanType = "SonarQube API Import"

	ReImportScanScanTypeSonarQubeScan ReImportScanScanType = "SonarQube Scan"

	ReImportScanScanTypeSonarQubeScanDetailed ReImportScanScanType = "SonarQube Scan detailed"

	ReImportScanScanTypeSonatypeApplicationScan ReImportScanScanType = "Sonatype Application Scan"

	ReImportScanScanTypeSpotBugsScan ReImportScanScanType = "SpotBugs Scan"

	ReImportScanScanTypeSslscan ReImportScanScanType = "Sslscan"

	ReImportScanScanTypeSslyzeScan ReImportScanScanType = "Sslyze Scan"

	ReImportScanScanTypeStackHawkHawkScan ReImportScanScanType = "StackHawk HawkScan"

	ReImportScanScanTypeTFSecScan ReImportScanScanType = "TFSec Scan"

	ReImportScanScanTypeTerrascanScan ReImportScanScanType = "Terrascan Scan"

	ReImportScanScanTypeTestsslScan ReImportScanScanType = "Testssl Scan"

	ReImportScanScanTypeTrivyScan ReImportScanScanType = "Trivy Scan"

	ReImportScanScanTypeTrufflehog3Scan ReImportScanScanType = "Trufflehog3 Scan"

	ReImportScanScanTypeTrufflehogScan ReImportScanScanType = "Trufflehog Scan"

	ReImportScanScanTypeTrustwaveFusionAPIScan ReImportScanScanType = "Trustwave Fusion API Scan"

	ReImportScanScanTypeTrustwaveScanCSV ReImportScanScanType = "Trustwave Scan (CSV)"

	ReImportScanScanTypeTwistlockImageScan ReImportScanScanType = "Twistlock Image Scan"

	ReImportScanScanTypeVCGScan ReImportScanScanType = "VCG Scan"

	ReImportScanScanTypeVeracodeScan ReImportScanScanType = "Veracode Scan"

	ReImportScanScanTypeVeracodeSourceClearScan ReImportScanScanType = "Veracode SourceClear Scan"

	ReImportScanScanTypeVulners ReImportScanScanType = "Vulners"

	ReImportScanScanTypeWFuzzJSONReport ReImportScanScanType = "WFuzz JSON report"

	ReImportScanScanTypeWapitiScan ReImportScanScanType = "Wapiti Scan"

	ReImportScanScanTypeWhispersScan ReImportScanScanType = "Whispers Scan"

	ReImportScanScanTypeWhiteHatSentinel ReImportScanScanType = "WhiteHat Sentinel"

	ReImportScanScanTypeWhitesourceScan ReImportScanScanType = "Whitesource Scan"

	ReImportScanScanTypeWpscan ReImportScanScanType = "Wpscan"

	ReImportScanScanTypeXanitizerScan ReImportScanScanType = "Xanitizer Scan"

	ReImportScanScanTypeYarnAuditScan ReImportScanScanType = "Yarn Audit Scan"

	ReImportScanScanTypeZAPScan ReImportScanScanType = "ZAP Scan"
)

// Defines values for ReImportScanRequestGroupBy.
const (
	ReImportScanRequestGroupByComponentName ReImportScanRequestGroupBy = "component_name"

	ReImportScanRequestGroupByComponentNameComponentVersion ReImportScanRequestGroupBy = "component_name+component_version"

	ReImportScanRequestGroupByFilePath ReImportScanRequestGroupBy = "file_path"
)

// Defines values for ReImportScanRequestMinimumSeverity.
const (
	ReImportScanRequestMinimumSeverityCritical ReImportScanRequestMinimumSeverity = "Critical"

	ReImportScanRequestMinimumSeverityHigh ReImportScanRequestMinimumSeverity = "High"

	ReImportScanRequestMinimumSeverityInfo ReImportScanRequestMinimumSeverity = "Info"

	ReImportScanRequestMinimumSeverityLow ReImportScanRequestMinimumSeverity = "Low"

	ReImportScanRequestMinimumSeverityMedium ReImportScanRequestMinimumSeverity = "Medium"
)

// Defines values for ReImportScanRequestScanType.
const (
	ReImportScanRequestScanTypeAWSProwlerScan ReImportScanRequestScanType = "AWS Prowler Scan"

	ReImportScanRequestScanTypeAWSScout2Scan ReImportScanRequestScanType = "AWS Scout2 Scan"

	ReImportScanRequestScanTypeAWSSecurityHubScan ReImportScanRequestScanType = "AWS Security Hub Scan"

	ReImportScanRequestScanTypeAcunetix360Scan ReImportScanRequestScanType = "Acunetix360 Scan"

	ReImportScanRequestScanTypeAcunetixScan ReImportScanRequestScanType = "Acunetix Scan"

	ReImportScanRequestScanTypeAnchoreCTLPoliciesReport ReImportScanRequestScanType = "AnchoreCTL Policies Report"

	ReImportScanRequestScanTypeAnchoreCTLVulnReport ReImportScanRequestScanType = "AnchoreCTL Vuln Report"

	ReImportScanRequestScanTypeAnchoreEngineScan ReImportScanRequestScanType = "Anchore Engine Scan"

	ReImportScanRequestScanTypeAnchoreEnterprisePolicyCheck ReImportScanRequestScanType = "Anchore Enterprise Policy Check"

	ReImportScanRequestScanTypeAnchoreGrype ReImportScanRequestScanType = "Anchore Grype"

	ReImportScanRequestScanTypeAppSpiderScan ReImportScanRequestScanType = "AppSpider Scan"

	ReImportScanRequestScanTypeAquaScan ReImportScanRequestScanType = "Aqua Scan"

	ReImportScanRequestScanTypeArachniScan ReImportScanRequestScanType = "Arachni Scan"

	ReImportScanRequestScanTypeAuditJSScan ReImportScanRequestScanType = "AuditJS Scan"

	ReImportScanRequestScanTypeAzureSecurityCenterRecommendationsScan ReImportScanRequestScanType = "Azure Security Center Recommendations Scan"

	ReImportScanRequestScanTypeBanditScan ReImportScanRequestScanType = "Bandit Scan"

	ReImportScanRequestScanTypeBlackDuckAPI ReImportScanRequestScanType = "BlackDuck API"

	ReImportScanRequestScanTypeBlackduckComponentRisk ReImportScanRequestScanType = "Blackduck Component Risk"

	ReImportScanRequestScanTypeBlackduckHubScan ReImportScanRequestScanType = "Blackduck Hub Scan"

	ReImportScanRequestScanTypeBrakemanScan ReImportScanRequestScanType = "Brakeman Scan"

	ReImportScanRequestScanTypeBugCrowdScan ReImportScanRequestScanType = "BugCrowd Scan"

	ReImportScanRequestScanTypeBugcrowdAPIImport ReImportScanRequestScanType = "Bugcrowd API Import"

	ReImportScanRequestScanTypeBundlerAuditScan ReImportScanRequestScanType = "Bundler-Audit Scan"

	ReImportScanRequestScanTypeBurpEnterpriseScan ReImportScanRequestScanType = "Burp Enterprise Scan"

	ReImportScanRequestScanTypeBurpGraphQLAPI ReImportScanRequestScanType = "Burp GraphQL API"

	ReImportScanRequestScanTypeBurpRESTAPI ReImportScanRequestScanType = "Burp REST API"

	ReImportScanRequestScanTypeBurpScan ReImportScanRequestScanType = "Burp Scan"

	ReImportScanRequestScanTypeCargoAuditScan ReImportScanRequestScanType = "CargoAudit Scan"

	ReImportScanRequestScanTypeCheckmarxOSA ReImportScanRequestScanType = "Checkmarx OSA"

	ReImportScanRequestScanTypeCheckmarxScan ReImportScanRequestScanType = "Checkmarx Scan"

	ReImportScanRequestScanTypeCheckmarxScanDetailed ReImportScanRequestScanType = "Checkmarx Scan detailed"

	ReImportScanRequestScanTypeCheckovScan ReImportScanRequestScanType = "Checkov Scan"

	ReImportScanRequestScanTypeClairKlarScan ReImportScanRequestScanType = "Clair Klar Scan"

	ReImportScanRequestScanTypeClairScan ReImportScanRequestScanType = "Clair Scan"

	ReImportScanRequestScanTypeCloudsploitScan ReImportScanRequestScanType = "Cloudsploit Scan"

	ReImportScanRequestScanTypeCobaltIoAPIImport ReImportScanRequestScanType = "Cobalt.io API Import"

	ReImportScanRequestScanTypeCobaltIoScan ReImportScanRequestScanType = "Cobalt.io Scan"

	ReImportScanRequestScanTypeContrastScan ReImportScanRequestScanType = "Contrast Scan"

	ReImportScanRequestScanTypeCoverityAPI ReImportScanRequestScanType = "Coverity API"

	ReImportScanRequestScanTypeCrashtestSecurityJSONFile ReImportScanRequestScanType = "Crashtest Security JSON File"

	ReImportScanRequestScanTypeCrashtestSecurityXMLFile ReImportScanRequestScanType = "Crashtest Security XML File"

	ReImportScanRequestScanTypeCredScanScan ReImportScanRequestScanType = "CredScan Scan"

	ReImportScanRequestScanTypeCycloneDXScan ReImportScanRequestScanType = "CycloneDX Scan"

	ReImportScanRequestScanTypeDSOPScan ReImportScanRequestScanType = "DSOP Scan"

	ReImportScanRequestScanTypeDawnScannerScan ReImportScanRequestScanType = "DawnScanner Scan"

	ReImportScanRequestScanTypeDependencyCheckScan ReImportScanRequestScanType = "Dependency Check Scan"

	ReImportScanRequestScanTypeDependencyTrackFindingPackagingFormatFPFExport ReImportScanRequestScanType = "Dependency Track Finding Packaging Format (FPF) Export"

	ReImportScanRequestScanTypeDetectSecretsScan ReImportScanRequestScanType = "Detect-secrets Scan"

	ReImportScanRequestScanTypeDockerBenchSecurityScan ReImportScanRequestScanType = "docker-bench-security Scan"

	ReImportScanRequestScanTypeDockleScan ReImportScanRequestScanType = "Dockle Scan"

	ReImportScanRequestScanTypeDrHeaderJSONImporter ReImportScanRequestScanType = "DrHeader JSON Importer"

	ReImportScanRequestScanTypeESLintScan ReImportScanRequestScanType = "ESLint Scan"

	ReImportScanRequestScanTypeEdgescanScan ReImportScanRequestScanType = "Edgescan Scan"

	ReImportScanRequestScanTypeFortifyScan ReImportScanRequestScanType = "Fortify Scan"

	ReImportScanRequestScanTypeGenericFindingsImport ReImportScanRequestScanType = "Generic Findings Import"

	ReImportScanRequestScanTypeGgshieldScan ReImportScanRequestScanType = "Ggshield Scan"

	ReImportScanRequestScanTypeGitLabAPIFuzzingReportScan ReImportScanRequestScanType = "GitLab API Fuzzing Report Scan"

	ReImportScanRequestScanTypeGitLabContainerScan ReImportScanRequestScanType = "GitLab Container Scan"

	ReImportScanRequestScanTypeGitLabDASTReport ReImportScanRequestScanType = "GitLab DAST Report"

	ReImportScanRequestScanTypeGitLabDependencyScanningReport ReImportScanRequestScanType = "GitLab Dependency Scanning Report"

	ReImportScanRequestScanTypeGitLabSASTReport ReImportScanRequestScanType = "GitLab SAST Report"

	ReImportScanRequestScanTypeGitLabSecretDetectionReport ReImportScanRequestScanType = "GitLab Secret Detection Report"

	ReImportScanRequestScanTypeGithubVulnerabilityScan ReImportScanRequestScanType = "Github Vulnerability Scan"

	ReImportScanRequestScanTypeGitleaksScan ReImportScanRequestScanType = "Gitleaks Scan"

	ReImportScanRequestScanTypeGosecScanner ReImportScanRequestScanType = "Gosec Scanner"

	ReImportScanRequestScanTypeHackerOneCases ReImportScanRequestScanType = "HackerOne Cases"

	ReImportScanRequestScanTypeHadolintDockerfileCheck ReImportScanRequestScanType = "Hadolint Dockerfile check"

	ReImportScanRequestScanTypeHarborVulnerabilityScan ReImportScanRequestScanType = "Harbor Vulnerability Scan"

	ReImportScanRequestScanTypeHorusecScan ReImportScanRequestScanType = "Horusec Scan"

	ReImportScanRequestScanTypeHuskyCIReport ReImportScanRequestScanType = "HuskyCI Report"

	ReImportScanRequestScanTypeHydraScan ReImportScanRequestScanType = "Hydra Scan"

	ReImportScanRequestScanTypeIBMAppScanDAST ReImportScanRequestScanType = "IBM AppScan DAST"

	ReImportScanRequestScanTypeImmuniwebScan ReImportScanRequestScanType = "Immuniweb Scan"

	ReImportScanRequestScanTypeIntSightsReport ReImportScanRequestScanType = "IntSights Report"

	ReImportScanRequestScanTypeJFrogXrayAPISummaryArtifactScan ReImportScanRequestScanType = "JFrog Xray API Summary Artifact Scan"

	ReImportScanRequestScanTypeJFrogXrayScan ReImportScanRequestScanType = "JFrog Xray Scan"

	ReImportScanRequestScanTypeJFrogXrayUnifiedScan ReImportScanRequestScanType = "JFrog Xray Unified Scan"

	ReImportScanRequestScanTypeKICSScan ReImportScanRequestScanType = "KICS Scan"

	ReImportScanRequestScanTypeKiuwanScan ReImportScanRequestScanType = "Kiuwan Scan"

	ReImportScanRequestScanTypeKubeBenchScan ReImportScanRequestScanType = "kube-bench Scan"

	ReImportScanRequestScanTypeMeterianScan ReImportScanRequestScanType = "Meterian Scan"

	ReImportScanRequestScanTypeMicrofocusWebinspectScan ReImportScanRequestScanType = "Microfocus Webinspect Scan"

	ReImportScanRequestScanTypeMobSFScan ReImportScanRequestScanType = "MobSF Scan"

	ReImportScanRequestScanTypeMobsfscanScan ReImportScanRequestScanType = "Mobsfscan Scan"

	ReImportScanRequestScanTypeMozillaObservatoryScan ReImportScanRequestScanType = "Mozilla Observatory Scan"

	ReImportScanRequestScanTypeNPMAuditScan ReImportScanRequestScanType = "NPM Audit Scan"

	ReImportScanRequestScanTypeNessusScan ReImportScanRequestScanType = "Nessus Scan"

	ReImportScanRequestScanTypeNessusWASScan ReImportScanRequestScanType = "Nessus WAS Scan"

	ReImportScanRequestScanTypeNetsparkerScan ReImportScanRequestScanType = "Netsparker Scan"

	ReImportScanRequestScanTypeNeuVectorCompliance ReImportScanRequestScanType = "NeuVector (compliance)"

	ReImportScanRequestScanTypeNeuVectorREST ReImportScanRequestScanType = "NeuVector (REST)"

	ReImportScanRequestScanTypeNexposeScan ReImportScanRequestScanType = "Nexpose Scan"

	ReImportScanRequestScanTypeNiktoScan ReImportScanRequestScanType = "Nikto Scan"

	ReImportScanRequestScanTypeNmapScan ReImportScanRequestScanType = "Nmap Scan"

	ReImportScanRequestScanTypeNodeSecurityPlatformScan ReImportScanRequestScanType = "Node Security Platform Scan"

	ReImportScanRequestScanTypeNucleiScan ReImportScanRequestScanType = "Nuclei Scan"

	ReImportScanRequestScanTypeORTEvaluatedModelImporter ReImportScanRequestScanType = "ORT evaluated model Importer"

	ReImportScanRequestScanTypeOpenVASCSV ReImportScanRequestScanType = "OpenVAS CSV"

	ReImportScanRequestScanTypeOpenscapVulnerabilityScan ReImportScanRequestScanType = "Openscap Vulnerability Scan"

	ReImportScanRequestScanTypeOssIndexDevauditSCAScanImporter ReImportScanRequestScanType = "OssIndex Devaudit SCA Scan Importer"

	ReImportScanRequestScanTypeOutpost24Scan ReImportScanRequestScanType = "Outpost24 Scan"

	ReImportScanRequestScanTypePHPSecurityAuditV2 ReImportScanRequestScanType = "PHP Security Audit v2"

	ReImportScanRequestScanTypePHPSymfonySecurityCheck ReImportScanRequestScanType = "PHP Symfony Security Check"

	ReImportScanRequestScanTypePMDScan ReImportScanRequestScanType = "PMD Scan"

	ReImportScanRequestScanTypePWNSAST ReImportScanRequestScanType = "PWN SAST"

	ReImportScanRequestScanTypePipAuditScan ReImportScanRequestScanType = "pip-audit Scan"

	ReImportScanRequestScanTypeQualysInfrastructureScanWebGUIXML ReImportScanRequestScanType = "Qualys Infrastructure Scan (WebGUI XML)"

	ReImportScanRequestScanTypeQualysScan ReImportScanRequestScanType = "Qualys Scan"

	ReImportScanRequestScanTypeQualysWebappScan ReImportScanRequestScanType = "Qualys Webapp Scan"

	ReImportScanRequestScanTypeRetireJsScan ReImportScanRequestScanType = "Retire.js Scan"

	ReImportScanRequestScanTypeRiskReconAPIImporter ReImportScanRequestScanType = "Risk Recon API Importer"

	ReImportScanRequestScanTypeRubocopScan ReImportScanRequestScanType = "Rubocop Scan"

	ReImportScanRequestScanTypeRustyHogScan ReImportScanRequestScanType = "Rusty Hog Scan"

	ReImportScanRequestScanTypeSARIF ReImportScanRequestScanType = "SARIF"

	ReImportScanRequestScanTypeSKFScan ReImportScanRequestScanType = "SKF Scan"

	ReImportScanRequestScanTypeSSLLabsScan ReImportScanRequestScanType = "SSL Labs Scan"

	ReImportScanRequestScanTypeSSLyzeScanJSON ReImportScanRequestScanType = "SSLyze Scan (JSON)"

	ReImportScanRequestScanTypeScantistScan ReImportScanRequestScanType = "Scantist Scan"

	ReImportScanRequestScanTypeScoutSuiteScan ReImportScanRequestScanType = "Scout Suite Scan"

	ReImportScanRequestScanTypeSemgrepJSONReport ReImportScanRequestScanType = "Semgrep JSON Report"

	ReImportScanRequestScanTypeSnykScan ReImportScanRequestScanType = "Snyk Scan"

	ReImportScanRequestScanTypeSolarAppscreenerScan ReImportScanRequestScanType = "Solar Appscreener Scan"

	ReImportScanRequestScanTypeSonarQubeAPIImport ReImportScanRequestScanType = "SonarQube API Import"

	ReImportScanRequestScanTypeSonarQubeScan ReImportScanRequestScanType = "SonarQube Scan"

	ReImportScanRequestScanTypeSonarQubeScanDetailed ReImportScanRequestScanType = "SonarQube Scan detailed"

	ReImportScanRequestScanTypeSonatypeApplicationScan ReImportScanRequestScanType = "Sonatype Application Scan"

	ReImportScanRequestScanTypeSpotBugsScan ReImportScanRequestScanType = "SpotBugs Scan"

	ReImportScanRequestScanTypeSslscan ReImportScanRequestScanType = "Sslscan"

	ReImportScanRequestScanTypeSslyzeScan ReImportScanRequestScanType = "Sslyze Scan"

	ReImportScanRequestScanTypeStackHawkHawkScan ReImportScanRequestScanType = "StackHawk HawkScan"

	ReImportScanRequestScanTypeTFSecScan ReImportScanRequestScanType = "TFSec Scan"

	ReImportScanRequestScanTypeTerrascanScan ReImportScanRequestScanType = "Terrascan Scan"

	ReImportScanRequestScanTypeTestsslScan ReImportScanRequestScanType = "Testssl Scan"

	ReImportScanRequestScanTypeTrivyScan ReImportScanRequestScanType = "Trivy Scan"

	ReImportScanRequestScanTypeTrufflehog3Scan ReImportScanRequestScanType = "Trufflehog3 Scan"

	ReImportScanRequestScanTypeTrufflehogScan ReImportScanRequestScanType = "Trufflehog Scan"

	ReImportScanRequestScanTypeTrustwaveFusionAPIScan ReImportScanRequestScanType = "Trustwave Fusion API Scan"

	ReImportScanRequestScanTypeTrustwaveScanCSV ReImportScanRequestScanType = "Trustwave Scan (CSV)"

	ReImportScanRequestScanTypeTwistlockImageScan ReImportScanRequestScanType = "Twistlock Image Scan"

	ReImportScanRequestScanTypeVCGScan ReImportScanRequestScanType = "VCG Scan"

	ReImportScanRequestScanTypeVeracodeScan ReImportScanRequestScanType = "Veracode Scan"

	ReImportScanRequestScanTypeVeracodeSourceClearScan ReImportScanRequestScanType = "Veracode SourceClear Scan"

	ReImportScanRequestScanTypeVulners ReImportScanRequestScanType = "Vulners"

	ReImportScanRequestScanTypeWFuzzJSONReport ReImportScanRequestScanType = "WFuzz JSON report"

	ReImportScanRequestScanTypeWapitiScan ReImportScanRequestScanType = "Wapiti Scan"

	ReImportScanRequestScanTypeWhispersScan ReImportScanRequestScanType = "Whispers Scan"

	ReImportScanRequestScanTypeWhiteHatSentinel ReImportScanRequestScanType = "WhiteHat Sentinel"

	ReImportScanRequestScanTypeWhitesourceScan ReImportScanRequestScanType = "Whitesource Scan"

	ReImportScanRequestScanTypeWpscan ReImportScanRequestScanType = "Wpscan"

	ReImportScanRequestScanTypeXanitizerScan ReImportScanRequestScanType = "Xanitizer Scan"

	ReImportScanRequestScanTypeYarnAuditScan ReImportScanRequestScanType = "Yarn Audit Scan"

	ReImportScanRequestScanTypeZAPScan ReImportScanRequestScanType = "ZAP Scan"
)

// Defines values for RegulationCategory.
const (
	RegulationCategoryCorporate RegulationCategory = "corporate"

	RegulationCategoryEducation RegulationCategory = "education"

	RegulationCategoryFinance RegulationCategory = "finance"

	RegulationCategoryMedical RegulationCategory = "medical"

	RegulationCategoryOther RegulationCategory = "other"

	RegulationCategoryPrivacy RegulationCategory = "privacy"
)

// Defines values for RegulationRequestCategory.
const (
	RegulationRequestCategoryCorporate RegulationRequestCategory = "corporate"

	RegulationRequestCategoryEducation RegulationRequestCategory = "education"

	RegulationRequestCategoryFinance RegulationRequestCategory = "finance"

	RegulationRequestCategoryMedical RegulationRequestCategory = "medical"

	RegulationRequestCategoryOther RegulationRequestCategory = "other"

	RegulationRequestCategoryPrivacy RegulationRequestCategory = "privacy"
)

// Defines values for RiskAcceptanceDecision.
const (
	RiskAcceptanceDecisionA RiskAcceptanceDecision = "A"

	RiskAcceptanceDecisionF RiskAcceptanceDecision = "F"

	RiskAcceptanceDecisionM RiskAcceptanceDecision = "M"

	RiskAcceptanceDecisionT RiskAcceptanceDecision = "T"

	RiskAcceptanceDecisionV RiskAcceptanceDecision = "V"
)

// Defines values for RiskAcceptanceRecommendation.
const (
	RiskAcceptanceRecommendationA RiskAcceptanceRecommendation = "A"

	RiskAcceptanceRecommendationF RiskAcceptanceRecommendation = "F"

	RiskAcceptanceRecommendationM RiskAcceptanceRecommendation = "M"

	RiskAcceptanceRecommendationT RiskAcceptanceRecommendation = "T"

	RiskAcceptanceRecommendationV RiskAcceptanceRecommendation = "V"
)

// Defines values for SystemSettingsJiraMinimumSeverity.
const (
	SystemSettingsJiraMinimumSeverityCritical SystemSettingsJiraMinimumSeverity = "Critical"

	SystemSettingsJiraMinimumSeverityEmpty SystemSettingsJiraMinimumSeverity = ""

	SystemSettingsJiraMinimumSeverityHigh SystemSettingsJiraMinimumSeverity = "High"

	SystemSettingsJiraMinimumSeverityInfo SystemSettingsJiraMinimumSeverity = "Info"

	SystemSettingsJiraMinimumSeverityLow SystemSettingsJiraMinimumSeverity = "Low"

	SystemSettingsJiraMinimumSeverityMedium SystemSettingsJiraMinimumSeverity = "Medium"

	SystemSettingsJiraMinimumSeverityNil SystemSettingsJiraMinimumSeverity = "<nil>"
)

// Defines values for SystemSettingsTimeZone.
const (
	SystemSettingsTimeZoneAfricaAbidjan SystemSettingsTimeZone = "Africa/Abidjan"

	SystemSettingsTimeZoneAfricaAccra SystemSettingsTimeZone = "Africa/Accra"

	SystemSettingsTimeZoneAfricaAddisAbaba SystemSettingsTimeZone = "Africa/Addis_Ababa"

	SystemSettingsTimeZoneAfricaAlgiers SystemSettingsTimeZone = "Africa/Algiers"

	SystemSettingsTimeZoneAfricaAsmara SystemSettingsTimeZone = "Africa/Asmara"

	SystemSettingsTimeZoneAfricaAsmera SystemSettingsTimeZone = "Africa/Asmera"

	SystemSettingsTimeZoneAfricaBamako SystemSettingsTimeZone = "Africa/Bamako"

	SystemSettingsTimeZoneAfricaBangui SystemSettingsTimeZone = "Africa/Bangui"

	SystemSettingsTimeZoneAfricaBanjul SystemSettingsTimeZone = "Africa/Banjul"

	SystemSettingsTimeZoneAfricaBissau SystemSettingsTimeZone = "Africa/Bissau"

	SystemSettingsTimeZoneAfricaBlantyre SystemSettingsTimeZone = "Africa/Blantyre"

	SystemSettingsTimeZoneAfricaBrazzaville SystemSettingsTimeZone = "Africa/Brazzaville"

	SystemSettingsTimeZoneAfricaBujumbura SystemSettingsTimeZone = "Africa/Bujumbura"

	SystemSettingsTimeZoneAfricaCairo SystemSettingsTimeZone = "Africa/Cairo"

	SystemSettingsTimeZoneAfricaCasablanca SystemSettingsTimeZone = "Africa/Casablanca"

	SystemSettingsTimeZoneAfricaCeuta SystemSettingsTimeZone = "Africa/Ceuta"

	SystemSettingsTimeZoneAfricaConakry SystemSettingsTimeZone = "Africa/Conakry"

	SystemSettingsTimeZoneAfricaDakar SystemSettingsTimeZone = "Africa/Dakar"

	SystemSettingsTimeZoneAfricaDarEsSalaam SystemSettingsTimeZone = "Africa/Dar_es_Salaam"

	SystemSettingsTimeZoneAfricaDjibouti SystemSettingsTimeZone = "Africa/Djibouti"

	SystemSettingsTimeZoneAfricaDouala SystemSettingsTimeZone = "Africa/Douala"

	SystemSettingsTimeZoneAfricaElAaiun SystemSettingsTimeZone = "Africa/El_Aaiun"

	SystemSettingsTimeZoneAfricaFreetown SystemSettingsTimeZone = "Africa/Freetown"

	SystemSettingsTimeZoneAfricaGaborone SystemSettingsTimeZone = "Africa/Gaborone"

	SystemSettingsTimeZoneAfricaHarare SystemSettingsTimeZone = "Africa/Harare"

	SystemSettingsTimeZoneAfricaJohannesburg SystemSettingsTimeZone = "Africa/Johannesburg"

	SystemSettingsTimeZoneAfricaJuba SystemSettingsTimeZone = "Africa/Juba"

	SystemSettingsTimeZoneAfricaKampala SystemSettingsTimeZone = "Africa/Kampala"

	SystemSettingsTimeZoneAfricaKhartoum SystemSettingsTimeZone = "Africa/Khartoum"

	SystemSettingsTimeZoneAfricaKigali SystemSettingsTimeZone = "Africa/Kigali"

	SystemSettingsTimeZoneAfricaKinshasa SystemSettingsTimeZone = "Africa/Kinshasa"

	SystemSettingsTimeZoneAfricaLagos SystemSettingsTimeZone = "Africa/Lagos"

	SystemSettingsTimeZoneAfricaLibreville SystemSettingsTimeZone = "Africa/Libreville"

	SystemSettingsTimeZoneAfricaLome SystemSettingsTimeZone = "Africa/Lome"

	SystemSettingsTimeZoneAfricaLuanda SystemSettingsTimeZone = "Africa/Luanda"

	SystemSettingsTimeZoneAfricaLubumbashi SystemSettingsTimeZone = "Africa/Lubumbashi"

	SystemSettingsTimeZoneAfricaLusaka SystemSettingsTimeZone = "Africa/Lusaka"

	SystemSettingsTimeZoneAfricaMalabo SystemSettingsTimeZone = "Africa/Malabo"

	SystemSettingsTimeZoneAfricaMaputo SystemSettingsTimeZone = "Africa/Maputo"

	SystemSettingsTimeZoneAfricaMaseru SystemSettingsTimeZone = "Africa/Maseru"

	SystemSettingsTimeZoneAfricaMbabane SystemSettingsTimeZone = "Africa/Mbabane"

	SystemSettingsTimeZoneAfricaMogadishu SystemSettingsTimeZone = "Africa/Mogadishu"

	SystemSettingsTimeZoneAfricaMonrovia SystemSettingsTimeZone = "Africa/Monrovia"

	SystemSettingsTimeZoneAfricaNairobi SystemSettingsTimeZone = "Africa/Nairobi"

	SystemSettingsTimeZoneAfricaNdjamena SystemSettingsTimeZone = "Africa/Ndjamena"

	SystemSettingsTimeZoneAfricaNiamey SystemSettingsTimeZone = "Africa/Niamey"

	SystemSettingsTimeZoneAfricaNouakchott SystemSettingsTimeZone = "Africa/Nouakchott"

	SystemSettingsTimeZoneAfricaOuagadougou SystemSettingsTimeZone = "Africa/Ouagadougou"

	SystemSettingsTimeZoneAfricaPortoNovo SystemSettingsTimeZone = "Africa/Porto-Novo"

	SystemSettingsTimeZoneAfricaSaoTome SystemSettingsTimeZone = "Africa/Sao_Tome"

	SystemSettingsTimeZoneAfricaTimbuktu SystemSettingsTimeZone = "Africa/Timbuktu"

	SystemSettingsTimeZoneAfricaTripoli SystemSettingsTimeZone = "Africa/Tripoli"

	SystemSettingsTimeZoneAfricaTunis SystemSettingsTimeZone = "Africa/Tunis"

	SystemSettingsTimeZoneAfricaWindhoek SystemSettingsTimeZone = "Africa/Windhoek"

	SystemSettingsTimeZoneAmericaAdak SystemSettingsTimeZone = "America/Adak"

	SystemSettingsTimeZoneAmericaAnchorage SystemSettingsTimeZone = "America/Anchorage"

	SystemSettingsTimeZoneAmericaAnguilla SystemSettingsTimeZone = "America/Anguilla"

	SystemSettingsTimeZoneAmericaAntigua SystemSettingsTimeZone = "America/Antigua"

	SystemSettingsTimeZoneAmericaAraguaina SystemSettingsTimeZone = "America/Araguaina"

	SystemSettingsTimeZoneAmericaArgentinaBuenosAires SystemSettingsTimeZone = "America/Argentina/Buenos_Aires"

	SystemSettingsTimeZoneAmericaArgentinaCatamarca SystemSettingsTimeZone = "America/Argentina/Catamarca"

	SystemSettingsTimeZoneAmericaArgentinaComodRivadavia SystemSettingsTimeZone = "America/Argentina/ComodRivadavia"

	SystemSettingsTimeZoneAmericaArgentinaCordoba SystemSettingsTimeZone = "America/Argentina/Cordoba"

	SystemSettingsTimeZoneAmericaArgentinaJujuy SystemSettingsTimeZone = "America/Argentina/Jujuy"

	SystemSettingsTimeZoneAmericaArgentinaLaRioja SystemSettingsTimeZone = "America/Argentina/La_Rioja"

	SystemSettingsTimeZoneAmericaArgentinaMendoza SystemSettingsTimeZone = "America/Argentina/Mendoza"

	SystemSettingsTimeZoneAmericaArgentinaRioGallegos SystemSettingsTimeZone = "America/Argentina/Rio_Gallegos"

	SystemSettingsTimeZoneAmericaArgentinaSalta SystemSettingsTimeZone = "America/Argentina/Salta"

	SystemSettingsTimeZoneAmericaArgentinaSanJuan SystemSettingsTimeZone = "America/Argentina/San_Juan"

	SystemSettingsTimeZoneAmericaArgentinaSanLuis SystemSettingsTimeZone = "America/Argentina/San_Luis"

	SystemSettingsTimeZoneAmericaArgentinaTucuman SystemSettingsTimeZone = "America/Argentina/Tucuman"

	SystemSettingsTimeZoneAmericaArgentinaUshuaia SystemSettingsTimeZone = "America/Argentina/Ushuaia"

	SystemSettingsTimeZoneAmericaAruba SystemSettingsTimeZone = "America/Aruba"

	SystemSettingsTimeZoneAmericaAsuncion SystemSettingsTimeZone = "America/Asuncion"

	SystemSettingsTimeZoneAmericaAtikokan SystemSettingsTimeZone = "America/Atikokan"

	SystemSettingsTimeZoneAmericaAtka SystemSettingsTimeZone = "America/Atka"

	SystemSettingsTimeZoneAmericaBahia SystemSettingsTimeZone = "America/Bahia"

	SystemSettingsTimeZoneAmericaBahiaBanderas SystemSettingsTimeZone = "America/Bahia_Banderas"

	SystemSettingsTimeZoneAmericaBarbados SystemSettingsTimeZone = "America/Barbados"

	SystemSettingsTimeZoneAmericaBelem SystemSettingsTimeZone = "America/Belem"

	SystemSettingsTimeZoneAmericaBelize SystemSettingsTimeZone = "America/Belize"

	SystemSettingsTimeZoneAmericaBlancSablon SystemSettingsTimeZone = "America/Blanc-Sablon"

	SystemSettingsTimeZoneAmericaBoaVista SystemSettingsTimeZone = "America/Boa_Vista"

	SystemSettingsTimeZoneAmericaBogota SystemSettingsTimeZone = "America/Bogota"

	SystemSettingsTimeZoneAmericaBoise SystemSettingsTimeZone = "America/Boise"

	SystemSettingsTimeZoneAmericaBuenosAires SystemSettingsTimeZone = "America/Buenos_Aires"

	SystemSettingsTimeZoneAmericaCambridgeBay SystemSettingsTimeZone = "America/Cambridge_Bay"

	SystemSettingsTimeZoneAmericaCampoGrande SystemSettingsTimeZone = "America/Campo_Grande"

	SystemSettingsTimeZoneAmericaCancun SystemSettingsTimeZone = "America/Cancun"

	SystemSettingsTimeZoneAmericaCaracas SystemSettingsTimeZone = "America/Caracas"

	SystemSettingsTimeZoneAmericaCatamarca SystemSettingsTimeZone = "America/Catamarca"

	SystemSettingsTimeZoneAmericaCayenne SystemSettingsTimeZone = "America/Cayenne"

	SystemSettingsTimeZoneAmericaCayman SystemSettingsTimeZone = "America/Cayman"

	SystemSettingsTimeZoneAmericaChicago SystemSettingsTimeZone = "America/Chicago"

	SystemSettingsTimeZoneAmericaChihuahua SystemSettingsTimeZone = "America/Chihuahua"

	SystemSettingsTimeZoneAmericaCoralHarbour SystemSettingsTimeZone = "America/Coral_Harbour"

	SystemSettingsTimeZoneAmericaCordoba SystemSettingsTimeZone = "America/Cordoba"

	SystemSettingsTimeZoneAmericaCostaRica SystemSettingsTimeZone = "America/Costa_Rica"

	SystemSettingsTimeZoneAmericaCreston SystemSettingsTimeZone = "America/Creston"

	SystemSettingsTimeZoneAmericaCuiaba SystemSettingsTimeZone = "America/Cuiaba"

	SystemSettingsTimeZoneAmericaCuracao SystemSettingsTimeZone = "America/Curacao"

	SystemSettingsTimeZoneAmericaDanmarkshavn SystemSettingsTimeZone = "America/Danmarkshavn"

	SystemSettingsTimeZoneAmericaDawson SystemSettingsTimeZone = "America/Dawson"

	SystemSettingsTimeZoneAmericaDawsonCreek SystemSettingsTimeZone = "America/Dawson_Creek"

	SystemSettingsTimeZoneAmericaDenver SystemSettingsTimeZone = "America/Denver"

	SystemSettingsTimeZoneAmericaDetroit SystemSettingsTimeZone = "America/Detroit"

	SystemSettingsTimeZoneAmericaDominica SystemSettingsTimeZone = "America/Dominica"

	SystemSettingsTimeZoneAmericaEdmonton SystemSettingsTimeZone = "America/Edmonton"

	SystemSettingsTimeZoneAmericaEirunepe SystemSettingsTimeZone = "America/Eirunepe"

	SystemSettingsTimeZoneAmericaElSalvador SystemSettingsTimeZone = "America/El_Salvador"

	SystemSettingsTimeZoneAmericaEnsenada SystemSettingsTimeZone = "America/Ensenada"

	SystemSettingsTimeZoneAmericaFortNelson SystemSettingsTimeZone = "America/Fort_Nelson"

	SystemSettingsTimeZoneAmericaFortWayne SystemSettingsTimeZone = "America/Fort_Wayne"

	SystemSettingsTimeZoneAmericaFortaleza SystemSettingsTimeZone = "America/Fortaleza"

	SystemSettingsTimeZoneAmericaGlaceBay SystemSettingsTimeZone = "America/Glace_Bay"

	SystemSettingsTimeZoneAmericaGodthab SystemSettingsTimeZone = "America/Godthab"

	SystemSettingsTimeZoneAmericaGooseBay SystemSettingsTimeZone = "America/Goose_Bay"

	SystemSettingsTimeZoneAmericaGrandTurk SystemSettingsTimeZone = "America/Grand_Turk"

	SystemSettingsTimeZoneAmericaGrenada SystemSettingsTimeZone = "America/Grenada"

	SystemSettingsTimeZoneAmericaGuadeloupe SystemSettingsTimeZone = "America/Guadeloupe"

	SystemSettingsTimeZoneAmericaGuatemala SystemSettingsTimeZone = "America/Guatemala"

	SystemSettingsTimeZoneAmericaGuayaquil SystemSettingsTimeZone = "America/Guayaquil"

	SystemSettingsTimeZoneAmericaGuyana SystemSettingsTimeZone = "America/Guyana"

	SystemSettingsTimeZoneAmericaHalifax SystemSettingsTimeZone = "America/Halifax"

	SystemSettingsTimeZoneAmericaHavana SystemSettingsTimeZone = "America/Havana"

	SystemSettingsTimeZoneAmericaHermosillo SystemSettingsTimeZone = "America/Hermosillo"

	SystemSettingsTimeZoneAmericaIndianaIndianapolis SystemSettingsTimeZone = "America/Indiana/Indianapolis"

	SystemSettingsTimeZoneAmericaIndianaKnox SystemSettingsTimeZone = "America/Indiana/Knox"

	SystemSettingsTimeZoneAmericaIndianaMarengo SystemSettingsTimeZone = "America/Indiana/Marengo"

	SystemSettingsTimeZoneAmericaIndianaPetersburg SystemSettingsTimeZone = "America/Indiana/Petersburg"

	SystemSettingsTimeZoneAmericaIndianaTellCity SystemSettingsTimeZone = "America/Indiana/Tell_City"

	SystemSettingsTimeZoneAmericaIndianaVevay SystemSettingsTimeZone = "America/Indiana/Vevay"

	SystemSettingsTimeZoneAmericaIndianaVincennes SystemSettingsTimeZone = "America/Indiana/Vincennes"

	SystemSettingsTimeZoneAmericaIndianaWinamac SystemSettingsTimeZone = "America/Indiana/Winamac"

	SystemSettingsTimeZoneAmericaIndianapolis SystemSettingsTimeZone = "America/Indianapolis"

	SystemSettingsTimeZoneAmericaInuvik SystemSettingsTimeZone = "America/Inuvik"

	SystemSettingsTimeZoneAmericaIqaluit SystemSettingsTimeZone = "America/Iqaluit"

	SystemSettingsTimeZoneAmericaJamaica SystemSettingsTimeZone = "America/Jamaica"

	SystemSettingsTimeZoneAmericaJujuy SystemSettingsTimeZone = "America/Jujuy"

	SystemSettingsTimeZoneAmericaJuneau SystemSettingsTimeZone = "America/Juneau"

	SystemSettingsTimeZoneAmericaKentuckyLouisville SystemSettingsTimeZone = "America/Kentucky/Louisville"

	SystemSettingsTimeZoneAmericaKentuckyMonticello SystemSettingsTimeZone = "America/Kentucky/Monticello"

	SystemSettingsTimeZoneAmericaKnoxIN SystemSettingsTimeZone = "America/Knox_IN"

	SystemSettingsTimeZoneAmericaKralendijk SystemSettingsTimeZone = "America/Kralendijk"

	SystemSettingsTimeZoneAmericaLaPaz SystemSettingsTimeZone = "America/La_Paz"

	SystemSettingsTimeZoneAmericaLima SystemSettingsTimeZone = "America/Lima"

	SystemSettingsTimeZoneAmericaLosAngeles SystemSettingsTimeZone = "America/Los_Angeles"

	SystemSettingsTimeZoneAmericaLouisville SystemSettingsTimeZone = "America/Louisville"

	SystemSettingsTimeZoneAmericaLowerPrinces SystemSettingsTimeZone = "America/Lower_Princes"

	SystemSettingsTimeZoneAmericaMaceio SystemSettingsTimeZone = "America/Maceio"

	SystemSettingsTimeZoneAmericaManagua SystemSettingsTimeZone = "America/Managua"

	SystemSettingsTimeZoneAmericaManaus SystemSettingsTimeZone = "America/Manaus"

	SystemSettingsTimeZoneAmericaMarigot SystemSettingsTimeZone = "America/Marigot"

	SystemSettingsTimeZoneAmericaMartinique SystemSettingsTimeZone = "America/Martinique"

	SystemSettingsTimeZoneAmericaMatamoros SystemSettingsTimeZone = "America/Matamoros"

	SystemSettingsTimeZoneAmericaMazatlan SystemSettingsTimeZone = "America/Mazatlan"

	SystemSettingsTimeZoneAmericaMendoza SystemSettingsTimeZone = "America/Mendoza"

	SystemSettingsTimeZoneAmericaMenominee SystemSettingsTimeZone = "America/Menominee"

	SystemSettingsTimeZoneAmericaMerida SystemSettingsTimeZone = "America/Merida"

	SystemSettingsTimeZoneAmericaMetlakatla SystemSettingsTimeZone = "America/Metlakatla"

	SystemSettingsTimeZoneAmericaMexicoCity SystemSettingsTimeZone = "America/Mexico_City"

	SystemSettingsTimeZoneAmericaMiquelon SystemSettingsTimeZone = "America/Miquelon"

	SystemSettingsTimeZoneAmericaMoncton SystemSettingsTimeZone = "America/Moncton"

	SystemSettingsTimeZoneAmericaMonterrey SystemSettingsTimeZone = "America/Monterrey"

	SystemSettingsTimeZoneAmericaMontevideo SystemSettingsTimeZone = "America/Montevideo"

	SystemSettingsTimeZoneAmericaMontreal SystemSettingsTimeZone = "America/Montreal"

	SystemSettingsTimeZoneAmericaMontserrat SystemSettingsTimeZone = "America/Montserrat"

	SystemSettingsTimeZoneAmericaNassau SystemSettingsTimeZone = "America/Nassau"

	SystemSettingsTimeZoneAmericaNewYork SystemSettingsTimeZone = "America/New_York"

	SystemSettingsTimeZoneAmericaNipigon SystemSettingsTimeZone = "America/Nipigon"

	SystemSettingsTimeZoneAmericaNome SystemSettingsTimeZone = "America/Nome"

	SystemSettingsTimeZoneAmericaNoronha SystemSettingsTimeZone = "America/Noronha"

	SystemSettingsTimeZoneAmericaNorthDakotaBeulah SystemSettingsTimeZone = "America/North_Dakota/Beulah"

	SystemSettingsTimeZoneAmericaNorthDakotaCenter SystemSettingsTimeZone = "America/North_Dakota/Center"

	SystemSettingsTimeZoneAmericaNorthDakotaNewSalem SystemSettingsTimeZone = "America/North_Dakota/New_Salem"

	SystemSettingsTimeZoneAmericaNuuk SystemSettingsTimeZone = "America/Nuuk"

	SystemSettingsTimeZoneAmericaOjinaga SystemSettingsTimeZone = "America/Ojinaga"

	SystemSettingsTimeZoneAmericaPanama SystemSettingsTimeZone = "America/Panama"

	SystemSettingsTimeZoneAmericaPangnirtung SystemSettingsTimeZone = "America/Pangnirtung"

	SystemSettingsTimeZoneAmericaParamaribo SystemSettingsTimeZone = "America/Paramaribo"

	SystemSettingsTimeZoneAmericaPhoenix SystemSettingsTimeZone = "America/Phoenix"

	SystemSettingsTimeZoneAmericaPortAuPrince SystemSettingsTimeZone = "America/Port-au-Prince"

	SystemSettingsTimeZoneAmericaPortOfSpain SystemSettingsTimeZone = "America/Port_of_Spain"

	SystemSettingsTimeZoneAmericaPortoAcre SystemSettingsTimeZone = "America/Porto_Acre"

	SystemSettingsTimeZoneAmericaPortoVelho SystemSettingsTimeZone = "America/Porto_Velho"

	SystemSettingsTimeZoneAmericaPuertoRico SystemSettingsTimeZone = "America/Puerto_Rico"

	SystemSettingsTimeZoneAmericaPuntaArenas SystemSettingsTimeZone = "America/Punta_Arenas"

	SystemSettingsTimeZoneAmericaRainyRiver SystemSettingsTimeZone = "America/Rainy_River"

	SystemSettingsTimeZoneAmericaRankinInlet SystemSettingsTimeZone = "America/Rankin_Inlet"

	SystemSettingsTimeZoneAmericaRecife SystemSettingsTimeZone = "America/Recife"

	SystemSettingsTimeZoneAmericaRegina SystemSettingsTimeZone = "America/Regina"

	SystemSettingsTimeZoneAmericaResolute SystemSettingsTimeZone = "America/Resolute"

	SystemSettingsTimeZoneAmericaRioBranco SystemSettingsTimeZone = "America/Rio_Branco"

	SystemSettingsTimeZoneAmericaRosario SystemSettingsTimeZone = "America/Rosario"

	SystemSettingsTimeZoneAmericaSantaIsabel SystemSettingsTimeZone = "America/Santa_Isabel"

	SystemSettingsTimeZoneAmericaSantarem SystemSettingsTimeZone = "America/Santarem"

	SystemSettingsTimeZoneAmericaSantiago SystemSettingsTimeZone = "America/Santiago"

	SystemSettingsTimeZoneAmericaSantoDomingo SystemSettingsTimeZone = "America/Santo_Domingo"

	SystemSettingsTimeZoneAmericaSaoPaulo SystemSettingsTimeZone = "America/Sao_Paulo"

	SystemSettingsTimeZoneAmericaScoresbysund SystemSettingsTimeZone = "America/Scoresbysund"

	SystemSettingsTimeZoneAmericaShiprock SystemSettingsTimeZone = "America/Shiprock"

	SystemSettingsTimeZoneAmericaSitka SystemSettingsTimeZone = "America/Sitka"

	SystemSettingsTimeZoneAmericaStBarthelemy SystemSettingsTimeZone = "America/St_Barthelemy"

	SystemSettingsTimeZoneAmericaStJohns SystemSettingsTimeZone = "America/St_Johns"

	SystemSettingsTimeZoneAmericaStKitts SystemSettingsTimeZone = "America/St_Kitts"

	SystemSettingsTimeZoneAmericaStLucia SystemSettingsTimeZone = "America/St_Lucia"

	SystemSettingsTimeZoneAmericaStThomas SystemSettingsTimeZone = "America/St_Thomas"

	SystemSettingsTimeZoneAmericaStVincent SystemSettingsTimeZone = "America/St_Vincent"

	SystemSettingsTimeZoneAmericaSwiftCurrent SystemSettingsTimeZone = "America/Swift_Current"

	SystemSettingsTimeZoneAmericaTegucigalpa SystemSettingsTimeZone = "America/Tegucigalpa"

	SystemSettingsTimeZoneAmericaThule SystemSettingsTimeZone = "America/Thule"

	SystemSettingsTimeZoneAmericaThunderBay SystemSettingsTimeZone = "America/Thunder_Bay"

	SystemSettingsTimeZoneAmericaTijuana SystemSettingsTimeZone = "America/Tijuana"

	SystemSettingsTimeZoneAmericaToronto SystemSettingsTimeZone = "America/Toronto"

	SystemSettingsTimeZoneAmericaTortola SystemSettingsTimeZone = "America/Tortola"

	SystemSettingsTimeZoneAmericaVancouver SystemSettingsTimeZone = "America/Vancouver"

	SystemSettingsTimeZoneAmericaVirgin SystemSettingsTimeZone = "America/Virgin"

	SystemSettingsTimeZoneAmericaWhitehorse SystemSettingsTimeZone = "America/Whitehorse"

	SystemSettingsTimeZoneAmericaWinnipeg SystemSettingsTimeZone = "America/Winnipeg"

	SystemSettingsTimeZoneAmericaYakutat SystemSettingsTimeZone = "America/Yakutat"

	SystemSettingsTimeZoneAmericaYellowknife SystemSettingsTimeZone = "America/Yellowknife"

	SystemSettingsTimeZoneAntarcticaCasey SystemSettingsTimeZone = "Antarctica/Casey"

	SystemSettingsTimeZoneAntarcticaDavis SystemSettingsTimeZone = "Antarctica/Davis"

	SystemSettingsTimeZoneAntarcticaDumontDUrville SystemSettingsTimeZone = "Antarctica/DumontDUrville"

	SystemSettingsTimeZoneAntarcticaMacquarie SystemSettingsTimeZone = "Antarctica/Macquarie"

	SystemSettingsTimeZoneAntarcticaMawson SystemSettingsTimeZone = "Antarctica/Mawson"

	SystemSettingsTimeZoneAntarcticaMcMurdo SystemSettingsTimeZone = "Antarctica/McMurdo"

	SystemSettingsTimeZoneAntarcticaPalmer SystemSettingsTimeZone = "Antarctica/Palmer"

	SystemSettingsTimeZoneAntarcticaRothera SystemSettingsTimeZone = "Antarctica/Rothera"

	SystemSettingsTimeZoneAntarcticaSouthPole SystemSettingsTimeZone = "Antarctica/South_Pole"

	SystemSettingsTimeZoneAntarcticaSyowa SystemSettingsTimeZone = "Antarctica/Syowa"

	SystemSettingsTimeZoneAntarcticaTroll SystemSettingsTimeZone = "Antarctica/Troll"

	SystemSettingsTimeZoneAntarcticaVostok SystemSettingsTimeZone = "Antarctica/Vostok"

	SystemSettingsTimeZoneArcticLongyearbyen SystemSettingsTimeZone = "Arctic/Longyearbyen"

	SystemSettingsTimeZoneAsiaAden SystemSettingsTimeZone = "Asia/Aden"

	SystemSettingsTimeZoneAsiaAlmaty SystemSettingsTimeZone = "Asia/Almaty"

	SystemSettingsTimeZoneAsiaAmman SystemSettingsTimeZone = "Asia/Amman"

	SystemSettingsTimeZoneAsiaAnadyr SystemSettingsTimeZone = "Asia/Anadyr"

	SystemSettingsTimeZoneAsiaAqtau SystemSettingsTimeZone = "Asia/Aqtau"

	SystemSettingsTimeZoneAsiaAqtobe SystemSettingsTimeZone = "Asia/Aqtobe"

	SystemSettingsTimeZoneAsiaAshgabat SystemSettingsTimeZone = "Asia/Ashgabat"

	SystemSettingsTimeZoneAsiaAshkhabad SystemSettingsTimeZone = "Asia/Ashkhabad"

	SystemSettingsTimeZoneAsiaAtyrau SystemSettingsTimeZone = "Asia/Atyrau"

	SystemSettingsTimeZoneAsiaBaghdad SystemSettingsTimeZone = "Asia/Baghdad"

	SystemSettingsTimeZoneAsiaBahrain SystemSettingsTimeZone = "Asia/Bahrain"

	SystemSettingsTimeZoneAsiaBaku SystemSettingsTimeZone = "Asia/Baku"

	SystemSettingsTimeZoneAsiaBangkok SystemSettingsTimeZone = "Asia/Bangkok"

	SystemSettingsTimeZoneAsiaBarnaul SystemSettingsTimeZone = "Asia/Barnaul"

	SystemSettingsTimeZoneAsiaBeirut SystemSettingsTimeZone = "Asia/Beirut"

	SystemSettingsTimeZoneAsiaBishkek SystemSettingsTimeZone = "Asia/Bishkek"

	SystemSettingsTimeZoneAsiaBrunei SystemSettingsTimeZone = "Asia/Brunei"

	SystemSettingsTimeZoneAsiaCalcutta SystemSettingsTimeZone = "Asia/Calcutta"

	SystemSettingsTimeZoneAsiaChita SystemSettingsTimeZone = "Asia/Chita"

	SystemSettingsTimeZoneAsiaChoibalsan SystemSettingsTimeZone = "Asia/Choibalsan"

	SystemSettingsTimeZoneAsiaChongqing SystemSettingsTimeZone = "Asia/Chongqing"

	SystemSettingsTimeZoneAsiaChungking SystemSettingsTimeZone = "Asia/Chungking"

	SystemSettingsTimeZoneAsiaColombo SystemSettingsTimeZone = "Asia/Colombo"

	SystemSettingsTimeZoneAsiaDacca SystemSettingsTimeZone = "Asia/Dacca"

	SystemSettingsTimeZoneAsiaDamascus SystemSettingsTimeZone = "Asia/Damascus"

	SystemSettingsTimeZoneAsiaDhaka SystemSettingsTimeZone = "Asia/Dhaka"

	SystemSettingsTimeZoneAsiaDili SystemSettingsTimeZone = "Asia/Dili"

	SystemSettingsTimeZoneAsiaDubai SystemSettingsTimeZone = "Asia/Dubai"

	SystemSettingsTimeZoneAsiaDushanbe SystemSettingsTimeZone = "Asia/Dushanbe"

	SystemSettingsTimeZoneAsiaFamagusta SystemSettingsTimeZone = "Asia/Famagusta"

	SystemSettingsTimeZoneAsiaGaza SystemSettingsTimeZone = "Asia/Gaza"

	SystemSettingsTimeZoneAsiaHarbin SystemSettingsTimeZone = "Asia/Harbin"

	SystemSettingsTimeZoneAsiaHebron SystemSettingsTimeZone = "Asia/Hebron"

	SystemSettingsTimeZoneAsiaHoChiMinh SystemSettingsTimeZone = "Asia/Ho_Chi_Minh"

	SystemSettingsTimeZoneAsiaHongKong SystemSettingsTimeZone = "Asia/Hong_Kong"

	SystemSettingsTimeZoneAsiaHovd SystemSettingsTimeZone = "Asia/Hovd"

	SystemSettingsTimeZoneAsiaIrkutsk SystemSettingsTimeZone = "Asia/Irkutsk"

	SystemSettingsTimeZoneAsiaIstanbul SystemSettingsTimeZone = "Asia/Istanbul"

	SystemSettingsTimeZoneAsiaJakarta SystemSettingsTimeZone = "Asia/Jakarta"

	SystemSettingsTimeZoneAsiaJayapura SystemSettingsTimeZone = "Asia/Jayapura"

	SystemSettingsTimeZoneAsiaJerusalem SystemSettingsTimeZone = "Asia/Jerusalem"

	SystemSettingsTimeZoneAsiaKabul SystemSettingsTimeZone = "Asia/Kabul"

	SystemSettingsTimeZoneAsiaKamchatka SystemSettingsTimeZone = "Asia/Kamchatka"

	SystemSettingsTimeZoneAsiaKarachi SystemSettingsTimeZone = "Asia/Karachi"

	SystemSettingsTimeZoneAsiaKashgar SystemSettingsTimeZone = "Asia/Kashgar"

	SystemSettingsTimeZoneAsiaKathmandu SystemSettingsTimeZone = "Asia/Kathmandu"

	SystemSettingsTimeZoneAsiaKatmandu SystemSettingsTimeZone = "Asia/Katmandu"

	SystemSettingsTimeZoneAsiaKhandyga SystemSettingsTimeZone = "Asia/Khandyga"

	SystemSettingsTimeZoneAsiaKolkata SystemSettingsTimeZone = "Asia/Kolkata"

	SystemSettingsTimeZoneAsiaKrasnoyarsk SystemSettingsTimeZone = "Asia/Krasnoyarsk"

	SystemSettingsTimeZoneAsiaKualaLumpur SystemSettingsTimeZone = "Asia/Kuala_Lumpur"

	SystemSettingsTimeZoneAsiaKuching SystemSettingsTimeZone = "Asia/Kuching"

	SystemSettingsTimeZoneAsiaKuwait SystemSettingsTimeZone = "Asia/Kuwait"

	SystemSettingsTimeZoneAsiaMacao SystemSettingsTimeZone = "Asia/Macao"

	SystemSettingsTimeZoneAsiaMacau SystemSettingsTimeZone = "Asia/Macau"

	SystemSettingsTimeZoneAsiaMagadan SystemSettingsTimeZone = "Asia/Magadan"

	SystemSettingsTimeZoneAsiaMakassar SystemSettingsTimeZone = "Asia/Makassar"

	SystemSettingsTimeZoneAsiaManila SystemSettingsTimeZone = "Asia/Manila"

	SystemSettingsTimeZoneAsiaMuscat SystemSettingsTimeZone = "Asia/Muscat"

	SystemSettingsTimeZoneAsiaNicosia SystemSettingsTimeZone = "Asia/Nicosia"

	SystemSettingsTimeZoneAsiaNovokuznetsk SystemSettingsTimeZone = "Asia/Novokuznetsk"

	SystemSettingsTimeZoneAsiaNovosibirsk SystemSettingsTimeZone = "Asia/Novosibirsk"

	SystemSettingsTimeZoneAsiaOmsk SystemSettingsTimeZone = "Asia/Omsk"

	SystemSettingsTimeZoneAsiaOral SystemSettingsTimeZone = "Asia/Oral"

	SystemSettingsTimeZoneAsiaPhnomPenh SystemSettingsTimeZone = "Asia/Phnom_Penh"

	SystemSettingsTimeZoneAsiaPontianak SystemSettingsTimeZone = "Asia/Pontianak"

	SystemSettingsTimeZoneAsiaPyongyang SystemSettingsTimeZone = "Asia/Pyongyang"

	SystemSettingsTimeZoneAsiaQatar SystemSettingsTimeZone = "Asia/Qatar"

	SystemSettingsTimeZoneAsiaQostanay SystemSettingsTimeZone = "Asia/Qostanay"

	SystemSettingsTimeZoneAsiaQyzylorda SystemSettingsTimeZone = "Asia/Qyzylorda"

	SystemSettingsTimeZoneAsiaRangoon SystemSettingsTimeZone = "Asia/Rangoon"

	SystemSettingsTimeZoneAsiaRiyadh SystemSettingsTimeZone = "Asia/Riyadh"

	SystemSettingsTimeZoneAsiaSaigon SystemSettingsTimeZone = "Asia/Saigon"

	SystemSettingsTimeZoneAsiaSakhalin SystemSettingsTimeZone = "Asia/Sakhalin"

	SystemSettingsTimeZoneAsiaSamarkand SystemSettingsTimeZone = "Asia/Samarkand"

	SystemSettingsTimeZoneAsiaSeoul SystemSettingsTimeZone = "Asia/Seoul"

	SystemSettingsTimeZoneAsiaShanghai SystemSettingsTimeZone = "Asia/Shanghai"

	SystemSettingsTimeZoneAsiaSingapore SystemSettingsTimeZone = "Asia/Singapore"

	SystemSettingsTimeZoneAsiaSrednekolymsk SystemSettingsTimeZone = "Asia/Srednekolymsk"

	SystemSettingsTimeZoneAsiaTaipei SystemSettingsTimeZone = "Asia/Taipei"

	SystemSettingsTimeZoneAsiaTashkent SystemSettingsTimeZone = "Asia/Tashkent"

	SystemSettingsTimeZoneAsiaTbilisi SystemSettingsTimeZone = "Asia/Tbilisi"

	SystemSettingsTimeZoneAsiaTehran SystemSettingsTimeZone = "Asia/Tehran"

	SystemSettingsTimeZoneAsiaTelAviv SystemSettingsTimeZone = "Asia/Tel_Aviv"

	SystemSettingsTimeZoneAsiaThimbu SystemSettingsTimeZone = "Asia/Thimbu"

	SystemSettingsTimeZoneAsiaThimphu SystemSettingsTimeZone = "Asia/Thimphu"

	SystemSettingsTimeZoneAsiaTokyo SystemSettingsTimeZone = "Asia/Tokyo"

	SystemSettingsTimeZoneAsiaTomsk SystemSettingsTimeZone = "Asia/Tomsk"

	SystemSettingsTimeZoneAsiaUjungPandang SystemSettingsTimeZone = "Asia/Ujung_Pandang"

	SystemSettingsTimeZoneAsiaUlaanbaatar SystemSettingsTimeZone = "Asia/Ulaanbaatar"

	SystemSettingsTimeZoneAsiaUlanBator SystemSettingsTimeZone = "Asia/Ulan_Bator"

	SystemSettingsTimeZoneAsiaUrumqi SystemSettingsTimeZone = "Asia/Urumqi"

	SystemSettingsTimeZoneAsiaUstNera SystemSettingsTimeZone = "Asia/Ust-Nera"

	SystemSettingsTimeZoneAsiaVientiane SystemSettingsTimeZone = "Asia/Vientiane"

	SystemSettingsTimeZoneAsiaVladivostok SystemSettingsTimeZone = "Asia/Vladivostok"

	SystemSettingsTimeZoneAsiaYakutsk SystemSettingsTimeZone = "Asia/Yakutsk"

	SystemSettingsTimeZoneAsiaYangon SystemSettingsTimeZone = "Asia/Yangon"

	SystemSettingsTimeZoneAsiaYekaterinburg SystemSettingsTimeZone = "Asia/Yekaterinburg"

	SystemSettingsTimeZoneAsiaYerevan SystemSettingsTimeZone = "Asia/Yerevan"

	SystemSettingsTimeZoneAtlanticAzores SystemSettingsTimeZone = "Atlantic/Azores"

	SystemSettingsTimeZoneAtlanticBermuda SystemSettingsTimeZone = "Atlantic/Bermuda"

	SystemSettingsTimeZoneAtlanticCanary SystemSettingsTimeZone = "Atlantic/Canary"

	SystemSettingsTimeZoneAtlanticCapeVerde SystemSettingsTimeZone = "Atlantic/Cape_Verde"

	SystemSettingsTimeZoneAtlanticFaeroe SystemSettingsTimeZone = "Atlantic/Faeroe"

	SystemSettingsTimeZoneAtlanticFaroe SystemSettingsTimeZone = "Atlantic/Faroe"

	SystemSettingsTimeZoneAtlanticJanMayen SystemSettingsTimeZone = "Atlantic/Jan_Mayen"

	SystemSettingsTimeZoneAtlanticMadeira SystemSettingsTimeZone = "Atlantic/Madeira"

	SystemSettingsTimeZoneAtlanticReykjavik SystemSettingsTimeZone = "Atlantic/Reykjavik"

	SystemSettingsTimeZoneAtlanticSouthGeorgia SystemSettingsTimeZone = "Atlantic/South_Georgia"

	SystemSettingsTimeZoneAtlanticStHelena SystemSettingsTimeZone = "Atlantic/St_Helena"

	SystemSettingsTimeZoneAtlanticStanley SystemSettingsTimeZone = "Atlantic/Stanley"

	SystemSettingsTimeZoneAustraliaACT SystemSettingsTimeZone = "Australia/ACT"

	SystemSettingsTimeZoneAustraliaAdelaide SystemSettingsTimeZone = "Australia/Adelaide"

	SystemSettingsTimeZoneAustraliaBrisbane SystemSettingsTimeZone = "Australia/Brisbane"

	SystemSettingsTimeZoneAustraliaBrokenHill SystemSettingsTimeZone = "Australia/Broken_Hill"

	SystemSettingsTimeZoneAustraliaCanberra SystemSettingsTimeZone = "Australia/Canberra"

	SystemSettingsTimeZoneAustraliaCurrie SystemSettingsTimeZone = "Australia/Currie"

	SystemSettingsTimeZoneAustraliaDarwin SystemSettingsTimeZone = "Australia/Darwin"

	SystemSettingsTimeZoneAustraliaEucla SystemSettingsTimeZone = "Australia/Eucla"

	SystemSettingsTimeZoneAustraliaHobart SystemSettingsTimeZone = "Australia/Hobart"

	SystemSettingsTimeZoneAustraliaLHI SystemSettingsTimeZone = "Australia/LHI"

	SystemSettingsTimeZoneAustraliaLindeman SystemSettingsTimeZone = "Australia/Lindeman"

	SystemSettingsTimeZoneAustraliaLordHowe SystemSettingsTimeZone = "Australia/Lord_Howe"

	SystemSettingsTimeZoneAustraliaMelbourne SystemSettingsTimeZone = "Australia/Melbourne"

	SystemSettingsTimeZoneAustraliaNSW SystemSettingsTimeZone = "Australia/NSW"

	SystemSettingsTimeZoneAustraliaNorth SystemSettingsTimeZone = "Australia/North"

	SystemSettingsTimeZoneAustraliaPerth SystemSettingsTimeZone = "Australia/Perth"

	SystemSettingsTimeZoneAustraliaQueensland SystemSettingsTimeZone = "Australia/Queensland"

	SystemSettingsTimeZoneAustraliaSouth SystemSettingsTimeZone = "Australia/South"

	SystemSettingsTimeZoneAustraliaSydney SystemSettingsTimeZone = "Australia/Sydney"

	SystemSettingsTimeZoneAustraliaTasmania SystemSettingsTimeZone = "Australia/Tasmania"

	SystemSettingsTimeZoneAustraliaVictoria SystemSettingsTimeZone = "Australia/Victoria"

	SystemSettingsTimeZoneAustraliaWest SystemSettingsTimeZone = "Australia/West"

	SystemSettingsTimeZoneAustraliaYancowinna SystemSettingsTimeZone = "Australia/Yancowinna"

	SystemSettingsTimeZoneBrazilAcre SystemSettingsTimeZone = "Brazil/Acre"

	SystemSettingsTimeZoneBrazilDeNoronha SystemSettingsTimeZone = "Brazil/DeNoronha"

	SystemSettingsTimeZoneBrazilEast SystemSettingsTimeZone = "Brazil/East"

	SystemSettingsTimeZoneBrazilWest SystemSettingsTimeZone = "Brazil/West"

	SystemSettingsTimeZoneCET SystemSettingsTimeZone = "CET"

	SystemSettingsTimeZoneCST6CDT SystemSettingsTimeZone = "CST6CDT"

	SystemSettingsTimeZoneCanadaAtlantic SystemSettingsTimeZone = "Canada/Atlantic"

	SystemSettingsTimeZoneCanadaCentral SystemSettingsTimeZone = "Canada/Central"

	SystemSettingsTimeZoneCanadaEastern SystemSettingsTimeZone = "Canada/Eastern"

	SystemSettingsTimeZoneCanadaMountain SystemSettingsTimeZone = "Canada/Mountain"

	SystemSettingsTimeZoneCanadaNewfoundland SystemSettingsTimeZone = "Canada/Newfoundland"

	SystemSettingsTimeZoneCanadaPacific SystemSettingsTimeZone = "Canada/Pacific"

	SystemSettingsTimeZoneCanadaSaskatchewan SystemSettingsTimeZone = "Canada/Saskatchewan"

	SystemSettingsTimeZoneCanadaYukon SystemSettingsTimeZone = "Canada/Yukon"

	SystemSettingsTimeZoneChileContinental SystemSettingsTimeZone = "Chile/Continental"

	SystemSettingsTimeZoneChileEasterIsland SystemSettingsTimeZone = "Chile/EasterIsland"

	SystemSettingsTimeZoneCuba SystemSettingsTimeZone = "Cuba"

	SystemSettingsTimeZoneEET SystemSettingsTimeZone = "EET"

	SystemSettingsTimeZoneEST SystemSettingsTimeZone = "EST"

	SystemSettingsTimeZoneEST5EDT SystemSettingsTimeZone = "EST5EDT"

	SystemSettingsTimeZoneEgypt SystemSettingsTimeZone = "Egypt"

	SystemSettingsTimeZoneEire SystemSettingsTimeZone = "Eire"

	SystemSettingsTimeZoneEtcGMT SystemSettingsTimeZone = "Etc/GMT"

	SystemSettingsTimeZoneEtcGMT0 SystemSettingsTimeZone = "Etc/GMT+0"

	SystemSettingsTimeZoneEtcGMT01 SystemSettingsTimeZone = "Etc/GMT-0"

	SystemSettingsTimeZoneEtcGMT02 SystemSettingsTimeZone = "Etc/GMT0"

	SystemSettingsTimeZoneEtcGMT1 SystemSettingsTimeZone = "Etc/GMT+1"

	SystemSettingsTimeZoneEtcGMT10 SystemSettingsTimeZone = "Etc/GMT+10"

	SystemSettingsTimeZoneEtcGMT101 SystemSettingsTimeZone = "Etc/GMT-10"

	SystemSettingsTimeZoneEtcGMT11 SystemSettingsTimeZone = "Etc/GMT-1"

	SystemSettingsTimeZoneEtcGMT111 SystemSettingsTimeZone = "Etc/GMT-11"

	SystemSettingsTimeZoneEtcGMT12 SystemSettingsTimeZone = "Etc/GMT+12"

	SystemSettingsTimeZoneEtcGMT121 SystemSettingsTimeZone = "Etc/GMT-12"

	SystemSettingsTimeZoneEtcGMT13 SystemSettingsTimeZone = "Etc/GMT-13"

	SystemSettingsTimeZoneEtcGMT14 SystemSettingsTimeZone = "Etc/GMT-14"

	SystemSettingsTimeZoneEtcGMT2 SystemSettingsTimeZone = "Etc/GMT+2"

	SystemSettingsTimeZoneEtcGMT21 SystemSettingsTimeZone = "Etc/GMT-2"

	SystemSettingsTimeZoneEtcGMT3 SystemSettingsTimeZone = "Etc/GMT+3"

	SystemSettingsTimeZoneEtcGMT31 SystemSettingsTimeZone = "Etc/GMT-3"

	SystemSettingsTimeZoneEtcGMT4 SystemSettingsTimeZone = "Etc/GMT+4"

	SystemSettingsTimeZoneEtcGMT41 SystemSettingsTimeZone = "Etc/GMT-4"

	SystemSettingsTimeZoneEtcGMT5 SystemSettingsTimeZone = "Etc/GMT+5"

	SystemSettingsTimeZoneEtcGMT51 SystemSettingsTimeZone = "Etc/GMT-5"

	SystemSettingsTimeZoneEtcGMT6 SystemSettingsTimeZone = "Etc/GMT+6"

	SystemSettingsTimeZoneEtcGMT61 SystemSettingsTimeZone = "Etc/GMT-6"

	SystemSettingsTimeZoneEtcGMT7 SystemSettingsTimeZone = "Etc/GMT+7"

	SystemSettingsTimeZoneEtcGMT71 SystemSettingsTimeZone = "Etc/GMT-7"

	SystemSettingsTimeZoneEtcGMT8 SystemSettingsTimeZone = "Etc/GMT+8"

	SystemSettingsTimeZoneEtcGMT81 SystemSettingsTimeZone = "Etc/GMT-8"

	SystemSettingsTimeZoneEtcGMT9 SystemSettingsTimeZone = "Etc/GMT+9"

	SystemSettingsTimeZoneEtcGMT91 SystemSettingsTimeZone = "Etc/GMT-9"

	SystemSettingsTimeZoneEtcGreenwich SystemSettingsTimeZone = "Etc/Greenwich"

	SystemSettingsTimeZoneEtcUCT SystemSettingsTimeZone = "Etc/UCT"

	SystemSettingsTimeZoneEtcUTC SystemSettingsTimeZone = "Etc/UTC"

	SystemSettingsTimeZoneEtcUniversal SystemSettingsTimeZone = "Etc/Universal"

	SystemSettingsTimeZoneEtcZulu SystemSettingsTimeZone = "Etc/Zulu"

	SystemSettingsTimeZoneEuropeAmsterdam SystemSettingsTimeZone = "Europe/Amsterdam"

	SystemSettingsTimeZoneEuropeAndorra SystemSettingsTimeZone = "Europe/Andorra"

	SystemSettingsTimeZoneEuropeAstrakhan SystemSettingsTimeZone = "Europe/Astrakhan"

	SystemSettingsTimeZoneEuropeAthens SystemSettingsTimeZone = "Europe/Athens"

	SystemSettingsTimeZoneEuropeBelfast SystemSettingsTimeZone = "Europe/Belfast"

	SystemSettingsTimeZoneEuropeBelgrade SystemSettingsTimeZone = "Europe/Belgrade"

	SystemSettingsTimeZoneEuropeBerlin SystemSettingsTimeZone = "Europe/Berlin"

	SystemSettingsTimeZoneEuropeBratislava SystemSettingsTimeZone = "Europe/Bratislava"

	SystemSettingsTimeZoneEuropeBrussels SystemSettingsTimeZone = "Europe/Brussels"

	SystemSettingsTimeZoneEuropeBucharest SystemSettingsTimeZone = "Europe/Bucharest"

	SystemSettingsTimeZoneEuropeBudapest SystemSettingsTimeZone = "Europe/Budapest"

	SystemSettingsTimeZoneEuropeBusingen SystemSettingsTimeZone = "Europe/Busingen"

	SystemSettingsTimeZoneEuropeChisinau SystemSettingsTimeZone = "Europe/Chisinau"

	SystemSettingsTimeZoneEuropeCopenhagen SystemSettingsTimeZone = "Europe/Copenhagen"

	SystemSettingsTimeZoneEuropeDublin SystemSettingsTimeZone = "Europe/Dublin"

	SystemSettingsTimeZoneEuropeGibraltar SystemSettingsTimeZone = "Europe/Gibraltar"

	SystemSettingsTimeZoneEuropeGuernsey SystemSettingsTimeZone = "Europe/Guernsey"

	SystemSettingsTimeZoneEuropeHelsinki SystemSettingsTimeZone = "Europe/Helsinki"

	SystemSettingsTimeZoneEuropeIsleOfMan SystemSettingsTimeZone = "Europe/Isle_of_Man"

	SystemSettingsTimeZoneEuropeIstanbul SystemSettingsTimeZone = "Europe/Istanbul"

	SystemSettingsTimeZoneEuropeJersey SystemSettingsTimeZone = "Europe/Jersey"

	SystemSettingsTimeZoneEuropeKaliningrad SystemSettingsTimeZone = "Europe/Kaliningrad"

	SystemSettingsTimeZoneEuropeKiev SystemSettingsTimeZone = "Europe/Kiev"

	SystemSettingsTimeZoneEuropeKirov SystemSettingsTimeZone = "Europe/Kirov"

	SystemSettingsTimeZoneEuropeKyiv SystemSettingsTimeZone = "Europe/Kyiv"

	SystemSettingsTimeZoneEuropeLisbon SystemSettingsTimeZone = "Europe/Lisbon"

	SystemSettingsTimeZoneEuropeLjubljana SystemSettingsTimeZone = "Europe/Ljubljana"

	SystemSettingsTimeZoneEuropeLondon SystemSettingsTimeZone = "Europe/London"

	SystemSettingsTimeZoneEuropeLuxembourg SystemSettingsTimeZone = "Europe/Luxembourg"

	SystemSettingsTimeZoneEuropeMadrid SystemSettingsTimeZone = "Europe/Madrid"

	SystemSettingsTimeZoneEuropeMalta SystemSettingsTimeZone = "Europe/Malta"

	SystemSettingsTimeZoneEuropeMariehamn SystemSettingsTimeZone = "Europe/Mariehamn"

	SystemSettingsTimeZoneEuropeMinsk SystemSettingsTimeZone = "Europe/Minsk"

	SystemSettingsTimeZoneEuropeMonaco SystemSettingsTimeZone = "Europe/Monaco"

	SystemSettingsTimeZoneEuropeMoscow SystemSettingsTimeZone = "Europe/Moscow"

	SystemSettingsTimeZoneEuropeNicosia SystemSettingsTimeZone = "Europe/Nicosia"

	SystemSettingsTimeZoneEuropeOslo SystemSettingsTimeZone = "Europe/Oslo"

	SystemSettingsTimeZoneEuropeParis SystemSettingsTimeZone = "Europe/Paris"

	SystemSettingsTimeZoneEuropePodgorica SystemSettingsTimeZone = "Europe/Podgorica"

	SystemSettingsTimeZoneEuropePrague SystemSettingsTimeZone = "Europe/Prague"

	SystemSettingsTimeZoneEuropeRiga SystemSettingsTimeZone = "Europe/Riga"

	SystemSettingsTimeZoneEuropeRome SystemSettingsTimeZone = "Europe/Rome"

	SystemSettingsTimeZoneEuropeSamara SystemSettingsTimeZone = "Europe/Samara"

	SystemSettingsTimeZoneEuropeSanMarino SystemSettingsTimeZone = "Europe/San_Marino"

	SystemSettingsTimeZoneEuropeSarajevo SystemSettingsTimeZone = "Europe/Sarajevo"

	SystemSettingsTimeZoneEuropeSaratov SystemSettingsTimeZone = "Europe/Saratov"

	SystemSettingsTimeZoneEuropeSimferopol SystemSettingsTimeZone = "Europe/Simferopol"

	SystemSettingsTimeZoneEuropeSkopje SystemSettingsTimeZone = "Europe/Skopje"

	SystemSettingsTimeZoneEuropeSofia SystemSettingsTimeZone = "Europe/Sofia"

	SystemSettingsTimeZoneEuropeStockholm SystemSettingsTimeZone = "Europe/Stockholm"

	SystemSettingsTimeZoneEuropeTallinn SystemSettingsTimeZone = "Europe/Tallinn"

	SystemSettingsTimeZoneEuropeTirane SystemSettingsTimeZone = "Europe/Tirane"

	SystemSettingsTimeZoneEuropeTiraspol SystemSettingsTimeZone = "Europe/Tiraspol"

	SystemSettingsTimeZoneEuropeUlyanovsk SystemSettingsTimeZone = "Europe/Ulyanovsk"

	SystemSettingsTimeZoneEuropeUzhgorod SystemSettingsTimeZone = "Europe/Uzhgorod"

	SystemSettingsTimeZoneEuropeVaduz SystemSettingsTimeZone = "Europe/Vaduz"

	SystemSettingsTimeZoneEuropeVatican SystemSettingsTimeZone = "Europe/Vatican"

	SystemSettingsTimeZoneEuropeVienna SystemSettingsTimeZone = "Europe/Vienna"

	SystemSettingsTimeZoneEuropeVilnius SystemSettingsTimeZone = "Europe/Vilnius"

	SystemSettingsTimeZoneEuropeVolgograd SystemSettingsTimeZone = "Europe/Volgograd"

	SystemSettingsTimeZoneEuropeWarsaw SystemSettingsTimeZone = "Europe/Warsaw"

	SystemSettingsTimeZoneEuropeZagreb SystemSettingsTimeZone = "Europe/Zagreb"

	SystemSettingsTimeZoneEuropeZaporozhye SystemSettingsTimeZone = "Europe/Zaporozhye"

	SystemSettingsTimeZoneEuropeZurich SystemSettingsTimeZone = "Europe/Zurich"

	SystemSettingsTimeZoneGB SystemSettingsTimeZone = "GB"

	SystemSettingsTimeZoneGBEire SystemSettingsTimeZone = "GB-Eire"

	SystemSettingsTimeZoneGMT SystemSettingsTimeZone = "GMT"

	SystemSettingsTimeZoneGMT0 SystemSettingsTimeZone = "GMT+0"

	SystemSettingsTimeZoneGMT01 SystemSettingsTimeZone = "GMT-0"

	SystemSettingsTimeZoneGMT02 SystemSettingsTimeZone = "GMT0"

	SystemSettingsTimeZoneGreenwich SystemSettingsTimeZone = "Greenwich"

	SystemSettingsTimeZoneHST SystemSettingsTimeZone = "HST"

	SystemSettingsTimeZoneHongkong SystemSettingsTimeZone = "Hongkong"

	SystemSettingsTimeZoneIceland SystemSettingsTimeZone = "Iceland"

	SystemSettingsTimeZoneIndianAntananarivo SystemSettingsTimeZone = "Indian/Antananarivo"

	SystemSettingsTimeZoneIndianChagos SystemSettingsTimeZone = "Indian/Chagos"

	SystemSettingsTimeZoneIndianChristmas SystemSettingsTimeZone = "Indian/Christmas"

	SystemSettingsTimeZoneIndianCocos SystemSettingsTimeZone = "Indian/Cocos"

	SystemSettingsTimeZoneIndianComoro SystemSettingsTimeZone = "Indian/Comoro"

	SystemSettingsTimeZoneIndianKerguelen SystemSettingsTimeZone = "Indian/Kerguelen"

	SystemSettingsTimeZoneIndianMahe SystemSettingsTimeZone = "Indian/Mahe"

	SystemSettingsTimeZoneIndianMaldives SystemSettingsTimeZone = "Indian/Maldives"

	SystemSettingsTimeZoneIndianMauritius SystemSettingsTimeZone = "Indian/Mauritius"

	SystemSettingsTimeZoneIndianMayotte SystemSettingsTimeZone = "Indian/Mayotte"

	SystemSettingsTimeZoneIndianReunion SystemSettingsTimeZone = "Indian/Reunion"

	SystemSettingsTimeZoneIran SystemSettingsTimeZone = "Iran"

	SystemSettingsTimeZoneIsrael SystemSettingsTimeZone = "Israel"

	SystemSettingsTimeZoneJamaica SystemSettingsTimeZone = "Jamaica"

	SystemSettingsTimeZoneJapan SystemSettingsTimeZone = "Japan"

	SystemSettingsTimeZoneKwajalein SystemSettingsTimeZone = "Kwajalein"

	SystemSettingsTimeZoneLibya SystemSettingsTimeZone = "Libya"

	SystemSettingsTimeZoneMET SystemSettingsTimeZone = "MET"

	SystemSettingsTimeZoneMST SystemSettingsTimeZone = "MST"

	SystemSettingsTimeZoneMST7MDT SystemSettingsTimeZone = "MST7MDT"

	SystemSettingsTimeZoneMexicoBajaNorte SystemSettingsTimeZone = "Mexico/BajaNorte"

	SystemSettingsTimeZoneMexicoBajaSur SystemSettingsTimeZone = "Mexico/BajaSur"

	SystemSettingsTimeZoneMexicoGeneral SystemSettingsTimeZone = "Mexico/General"

	SystemSettingsTimeZoneNZ SystemSettingsTimeZone = "NZ"

	SystemSettingsTimeZoneNZCHAT SystemSettingsTimeZone = "NZ-CHAT"

	SystemSettingsTimeZoneNavajo SystemSettingsTimeZone = "Navajo"

	SystemSettingsTimeZonePRC SystemSettingsTimeZone = "PRC"

	SystemSettingsTimeZonePST8PDT SystemSettingsTimeZone = "PST8PDT"

	SystemSettingsTimeZonePacificApia SystemSettingsTimeZone = "Pacific/Apia"

	SystemSettingsTimeZonePacificAuckland SystemSettingsTimeZone = "Pacific/Auckland"

	SystemSettingsTimeZonePacificBougainville SystemSettingsTimeZone = "Pacific/Bougainville"

	SystemSettingsTimeZonePacificChatham SystemSettingsTimeZone = "Pacific/Chatham"

	SystemSettingsTimeZonePacificChuuk SystemSettingsTimeZone = "Pacific/Chuuk"

	SystemSettingsTimeZonePacificEaster SystemSettingsTimeZone = "Pacific/Easter"

	SystemSettingsTimeZonePacificEfate SystemSettingsTimeZone = "Pacific/Efate"

	SystemSettingsTimeZonePacificEnderbury SystemSettingsTimeZone = "Pacific/Enderbury"

	SystemSettingsTimeZonePacificFakaofo SystemSettingsTimeZone = "Pacific/Fakaofo"

	SystemSettingsTimeZonePacificFiji SystemSettingsTimeZone = "Pacific/Fiji"

	SystemSettingsTimeZonePacificFunafuti SystemSettingsTimeZone = "Pacific/Funafuti"

	SystemSettingsTimeZonePacificGalapagos SystemSettingsTimeZone = "Pacific/Galapagos"

	SystemSettingsTimeZonePacificGambier SystemSettingsTimeZone = "Pacific/Gambier"

	SystemSettingsTimeZonePacificGuadalcanal SystemSettingsTimeZone = "Pacific/Guadalcanal"

	SystemSettingsTimeZonePacificGuam SystemSettingsTimeZone = "Pacific/Guam"

	SystemSettingsTimeZonePacificHonolulu SystemSettingsTimeZone = "Pacific/Honolulu"

	SystemSettingsTimeZonePacificJohnston SystemSettingsTimeZone = "Pacific/Johnston"

	SystemSettingsTimeZonePacificKanton SystemSettingsTimeZone = "Pacific/Kanton"

	SystemSettingsTimeZonePacificKiritimati SystemSettingsTimeZone = "Pacific/Kiritimati"

	SystemSettingsTimeZonePacificKosrae SystemSettingsTimeZone = "Pacific/Kosrae"

	SystemSettingsTimeZonePacificKwajalein SystemSettingsTimeZone = "Pacific/Kwajalein"

	SystemSettingsTimeZonePacificMajuro SystemSettingsTimeZone = "Pacific/Majuro"

	SystemSettingsTimeZonePacificMarquesas SystemSettingsTimeZone = "Pacific/Marquesas"

	SystemSettingsTimeZonePacificMidway SystemSettingsTimeZone = "Pacific/Midway"

	SystemSettingsTimeZonePacificNauru SystemSettingsTimeZone = "Pacific/Nauru"

	SystemSettingsTimeZonePacificNiue SystemSettingsTimeZone = "Pacific/Niue"

	SystemSettingsTimeZonePacificNorfolk SystemSettingsTimeZone = "Pacific/Norfolk"

	SystemSettingsTimeZonePacificNoumea SystemSettingsTimeZone = "Pacific/Noumea"

	SystemSettingsTimeZonePacificPagoPago SystemSettingsTimeZone = "Pacific/Pago_Pago"

	SystemSettingsTimeZonePacificPalau SystemSettingsTimeZone = "Pacific/Palau"

	SystemSettingsTimeZonePacificPitcairn SystemSettingsTimeZone = "Pacific/Pitcairn"

	SystemSettingsTimeZonePacificPohnpei SystemSettingsTimeZone = "Pacific/Pohnpei"

	SystemSettingsTimeZonePacificPonape SystemSettingsTimeZone = "Pacific/Ponape"

	SystemSettingsTimeZonePacificPortMoresby SystemSettingsTimeZone = "Pacific/Port_Moresby"

	SystemSettingsTimeZonePacificRarotonga SystemSettingsTimeZone = "Pacific/Rarotonga"

	SystemSettingsTimeZonePacificSaipan SystemSettingsTimeZone = "Pacific/Saipan"

	SystemSettingsTimeZonePacificSamoa SystemSettingsTimeZone = "Pacific/Samoa"

	SystemSettingsTimeZonePacificTahiti SystemSettingsTimeZone = "Pacific/Tahiti"

	SystemSettingsTimeZonePacificTarawa SystemSettingsTimeZone = "Pacific/Tarawa"

	SystemSettingsTimeZonePacificTongatapu SystemSettingsTimeZone = "Pacific/Tongatapu"

	SystemSettingsTimeZonePacificTruk SystemSettingsTimeZone = "Pacific/Truk"

	SystemSettingsTimeZonePacificWake SystemSettingsTimeZone = "Pacific/Wake"

	SystemSettingsTimeZonePacificWallis SystemSettingsTimeZone = "Pacific/Wallis"

	SystemSettingsTimeZonePacificYap SystemSettingsTimeZone = "Pacific/Yap"

	SystemSettingsTimeZonePoland SystemSettingsTimeZone = "Poland"

	SystemSettingsTimeZonePortugal SystemSettingsTimeZone = "Portugal"

	SystemSettingsTimeZoneROC SystemSettingsTimeZone = "ROC"

	SystemSettingsTimeZoneROK SystemSettingsTimeZone = "ROK"

	SystemSettingsTimeZoneSingapore SystemSettingsTimeZone = "Singapore"

	SystemSettingsTimeZoneTurkey SystemSettingsTimeZone = "Turkey"

	SystemSettingsTimeZoneUCT SystemSettingsTimeZone = "UCT"

	SystemSettingsTimeZoneUSAlaska SystemSettingsTimeZone = "US/Alaska"

	SystemSettingsTimeZoneUSAleutian SystemSettingsTimeZone = "US/Aleutian"

	SystemSettingsTimeZoneUSArizona SystemSettingsTimeZone = "US/Arizona"

	SystemSettingsTimeZoneUSCentral SystemSettingsTimeZone = "US/Central"

	SystemSettingsTimeZoneUSEastIndiana SystemSettingsTimeZone = "US/East-Indiana"

	SystemSettingsTimeZoneUSEastern SystemSettingsTimeZone = "US/Eastern"

	SystemSettingsTimeZoneUSHawaii SystemSettingsTimeZone = "US/Hawaii"

	SystemSettingsTimeZoneUSIndianaStarke SystemSettingsTimeZone = "US/Indiana-Starke"

	SystemSettingsTimeZoneUSMichigan SystemSettingsTimeZone = "US/Michigan"

	SystemSettingsTimeZoneUSMountain SystemSettingsTimeZone = "US/Mountain"

	SystemSettingsTimeZoneUSPacific SystemSettingsTimeZone = "US/Pacific"

	SystemSettingsTimeZoneUSSamoa SystemSettingsTimeZone = "US/Samoa"

	SystemSettingsTimeZoneUTC SystemSettingsTimeZone = "UTC"

	SystemSettingsTimeZoneUniversal SystemSettingsTimeZone = "Universal"

	SystemSettingsTimeZoneWET SystemSettingsTimeZone = "WET"

	SystemSettingsTimeZoneWSU SystemSettingsTimeZone = "W-SU"

	SystemSettingsTimeZoneZulu SystemSettingsTimeZone = "Zulu"
)

// Defines values for SystemSettingsRequestJiraMinimumSeverity.
const (
	SystemSettingsRequestJiraMinimumSeverityCritical SystemSettingsRequestJiraMinimumSeverity = "Critical"

	SystemSettingsRequestJiraMinimumSeverityEmpty SystemSettingsRequestJiraMinimumSeverity = ""

	SystemSettingsRequestJiraMinimumSeverityHigh SystemSettingsRequestJiraMinimumSeverity = "High"

	SystemSettingsRequestJiraMinimumSeverityInfo SystemSettingsRequestJiraMinimumSeverity = "Info"

	SystemSettingsRequestJiraMinimumSeverityLow SystemSettingsRequestJiraMinimumSeverity = "Low"

	SystemSettingsRequestJiraMinimumSeverityMedium SystemSettingsRequestJiraMinimumSeverity = "Medium"

	SystemSettingsRequestJiraMinimumSeverityNil SystemSettingsRequestJiraMinimumSeverity = "<nil>"
)

// Defines values for SystemSettingsRequestTimeZone.
const (
	SystemSettingsRequestTimeZoneAfricaAbidjan SystemSettingsRequestTimeZone = "Africa/Abidjan"

	SystemSettingsRequestTimeZoneAfricaAccra SystemSettingsRequestTimeZone = "Africa/Accra"

	SystemSettingsRequestTimeZoneAfricaAddisAbaba SystemSettingsRequestTimeZone = "Africa/Addis_Ababa"

	SystemSettingsRequestTimeZoneAfricaAlgiers SystemSettingsRequestTimeZone = "Africa/Algiers"

	SystemSettingsRequestTimeZoneAfricaAsmara SystemSettingsRequestTimeZone = "Africa/Asmara"

	SystemSettingsRequestTimeZoneAfricaAsmera SystemSettingsRequestTimeZone = "Africa/Asmera"

	SystemSettingsRequestTimeZoneAfricaBamako SystemSettingsRequestTimeZone = "Africa/Bamako"

	SystemSettingsRequestTimeZoneAfricaBangui SystemSettingsRequestTimeZone = "Africa/Bangui"

	SystemSettingsRequestTimeZoneAfricaBanjul SystemSettingsRequestTimeZone = "Africa/Banjul"

	SystemSettingsRequestTimeZoneAfricaBissau SystemSettingsRequestTimeZone = "Africa/Bissau"

	SystemSettingsRequestTimeZoneAfricaBlantyre SystemSettingsRequestTimeZone = "Africa/Blantyre"

	SystemSettingsRequestTimeZoneAfricaBrazzaville SystemSettingsRequestTimeZone = "Africa/Brazzaville"

	SystemSettingsRequestTimeZoneAfricaBujumbura SystemSettingsRequestTimeZone = "Africa/Bujumbura"

	SystemSettingsRequestTimeZoneAfricaCairo SystemSettingsRequestTimeZone = "Africa/Cairo"

	SystemSettingsRequestTimeZoneAfricaCasablanca SystemSettingsRequestTimeZone = "Africa/Casablanca"

	SystemSettingsRequestTimeZoneAfricaCeuta SystemSettingsRequestTimeZone = "Africa/Ceuta"

	SystemSettingsRequestTimeZoneAfricaConakry SystemSettingsRequestTimeZone = "Africa/Conakry"

	SystemSettingsRequestTimeZoneAfricaDakar SystemSettingsRequestTimeZone = "Africa/Dakar"

	SystemSettingsRequestTimeZoneAfricaDarEsSalaam SystemSettingsRequestTimeZone = "Africa/Dar_es_Salaam"

	SystemSettingsRequestTimeZoneAfricaDjibouti SystemSettingsRequestTimeZone = "Africa/Djibouti"

	SystemSettingsRequestTimeZoneAfricaDouala SystemSettingsRequestTimeZone = "Africa/Douala"

	SystemSettingsRequestTimeZoneAfricaElAaiun SystemSettingsRequestTimeZone = "Africa/El_Aaiun"

	SystemSettingsRequestTimeZoneAfricaFreetown SystemSettingsRequestTimeZone = "Africa/Freetown"

	SystemSettingsRequestTimeZoneAfricaGaborone SystemSettingsRequestTimeZone = "Africa/Gaborone"

	SystemSettingsRequestTimeZoneAfricaHarare SystemSettingsRequestTimeZone = "Africa/Harare"

	SystemSettingsRequestTimeZoneAfricaJohannesburg SystemSettingsRequestTimeZone = "Africa/Johannesburg"

	SystemSettingsRequestTimeZoneAfricaJuba SystemSettingsRequestTimeZone = "Africa/Juba"

	SystemSettingsRequestTimeZoneAfricaKampala SystemSettingsRequestTimeZone = "Africa/Kampala"

	SystemSettingsRequestTimeZoneAfricaKhartoum SystemSettingsRequestTimeZone = "Africa/Khartoum"

	SystemSettingsRequestTimeZoneAfricaKigali SystemSettingsRequestTimeZone = "Africa/Kigali"

	SystemSettingsRequestTimeZoneAfricaKinshasa SystemSettingsRequestTimeZone = "Africa/Kinshasa"

	SystemSettingsRequestTimeZoneAfricaLagos SystemSettingsRequestTimeZone = "Africa/Lagos"

	SystemSettingsRequestTimeZoneAfricaLibreville SystemSettingsRequestTimeZone = "Africa/Libreville"

	SystemSettingsRequestTimeZoneAfricaLome SystemSettingsRequestTimeZone = "Africa/Lome"

	SystemSettingsRequestTimeZoneAfricaLuanda SystemSettingsRequestTimeZone = "Africa/Luanda"

	SystemSettingsRequestTimeZoneAfricaLubumbashi SystemSettingsRequestTimeZone = "Africa/Lubumbashi"

	SystemSettingsRequestTimeZoneAfricaLusaka SystemSettingsRequestTimeZone = "Africa/Lusaka"

	SystemSettingsRequestTimeZoneAfricaMalabo SystemSettingsRequestTimeZone = "Africa/Malabo"

	SystemSettingsRequestTimeZoneAfricaMaputo SystemSettingsRequestTimeZone = "Africa/Maputo"

	SystemSettingsRequestTimeZoneAfricaMaseru SystemSettingsRequestTimeZone = "Africa/Maseru"

	SystemSettingsRequestTimeZoneAfricaMbabane SystemSettingsRequestTimeZone = "Africa/Mbabane"

	SystemSettingsRequestTimeZoneAfricaMogadishu SystemSettingsRequestTimeZone = "Africa/Mogadishu"

	SystemSettingsRequestTimeZoneAfricaMonrovia SystemSettingsRequestTimeZone = "Africa/Monrovia"

	SystemSettingsRequestTimeZoneAfricaNairobi SystemSettingsRequestTimeZone = "Africa/Nairobi"

	SystemSettingsRequestTimeZoneAfricaNdjamena SystemSettingsRequestTimeZone = "Africa/Ndjamena"

	SystemSettingsRequestTimeZoneAfricaNiamey SystemSettingsRequestTimeZone = "Africa/Niamey"

	SystemSettingsRequestTimeZoneAfricaNouakchott SystemSettingsRequestTimeZone = "Africa/Nouakchott"

	SystemSettingsRequestTimeZoneAfricaOuagadougou SystemSettingsRequestTimeZone = "Africa/Ouagadougou"

	SystemSettingsRequestTimeZoneAfricaPortoNovo SystemSettingsRequestTimeZone = "Africa/Porto-Novo"

	SystemSettingsRequestTimeZoneAfricaSaoTome SystemSettingsRequestTimeZone = "Africa/Sao_Tome"

	SystemSettingsRequestTimeZoneAfricaTimbuktu SystemSettingsRequestTimeZone = "Africa/Timbuktu"

	SystemSettingsRequestTimeZoneAfricaTripoli SystemSettingsRequestTimeZone = "Africa/Tripoli"

	SystemSettingsRequestTimeZoneAfricaTunis SystemSettingsRequestTimeZone = "Africa/Tunis"

	SystemSettingsRequestTimeZoneAfricaWindhoek SystemSettingsRequestTimeZone = "Africa/Windhoek"

	SystemSettingsRequestTimeZoneAmericaAdak SystemSettingsRequestTimeZone = "America/Adak"

	SystemSettingsRequestTimeZoneAmericaAnchorage SystemSettingsRequestTimeZone = "America/Anchorage"

	SystemSettingsRequestTimeZoneAmericaAnguilla SystemSettingsRequestTimeZone = "America/Anguilla"

	SystemSettingsRequestTimeZoneAmericaAntigua SystemSettingsRequestTimeZone = "America/Antigua"

	SystemSettingsRequestTimeZoneAmericaAraguaina SystemSettingsRequestTimeZone = "America/Araguaina"

	SystemSettingsRequestTimeZoneAmericaArgentinaBuenosAires SystemSettingsRequestTimeZone = "America/Argentina/Buenos_Aires"

	SystemSettingsRequestTimeZoneAmericaArgentinaCatamarca SystemSettingsRequestTimeZone = "America/Argentina/Catamarca"

	SystemSettingsRequestTimeZoneAmericaArgentinaComodRivadavia SystemSettingsRequestTimeZone = "America/Argentina/ComodRivadavia"

	SystemSettingsRequestTimeZoneAmericaArgentinaCordoba SystemSettingsRequestTimeZone = "America/Argentina/Cordoba"

	SystemSettingsRequestTimeZoneAmericaArgentinaJujuy SystemSettingsRequestTimeZone = "America/Argentina/Jujuy"

	SystemSettingsRequestTimeZoneAmericaArgentinaLaRioja SystemSettingsRequestTimeZone = "America/Argentina/La_Rioja"

	SystemSettingsRequestTimeZoneAmericaArgentinaMendoza SystemSettingsRequestTimeZone = "America/Argentina/Mendoza"

	SystemSettingsRequestTimeZoneAmericaArgentinaRioGallegos SystemSettingsRequestTimeZone = "America/Argentina/Rio_Gallegos"

	SystemSettingsRequestTimeZoneAmericaArgentinaSalta SystemSettingsRequestTimeZone = "America/Argentina/Salta"

	SystemSettingsRequestTimeZoneAmericaArgentinaSanJuan SystemSettingsRequestTimeZone = "America/Argentina/San_Juan"

	SystemSettingsRequestTimeZoneAmericaArgentinaSanLuis SystemSettingsRequestTimeZone = "America/Argentina/San_Luis"

	SystemSettingsRequestTimeZoneAmericaArgentinaTucuman SystemSettingsRequestTimeZone = "America/Argentina/Tucuman"

	SystemSettingsRequestTimeZoneAmericaArgentinaUshuaia SystemSettingsRequestTimeZone = "America/Argentina/Ushuaia"

	SystemSettingsRequestTimeZoneAmericaAruba SystemSettingsRequestTimeZone = "America/Aruba"

	SystemSettingsRequestTimeZoneAmericaAsuncion SystemSettingsRequestTimeZone = "America/Asuncion"

	SystemSettingsRequestTimeZoneAmericaAtikokan SystemSettingsRequestTimeZone = "America/Atikokan"

	SystemSettingsRequestTimeZoneAmericaAtka SystemSettingsRequestTimeZone = "America/Atka"

	SystemSettingsRequestTimeZoneAmericaBahia SystemSettingsRequestTimeZone = "America/Bahia"

	SystemSettingsRequestTimeZoneAmericaBahiaBanderas SystemSettingsRequestTimeZone = "America/Bahia_Banderas"

	SystemSettingsRequestTimeZoneAmericaBarbados SystemSettingsRequestTimeZone = "America/Barbados"

	SystemSettingsRequestTimeZoneAmericaBelem SystemSettingsRequestTimeZone = "America/Belem"

	SystemSettingsRequestTimeZoneAmericaBelize SystemSettingsRequestTimeZone = "America/Belize"

	SystemSettingsRequestTimeZoneAmericaBlancSablon SystemSettingsRequestTimeZone = "America/Blanc-Sablon"

	SystemSettingsRequestTimeZoneAmericaBoaVista SystemSettingsRequestTimeZone = "America/Boa_Vista"

	SystemSettingsRequestTimeZoneAmericaBogota SystemSettingsRequestTimeZone = "America/Bogota"

	SystemSettingsRequestTimeZoneAmericaBoise SystemSettingsRequestTimeZone = "America/Boise"

	SystemSettingsRequestTimeZoneAmericaBuenosAires SystemSettingsRequestTimeZone = "America/Buenos_Aires"

	SystemSettingsRequestTimeZoneAmericaCambridgeBay SystemSettingsRequestTimeZone = "America/Cambridge_Bay"

	SystemSettingsRequestTimeZoneAmericaCampoGrande SystemSettingsRequestTimeZone = "America/Campo_Grande"

	SystemSettingsRequestTimeZoneAmericaCancun SystemSettingsRequestTimeZone = "America/Cancun"

	SystemSettingsRequestTimeZoneAmericaCaracas SystemSettingsRequestTimeZone = "America/Caracas"

	SystemSettingsRequestTimeZoneAmericaCatamarca SystemSettingsRequestTimeZone = "America/Catamarca"

	SystemSettingsRequestTimeZoneAmericaCayenne SystemSettingsRequestTimeZone = "America/Cayenne"

	SystemSettingsRequestTimeZoneAmericaCayman SystemSettingsRequestTimeZone = "America/Cayman"

	SystemSettingsRequestTimeZoneAmericaChicago SystemSettingsRequestTimeZone = "America/Chicago"

	SystemSettingsRequestTimeZoneAmericaChihuahua SystemSettingsRequestTimeZone = "America/Chihuahua"

	SystemSettingsRequestTimeZoneAmericaCoralHarbour SystemSettingsRequestTimeZone = "America/Coral_Harbour"

	SystemSettingsRequestTimeZoneAmericaCordoba SystemSettingsRequestTimeZone = "America/Cordoba"

	SystemSettingsRequestTimeZoneAmericaCostaRica SystemSettingsRequestTimeZone = "America/Costa_Rica"

	SystemSettingsRequestTimeZoneAmericaCreston SystemSettingsRequestTimeZone = "America/Creston"

	SystemSettingsRequestTimeZoneAmericaCuiaba SystemSettingsRequestTimeZone = "America/Cuiaba"

	SystemSettingsRequestTimeZoneAmericaCuracao SystemSettingsRequestTimeZone = "America/Curacao"

	SystemSettingsRequestTimeZoneAmericaDanmarkshavn SystemSettingsRequestTimeZone = "America/Danmarkshavn"

	SystemSettingsRequestTimeZoneAmericaDawson SystemSettingsRequestTimeZone = "America/Dawson"

	SystemSettingsRequestTimeZoneAmericaDawsonCreek SystemSettingsRequestTimeZone = "America/Dawson_Creek"

	SystemSettingsRequestTimeZoneAmericaDenver SystemSettingsRequestTimeZone = "America/Denver"

	SystemSettingsRequestTimeZoneAmericaDetroit SystemSettingsRequestTimeZone = "America/Detroit"

	SystemSettingsRequestTimeZoneAmericaDominica SystemSettingsRequestTimeZone = "America/Dominica"

	SystemSettingsRequestTimeZoneAmericaEdmonton SystemSettingsRequestTimeZone = "America/Edmonton"

	SystemSettingsRequestTimeZoneAmericaEirunepe SystemSettingsRequestTimeZone = "America/Eirunepe"

	SystemSettingsRequestTimeZoneAmericaElSalvador SystemSettingsRequestTimeZone = "America/El_Salvador"

	SystemSettingsRequestTimeZoneAmericaEnsenada SystemSettingsRequestTimeZone = "America/Ensenada"

	SystemSettingsRequestTimeZoneAmericaFortNelson SystemSettingsRequestTimeZone = "America/Fort_Nelson"

	SystemSettingsRequestTimeZoneAmericaFortWayne SystemSettingsRequestTimeZone = "America/Fort_Wayne"

	SystemSettingsRequestTimeZoneAmericaFortaleza SystemSettingsRequestTimeZone = "America/Fortaleza"

	SystemSettingsRequestTimeZoneAmericaGlaceBay SystemSettingsRequestTimeZone = "America/Glace_Bay"

	SystemSettingsRequestTimeZoneAmericaGodthab SystemSettingsRequestTimeZone = "America/Godthab"

	SystemSettingsRequestTimeZoneAmericaGooseBay SystemSettingsRequestTimeZone = "America/Goose_Bay"

	SystemSettingsRequestTimeZoneAmericaGrandTurk SystemSettingsRequestTimeZone = "America/Grand_Turk"

	SystemSettingsRequestTimeZoneAmericaGrenada SystemSettingsRequestTimeZone = "America/Grenada"

	SystemSettingsRequestTimeZoneAmericaGuadeloupe SystemSettingsRequestTimeZone = "America/Guadeloupe"

	SystemSettingsRequestTimeZoneAmericaGuatemala SystemSettingsRequestTimeZone = "America/Guatemala"

	SystemSettingsRequestTimeZoneAmericaGuayaquil SystemSettingsRequestTimeZone = "America/Guayaquil"

	SystemSettingsRequestTimeZoneAmericaGuyana SystemSettingsRequestTimeZone = "America/Guyana"

	SystemSettingsRequestTimeZoneAmericaHalifax SystemSettingsRequestTimeZone = "America/Halifax"

	SystemSettingsRequestTimeZoneAmericaHavana SystemSettingsRequestTimeZone = "America/Havana"

	SystemSettingsRequestTimeZoneAmericaHermosillo SystemSettingsRequestTimeZone = "America/Hermosillo"

	SystemSettingsRequestTimeZoneAmericaIndianaIndianapolis SystemSettingsRequestTimeZone = "America/Indiana/Indianapolis"

	SystemSettingsRequestTimeZoneAmericaIndianaKnox SystemSettingsRequestTimeZone = "America/Indiana/Knox"

	SystemSettingsRequestTimeZoneAmericaIndianaMarengo SystemSettingsRequestTimeZone = "America/Indiana/Marengo"

	SystemSettingsRequestTimeZoneAmericaIndianaPetersburg SystemSettingsRequestTimeZone = "America/Indiana/Petersburg"

	SystemSettingsRequestTimeZoneAmericaIndianaTellCity SystemSettingsRequestTimeZone = "America/Indiana/Tell_City"

	SystemSettingsRequestTimeZoneAmericaIndianaVevay SystemSettingsRequestTimeZone = "America/Indiana/Vevay"

	SystemSettingsRequestTimeZoneAmericaIndianaVincennes SystemSettingsRequestTimeZone = "America/Indiana/Vincennes"

	SystemSettingsRequestTimeZoneAmericaIndianaWinamac SystemSettingsRequestTimeZone = "America/Indiana/Winamac"

	SystemSettingsRequestTimeZoneAmericaIndianapolis SystemSettingsRequestTimeZone = "America/Indianapolis"

	SystemSettingsRequestTimeZoneAmericaInuvik SystemSettingsRequestTimeZone = "America/Inuvik"

	SystemSettingsRequestTimeZoneAmericaIqaluit SystemSettingsRequestTimeZone = "America/Iqaluit"

	SystemSettingsRequestTimeZoneAmericaJamaica SystemSettingsRequestTimeZone = "America/Jamaica"

	SystemSettingsRequestTimeZoneAmericaJujuy SystemSettingsRequestTimeZone = "America/Jujuy"

	SystemSettingsRequestTimeZoneAmericaJuneau SystemSettingsRequestTimeZone = "America/Juneau"

	SystemSettingsRequestTimeZoneAmericaKentuckyLouisville SystemSettingsRequestTimeZone = "America/Kentucky/Louisville"

	SystemSettingsRequestTimeZoneAmericaKentuckyMonticello SystemSettingsRequestTimeZone = "America/Kentucky/Monticello"

	SystemSettingsRequestTimeZoneAmericaKnoxIN SystemSettingsRequestTimeZone = "America/Knox_IN"

	SystemSettingsRequestTimeZoneAmericaKralendijk SystemSettingsRequestTimeZone = "America/Kralendijk"

	SystemSettingsRequestTimeZoneAmericaLaPaz SystemSettingsRequestTimeZone = "America/La_Paz"

	SystemSettingsRequestTimeZoneAmericaLima SystemSettingsRequestTimeZone = "America/Lima"

	SystemSettingsRequestTimeZoneAmericaLosAngeles SystemSettingsRequestTimeZone = "America/Los_Angeles"

	SystemSettingsRequestTimeZoneAmericaLouisville SystemSettingsRequestTimeZone = "America/Louisville"

	SystemSettingsRequestTimeZoneAmericaLowerPrinces SystemSettingsRequestTimeZone = "America/Lower_Princes"

	SystemSettingsRequestTimeZoneAmericaMaceio SystemSettingsRequestTimeZone = "America/Maceio"

	SystemSettingsRequestTimeZoneAmericaManagua SystemSettingsRequestTimeZone = "America/Managua"

	SystemSettingsRequestTimeZoneAmericaManaus SystemSettingsRequestTimeZone = "America/Manaus"

	SystemSettingsRequestTimeZoneAmericaMarigot SystemSettingsRequestTimeZone = "America/Marigot"

	SystemSettingsRequestTimeZoneAmericaMartinique SystemSettingsRequestTimeZone = "America/Martinique"

	SystemSettingsRequestTimeZoneAmericaMatamoros SystemSettingsRequestTimeZone = "America/Matamoros"

	SystemSettingsRequestTimeZoneAmericaMazatlan SystemSettingsRequestTimeZone = "America/Mazatlan"

	SystemSettingsRequestTimeZoneAmericaMendoza SystemSettingsRequestTimeZone = "America/Mendoza"

	SystemSettingsRequestTimeZoneAmericaMenominee SystemSettingsRequestTimeZone = "America/Menominee"

	SystemSettingsRequestTimeZoneAmericaMerida SystemSettingsRequestTimeZone = "America/Merida"

	SystemSettingsRequestTimeZoneAmericaMetlakatla SystemSettingsRequestTimeZone = "America/Metlakatla"

	SystemSettingsRequestTimeZoneAmericaMexicoCity SystemSettingsRequestTimeZone = "America/Mexico_City"

	SystemSettingsRequestTimeZoneAmericaMiquelon SystemSettingsRequestTimeZone = "America/Miquelon"

	SystemSettingsRequestTimeZoneAmericaMoncton SystemSettingsRequestTimeZone = "America/Moncton"

	SystemSettingsRequestTimeZoneAmericaMonterrey SystemSettingsRequestTimeZone = "America/Monterrey"

	SystemSettingsRequestTimeZoneAmericaMontevideo SystemSettingsRequestTimeZone = "America/Montevideo"

	SystemSettingsRequestTimeZoneAmericaMontreal SystemSettingsRequestTimeZone = "America/Montreal"

	SystemSettingsRequestTimeZoneAmericaMontserrat SystemSettingsRequestTimeZone = "America/Montserrat"

	SystemSettingsRequestTimeZoneAmericaNassau SystemSettingsRequestTimeZone = "America/Nassau"

	SystemSettingsRequestTimeZoneAmericaNewYork SystemSettingsRequestTimeZone = "America/New_York"

	SystemSettingsRequestTimeZoneAmericaNipigon SystemSettingsRequestTimeZone = "America/Nipigon"

	SystemSettingsRequestTimeZoneAmericaNome SystemSettingsRequestTimeZone = "America/Nome"

	SystemSettingsRequestTimeZoneAmericaNoronha SystemSettingsRequestTimeZone = "America/Noronha"

	SystemSettingsRequestTimeZoneAmericaNorthDakotaBeulah SystemSettingsRequestTimeZone = "America/North_Dakota/Beulah"

	SystemSettingsRequestTimeZoneAmericaNorthDakotaCenter SystemSettingsRequestTimeZone = "America/North_Dakota/Center"

	SystemSettingsRequestTimeZoneAmericaNorthDakotaNewSalem SystemSettingsRequestTimeZone = "America/North_Dakota/New_Salem"

	SystemSettingsRequestTimeZoneAmericaNuuk SystemSettingsRequestTimeZone = "America/Nuuk"

	SystemSettingsRequestTimeZoneAmericaOjinaga SystemSettingsRequestTimeZone = "America/Ojinaga"

	SystemSettingsRequestTimeZoneAmericaPanama SystemSettingsRequestTimeZone = "America/Panama"

	SystemSettingsRequestTimeZoneAmericaPangnirtung SystemSettingsRequestTimeZone = "America/Pangnirtung"

	SystemSettingsRequestTimeZoneAmericaParamaribo SystemSettingsRequestTimeZone = "America/Paramaribo"

	SystemSettingsRequestTimeZoneAmericaPhoenix SystemSettingsRequestTimeZone = "America/Phoenix"

	SystemSettingsRequestTimeZoneAmericaPortAuPrince SystemSettingsRequestTimeZone = "America/Port-au-Prince"

	SystemSettingsRequestTimeZoneAmericaPortOfSpain SystemSettingsRequestTimeZone = "America/Port_of_Spain"

	SystemSettingsRequestTimeZoneAmericaPortoAcre SystemSettingsRequestTimeZone = "America/Porto_Acre"

	SystemSettingsRequestTimeZoneAmericaPortoVelho SystemSettingsRequestTimeZone = "America/Porto_Velho"

	SystemSettingsRequestTimeZoneAmericaPuertoRico SystemSettingsRequestTimeZone = "America/Puerto_Rico"

	SystemSettingsRequestTimeZoneAmericaPuntaArenas SystemSettingsRequestTimeZone = "America/Punta_Arenas"

	SystemSettingsRequestTimeZoneAmericaRainyRiver SystemSettingsRequestTimeZone = "America/Rainy_River"

	SystemSettingsRequestTimeZoneAmericaRankinInlet SystemSettingsRequestTimeZone = "America/Rankin_Inlet"

	SystemSettingsRequestTimeZoneAmericaRecife SystemSettingsRequestTimeZone = "America/Recife"

	SystemSettingsRequestTimeZoneAmericaRegina SystemSettingsRequestTimeZone = "America/Regina"

	SystemSettingsRequestTimeZoneAmericaResolute SystemSettingsRequestTimeZone = "America/Resolute"

	SystemSettingsRequestTimeZoneAmericaRioBranco SystemSettingsRequestTimeZone = "America/Rio_Branco"

	SystemSettingsRequestTimeZoneAmericaRosario SystemSettingsRequestTimeZone = "America/Rosario"

	SystemSettingsRequestTimeZoneAmericaSantaIsabel SystemSettingsRequestTimeZone = "America/Santa_Isabel"

	SystemSettingsRequestTimeZoneAmericaSantarem SystemSettingsRequestTimeZone = "America/Santarem"

	SystemSettingsRequestTimeZoneAmericaSantiago SystemSettingsRequestTimeZone = "America/Santiago"

	SystemSettingsRequestTimeZoneAmericaSantoDomingo SystemSettingsRequestTimeZone = "America/Santo_Domingo"

	SystemSettingsRequestTimeZoneAmericaSaoPaulo SystemSettingsRequestTimeZone = "America/Sao_Paulo"

	SystemSettingsRequestTimeZoneAmericaScoresbysund SystemSettingsRequestTimeZone = "America/Scoresbysund"

	SystemSettingsRequestTimeZoneAmericaShiprock SystemSettingsRequestTimeZone = "America/Shiprock"

	SystemSettingsRequestTimeZoneAmericaSitka SystemSettingsRequestTimeZone = "America/Sitka"

	SystemSettingsRequestTimeZoneAmericaStBarthelemy SystemSettingsRequestTimeZone = "America/St_Barthelemy"

	SystemSettingsRequestTimeZoneAmericaStJohns SystemSettingsRequestTimeZone = "America/St_Johns"

	SystemSettingsRequestTimeZoneAmericaStKitts SystemSettingsRequestTimeZone = "America/St_Kitts"

	SystemSettingsRequestTimeZoneAmericaStLucia SystemSettingsRequestTimeZone = "America/St_Lucia"

	SystemSettingsRequestTimeZoneAmericaStThomas SystemSettingsRequestTimeZone = "America/St_Thomas"

	SystemSettingsRequestTimeZoneAmericaStVincent SystemSettingsRequestTimeZone = "America/St_Vincent"

	SystemSettingsRequestTimeZoneAmericaSwiftCurrent SystemSettingsRequestTimeZone = "America/Swift_Current"

	SystemSettingsRequestTimeZoneAmericaTegucigalpa SystemSettingsRequestTimeZone = "America/Tegucigalpa"

	SystemSettingsRequestTimeZoneAmericaThule SystemSettingsRequestTimeZone = "America/Thule"

	SystemSettingsRequestTimeZoneAmericaThunderBay SystemSettingsRequestTimeZone = "America/Thunder_Bay"

	SystemSettingsRequestTimeZoneAmericaTijuana SystemSettingsRequestTimeZone = "America/Tijuana"

	SystemSettingsRequestTimeZoneAmericaToronto SystemSettingsRequestTimeZone = "America/Toronto"

	SystemSettingsRequestTimeZoneAmericaTortola SystemSettingsRequestTimeZone = "America/Tortola"

	SystemSettingsRequestTimeZoneAmericaVancouver SystemSettingsRequestTimeZone = "America/Vancouver"

	SystemSettingsRequestTimeZoneAmericaVirgin SystemSettingsRequestTimeZone = "America/Virgin"

	SystemSettingsRequestTimeZoneAmericaWhitehorse SystemSettingsRequestTimeZone = "America/Whitehorse"

	SystemSettingsRequestTimeZoneAmericaWinnipeg SystemSettingsRequestTimeZone = "America/Winnipeg"

	SystemSettingsRequestTimeZoneAmericaYakutat SystemSettingsRequestTimeZone = "America/Yakutat"

	SystemSettingsRequestTimeZoneAmericaYellowknife SystemSettingsRequestTimeZone = "America/Yellowknife"

	SystemSettingsRequestTimeZoneAntarcticaCasey SystemSettingsRequestTimeZone = "Antarctica/Casey"

	SystemSettingsRequestTimeZoneAntarcticaDavis SystemSettingsRequestTimeZone = "Antarctica/Davis"

	SystemSettingsRequestTimeZoneAntarcticaDumontDUrville SystemSettingsRequestTimeZone = "Antarctica/DumontDUrville"

	SystemSettingsRequestTimeZoneAntarcticaMacquarie SystemSettingsRequestTimeZone = "Antarctica/Macquarie"

	SystemSettingsRequestTimeZoneAntarcticaMawson SystemSettingsRequestTimeZone = "Antarctica/Mawson"

	SystemSettingsRequestTimeZoneAntarcticaMcMurdo SystemSettingsRequestTimeZone = "Antarctica/McMurdo"

	SystemSettingsRequestTimeZoneAntarcticaPalmer SystemSettingsRequestTimeZone = "Antarctica/Palmer"

	SystemSettingsRequestTimeZoneAntarcticaRothera SystemSettingsRequestTimeZone = "Antarctica/Rothera"

	SystemSettingsRequestTimeZoneAntarcticaSouthPole SystemSettingsRequestTimeZone = "Antarctica/South_Pole"

	SystemSettingsRequestTimeZoneAntarcticaSyowa SystemSettingsRequestTimeZone = "Antarctica/Syowa"

	SystemSettingsRequestTimeZoneAntarcticaTroll SystemSettingsRequestTimeZone = "Antarctica/Troll"

	SystemSettingsRequestTimeZoneAntarcticaVostok SystemSettingsRequestTimeZone = "Antarctica/Vostok"

	SystemSettingsRequestTimeZoneArcticLongyearbyen SystemSettingsRequestTimeZone = "Arctic/Longyearbyen"

	SystemSettingsRequestTimeZoneAsiaAden SystemSettingsRequestTimeZone = "Asia/Aden"

	SystemSettingsRequestTimeZoneAsiaAlmaty SystemSettingsRequestTimeZone = "Asia/Almaty"

	SystemSettingsRequestTimeZoneAsiaAmman SystemSettingsRequestTimeZone = "Asia/Amman"

	SystemSettingsRequestTimeZoneAsiaAnadyr SystemSettingsRequestTimeZone = "Asia/Anadyr"

	SystemSettingsRequestTimeZoneAsiaAqtau SystemSettingsRequestTimeZone = "Asia/Aqtau"

	SystemSettingsRequestTimeZoneAsiaAqtobe SystemSettingsRequestTimeZone = "Asia/Aqtobe"

	SystemSettingsRequestTimeZoneAsiaAshgabat SystemSettingsRequestTimeZone = "Asia/Ashgabat"

	SystemSettingsRequestTimeZoneAsiaAshkhabad SystemSettingsRequestTimeZone = "Asia/Ashkhabad"

	SystemSettingsRequestTimeZoneAsiaAtyrau SystemSettingsRequestTimeZone = "Asia/Atyrau"

	SystemSettingsRequestTimeZoneAsiaBaghdad SystemSettingsRequestTimeZone = "Asia/Baghdad"

	SystemSettingsRequestTimeZoneAsiaBahrain SystemSettingsRequestTimeZone = "Asia/Bahrain"

	SystemSettingsRequestTimeZoneAsiaBaku SystemSettingsRequestTimeZone = "Asia/Baku"

	SystemSettingsRequestTimeZoneAsiaBangkok SystemSettingsRequestTimeZone = "Asia/Bangkok"

	SystemSettingsRequestTimeZoneAsiaBarnaul SystemSettingsRequestTimeZone = "Asia/Barnaul"

	SystemSettingsRequestTimeZoneAsiaBeirut SystemSettingsRequestTimeZone = "Asia/Beirut"

	SystemSettingsRequestTimeZoneAsiaBishkek SystemSettingsRequestTimeZone = "Asia/Bishkek"

	SystemSettingsRequestTimeZoneAsiaBrunei SystemSettingsRequestTimeZone = "Asia/Brunei"

	SystemSettingsRequestTimeZoneAsiaCalcutta SystemSettingsRequestTimeZone = "Asia/Calcutta"

	SystemSettingsRequestTimeZoneAsiaChita SystemSettingsRequestTimeZone = "Asia/Chita"

	SystemSettingsRequestTimeZoneAsiaChoibalsan SystemSettingsRequestTimeZone = "Asia/Choibalsan"

	SystemSettingsRequestTimeZoneAsiaChongqing SystemSettingsRequestTimeZone = "Asia/Chongqing"

	SystemSettingsRequestTimeZoneAsiaChungking SystemSettingsRequestTimeZone = "Asia/Chungking"

	SystemSettingsRequestTimeZoneAsiaColombo SystemSettingsRequestTimeZone = "Asia/Colombo"

	SystemSettingsRequestTimeZoneAsiaDacca SystemSettingsRequestTimeZone = "Asia/Dacca"

	SystemSettingsRequestTimeZoneAsiaDamascus SystemSettingsRequestTimeZone = "Asia/Damascus"

	SystemSettingsRequestTimeZoneAsiaDhaka SystemSettingsRequestTimeZone = "Asia/Dhaka"

	SystemSettingsRequestTimeZoneAsiaDili SystemSettingsRequestTimeZone = "Asia/Dili"

	SystemSettingsRequestTimeZoneAsiaDubai SystemSettingsRequestTimeZone = "Asia/Dubai"

	SystemSettingsRequestTimeZoneAsiaDushanbe SystemSettingsRequestTimeZone = "Asia/Dushanbe"

	SystemSettingsRequestTimeZoneAsiaFamagusta SystemSettingsRequestTimeZone = "Asia/Famagusta"

	SystemSettingsRequestTimeZoneAsiaGaza SystemSettingsRequestTimeZone = "Asia/Gaza"

	SystemSettingsRequestTimeZoneAsiaHarbin SystemSettingsRequestTimeZone = "Asia/Harbin"

	SystemSettingsRequestTimeZoneAsiaHebron SystemSettingsRequestTimeZone = "Asia/Hebron"

	SystemSettingsRequestTimeZoneAsiaHoChiMinh SystemSettingsRequestTimeZone = "Asia/Ho_Chi_Minh"

	SystemSettingsRequestTimeZoneAsiaHongKong SystemSettingsRequestTimeZone = "Asia/Hong_Kong"

	SystemSettingsRequestTimeZoneAsiaHovd SystemSettingsRequestTimeZone = "Asia/Hovd"

	SystemSettingsRequestTimeZoneAsiaIrkutsk SystemSettingsRequestTimeZone = "Asia/Irkutsk"

	SystemSettingsRequestTimeZoneAsiaIstanbul SystemSettingsRequestTimeZone = "Asia/Istanbul"

	SystemSettingsRequestTimeZoneAsiaJakarta SystemSettingsRequestTimeZone = "Asia/Jakarta"

	SystemSettingsRequestTimeZoneAsiaJayapura SystemSettingsRequestTimeZone = "Asia/Jayapura"

	SystemSettingsRequestTimeZoneAsiaJerusalem SystemSettingsRequestTimeZone = "Asia/Jerusalem"

	SystemSettingsRequestTimeZoneAsiaKabul SystemSettingsRequestTimeZone = "Asia/Kabul"

	SystemSettingsRequestTimeZoneAsiaKamchatka SystemSettingsRequestTimeZone = "Asia/Kamchatka"

	SystemSettingsRequestTimeZoneAsiaKarachi SystemSettingsRequestTimeZone = "Asia/Karachi"

	SystemSettingsRequestTimeZoneAsiaKashgar SystemSettingsRequestTimeZone = "Asia/Kashgar"

	SystemSettingsRequestTimeZoneAsiaKathmandu SystemSettingsRequestTimeZone = "Asia/Kathmandu"

	SystemSettingsRequestTimeZoneAsiaKatmandu SystemSettingsRequestTimeZone = "Asia/Katmandu"

	SystemSettingsRequestTimeZoneAsiaKhandyga SystemSettingsRequestTimeZone = "Asia/Khandyga"

	SystemSettingsRequestTimeZoneAsiaKolkata SystemSettingsRequestTimeZone = "Asia/Kolkata"

	SystemSettingsRequestTimeZoneAsiaKrasnoyarsk SystemSettingsRequestTimeZone = "Asia/Krasnoyarsk"

	SystemSettingsRequestTimeZoneAsiaKualaLumpur SystemSettingsRequestTimeZone = "Asia/Kuala_Lumpur"

	SystemSettingsRequestTimeZoneAsiaKuching SystemSettingsRequestTimeZone = "Asia/Kuching"

	SystemSettingsRequestTimeZoneAsiaKuwait SystemSettingsRequestTimeZone = "Asia/Kuwait"

	SystemSettingsRequestTimeZoneAsiaMacao SystemSettingsRequestTimeZone = "Asia/Macao"

	SystemSettingsRequestTimeZoneAsiaMacau SystemSettingsRequestTimeZone = "Asia/Macau"

	SystemSettingsRequestTimeZoneAsiaMagadan SystemSettingsRequestTimeZone = "Asia/Magadan"

	SystemSettingsRequestTimeZoneAsiaMakassar SystemSettingsRequestTimeZone = "Asia/Makassar"

	SystemSettingsRequestTimeZoneAsiaManila SystemSettingsRequestTimeZone = "Asia/Manila"

	SystemSettingsRequestTimeZoneAsiaMuscat SystemSettingsRequestTimeZone = "Asia/Muscat"

	SystemSettingsRequestTimeZoneAsiaNicosia SystemSettingsRequestTimeZone = "Asia/Nicosia"

	SystemSettingsRequestTimeZoneAsiaNovokuznetsk SystemSettingsRequestTimeZone = "Asia/Novokuznetsk"

	SystemSettingsRequestTimeZoneAsiaNovosibirsk SystemSettingsRequestTimeZone = "Asia/Novosibirsk"

	SystemSettingsRequestTimeZoneAsiaOmsk SystemSettingsRequestTimeZone = "Asia/Omsk"

	SystemSettingsRequestTimeZoneAsiaOral SystemSettingsRequestTimeZone = "Asia/Oral"

	SystemSettingsRequestTimeZoneAsiaPhnomPenh SystemSettingsRequestTimeZone = "Asia/Phnom_Penh"

	SystemSettingsRequestTimeZoneAsiaPontianak SystemSettingsRequestTimeZone = "Asia/Pontianak"

	SystemSettingsRequestTimeZoneAsiaPyongyang SystemSettingsRequestTimeZone = "Asia/Pyongyang"

	SystemSettingsRequestTimeZoneAsiaQatar SystemSettingsRequestTimeZone = "Asia/Qatar"

	SystemSettingsRequestTimeZoneAsiaQostanay SystemSettingsRequestTimeZone = "Asia/Qostanay"

	SystemSettingsRequestTimeZoneAsiaQyzylorda SystemSettingsRequestTimeZone = "Asia/Qyzylorda"

	SystemSettingsRequestTimeZoneAsiaRangoon SystemSettingsRequestTimeZone = "Asia/Rangoon"

	SystemSettingsRequestTimeZoneAsiaRiyadh SystemSettingsRequestTimeZone = "Asia/Riyadh"

	SystemSettingsRequestTimeZoneAsiaSaigon SystemSettingsRequestTimeZone = "Asia/Saigon"

	SystemSettingsRequestTimeZoneAsiaSakhalin SystemSettingsRequestTimeZone = "Asia/Sakhalin"

	SystemSettingsRequestTimeZoneAsiaSamarkand SystemSettingsRequestTimeZone = "Asia/Samarkand"

	SystemSettingsRequestTimeZoneAsiaSeoul SystemSettingsRequestTimeZone = "Asia/Seoul"

	SystemSettingsRequestTimeZoneAsiaShanghai SystemSettingsRequestTimeZone = "Asia/Shanghai"

	SystemSettingsRequestTimeZoneAsiaSingapore SystemSettingsRequestTimeZone = "Asia/Singapore"

	SystemSettingsRequestTimeZoneAsiaSrednekolymsk SystemSettingsRequestTimeZone = "Asia/Srednekolymsk"

	SystemSettingsRequestTimeZoneAsiaTaipei SystemSettingsRequestTimeZone = "Asia/Taipei"

	SystemSettingsRequestTimeZoneAsiaTashkent SystemSettingsRequestTimeZone = "Asia/Tashkent"

	SystemSettingsRequestTimeZoneAsiaTbilisi SystemSettingsRequestTimeZone = "Asia/Tbilisi"

	SystemSettingsRequestTimeZoneAsiaTehran SystemSettingsRequestTimeZone = "Asia/Tehran"

	SystemSettingsRequestTimeZoneAsiaTelAviv SystemSettingsRequestTimeZone = "Asia/Tel_Aviv"

	SystemSettingsRequestTimeZoneAsiaThimbu SystemSettingsRequestTimeZone = "Asia/Thimbu"

	SystemSettingsRequestTimeZoneAsiaThimphu SystemSettingsRequestTimeZone = "Asia/Thimphu"

	SystemSettingsRequestTimeZoneAsiaTokyo SystemSettingsRequestTimeZone = "Asia/Tokyo"

	SystemSettingsRequestTimeZoneAsiaTomsk SystemSettingsRequestTimeZone = "Asia/Tomsk"

	SystemSettingsRequestTimeZoneAsiaUjungPandang SystemSettingsRequestTimeZone = "Asia/Ujung_Pandang"

	SystemSettingsRequestTimeZoneAsiaUlaanbaatar SystemSettingsRequestTimeZone = "Asia/Ulaanbaatar"

	SystemSettingsRequestTimeZoneAsiaUlanBator SystemSettingsRequestTimeZone = "Asia/Ulan_Bator"

	SystemSettingsRequestTimeZoneAsiaUrumqi SystemSettingsRequestTimeZone = "Asia/Urumqi"

	SystemSettingsRequestTimeZoneAsiaUstNera SystemSettingsRequestTimeZone = "Asia/Ust-Nera"

	SystemSettingsRequestTimeZoneAsiaVientiane SystemSettingsRequestTimeZone = "Asia/Vientiane"

	SystemSettingsRequestTimeZoneAsiaVladivostok SystemSettingsRequestTimeZone = "Asia/Vladivostok"

	SystemSettingsRequestTimeZoneAsiaYakutsk SystemSettingsRequestTimeZone = "Asia/Yakutsk"

	SystemSettingsRequestTimeZoneAsiaYangon SystemSettingsRequestTimeZone = "Asia/Yangon"

	SystemSettingsRequestTimeZoneAsiaYekaterinburg SystemSettingsRequestTimeZone = "Asia/Yekaterinburg"

	SystemSettingsRequestTimeZoneAsiaYerevan SystemSettingsRequestTimeZone = "Asia/Yerevan"

	SystemSettingsRequestTimeZoneAtlanticAzores SystemSettingsRequestTimeZone = "Atlantic/Azores"

	SystemSettingsRequestTimeZoneAtlanticBermuda SystemSettingsRequestTimeZone = "Atlantic/Bermuda"

	SystemSettingsRequestTimeZoneAtlanticCanary SystemSettingsRequestTimeZone = "Atlantic/Canary"

	SystemSettingsRequestTimeZoneAtlanticCapeVerde SystemSettingsRequestTimeZone = "Atlantic/Cape_Verde"

	SystemSettingsRequestTimeZoneAtlanticFaeroe SystemSettingsRequestTimeZone = "Atlantic/Faeroe"

	SystemSettingsRequestTimeZoneAtlanticFaroe SystemSettingsRequestTimeZone = "Atlantic/Faroe"

	SystemSettingsRequestTimeZoneAtlanticJanMayen SystemSettingsRequestTimeZone = "Atlantic/Jan_Mayen"

	SystemSettingsRequestTimeZoneAtlanticMadeira SystemSettingsRequestTimeZone = "Atlantic/Madeira"

	SystemSettingsRequestTimeZoneAtlanticReykjavik SystemSettingsRequestTimeZone = "Atlantic/Reykjavik"

	SystemSettingsRequestTimeZoneAtlanticSouthGeorgia SystemSettingsRequestTimeZone = "Atlantic/South_Georgia"

	SystemSettingsRequestTimeZoneAtlanticStHelena SystemSettingsRequestTimeZone = "Atlantic/St_Helena"

	SystemSettingsRequestTimeZoneAtlanticStanley SystemSettingsRequestTimeZone = "Atlantic/Stanley"

	SystemSettingsRequestTimeZoneAustraliaACT SystemSettingsRequestTimeZone = "Australia/ACT"

	SystemSettingsRequestTimeZoneAustraliaAdelaide SystemSettingsRequestTimeZone = "Australia/Adelaide"

	SystemSettingsRequestTimeZoneAustraliaBrisbane SystemSettingsRequestTimeZone = "Australia/Brisbane"

	SystemSettingsRequestTimeZoneAustraliaBrokenHill SystemSettingsRequestTimeZone = "Australia/Broken_Hill"

	SystemSettingsRequestTimeZoneAustraliaCanberra SystemSettingsRequestTimeZone = "Australia/Canberra"

	SystemSettingsRequestTimeZoneAustraliaCurrie SystemSettingsRequestTimeZone = "Australia/Currie"

	SystemSettingsRequestTimeZoneAustraliaDarwin SystemSettingsRequestTimeZone = "Australia/Darwin"

	SystemSettingsRequestTimeZoneAustraliaEucla SystemSettingsRequestTimeZone = "Australia/Eucla"

	SystemSettingsRequestTimeZoneAustraliaHobart SystemSettingsRequestTimeZone = "Australia/Hobart"

	SystemSettingsRequestTimeZoneAustraliaLHI SystemSettingsRequestTimeZone = "Australia/LHI"

	SystemSettingsRequestTimeZoneAustraliaLindeman SystemSettingsRequestTimeZone = "Australia/Lindeman"

	SystemSettingsRequestTimeZoneAustraliaLordHowe SystemSettingsRequestTimeZone = "Australia/Lord_Howe"

	SystemSettingsRequestTimeZoneAustraliaMelbourne SystemSettingsRequestTimeZone = "Australia/Melbourne"

	SystemSettingsRequestTimeZoneAustraliaNSW SystemSettingsRequestTimeZone = "Australia/NSW"

	SystemSettingsRequestTimeZoneAustraliaNorth SystemSettingsRequestTimeZone = "Australia/North"

	SystemSettingsRequestTimeZoneAustraliaPerth SystemSettingsRequestTimeZone = "Australia/Perth"

	SystemSettingsRequestTimeZoneAustraliaQueensland SystemSettingsRequestTimeZone = "Australia/Queensland"

	SystemSettingsRequestTimeZoneAustraliaSouth SystemSettingsRequestTimeZone = "Australia/South"

	SystemSettingsRequestTimeZoneAustraliaSydney SystemSettingsRequestTimeZone = "Australia/Sydney"

	SystemSettingsRequestTimeZoneAustraliaTasmania SystemSettingsRequestTimeZone = "Australia/Tasmania"

	SystemSettingsRequestTimeZoneAustraliaVictoria SystemSettingsRequestTimeZone = "Australia/Victoria"

	SystemSettingsRequestTimeZoneAustraliaWest SystemSettingsRequestTimeZone = "Australia/West"

	SystemSettingsRequestTimeZoneAustraliaYancowinna SystemSettingsRequestTimeZone = "Australia/Yancowinna"

	SystemSettingsRequestTimeZoneBrazilAcre SystemSettingsRequestTimeZone = "Brazil/Acre"

	SystemSettingsRequestTimeZoneBrazilDeNoronha SystemSettingsRequestTimeZone = "Brazil/DeNoronha"

	SystemSettingsRequestTimeZoneBrazilEast SystemSettingsRequestTimeZone = "Brazil/East"

	SystemSettingsRequestTimeZoneBrazilWest SystemSettingsRequestTimeZone = "Brazil/West"

	SystemSettingsRequestTimeZoneCET SystemSettingsRequestTimeZone = "CET"

	SystemSettingsRequestTimeZoneCST6CDT SystemSettingsRequestTimeZone = "CST6CDT"

	SystemSettingsRequestTimeZoneCanadaAtlantic SystemSettingsRequestTimeZone = "Canada/Atlantic"

	SystemSettingsRequestTimeZoneCanadaCentral SystemSettingsRequestTimeZone = "Canada/Central"

	SystemSettingsRequestTimeZoneCanadaEastern SystemSettingsRequestTimeZone = "Canada/Eastern"

	SystemSettingsRequestTimeZoneCanadaMountain SystemSettingsRequestTimeZone = "Canada/Mountain"

	SystemSettingsRequestTimeZoneCanadaNewfoundland SystemSettingsRequestTimeZone = "Canada/Newfoundland"

	SystemSettingsRequestTimeZoneCanadaPacific SystemSettingsRequestTimeZone = "Canada/Pacific"

	SystemSettingsRequestTimeZoneCanadaSaskatchewan SystemSettingsRequestTimeZone = "Canada/Saskatchewan"

	SystemSettingsRequestTimeZoneCanadaYukon SystemSettingsRequestTimeZone = "Canada/Yukon"

	SystemSettingsRequestTimeZoneChileContinental SystemSettingsRequestTimeZone = "Chile/Continental"

	SystemSettingsRequestTimeZoneChileEasterIsland SystemSettingsRequestTimeZone = "Chile/EasterIsland"

	SystemSettingsRequestTimeZoneCuba SystemSettingsRequestTimeZone = "Cuba"

	SystemSettingsRequestTimeZoneEET SystemSettingsRequestTimeZone = "EET"

	SystemSettingsRequestTimeZoneEST SystemSettingsRequestTimeZone = "EST"

	SystemSettingsRequestTimeZoneEST5EDT SystemSettingsRequestTimeZone = "EST5EDT"

	SystemSettingsRequestTimeZoneEgypt SystemSettingsRequestTimeZone = "Egypt"

	SystemSettingsRequestTimeZoneEire SystemSettingsRequestTimeZone = "Eire"

	SystemSettingsRequestTimeZoneEtcGMT SystemSettingsRequestTimeZone = "Etc/GMT"

	SystemSettingsRequestTimeZoneEtcGMT0 SystemSettingsRequestTimeZone = "Etc/GMT+0"

	SystemSettingsRequestTimeZoneEtcGMT01 SystemSettingsRequestTimeZone = "Etc/GMT-0"

	SystemSettingsRequestTimeZoneEtcGMT02 SystemSettingsRequestTimeZone = "Etc/GMT0"

	SystemSettingsRequestTimeZoneEtcGMT1 SystemSettingsRequestTimeZone = "Etc/GMT+1"

	SystemSettingsRequestTimeZoneEtcGMT10 SystemSettingsRequestTimeZone = "Etc/GMT+10"

	SystemSettingsRequestTimeZoneEtcGMT101 SystemSettingsRequestTimeZone = "Etc/GMT-10"

	SystemSettingsRequestTimeZoneEtcGMT11 SystemSettingsRequestTimeZone = "Etc/GMT-1"

	SystemSettingsRequestTimeZoneEtcGMT111 SystemSettingsRequestTimeZone = "Etc/GMT-11"

	SystemSettingsRequestTimeZoneEtcGMT12 SystemSettingsRequestTimeZone = "Etc/GMT+12"

	SystemSettingsRequestTimeZoneEtcGMT121 SystemSettingsRequestTimeZone = "Etc/GMT-12"

	SystemSettingsRequestTimeZoneEtcGMT13 SystemSettingsRequestTimeZone = "Etc/GMT-13"

	SystemSettingsRequestTimeZoneEtcGMT14 SystemSettingsRequestTimeZone = "Etc/GMT-14"

	SystemSettingsRequestTimeZoneEtcGMT2 SystemSettingsRequestTimeZone = "Etc/GMT+2"

	SystemSettingsRequestTimeZoneEtcGMT21 SystemSettingsRequestTimeZone = "Etc/GMT-2"

	SystemSettingsRequestTimeZoneEtcGMT3 SystemSettingsRequestTimeZone = "Etc/GMT+3"

	SystemSettingsRequestTimeZoneEtcGMT31 SystemSettingsRequestTimeZone = "Etc/GMT-3"

	SystemSettingsRequestTimeZoneEtcGMT4 SystemSettingsRequestTimeZone = "Etc/GMT+4"

	SystemSettingsRequestTimeZoneEtcGMT41 SystemSettingsRequestTimeZone = "Etc/GMT-4"

	SystemSettingsRequestTimeZoneEtcGMT5 SystemSettingsRequestTimeZone = "Etc/GMT+5"

	SystemSettingsRequestTimeZoneEtcGMT51 SystemSettingsRequestTimeZone = "Etc/GMT-5"

	SystemSettingsRequestTimeZoneEtcGMT6 SystemSettingsRequestTimeZone = "Etc/GMT+6"

	SystemSettingsRequestTimeZoneEtcGMT61 SystemSettingsRequestTimeZone = "Etc/GMT-6"

	SystemSettingsRequestTimeZoneEtcGMT7 SystemSettingsRequestTimeZone = "Etc/GMT+7"

	SystemSettingsRequestTimeZoneEtcGMT71 SystemSettingsRequestTimeZone = "Etc/GMT-7"

	SystemSettingsRequestTimeZoneEtcGMT8 SystemSettingsRequestTimeZone = "Etc/GMT+8"

	SystemSettingsRequestTimeZoneEtcGMT81 SystemSettingsRequestTimeZone = "Etc/GMT-8"

	SystemSettingsRequestTimeZoneEtcGMT9 SystemSettingsRequestTimeZone = "Etc/GMT+9"

	SystemSettingsRequestTimeZoneEtcGMT91 SystemSettingsRequestTimeZone = "Etc/GMT-9"

	SystemSettingsRequestTimeZoneEtcGreenwich SystemSettingsRequestTimeZone = "Etc/Greenwich"

	SystemSettingsRequestTimeZoneEtcUCT SystemSettingsRequestTimeZone = "Etc/UCT"

	SystemSettingsRequestTimeZoneEtcUTC SystemSettingsRequestTimeZone = "Etc/UTC"

	SystemSettingsRequestTimeZoneEtcUniversal SystemSettingsRequestTimeZone = "Etc/Universal"

	SystemSettingsRequestTimeZoneEtcZulu SystemSettingsRequestTimeZone = "Etc/Zulu"

	SystemSettingsRequestTimeZoneEuropeAmsterdam SystemSettingsRequestTimeZone = "Europe/Amsterdam"

	SystemSettingsRequestTimeZoneEuropeAndorra SystemSettingsRequestTimeZone = "Europe/Andorra"

	SystemSettingsRequestTimeZoneEuropeAstrakhan SystemSettingsRequestTimeZone = "Europe/Astrakhan"

	SystemSettingsRequestTimeZoneEuropeAthens SystemSettingsRequestTimeZone = "Europe/Athens"

	SystemSettingsRequestTimeZoneEuropeBelfast SystemSettingsRequestTimeZone = "Europe/Belfast"

	SystemSettingsRequestTimeZoneEuropeBelgrade SystemSettingsRequestTimeZone = "Europe/Belgrade"

	SystemSettingsRequestTimeZoneEuropeBerlin SystemSettingsRequestTimeZone = "Europe/Berlin"

	SystemSettingsRequestTimeZoneEuropeBratislava SystemSettingsRequestTimeZone = "Europe/Bratislava"

	SystemSettingsRequestTimeZoneEuropeBrussels SystemSettingsRequestTimeZone = "Europe/Brussels"

	SystemSettingsRequestTimeZoneEuropeBucharest SystemSettingsRequestTimeZone = "Europe/Bucharest"

	SystemSettingsRequestTimeZoneEuropeBudapest SystemSettingsRequestTimeZone = "Europe/Budapest"

	SystemSettingsRequestTimeZoneEuropeBusingen SystemSettingsRequestTimeZone = "Europe/Busingen"

	SystemSettingsRequestTimeZoneEuropeChisinau SystemSettingsRequestTimeZone = "Europe/Chisinau"

	SystemSettingsRequestTimeZoneEuropeCopenhagen SystemSettingsRequestTimeZone = "Europe/Copenhagen"

	SystemSettingsRequestTimeZoneEuropeDublin SystemSettingsRequestTimeZone = "Europe/Dublin"

	SystemSettingsRequestTimeZoneEuropeGibraltar SystemSettingsRequestTimeZone = "Europe/Gibraltar"

	SystemSettingsRequestTimeZoneEuropeGuernsey SystemSettingsRequestTimeZone = "Europe/Guernsey"

	SystemSettingsRequestTimeZoneEuropeHelsinki SystemSettingsRequestTimeZone = "Europe/Helsinki"

	SystemSettingsRequestTimeZoneEuropeIsleOfMan SystemSettingsRequestTimeZone = "Europe/Isle_of_Man"

	SystemSettingsRequestTimeZoneEuropeIstanbul SystemSettingsRequestTimeZone = "Europe/Istanbul"

	SystemSettingsRequestTimeZoneEuropeJersey SystemSettingsRequestTimeZone = "Europe/Jersey"

	SystemSettingsRequestTimeZoneEuropeKaliningrad SystemSettingsRequestTimeZone = "Europe/Kaliningrad"

	SystemSettingsRequestTimeZoneEuropeKiev SystemSettingsRequestTimeZone = "Europe/Kiev"

	SystemSettingsRequestTimeZoneEuropeKirov SystemSettingsRequestTimeZone = "Europe/Kirov"

	SystemSettingsRequestTimeZoneEuropeKyiv SystemSettingsRequestTimeZone = "Europe/Kyiv"

	SystemSettingsRequestTimeZoneEuropeLisbon SystemSettingsRequestTimeZone = "Europe/Lisbon"

	SystemSettingsRequestTimeZoneEuropeLjubljana SystemSettingsRequestTimeZone = "Europe/Ljubljana"

	SystemSettingsRequestTimeZoneEuropeLondon SystemSettingsRequestTimeZone = "Europe/London"

	SystemSettingsRequestTimeZoneEuropeLuxembourg SystemSettingsRequestTimeZone = "Europe/Luxembourg"

	SystemSettingsRequestTimeZoneEuropeMadrid SystemSettingsRequestTimeZone = "Europe/Madrid"

	SystemSettingsRequestTimeZoneEuropeMalta SystemSettingsRequestTimeZone = "Europe/Malta"

	SystemSettingsRequestTimeZoneEuropeMariehamn SystemSettingsRequestTimeZone = "Europe/Mariehamn"

	SystemSettingsRequestTimeZoneEuropeMinsk SystemSettingsRequestTimeZone = "Europe/Minsk"

	SystemSettingsRequestTimeZoneEuropeMonaco SystemSettingsRequestTimeZone = "Europe/Monaco"

	SystemSettingsRequestTimeZoneEuropeMoscow SystemSettingsRequestTimeZone = "Europe/Moscow"

	SystemSettingsRequestTimeZoneEuropeNicosia SystemSettingsRequestTimeZone = "Europe/Nicosia"

	SystemSettingsRequestTimeZoneEuropeOslo SystemSettingsRequestTimeZone = "Europe/Oslo"

	SystemSettingsRequestTimeZoneEuropeParis SystemSettingsRequestTimeZone = "Europe/Paris"

	SystemSettingsRequestTimeZoneEuropePodgorica SystemSettingsRequestTimeZone = "Europe/Podgorica"

	SystemSettingsRequestTimeZoneEuropePrague SystemSettingsRequestTimeZone = "Europe/Prague"

	SystemSettingsRequestTimeZoneEuropeRiga SystemSettingsRequestTimeZone = "Europe/Riga"

	SystemSettingsRequestTimeZoneEuropeRome SystemSettingsRequestTimeZone = "Europe/Rome"

	SystemSettingsRequestTimeZoneEuropeSamara SystemSettingsRequestTimeZone = "Europe/Samara"

	SystemSettingsRequestTimeZoneEuropeSanMarino SystemSettingsRequestTimeZone = "Europe/San_Marino"

	SystemSettingsRequestTimeZoneEuropeSarajevo SystemSettingsRequestTimeZone = "Europe/Sarajevo"

	SystemSettingsRequestTimeZoneEuropeSaratov SystemSettingsRequestTimeZone = "Europe/Saratov"

	SystemSettingsRequestTimeZoneEuropeSimferopol SystemSettingsRequestTimeZone = "Europe/Simferopol"

	SystemSettingsRequestTimeZoneEuropeSkopje SystemSettingsRequestTimeZone = "Europe/Skopje"

	SystemSettingsRequestTimeZoneEuropeSofia SystemSettingsRequestTimeZone = "Europe/Sofia"

	SystemSettingsRequestTimeZoneEuropeStockholm SystemSettingsRequestTimeZone = "Europe/Stockholm"

	SystemSettingsRequestTimeZoneEuropeTallinn SystemSettingsRequestTimeZone = "Europe/Tallinn"

	SystemSettingsRequestTimeZoneEuropeTirane SystemSettingsRequestTimeZone = "Europe/Tirane"

	SystemSettingsRequestTimeZoneEuropeTiraspol SystemSettingsRequestTimeZone = "Europe/Tiraspol"

	SystemSettingsRequestTimeZoneEuropeUlyanovsk SystemSettingsRequestTimeZone = "Europe/Ulyanovsk"

	SystemSettingsRequestTimeZoneEuropeUzhgorod SystemSettingsRequestTimeZone = "Europe/Uzhgorod"

	SystemSettingsRequestTimeZoneEuropeVaduz SystemSettingsRequestTimeZone = "Europe/Vaduz"

	SystemSettingsRequestTimeZoneEuropeVatican SystemSettingsRequestTimeZone = "Europe/Vatican"

	SystemSettingsRequestTimeZoneEuropeVienna SystemSettingsRequestTimeZone = "Europe/Vienna"

	SystemSettingsRequestTimeZoneEuropeVilnius SystemSettingsRequestTimeZone = "Europe/Vilnius"

	SystemSettingsRequestTimeZoneEuropeVolgograd SystemSettingsRequestTimeZone = "Europe/Volgograd"

	SystemSettingsRequestTimeZoneEuropeWarsaw SystemSettingsRequestTimeZone = "Europe/Warsaw"

	SystemSettingsRequestTimeZoneEuropeZagreb SystemSettingsRequestTimeZone = "Europe/Zagreb"

	SystemSettingsRequestTimeZoneEuropeZaporozhye SystemSettingsRequestTimeZone = "Europe/Zaporozhye"

	SystemSettingsRequestTimeZoneEuropeZurich SystemSettingsRequestTimeZone = "Europe/Zurich"

	SystemSettingsRequestTimeZoneGB SystemSettingsRequestTimeZone = "GB"

	SystemSettingsRequestTimeZoneGBEire SystemSettingsRequestTimeZone = "GB-Eire"

	SystemSettingsRequestTimeZoneGMT SystemSettingsRequestTimeZone = "GMT"

	SystemSettingsRequestTimeZoneGMT0 SystemSettingsRequestTimeZone = "GMT+0"

	SystemSettingsRequestTimeZoneGMT01 SystemSettingsRequestTimeZone = "GMT-0"

	SystemSettingsRequestTimeZoneGMT02 SystemSettingsRequestTimeZone = "GMT0"

	SystemSettingsRequestTimeZoneGreenwich SystemSettingsRequestTimeZone = "Greenwich"

	SystemSettingsRequestTimeZoneHST SystemSettingsRequestTimeZone = "HST"

	SystemSettingsRequestTimeZoneHongkong SystemSettingsRequestTimeZone = "Hongkong"

	SystemSettingsRequestTimeZoneIceland SystemSettingsRequestTimeZone = "Iceland"

	SystemSettingsRequestTimeZoneIndianAntananarivo SystemSettingsRequestTimeZone = "Indian/Antananarivo"

	SystemSettingsRequestTimeZoneIndianChagos SystemSettingsRequestTimeZone = "Indian/Chagos"

	SystemSettingsRequestTimeZoneIndianChristmas SystemSettingsRequestTimeZone = "Indian/Christmas"

	SystemSettingsRequestTimeZoneIndianCocos SystemSettingsRequestTimeZone = "Indian/Cocos"

	SystemSettingsRequestTimeZoneIndianComoro SystemSettingsRequestTimeZone = "Indian/Comoro"

	SystemSettingsRequestTimeZoneIndianKerguelen SystemSettingsRequestTimeZone = "Indian/Kerguelen"

	SystemSettingsRequestTimeZoneIndianMahe SystemSettingsRequestTimeZone = "Indian/Mahe"

	SystemSettingsRequestTimeZoneIndianMaldives SystemSettingsRequestTimeZone = "Indian/Maldives"

	SystemSettingsRequestTimeZoneIndianMauritius SystemSettingsRequestTimeZone = "Indian/Mauritius"

	SystemSettingsRequestTimeZoneIndianMayotte SystemSettingsRequestTimeZone = "Indian/Mayotte"

	SystemSettingsRequestTimeZoneIndianReunion SystemSettingsRequestTimeZone = "Indian/Reunion"

	SystemSettingsRequestTimeZoneIran SystemSettingsRequestTimeZone = "Iran"

	SystemSettingsRequestTimeZoneIsrael SystemSettingsRequestTimeZone = "Israel"

	SystemSettingsRequestTimeZoneJamaica SystemSettingsRequestTimeZone = "Jamaica"

	SystemSettingsRequestTimeZoneJapan SystemSettingsRequestTimeZone = "Japan"

	SystemSettingsRequestTimeZoneKwajalein SystemSettingsRequestTimeZone = "Kwajalein"

	SystemSettingsRequestTimeZoneLibya SystemSettingsRequestTimeZone = "Libya"

	SystemSettingsRequestTimeZoneMET SystemSettingsRequestTimeZone = "MET"

	SystemSettingsRequestTimeZoneMST SystemSettingsRequestTimeZone = "MST"

	SystemSettingsRequestTimeZoneMST7MDT SystemSettingsRequestTimeZone = "MST7MDT"

	SystemSettingsRequestTimeZoneMexicoBajaNorte SystemSettingsRequestTimeZone = "Mexico/BajaNorte"

	SystemSettingsRequestTimeZoneMexicoBajaSur SystemSettingsRequestTimeZone = "Mexico/BajaSur"

	SystemSettingsRequestTimeZoneMexicoGeneral SystemSettingsRequestTimeZone = "Mexico/General"

	SystemSettingsRequestTimeZoneNZ SystemSettingsRequestTimeZone = "NZ"

	SystemSettingsRequestTimeZoneNZCHAT SystemSettingsRequestTimeZone = "NZ-CHAT"

	SystemSettingsRequestTimeZoneNavajo SystemSettingsRequestTimeZone = "Navajo"

	SystemSettingsRequestTimeZonePRC SystemSettingsRequestTimeZone = "PRC"

	SystemSettingsRequestTimeZonePST8PDT SystemSettingsRequestTimeZone = "PST8PDT"

	SystemSettingsRequestTimeZonePacificApia SystemSettingsRequestTimeZone = "Pacific/Apia"

	SystemSettingsRequestTimeZonePacificAuckland SystemSettingsRequestTimeZone = "Pacific/Auckland"

	SystemSettingsRequestTimeZonePacificBougainville SystemSettingsRequestTimeZone = "Pacific/Bougainville"

	SystemSettingsRequestTimeZonePacificChatham SystemSettingsRequestTimeZone = "Pacific/Chatham"

	SystemSettingsRequestTimeZonePacificChuuk SystemSettingsRequestTimeZone = "Pacific/Chuuk"

	SystemSettingsRequestTimeZonePacificEaster SystemSettingsRequestTimeZone = "Pacific/Easter"

	SystemSettingsRequestTimeZonePacificEfate SystemSettingsRequestTimeZone = "Pacific/Efate"

	SystemSettingsRequestTimeZonePacificEnderbury SystemSettingsRequestTimeZone = "Pacific/Enderbury"

	SystemSettingsRequestTimeZonePacificFakaofo SystemSettingsRequestTimeZone = "Pacific/Fakaofo"

	SystemSettingsRequestTimeZonePacificFiji SystemSettingsRequestTimeZone = "Pacific/Fiji"

	SystemSettingsRequestTimeZonePacificFunafuti SystemSettingsRequestTimeZone = "Pacific/Funafuti"

	SystemSettingsRequestTimeZonePacificGalapagos SystemSettingsRequestTimeZone = "Pacific/Galapagos"

	SystemSettingsRequestTimeZonePacificGambier SystemSettingsRequestTimeZone = "Pacific/Gambier"

	SystemSettingsRequestTimeZonePacificGuadalcanal SystemSettingsRequestTimeZone = "Pacific/Guadalcanal"

	SystemSettingsRequestTimeZonePacificGuam SystemSettingsRequestTimeZone = "Pacific/Guam"

	SystemSettingsRequestTimeZonePacificHonolulu SystemSettingsRequestTimeZone = "Pacific/Honolulu"

	SystemSettingsRequestTimeZonePacificJohnston SystemSettingsRequestTimeZone = "Pacific/Johnston"

	SystemSettingsRequestTimeZonePacificKanton SystemSettingsRequestTimeZone = "Pacific/Kanton"

	SystemSettingsRequestTimeZonePacificKiritimati SystemSettingsRequestTimeZone = "Pacific/Kiritimati"

	SystemSettingsRequestTimeZonePacificKosrae SystemSettingsRequestTimeZone = "Pacific/Kosrae"

	SystemSettingsRequestTimeZonePacificKwajalein SystemSettingsRequestTimeZone = "Pacific/Kwajalein"

	SystemSettingsRequestTimeZonePacificMajuro SystemSettingsRequestTimeZone = "Pacific/Majuro"

	SystemSettingsRequestTimeZonePacificMarquesas SystemSettingsRequestTimeZone = "Pacific/Marquesas"

	SystemSettingsRequestTimeZonePacificMidway SystemSettingsRequestTimeZone = "Pacific/Midway"

	SystemSettingsRequestTimeZonePacificNauru SystemSettingsRequestTimeZone = "Pacific/Nauru"

	SystemSettingsRequestTimeZonePacificNiue SystemSettingsRequestTimeZone = "Pacific/Niue"

	SystemSettingsRequestTimeZonePacificNorfolk SystemSettingsRequestTimeZone = "Pacific/Norfolk"

	SystemSettingsRequestTimeZonePacificNoumea SystemSettingsRequestTimeZone = "Pacific/Noumea"

	SystemSettingsRequestTimeZonePacificPagoPago SystemSettingsRequestTimeZone = "Pacific/Pago_Pago"

	SystemSettingsRequestTimeZonePacificPalau SystemSettingsRequestTimeZone = "Pacific/Palau"

	SystemSettingsRequestTimeZonePacificPitcairn SystemSettingsRequestTimeZone = "Pacific/Pitcairn"

	SystemSettingsRequestTimeZonePacificPohnpei SystemSettingsRequestTimeZone = "Pacific/Pohnpei"

	SystemSettingsRequestTimeZonePacificPonape SystemSettingsRequestTimeZone = "Pacific/Ponape"

	SystemSettingsRequestTimeZonePacificPortMoresby SystemSettingsRequestTimeZone = "Pacific/Port_Moresby"

	SystemSettingsRequestTimeZonePacificRarotonga SystemSettingsRequestTimeZone = "Pacific/Rarotonga"

	SystemSettingsRequestTimeZonePacificSaipan SystemSettingsRequestTimeZone = "Pacific/Saipan"

	SystemSettingsRequestTimeZonePacificSamoa SystemSettingsRequestTimeZone = "Pacific/Samoa"

	SystemSettingsRequestTimeZonePacificTahiti SystemSettingsRequestTimeZone = "Pacific/Tahiti"

	SystemSettingsRequestTimeZonePacificTarawa SystemSettingsRequestTimeZone = "Pacific/Tarawa"

	SystemSettingsRequestTimeZonePacificTongatapu SystemSettingsRequestTimeZone = "Pacific/Tongatapu"

	SystemSettingsRequestTimeZonePacificTruk SystemSettingsRequestTimeZone = "Pacific/Truk"

	SystemSettingsRequestTimeZonePacificWake SystemSettingsRequestTimeZone = "Pacific/Wake"

	SystemSettingsRequestTimeZonePacificWallis SystemSettingsRequestTimeZone = "Pacific/Wallis"

	SystemSettingsRequestTimeZonePacificYap SystemSettingsRequestTimeZone = "Pacific/Yap"

	SystemSettingsRequestTimeZonePoland SystemSettingsRequestTimeZone = "Poland"

	SystemSettingsRequestTimeZonePortugal SystemSettingsRequestTimeZone = "Portugal"

	SystemSettingsRequestTimeZoneROC SystemSettingsRequestTimeZone = "ROC"

	SystemSettingsRequestTimeZoneROK SystemSettingsRequestTimeZone = "ROK"

	SystemSettingsRequestTimeZoneSingapore SystemSettingsRequestTimeZone = "Singapore"

	SystemSettingsRequestTimeZoneTurkey SystemSettingsRequestTimeZone = "Turkey"

	SystemSettingsRequestTimeZoneUCT SystemSettingsRequestTimeZone = "UCT"

	SystemSettingsRequestTimeZoneUSAlaska SystemSettingsRequestTimeZone = "US/Alaska"

	SystemSettingsRequestTimeZoneUSAleutian SystemSettingsRequestTimeZone = "US/Aleutian"

	SystemSettingsRequestTimeZoneUSArizona SystemSettingsRequestTimeZone = "US/Arizona"

	SystemSettingsRequestTimeZoneUSCentral SystemSettingsRequestTimeZone = "US/Central"

	SystemSettingsRequestTimeZoneUSEastIndiana SystemSettingsRequestTimeZone = "US/East-Indiana"

	SystemSettingsRequestTimeZoneUSEastern SystemSettingsRequestTimeZone = "US/Eastern"

	SystemSettingsRequestTimeZoneUSHawaii SystemSettingsRequestTimeZone = "US/Hawaii"

	SystemSettingsRequestTimeZoneUSIndianaStarke SystemSettingsRequestTimeZone = "US/Indiana-Starke"

	SystemSettingsRequestTimeZoneUSMichigan SystemSettingsRequestTimeZone = "US/Michigan"

	SystemSettingsRequestTimeZoneUSMountain SystemSettingsRequestTimeZone = "US/Mountain"

	SystemSettingsRequestTimeZoneUSPacific SystemSettingsRequestTimeZone = "US/Pacific"

	SystemSettingsRequestTimeZoneUSSamoa SystemSettingsRequestTimeZone = "US/Samoa"

	SystemSettingsRequestTimeZoneUTC SystemSettingsRequestTimeZone = "UTC"

	SystemSettingsRequestTimeZoneUniversal SystemSettingsRequestTimeZone = "Universal"

	SystemSettingsRequestTimeZoneWET SystemSettingsRequestTimeZone = "WET"

	SystemSettingsRequestTimeZoneWSU SystemSettingsRequestTimeZone = "W-SU"

	SystemSettingsRequestTimeZoneZulu SystemSettingsRequestTimeZone = "Zulu"
)

// Defines values for TestImportFindingActionAction.
const (
	TestImportFindingActionActionC TestImportFindingActionAction = "C"

	TestImportFindingActionActionEmpty TestImportFindingActionAction = ""

	TestImportFindingActionActionN TestImportFindingActionAction = "N"

	TestImportFindingActionActionNil TestImportFindingActionAction = "<nil>"

	TestImportFindingActionActionR TestImportFindingActionAction = "R"

	TestImportFindingActionActionU TestImportFindingActionAction = "U"
)

// Defines values for ToolConfigurationAuthenticationType.
const (
	ToolConfigurationAuthenticationTypeAPI ToolConfigurationAuthenticationType = "API"

	ToolConfigurationAuthenticationTypeEmpty ToolConfigurationAuthenticationType = ""

	ToolConfigurationAuthenticationTypeNil ToolConfigurationAuthenticationType = "<nil>"

	ToolConfigurationAuthenticationTypePassword ToolConfigurationAuthenticationType = "Password"

	ToolConfigurationAuthenticationTypeSSH ToolConfigurationAuthenticationType = "SSH"
)

// Defines values for ToolConfigurationRequestAuthenticationType.
const (
	ToolConfigurationRequestAuthenticationTypeAPI ToolConfigurationRequestAuthenticationType = "API"

	ToolConfigurationRequestAuthenticationTypeEmpty ToolConfigurationRequestAuthenticationType = ""

	ToolConfigurationRequestAuthenticationTypeNil ToolConfigurationRequestAuthenticationType = "<nil>"

	ToolConfigurationRequestAuthenticationTypePassword ToolConfigurationRequestAuthenticationType = "Password"

	ToolConfigurationRequestAuthenticationTypeSSH ToolConfigurationRequestAuthenticationType = "SSH"
)

// AcceptedRiskRequest defines model for AcceptedRiskRequest.
type AcceptedRiskRequest struct {
	// Name or email of person who accepts the risk
	AcceptedBy string `json:"accepted_by"`

	// Justification for accepting findings with this vulnerability id
	Justification string `json:"justification"`

	// An id of a vulnerability in a security advisory associated with this finding. Can be a Common Vulnerabilities and Exposure (CVE) or from other sources.
	VulnerabilityId string `json:"vulnerability_id"`
}

// AddNewFileOptionRequest defines model for AddNewFileOptionRequest.
type AddNewFileOptionRequest struct {
	File  string `json:"file"`
	Title string `json:"title"`
}

// AddNewNoteOptionRequest defines model for AddNewNoteOptionRequest.
type AddNewNoteOptionRequest struct {
	Entry    string `json:"entry"`
	NoteType *int   `json:"note_type"`
	Private  *bool  `json:"private,omitempty"`
}

// AppAnalysis defines model for AppAnalysis.
type AppAnalysis struct {
	Confidence   *int      `json:"confidence"`
	Created      time.Time `json:"created"`
	Icon         *string   `json:"icon"`
	Id           int       `json:"id"`
	Name         string    `json:"name"`
	Product      int       `json:"product"`
	Tags         *[]string `json:"tags,omitempty"`
	User         int       `json:"user"`
	Version      *string   `json:"version"`
	Website      *string   `json:"website"`
	WebsiteFound *string   `json:"website_found"`
}

// AppAnalysisRequest defines model for AppAnalysisRequest.
type AppAnalysisRequest struct {
	Confidence   *int      `json:"confidence"`
	Icon         *string   `json:"icon"`
	Name         string    `json:"name"`
	Product      int       `json:"product"`
	Tags         *[]string `json:"tags,omitempty"`
	User         int       `json:"user"`
	Version      *string   `json:"version"`
	Website      *string   `json:"website"`
	WebsiteFound *string   `json:"website_found"`
}

// AuthToken defines model for AuthToken.
type AuthToken struct {
	Token string `json:"token"`
}

// AuthTokenRequest defines model for AuthTokenRequest.
type AuthTokenRequest struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// BurpRawRequestResponse defines model for BurpRawRequestResponse.
type BurpRawRequestResponse struct {
	ReqResp []struct {
		AdditionalProperties map[string]string `json:"-"`
	} `json:"req_resp"`
}

// BurpRawRequestResponseRequest defines model for BurpRawRequestResponseRequest.
type BurpRawRequestResponseRequest struct {
	ReqResp []struct {
		AdditionalProperties map[string]string `json:"-"`
	} `json:"req_resp"`
}

// ConfigurationPermission defines model for ConfigurationPermission.
type ConfigurationPermission struct {
	Codename string `json:"codename"`
	Id       int    `json:"id"`
	Name     string `json:"name"`
}

// DeletePreview defines model for DeletePreview.
type DeletePreview struct {
	Id    *int   `json:"id"`
	Model string `json:"model"`
	Name  string `json:"name"`
}

// DeltaStatistics defines model for DeltaStatistics.
type DeltaStatistics struct {
	Closed        SeverityStatusStatistics `json:"closed"`
	Created       SeverityStatusStatistics `json:"created"`
	LeftUntouched SeverityStatusStatistics `json:"left untouched"`
	Reactivated   SeverityStatusStatistics `json:"reactivated"`
}

// DevelopmentEnvironment defines model for DevelopmentEnvironment.
type DevelopmentEnvironment struct {
	Id   int    `json:"id"`
	Name string `json:"name"`
}

// DevelopmentEnvironmentRequest defines model for DevelopmentEnvironmentRequest.
type DevelopmentEnvironmentRequest struct {
	Name string `json:"name"`
}

// DojoGroup defines model for DojoGroup.
type DojoGroup struct {
	ConfigurationPermissions *[]int  `json:"configuration_permissions,omitempty"`
	Description              *string `json:"description"`
	Id                       int     `json:"id"`
	Name                     string  `json:"name"`
	Prefetch                 *struct {
		ProductGroups     *DojoGroup_Prefetch_ProductGroups     `json:"product_groups,omitempty"`
		ProductTypeGroups *DojoGroup_Prefetch_ProductTypeGroups `json:"product_type_groups,omitempty"`
		Users             *DojoGroup_Prefetch_Users             `json:"users,omitempty"`
	} `json:"prefetch,omitempty"`

	// Group imported from a social provider.
	SocialProvider *DojoGroupSocialProvider `json:"social_provider"`
	Users          []int                    `json:"users"`
}

// DojoGroup_Prefetch_ProductGroups defines model for DojoGroup.Prefetch.ProductGroups.
type DojoGroup_Prefetch_ProductGroups struct {
	AdditionalProperties map[string]Product `json:"-"`
}

// DojoGroup_Prefetch_ProductTypeGroups defines model for DojoGroup.Prefetch.ProductTypeGroups.
type DojoGroup_Prefetch_ProductTypeGroups struct {
	AdditionalProperties map[string]ProductType `json:"-"`
}

// DojoGroup_Prefetch_Users defines model for DojoGroup.Prefetch.Users.
type DojoGroup_Prefetch_Users struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// Group imported from a social provider.
type DojoGroupSocialProvider string

// DojoGroupMember defines model for DojoGroupMember.
type DojoGroupMember struct {
	Group    int `json:"group"`
	Id       int `json:"id"`
	Prefetch *struct {
		Group *DojoGroupMember_Prefetch_Group `json:"group,omitempty"`
		Role  *DojoGroupMember_Prefetch_Role  `json:"role,omitempty"`
		User  *DojoGroupMember_Prefetch_User  `json:"user,omitempty"`
	} `json:"prefetch,omitempty"`

	// This role determines the permissions of the user to manage the group.
	Role int `json:"role"`
	User int `json:"user"`
}

// DojoGroupMember_Prefetch_Group defines model for DojoGroupMember.Prefetch.Group.
type DojoGroupMember_Prefetch_Group struct {
	AdditionalProperties map[string]DojoGroup `json:"-"`
}

// DojoGroupMember_Prefetch_Role defines model for DojoGroupMember.Prefetch.Role.
type DojoGroupMember_Prefetch_Role struct {
	AdditionalProperties map[string]Role `json:"-"`
}

// DojoGroupMember_Prefetch_User defines model for DojoGroupMember.Prefetch.User.
type DojoGroupMember_Prefetch_User struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// DojoGroupMemberRequest defines model for DojoGroupMemberRequest.
type DojoGroupMemberRequest struct {
	Group int `json:"group"`

	// This role determines the permissions of the user to manage the group.
	Role int `json:"role"`
	User int `json:"user"`
}

// DojoGroupRequest defines model for DojoGroupRequest.
type DojoGroupRequest struct {
	ConfigurationPermissions *[]int  `json:"configuration_permissions,omitempty"`
	Description              *string `json:"description"`
	Name                     string  `json:"name"`

	// Group imported from a social provider.
	SocialProvider *DojoGroupRequestSocialProvider `json:"social_provider"`
}

// Group imported from a social provider.
type DojoGroupRequestSocialProvider string

// Endpoint defines model for Endpoint.
type Endpoint struct {
	EndpointParams []int `json:"endpoint_params"`
	Findings       []int `json:"findings"`

	// The fragment identifier which follows the hash mark. The hash mark should be omitted. For example 'section-13', 'paragraph-2'.
	Fragment *string `json:"fragment"`

	// The host name or IP address. It must not include the port number. For example '127.0.0.1', 'localhost', 'yourdomain.com'.
	Host *string `json:"host"`
	Id   int     `json:"id"`

	// The location of the resource, it must not start with a '/'. For example endpoint/420/edit
	Path *string `json:"path"`

	// The network port associated with the endpoint.
	Port    *int `json:"port"`
	Product *int `json:"product"`

	// The communication protocol/scheme such as 'http', 'ftp', 'dns', etc.
	Protocol *string `json:"protocol"`

	// The query string, the question mark should be omitted.For example 'group=4&team=8'
	Query *string   `json:"query"`
	Tags  *[]string `json:"tags,omitempty"`

	// User info as 'alice', 'bob', etc.
	Userinfo *string `json:"userinfo"`
}

// EndpointMetaImporter defines model for EndpointMetaImporter.
type EndpointMetaImporter struct {
	CreateDojoMeta  *bool   `json:"create_dojo_meta,omitempty"`
	CreateEndpoints *bool   `json:"create_endpoints,omitempty"`
	CreateTags      *bool   `json:"create_tags,omitempty"`
	File            string  `json:"file"`
	Product         *int    `json:"product,omitempty"`
	ProductId       int     `json:"product_id"`
	ProductName     *string `json:"product_name,omitempty"`
}

// EndpointMetaImporterRequest defines model for EndpointMetaImporterRequest.
type EndpointMetaImporterRequest struct {
	CreateDojoMeta  *bool   `json:"create_dojo_meta,omitempty"`
	CreateEndpoints *bool   `json:"create_endpoints,omitempty"`
	CreateTags      *bool   `json:"create_tags,omitempty"`
	File            string  `json:"file"`
	Product         *int    `json:"product,omitempty"`
	ProductName     *string `json:"product_name,omitempty"`
}

// EndpointRequest defines model for EndpointRequest.
type EndpointRequest struct {
	// The fragment identifier which follows the hash mark. The hash mark should be omitted. For example 'section-13', 'paragraph-2'.
	Fragment *string `json:"fragment"`

	// The host name or IP address. It must not include the port number. For example '127.0.0.1', 'localhost', 'yourdomain.com'.
	Host *string `json:"host"`

	// The location of the resource, it must not start with a '/'. For example endpoint/420/edit
	Path *string `json:"path"`

	// The network port associated with the endpoint.
	Port    *int `json:"port"`
	Product *int `json:"product"`

	// The communication protocol/scheme such as 'http', 'ftp', 'dns', etc.
	Protocol *string `json:"protocol"`

	// The query string, the question mark should be omitted.For example 'group=4&team=8'
	Query *string   `json:"query"`
	Tags  *[]string `json:"tags,omitempty"`

	// User info as 'alice', 'bob', etc.
	Userinfo *string `json:"userinfo"`
}

// EndpointStatus defines model for EndpointStatus.
type EndpointStatus struct {
	Date          *openapi_types.Date `json:"date,omitempty"`
	Endpoint      int                 `json:"endpoint"`
	FalsePositive *bool               `json:"false_positive,omitempty"`
	Finding       int                 `json:"finding"`
	Id            int                 `json:"id"`
	LastModified  *time.Time          `json:"last_modified"`
	Mitigated     *bool               `json:"mitigated,omitempty"`
	MitigatedBy   *int                `json:"mitigated_by"`
	MitigatedTime *time.Time          `json:"mitigated_time"`
	OutOfScope    *bool               `json:"out_of_scope,omitempty"`
	RiskAccepted  *bool               `json:"risk_accepted,omitempty"`
}

// EndpointStatusRequest defines model for EndpointStatusRequest.
type EndpointStatusRequest struct {
	Date          *openapi_types.Date `json:"date,omitempty"`
	Endpoint      int                 `json:"endpoint"`
	FalsePositive *bool               `json:"false_positive,omitempty"`
	Finding       int                 `json:"finding"`
	Mitigated     *bool               `json:"mitigated,omitempty"`
	MitigatedBy   *int                `json:"mitigated_by"`
	OutOfScope    *bool               `json:"out_of_scope,omitempty"`
	RiskAccepted  *bool               `json:"risk_accepted,omitempty"`
}

// Engagement defines model for Engagement.
type Engagement struct {
	Active  bool  `json:"active"`
	ApiTest *bool `json:"api_test,omitempty"`

	// Tag or branch of the product the engagement tested.
	BranchTag *string `json:"branch_tag"`

	// Build ID of the product the engagement tested.
	BuildId *string `json:"build_id"`

	// Build server responsible for CI/CD test
	BuildServer *int  `json:"build_server"`
	CheckList   *bool `json:"check_list,omitempty"`

	// Commit hash from repo
	CommitHash *string    `json:"commit_hash"`
	Created    *time.Time `json:"created"`

	// If enabled deduplication will only mark a finding in this engagement as duplicate of another finding if both findings are in this engagement. If disabled, deduplication is on the product level.
	DeduplicationOnEngagement *bool                     `json:"deduplication_on_engagement,omitempty"`
	Description               *string                   `json:"description"`
	DoneTesting               bool                      `json:"done_testing"`
	EngagementType            *EngagementEngagementType `json:"engagement_type"`
	Files                     []File                    `json:"files"`
	FirstContacted            *openapi_types.Date       `json:"first_contacted"`
	Id                        int                       `json:"id"`
	Lead                      *int                      `json:"lead"`
	Name                      *string                   `json:"name"`
	Notes                     []Note                    `json:"notes"`

	// Orchestration service responsible for CI/CD test
	OrchestrationEngine *int  `json:"orchestration_engine"`
	PenTest             *bool `json:"pen_test,omitempty"`

	// Settings and notes for performing this engagement.
	Preset         *int    `json:"preset"`
	Product        int     `json:"product"`
	Progress       string  `json:"progress"`
	Reason         *string `json:"reason"`
	ReportType     *int    `json:"report_type"`
	Requester      *int    `json:"requester"`
	RiskAcceptance []int   `json:"risk_acceptance"`

	// Source code server for CI/CD test
	SourceCodeManagementServer *int `json:"source_code_management_server"`

	// Resource link to source code
	SourceCodeManagementUri *string            `json:"source_code_management_uri"`
	Status                  *EngagementStatus  `json:"status"`
	Tags                    *[]string          `json:"tags,omitempty"`
	TargetEnd               openapi_types.Date `json:"target_end"`
	TargetStart             openapi_types.Date `json:"target_start"`
	TestStrategy            *string            `json:"test_strategy"`
	ThreatModel             *bool              `json:"threat_model,omitempty"`
	TmodelPath              *string            `json:"tmodel_path"`

	// Link to epic or ticket system with changes to version.
	Tracker *string    `json:"tracker"`
	Updated *time.Time `json:"updated"`

	// Version of the product the engagement tested.
	Version *string `json:"version"`
}

// EngagementEngagementType defines model for Engagement.EngagementType.
type EngagementEngagementType string

// EngagementStatus defines model for Engagement.Status.
type EngagementStatus string

// EngagementPresets defines model for EngagementPresets.
type EngagementPresets struct {
	Created          time.Time `json:"created"`
	Id               int       `json:"id"`
	NetworkLocations *[]int    `json:"network_locations,omitempty"`

	// Description of what needs to be tested or setting up environment for testing
	Notes   *string `json:"notes"`
	Product int     `json:"product"`

	// Scope of Engagement testing, IP's/Resources/URL's)
	Scope    *string `json:"scope,omitempty"`
	TestType *[]int  `json:"test_type,omitempty"`

	// Brief description of preset.
	Title *string `json:"title,omitempty"`
}

// EngagementPresetsRequest defines model for EngagementPresetsRequest.
type EngagementPresetsRequest struct {
	NetworkLocations *[]int `json:"network_locations,omitempty"`

	// Description of what needs to be tested or setting up environment for testing
	Notes   *string `json:"notes"`
	Product int     `json:"product"`

	// Scope of Engagement testing, IP's/Resources/URL's)
	Scope    *string `json:"scope,omitempty"`
	TestType *[]int  `json:"test_type,omitempty"`

	// Brief description of preset.
	Title *string `json:"title,omitempty"`
}

// EngagementRequest defines model for EngagementRequest.
type EngagementRequest struct {
	ApiTest *bool `json:"api_test,omitempty"`

	// Tag or branch of the product the engagement tested.
	BranchTag *string `json:"branch_tag"`

	// Build ID of the product the engagement tested.
	BuildId *string `json:"build_id"`

	// Build server responsible for CI/CD test
	BuildServer *int  `json:"build_server"`
	CheckList   *bool `json:"check_list,omitempty"`

	// Commit hash from repo
	CommitHash *string `json:"commit_hash"`

	// If enabled deduplication will only mark a finding in this engagement as duplicate of another finding if both findings are in this engagement. If disabled, deduplication is on the product level.
	DeduplicationOnEngagement *bool                            `json:"deduplication_on_engagement,omitempty"`
	Description               *string                          `json:"description"`
	EngagementType            *EngagementRequestEngagementType `json:"engagement_type"`
	FirstContacted            *openapi_types.Date              `json:"first_contacted"`
	Lead                      *int                             `json:"lead"`
	Name                      *string                          `json:"name"`

	// Orchestration service responsible for CI/CD test
	OrchestrationEngine *int  `json:"orchestration_engine"`
	PenTest             *bool `json:"pen_test,omitempty"`

	// Settings and notes for performing this engagement.
	Preset     *int    `json:"preset"`
	Product    int     `json:"product"`
	Reason     *string `json:"reason"`
	ReportType *int    `json:"report_type"`
	Requester  *int    `json:"requester"`

	// Source code server for CI/CD test
	SourceCodeManagementServer *int `json:"source_code_management_server"`

	// Resource link to source code
	SourceCodeManagementUri *string                  `json:"source_code_management_uri"`
	Status                  *EngagementRequestStatus `json:"status"`
	Tags                    *[]string                `json:"tags,omitempty"`
	TargetEnd               openapi_types.Date       `json:"target_end"`
	TargetStart             openapi_types.Date       `json:"target_start"`
	TestStrategy            *string                  `json:"test_strategy"`
	ThreatModel             *bool                    `json:"threat_model,omitempty"`

	// Link to epic or ticket system with changes to version.
	Tracker *string `json:"tracker"`

	// Version of the product the engagement tested.
	Version *string `json:"version"`
}

// EngagementRequestEngagementType defines model for EngagementRequest.EngagementType.
type EngagementRequestEngagementType string

// EngagementRequestStatus defines model for EngagementRequest.Status.
type EngagementRequestStatus string

// EngagementToFiles defines model for EngagementToFiles.
type EngagementToFiles struct {
	EngagementId *int   `json:"engagement_id"`
	Files        []File `json:"files"`
}

// EngagementToNotes defines model for EngagementToNotes.
type EngagementToNotes struct {
	EngagementId *int   `json:"engagement_id"`
	Notes        []Note `json:"notes"`
}

// ExecutiveSummary defines model for ExecutiveSummary.
type ExecutiveSummary struct {
	EngagementName        string             `json:"engagement_name"`
	EngagementTargetEnd   openapi_types.Date `json:"engagement_target_end"`
	EngagementTargetStart openapi_types.Date `json:"engagement_target_start"`
	TestEnvironmentName   string             `json:"test_environment_name"`
	TestStrategyRef       string             `json:"test_strategy_ref"`
	TestTargetEnd         time.Time          `json:"test_target_end"`
	TestTargetStart       time.Time          `json:"test_target_start"`
	TestTypeName          string             `json:"test_type_name"`
	TotalFindings         int                `json:"total_findings"`
}

// File defines model for File.
type File struct {
	File  string `json:"file"`
	Id    int    `json:"id"`
	Title string `json:"title"`
}

// Finding defines model for Finding.
type Finding struct {
	AcceptedRisks []RiskAcceptance `json:"accepted_risks"`

	// Denotes if this flaw is active or not.
	Active *bool `json:"active,omitempty"`
	Age    int   `json:"age"`

	// Name of the affected component (library name, part of a system, ...).
	ComponentName *string `json:"component_name"`

	// Version of the affected component.
	ComponentVersion *string `json:"component_version"`

	// The date the finding was created inside DefectDojo.
	Created *time.Time `json:"created"`

	// Common Vulnerability Scoring System version 3 (CVSSv3) score associated with this flaw.
	Cvssv3 *string `json:"cvssv3"`

	// Numerical CVSSv3 score for the vulnerability. If the vector is given, the score is updated while saving the finding
	Cvssv3Score *float64 `json:"cvssv3_score"`

	// The CWE number associated with this flaw.
	Cwe *int `json:"cwe"`

	// The date the flaw was discovered.
	Date *openapi_types.Date `json:"date,omitempty"`

	// Documents who requested a defect review for this flaw.
	DefectReviewRequestedBy *int `json:"defect_review_requested_by"`

	// Longer more descriptive information about the flaw.
	Description   string `json:"description"`
	DisplayStatus string `json:"display_status"`

	// Denotes if this flaw is a duplicate of other flaws reported.
	Duplicate *bool `json:"duplicate,omitempty"`

	// Link to the original finding if this finding is a duplicate.
	DuplicateFinding *int `json:"duplicate_finding"`

	// Flaw has been detected from a Dynamic Application Security Testing tool (DAST).
	DynamicFinding *bool `json:"dynamic_finding,omitempty"`

	// The hosts within the product that are susceptible to this flaw. + The status of the endpoint associated with this flaw (Vulnerable, Mitigated, ...).
	Endpoints []int `json:"endpoints"`

	// Denotes if this flaw has been deemed a false positive by the tester.
	FalseP *bool `json:"false_p,omitempty"`

	// Identified file(s) containing the flaw.
	FilePath *string `json:"file_path"`

	// Files(s) related to the flaw.
	Files         []int          `json:"files"`
	FindingGroups []FindingGroup `json:"finding_groups"`
	FindingMeta   []FindingMeta  `json:"finding_meta"`

	// The name of the scanner that identified the flaw.
	FoundBy []int `json:"found_by"`

	// A hash over a configurable set of fields that is used for findings deduplication.
	HashCode *string `json:"hash_code"`
	Id       int     `json:"id"`

	// Text describing the impact this flaw has on systems, products, enterprise, etc.
	Impact *string `json:"impact"`

	// Denotes if this flaw has been fixed.
	IsMitigated  *bool     `json:"is_mitigated,omitempty"`
	JiraChange   time.Time `json:"jira_change"`
	JiraCreation time.Time `json:"jira_creation"`

	// Provides the date the flaw was last 'touched' by a tester.
	LastReviewed *time.Time `json:"last_reviewed"`

	// Provides the person who last reviewed the flaw.
	LastReviewedBy *int `json:"last_reviewed_by"`

	// Timestamp of latest status update (change in status related fields).
	LastStatusUpdate *time.Time `json:"last_status_update"`

	// Source line number of the attack vector.
	Line *int `json:"line"`

	// Denotes if this flaw has been fixed by storing the date it was fixed.
	Mitigated *time.Time `json:"mitigated"`

	// Documents who has marked this flaw as fixed.
	MitigatedBy *int `json:"mitigated_by"`

	// Text describing how to best fix the flaw.
	Mitigation *string `json:"mitigation"`

	// Number of occurences in the source tool when several vulnerabilites were found and aggregated by the scanner.
	NbOccurences *int   `json:"nb_occurences"`
	Notes        []Note `json:"notes"`

	// The numerical representation of the severity (S0, S1, S2, S3, S4).
	NumericalSeverity string `json:"numerical_severity"`

	// Denotes if this flaw falls outside the scope of the test and/or engagement.
	OutOfScope *bool `json:"out_of_scope,omitempty"`

	// Parameter used to trigger the issue (DAST).
	Param *string `json:"param"`

	// Payload used to attack the service / application and trigger the bug / problem.
	Payload *string `json:"payload"`

	// The date the flaw is expected to be remediated.
	PlannedRemediationDate *openapi_types.Date `json:"planned_remediation_date"`
	Prefetch               *struct {
		DefectReviewRequestedBy *Finding_Prefetch_DefectReviewRequestedBy `json:"defect_review_requested_by,omitempty"`
		DuplicateFinding        *Finding_Prefetch_DuplicateFinding        `json:"duplicate_finding,omitempty"`
		EndpointSet             *Finding_Prefetch_EndpointSet             `json:"endpoint_set,omitempty"`
		Endpoints               *Finding_Prefetch_Endpoints               `json:"endpoints,omitempty"`
		Files                   *Finding_Prefetch_Files                   `json:"files,omitempty"`
		FindingGroupSet         *Finding_Prefetch_FindingGroupSet         `json:"finding_group_set,omitempty"`
		FoundBy                 *Finding_Prefetch_FoundBy                 `json:"found_by,omitempty"`
		LastReviewedBy          *Finding_Prefetch_LastReviewedBy          `json:"last_reviewed_by,omitempty"`
		MitigatedBy             *Finding_Prefetch_MitigatedBy             `json:"mitigated_by,omitempty"`
		Notes                   *Finding_Prefetch_Notes                   `json:"notes,omitempty"`
		Reporter                *Finding_Prefetch_Reporter                `json:"reporter,omitempty"`
		ReviewRequestedBy       *Finding_Prefetch_ReviewRequestedBy       `json:"review_requested_by,omitempty"`
		Reviewers               *Finding_Prefetch_Reviewers               `json:"reviewers,omitempty"`
		RiskAcceptanceSet       *Finding_Prefetch_RiskAcceptanceSet       `json:"risk_acceptance_set,omitempty"`
		SonarqubeIssue          *Finding_Prefetch_SonarqubeIssue          `json:"sonarqube_issue,omitempty"`
		Test                    *Finding_Prefetch_Test                    `json:"test,omitempty"`
		TestImportSet           *Finding_Prefetch_TestImportSet           `json:"test_import_set,omitempty"`
	} `json:"prefetch,omitempty"`

	// Date when this vulnerability was made publicly available.
	PublishDate *openapi_types.Date `json:"publish_date"`
	PushToJira  *bool               `json:"push_to_jira,omitempty"`

	// The external documentation available for this flaw.
	References    *string `json:"references"`
	RelatedFields struct {
		// Embedded struct due to allOf(#/components/schemas/FindingRelatedFields)
		FindingRelatedFields `yaml:",inline"`
	} `json:"related_fields"`

	// Documents who reported the flaw.
	Reporter        int `json:"reporter"`
	RequestResponse struct {
		// Embedded struct due to allOf(#/components/schemas/BurpRawRequestResponse)
		BurpRawRequestResponse `yaml:",inline"`
	} `json:"request_response"`

	// Documents who requested a review for this finding.
	ReviewRequestedBy *int `json:"review_requested_by"`

	// Documents who reviewed the flaw.
	Reviewers *[]int `json:"reviewers,omitempty"`

	// Denotes if this finding has been marked as an accepted risk.
	RiskAccepted *bool `json:"risk_accepted,omitempty"`

	// Sink object (variable, function...) of the attack vector.
	SastSinkObject *string `json:"sast_sink_object"`

	// Source file path of the attack vector.
	SastSourceFilePath *string `json:"sast_source_file_path"`

	// Source line number of the attack vector.
	SastSourceLine *int `json:"sast_source_line"`

	// Source object (variable, function...) of the attack vector.
	SastSourceObject *string `json:"sast_source_object"`

	// Confidence level of vulnerability which is supplied by the scanner.
	ScannerConfidence *int `json:"scanner_confidence"`

	// A service is a self-contained piece of functionality within a Product. This is an optional field which is used in deduplication of findings when set.
	Service *string `json:"service"`

	// The severity level of this flaw (Critical, High, Medium, Low, Informational).
	Severity string `json:"severity"`

	// Text describing why a certain severity was associated with this flaw.
	SeverityJustification *string `json:"severity_justification"`
	SlaDaysRemaining      int     `json:"sla_days_remaining"`

	// (readonly)The date used as start date for SLA calculation. Set by expiring risk acceptances. Empty by default, causing a fallback to 'date'.
	SlaStartDate *openapi_types.Date `json:"sla_start_date"`

	// The SonarQube issue associated with this finding.
	SonarqubeIssue *int `json:"sonarqube_issue"`

	// Flaw has been detected from a Static Application Security Testing tool (SAST).
	StaticFinding *bool `json:"static_finding,omitempty"`

	// Text describing the steps that must be followed in order to reproduce the flaw / bug.
	StepsToReproduce *string   `json:"steps_to_reproduce"`
	Tags             *[]string `json:"tags,omitempty"`

	// The test that is associated with this flaw.
	Test     int `json:"test"`
	ThreadId int `json:"thread_id"`

	// A short description of the flaw.
	Title string `json:"title"`

	// Denotes if this finding is under defect review.
	UnderDefectReview *bool `json:"under_defect_review,omitempty"`

	// Denotes is this flaw is currently being reviewed.
	UnderReview *bool `json:"under_review,omitempty"`

	// Vulnerability technical id from the source tool. Allows to track unique vulnerabilities.
	UniqueIdFromTool *string `json:"unique_id_from_tool"`

	// External reference that provides more information about this flaw.
	Url *string `json:"url"`

	// Denotes if this flaw has been manually verified by the tester.
	Verified *bool `json:"verified,omitempty"`

	// Non-unique technical id from the source tool associated with the vulnerability type.
	VulnIdFromTool   *string            `json:"vuln_id_from_tool"`
	VulnerabilityIds *[]VulnerabilityId `json:"vulnerability_ids,omitempty"`
}

// Finding_Prefetch_DefectReviewRequestedBy defines model for Finding.Prefetch.DefectReviewRequestedBy.
type Finding_Prefetch_DefectReviewRequestedBy struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// Finding_Prefetch_DuplicateFinding defines model for Finding.Prefetch.DuplicateFinding.
type Finding_Prefetch_DuplicateFinding struct {
	AdditionalProperties map[string]Finding `json:"-"`
}

// Finding_Prefetch_EndpointSet defines model for Finding.Prefetch.EndpointSet.
type Finding_Prefetch_EndpointSet struct {
	AdditionalProperties map[string]Endpoint `json:"-"`
}

// Finding_Prefetch_Endpoints defines model for Finding.Prefetch.Endpoints.
type Finding_Prefetch_Endpoints struct {
	AdditionalProperties map[string]Endpoint `json:"-"`
}

// Finding_Prefetch_Files defines model for Finding.Prefetch.Files.
type Finding_Prefetch_Files struct {
	AdditionalProperties map[string]File `json:"-"`
}

// Finding_Prefetch_FindingGroupSet defines model for Finding.Prefetch.FindingGroupSet.
type Finding_Prefetch_FindingGroupSet struct {
	AdditionalProperties map[string]FindingGroup `json:"-"`
}

// Finding_Prefetch_FoundBy defines model for Finding.Prefetch.FoundBy.
type Finding_Prefetch_FoundBy struct {
	AdditionalProperties map[string]TestType `json:"-"`
}

// Finding_Prefetch_LastReviewedBy defines model for Finding.Prefetch.LastReviewedBy.
type Finding_Prefetch_LastReviewedBy struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// Finding_Prefetch_MitigatedBy defines model for Finding.Prefetch.MitigatedBy.
type Finding_Prefetch_MitigatedBy struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// Finding_Prefetch_Notes defines model for Finding.Prefetch.Notes.
type Finding_Prefetch_Notes struct {
	AdditionalProperties map[string]Note `json:"-"`
}

// Finding_Prefetch_Reporter defines model for Finding.Prefetch.Reporter.
type Finding_Prefetch_Reporter struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// Finding_Prefetch_ReviewRequestedBy defines model for Finding.Prefetch.ReviewRequestedBy.
type Finding_Prefetch_ReviewRequestedBy struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// Finding_Prefetch_Reviewers defines model for Finding.Prefetch.Reviewers.
type Finding_Prefetch_Reviewers struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// Finding_Prefetch_RiskAcceptanceSet defines model for Finding.Prefetch.RiskAcceptanceSet.
type Finding_Prefetch_RiskAcceptanceSet struct {
	AdditionalProperties map[string]RiskAcceptance `json:"-"`
}

// Finding_Prefetch_SonarqubeIssue defines model for Finding.Prefetch.SonarqubeIssue.
type Finding_Prefetch_SonarqubeIssue struct {
	AdditionalProperties map[string]SonarqubeIssue `json:"-"`
}

// Finding_Prefetch_Test defines model for Finding.Prefetch.Test.
type Finding_Prefetch_Test struct {
	AdditionalProperties map[string]Test `json:"-"`
}

// Finding_Prefetch_TestImportSet defines model for Finding.Prefetch.TestImportSet.
type Finding_Prefetch_TestImportSet struct {
	AdditionalProperties map[string]TestImport `json:"-"`
}

// FindingClose defines model for FindingClose.
type FindingClose struct {
	Duplicate   *bool      `json:"duplicate,omitempty"`
	FalseP      *bool      `json:"false_p,omitempty"`
	IsMitigated *bool      `json:"is_mitigated,omitempty"`
	Mitigated   *time.Time `json:"mitigated,omitempty"`
	OutOfScope  *bool      `json:"out_of_scope,omitempty"`
}

// FindingCloseRequest defines model for FindingCloseRequest.
type FindingCloseRequest struct {
	Duplicate   *bool      `json:"duplicate,omitempty"`
	FalseP      *bool      `json:"false_p,omitempty"`
	IsMitigated *bool      `json:"is_mitigated,omitempty"`
	Mitigated   *time.Time `json:"mitigated,omitempty"`
	OutOfScope  *bool      `json:"out_of_scope,omitempty"`
}

// FindingCreate defines model for FindingCreate.
type FindingCreate struct {
	// Denotes if this flaw is active or not.
	Active bool `json:"active"`

	// Name of the affected component (library name, part of a system, ...).
	ComponentName *string `json:"component_name"`

	// Version of the affected component.
	ComponentVersion *string `json:"component_version"`

	// The date the finding was created inside DefectDojo.
	Created *time.Time `json:"created"`

	// Common Vulnerability Scoring System version 3 (CVSSv3) score associated with this flaw.
	Cvssv3 *string `json:"cvssv3"`

	// Numerical CVSSv3 score for the vulnerability. If the vector is given, the score is updated while saving the finding
	Cvssv3Score *float64 `json:"cvssv3_score"`

	// The CWE number associated with this flaw.
	Cwe *int `json:"cwe"`

	// The date the flaw was discovered.
	Date *openapi_types.Date `json:"date,omitempty"`

	// Documents who requested a defect review for this flaw.
	DefectReviewRequestedBy *int `json:"defect_review_requested_by"`

	// Longer more descriptive information about the flaw.
	Description string `json:"description"`

	// Denotes if this flaw is a duplicate of other flaws reported.
	Duplicate *bool `json:"duplicate,omitempty"`

	// Link to the original finding if this finding is a duplicate.
	DuplicateFinding *int `json:"duplicate_finding"`

	// Flaw has been detected from a Dynamic Application Security Testing tool (DAST).
	DynamicFinding *bool `json:"dynamic_finding,omitempty"`

	// The hosts within the product that are susceptible to this flaw. + The status of the endpoint associated with this flaw (Vulnerable, Mitigated, ...).
	Endpoints []int `json:"endpoints"`

	// Denotes if this flaw has been deemed a false positive by the tester.
	FalseP *bool `json:"false_p,omitempty"`

	// Identified file(s) containing the flaw.
	FilePath *string `json:"file_path"`

	// Files(s) related to the flaw.
	Files   []int `json:"files"`
	FoundBy []int `json:"found_by"`

	// A hash over a configurable set of fields that is used for findings deduplication.
	HashCode *string `json:"hash_code"`
	Id       int     `json:"id"`

	// Text describing the impact this flaw has on systems, products, enterprise, etc.
	Impact *string `json:"impact"`

	// Denotes if this flaw has been fixed.
	IsMitigated *bool `json:"is_mitigated,omitempty"`

	// Provides the date the flaw was last 'touched' by a tester.
	LastReviewed *time.Time `json:"last_reviewed"`

	// Provides the person who last reviewed the flaw.
	LastReviewedBy *int `json:"last_reviewed_by"`

	// Timestamp of latest status update (change in status related fields).
	LastStatusUpdate *time.Time `json:"last_status_update"`

	// Source line number of the attack vector.
	Line *int `json:"line"`

	// Denotes if this flaw has been fixed by storing the date it was fixed.
	Mitigated *time.Time `json:"mitigated"`

	// Documents who has marked this flaw as fixed.
	MitigatedBy *int `json:"mitigated_by"`

	// Text describing how to best fix the flaw.
	Mitigation *string `json:"mitigation"`

	// Number of occurences in the source tool when several vulnerabilites were found and aggregated by the scanner.
	NbOccurences *int  `json:"nb_occurences"`
	Notes        []int `json:"notes"`

	// The numerical representation of the severity (S0, S1, S2, S3, S4).
	NumericalSeverity string `json:"numerical_severity"`

	// Denotes if this flaw falls outside the scope of the test and/or engagement.
	OutOfScope *bool `json:"out_of_scope,omitempty"`

	// Parameter used to trigger the issue (DAST).
	Param *string `json:"param"`

	// Payload used to attack the service / application and trigger the bug / problem.
	Payload *string `json:"payload"`

	// The date the flaw is expected to be remediated.
	PlannedRemediationDate *openapi_types.Date `json:"planned_remediation_date"`

	// Date when this vulnerability was made publicly available.
	PublishDate *openapi_types.Date `json:"publish_date"`
	PushToJira  *bool               `json:"push_to_jira,omitempty"`

	// The external documentation available for this flaw.
	References *string `json:"references"`
	Reporter   *int    `json:"reporter,omitempty"`

	// Documents who requested a review for this finding.
	ReviewRequestedBy *int `json:"review_requested_by"`

	// Documents who reviewed the flaw.
	Reviewers *[]int `json:"reviewers,omitempty"`

	// Denotes if this finding has been marked as an accepted risk.
	RiskAccepted *bool `json:"risk_accepted,omitempty"`

	// Sink object (variable, function...) of the attack vector.
	SastSinkObject *string `json:"sast_sink_object"`

	// Source file path of the attack vector.
	SastSourceFilePath *string `json:"sast_source_file_path"`

	// Source line number of the attack vector.
	SastSourceLine *int `json:"sast_source_line"`

	// Source object (variable, function...) of the attack vector.
	SastSourceObject *string `json:"sast_source_object"`

	// Confidence level of vulnerability which is supplied by the scanner.
	ScannerConfidence *int `json:"scanner_confidence"`

	// A service is a self-contained piece of functionality within a Product. This is an optional field which is used in deduplication of findings when set.
	Service *string `json:"service"`

	// The severity level of this flaw (Critical, High, Medium, Low, Informational).
	Severity string `json:"severity"`

	// Text describing why a certain severity was associated with this flaw.
	SeverityJustification *string `json:"severity_justification"`

	// (readonly)The date used as start date for SLA calculation. Set by expiring risk acceptances. Empty by default, causing a fallback to 'date'.
	SlaStartDate *openapi_types.Date `json:"sla_start_date"`

	// The SonarQube issue associated with this finding.
	SonarqubeIssue *int `json:"sonarqube_issue"`

	// Flaw has been detected from a Static Application Security Testing tool (SAST).
	StaticFinding *bool `json:"static_finding,omitempty"`

	// Text describing the steps that must be followed in order to reproduce the flaw / bug.
	StepsToReproduce *string   `json:"steps_to_reproduce"`
	Tags             *[]string `json:"tags,omitempty"`
	Test             int       `json:"test"`
	ThreadId         *int      `json:"thread_id,omitempty"`

	// A short description of the flaw.
	Title string `json:"title"`

	// Denotes if this finding is under defect review.
	UnderDefectReview *bool `json:"under_defect_review,omitempty"`

	// Denotes is this flaw is currently being reviewed.
	UnderReview *bool `json:"under_review,omitempty"`

	// Vulnerability technical id from the source tool. Allows to track unique vulnerabilities.
	UniqueIdFromTool *string `json:"unique_id_from_tool"`
	Url              *string `json:"url"`

	// Denotes if this flaw has been manually verified by the tester.
	Verified bool `json:"verified"`

	// Non-unique technical id from the source tool associated with the vulnerability type.
	VulnIdFromTool   *string            `json:"vuln_id_from_tool"`
	VulnerabilityIds *[]VulnerabilityId `json:"vulnerability_ids,omitempty"`
}

// FindingCreateRequest defines model for FindingCreateRequest.
type FindingCreateRequest struct {
	// Denotes if this flaw is active or not.
	Active bool `json:"active"`

	// Name of the affected component (library name, part of a system, ...).
	ComponentName *string `json:"component_name"`

	// Version of the affected component.
	ComponentVersion *string `json:"component_version"`

	// Common Vulnerability Scoring System version 3 (CVSSv3) score associated with this flaw.
	Cvssv3 *string `json:"cvssv3"`

	// Numerical CVSSv3 score for the vulnerability. If the vector is given, the score is updated while saving the finding
	Cvssv3Score *float64 `json:"cvssv3_score"`

	// The CWE number associated with this flaw.
	Cwe *int `json:"cwe"`

	// The date the flaw was discovered.
	Date *openapi_types.Date `json:"date,omitempty"`

	// Documents who requested a defect review for this flaw.
	DefectReviewRequestedBy *int `json:"defect_review_requested_by"`

	// Longer more descriptive information about the flaw.
	Description string `json:"description"`

	// Denotes if this flaw is a duplicate of other flaws reported.
	Duplicate *bool `json:"duplicate,omitempty"`

	// Flaw has been detected from a Dynamic Application Security Testing tool (DAST).
	DynamicFinding *bool `json:"dynamic_finding,omitempty"`

	// Denotes if this flaw has been deemed a false positive by the tester.
	FalseP *bool `json:"false_p,omitempty"`

	// Identified file(s) containing the flaw.
	FilePath *string `json:"file_path"`
	FoundBy  []int   `json:"found_by"`

	// Text describing the impact this flaw has on systems, products, enterprise, etc.
	Impact *string `json:"impact"`

	// Denotes if this flaw has been fixed.
	IsMitigated *bool `json:"is_mitigated,omitempty"`

	// Source line number of the attack vector.
	Line *int `json:"line"`

	// Text describing how to best fix the flaw.
	Mitigation *string `json:"mitigation"`

	// Number of occurences in the source tool when several vulnerabilites were found and aggregated by the scanner.
	NbOccurences *int `json:"nb_occurences"`

	// The numerical representation of the severity (S0, S1, S2, S3, S4).
	NumericalSeverity string `json:"numerical_severity"`

	// Denotes if this flaw falls outside the scope of the test and/or engagement.
	OutOfScope *bool `json:"out_of_scope,omitempty"`

	// The date the flaw is expected to be remediated.
	PlannedRemediationDate *openapi_types.Date `json:"planned_remediation_date"`

	// Date when this vulnerability was made publicly available.
	PublishDate *openapi_types.Date `json:"publish_date"`
	PushToJira  *bool               `json:"push_to_jira,omitempty"`

	// The external documentation available for this flaw.
	References *string `json:"references"`
	Reporter   *int    `json:"reporter,omitempty"`

	// Documents who requested a review for this finding.
	ReviewRequestedBy *int `json:"review_requested_by"`

	// Documents who reviewed the flaw.
	Reviewers *[]int `json:"reviewers,omitempty"`

	// Denotes if this finding has been marked as an accepted risk.
	RiskAccepted *bool `json:"risk_accepted,omitempty"`

	// Sink object (variable, function...) of the attack vector.
	SastSinkObject *string `json:"sast_sink_object"`

	// Source file path of the attack vector.
	SastSourceFilePath *string `json:"sast_source_file_path"`

	// Source line number of the attack vector.
	SastSourceLine *int `json:"sast_source_line"`

	// Source object (variable, function...) of the attack vector.
	SastSourceObject *string `json:"sast_source_object"`

	// A service is a self-contained piece of functionality within a Product. This is an optional field which is used in deduplication of findings when set.
	Service *string `json:"service"`

	// The severity level of this flaw (Critical, High, Medium, Low, Informational).
	Severity string `json:"severity"`

	// Text describing why a certain severity was associated with this flaw.
	SeverityJustification *string `json:"severity_justification"`

	// (readonly)The date used as start date for SLA calculation. Set by expiring risk acceptances. Empty by default, causing a fallback to 'date'.
	SlaStartDate *openapi_types.Date `json:"sla_start_date"`

	// The SonarQube issue associated with this finding.
	SonarqubeIssue *int `json:"sonarqube_issue"`

	// Flaw has been detected from a Static Application Security Testing tool (SAST).
	StaticFinding *bool `json:"static_finding,omitempty"`

	// Text describing the steps that must be followed in order to reproduce the flaw / bug.
	StepsToReproduce *string   `json:"steps_to_reproduce"`
	Tags             *[]string `json:"tags,omitempty"`
	Test             int       `json:"test"`
	ThreadId         *int      `json:"thread_id,omitempty"`

	// A short description of the flaw.
	Title string `json:"title"`

	// Denotes if this finding is under defect review.
	UnderDefectReview *bool `json:"under_defect_review,omitempty"`

	// Denotes is this flaw is currently being reviewed.
	UnderReview *bool `json:"under_review,omitempty"`

	// Vulnerability technical id from the source tool. Allows to track unique vulnerabilities.
	UniqueIdFromTool *string `json:"unique_id_from_tool"`
	Url              *string `json:"url"`

	// Denotes if this flaw has been manually verified by the tester.
	Verified bool `json:"verified"`

	// Non-unique technical id from the source tool associated with the vulnerability type.
	VulnIdFromTool   *string                   `json:"vuln_id_from_tool"`
	VulnerabilityIds *[]VulnerabilityIdRequest `json:"vulnerability_ids,omitempty"`
}

// FindingEngagement defines model for FindingEngagement.
type FindingEngagement struct {
	// Tag or branch of the product the engagement tested.
	BranchTag *string `json:"branch_tag"`

	// Build ID of the product the engagement tested.
	BuildId *string `json:"build_id"`

	// Commit hash from repo
	CommitHash *string         `json:"commit_hash"`
	Id         int             `json:"id"`
	Name       *string         `json:"name"`
	Product    *FindingProduct `json:"product,omitempty"`

	// Version of the product the engagement tested.
	Version *string `json:"version"`
}

// FindingEnvironment defines model for FindingEnvironment.
type FindingEnvironment struct {
	Id   int    `json:"id"`
	Name string `json:"name"`
}

// FindingGroup defines model for FindingGroup.
type FindingGroup struct {
	Id        int `json:"id"`
	JiraIssue struct {
		// Embedded struct due to allOf(#/components/schemas/JIRAIssue)
		JIRAIssue `yaml:",inline"`
	} `json:"jira_issue"`
	Name string `json:"name"`
	Test int    `json:"test"`
}

// FindingMeta defines model for FindingMeta.
type FindingMeta struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// FindingMetaRequest defines model for FindingMetaRequest.
type FindingMetaRequest struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// FindingProdType defines model for FindingProdType.
type FindingProdType struct {
	Id   int    `json:"id"`
	Name string `json:"name"`
}

// FindingProduct defines model for FindingProduct.
type FindingProduct struct {
	Id       int              `json:"id"`
	Name     string           `json:"name"`
	ProdType *FindingProdType `json:"prod_type,omitempty"`
}

// FindingRelatedFields defines model for FindingRelatedFields.
type FindingRelatedFields struct {
	Jira struct {
		// Embedded struct due to allOf(#/components/schemas/JIRAIssue)
		JIRAIssue `yaml:",inline"`
	} `json:"jira"`
	Test struct {
		// Embedded struct due to allOf(#/components/schemas/FindingTest)
		FindingTest `yaml:",inline"`
	} `json:"test"`
}

// FindingRequest defines model for FindingRequest.
type FindingRequest struct {
	// Denotes if this flaw is active or not.
	Active *bool `json:"active,omitempty"`

	// Name of the affected component (library name, part of a system, ...).
	ComponentName *string `json:"component_name"`

	// Version of the affected component.
	ComponentVersion *string `json:"component_version"`

	// Common Vulnerability Scoring System version 3 (CVSSv3) score associated with this flaw.
	Cvssv3 *string `json:"cvssv3"`

	// Numerical CVSSv3 score for the vulnerability. If the vector is given, the score is updated while saving the finding
	Cvssv3Score *float64 `json:"cvssv3_score"`

	// The CWE number associated with this flaw.
	Cwe *int `json:"cwe"`

	// The date the flaw was discovered.
	Date *openapi_types.Date `json:"date,omitempty"`

	// Documents who requested a defect review for this flaw.
	DefectReviewRequestedBy *int `json:"defect_review_requested_by"`

	// Longer more descriptive information about the flaw.
	Description string `json:"description"`

	// Denotes if this flaw is a duplicate of other flaws reported.
	Duplicate *bool `json:"duplicate,omitempty"`

	// Flaw has been detected from a Dynamic Application Security Testing tool (DAST).
	DynamicFinding *bool `json:"dynamic_finding,omitempty"`

	// Denotes if this flaw has been deemed a false positive by the tester.
	FalseP *bool `json:"false_p,omitempty"`

	// Identified file(s) containing the flaw.
	FilePath *string `json:"file_path"`

	// Text describing the impact this flaw has on systems, products, enterprise, etc.
	Impact *string `json:"impact"`

	// Denotes if this flaw has been fixed.
	IsMitigated *bool `json:"is_mitigated,omitempty"`

	// Source line number of the attack vector.
	Line *int `json:"line"`

	// Text describing how to best fix the flaw.
	Mitigation *string `json:"mitigation"`

	// Number of occurences in the source tool when several vulnerabilites were found and aggregated by the scanner.
	NbOccurences *int `json:"nb_occurences"`

	// The numerical representation of the severity (S0, S1, S2, S3, S4).
	NumericalSeverity string `json:"numerical_severity"`

	// Denotes if this flaw falls outside the scope of the test and/or engagement.
	OutOfScope *bool `json:"out_of_scope,omitempty"`

	// The date the flaw is expected to be remediated.
	PlannedRemediationDate *openapi_types.Date `json:"planned_remediation_date"`

	// Date when this vulnerability was made publicly available.
	PublishDate *openapi_types.Date `json:"publish_date"`
	PushToJira  *bool               `json:"push_to_jira,omitempty"`

	// The external documentation available for this flaw.
	References *string `json:"references"`

	// Documents who requested a review for this finding.
	ReviewRequestedBy *int `json:"review_requested_by"`

	// Documents who reviewed the flaw.
	Reviewers *[]int `json:"reviewers,omitempty"`

	// Denotes if this finding has been marked as an accepted risk.
	RiskAccepted *bool `json:"risk_accepted,omitempty"`

	// Sink object (variable, function...) of the attack vector.
	SastSinkObject *string `json:"sast_sink_object"`

	// Source file path of the attack vector.
	SastSourceFilePath *string `json:"sast_source_file_path"`

	// Source line number of the attack vector.
	SastSourceLine *int `json:"sast_source_line"`

	// Source object (variable, function...) of the attack vector.
	SastSourceObject *string `json:"sast_source_object"`

	// A service is a self-contained piece of functionality within a Product. This is an optional field which is used in deduplication of findings when set.
	Service *string `json:"service"`

	// The severity level of this flaw (Critical, High, Medium, Low, Informational).
	Severity string `json:"severity"`

	// Text describing why a certain severity was associated with this flaw.
	SeverityJustification *string `json:"severity_justification"`

	// (readonly)The date used as start date for SLA calculation. Set by expiring risk acceptances. Empty by default, causing a fallback to 'date'.
	SlaStartDate *openapi_types.Date `json:"sla_start_date"`

	// The SonarQube issue associated with this finding.
	SonarqubeIssue *int `json:"sonarqube_issue"`

	// Flaw has been detected from a Static Application Security Testing tool (SAST).
	StaticFinding *bool `json:"static_finding,omitempty"`

	// Text describing the steps that must be followed in order to reproduce the flaw / bug.
	StepsToReproduce *string   `json:"steps_to_reproduce"`
	Tags             *[]string `json:"tags,omitempty"`

	// A short description of the flaw.
	Title string `json:"title"`

	// Denotes if this finding is under defect review.
	UnderDefectReview *bool `json:"under_defect_review,omitempty"`

	// Denotes is this flaw is currently being reviewed.
	UnderReview *bool `json:"under_review,omitempty"`

	// Vulnerability technical id from the source tool. Allows to track unique vulnerabilities.
	UniqueIdFromTool *string `json:"unique_id_from_tool"`

	// Denotes if this flaw has been manually verified by the tester.
	Verified *bool `json:"verified,omitempty"`

	// Non-unique technical id from the source tool associated with the vulnerability type.
	VulnIdFromTool   *string                   `json:"vuln_id_from_tool"`
	VulnerabilityIds *[]VulnerabilityIdRequest `json:"vulnerability_ids,omitempty"`
}

// FindingTemplate defines model for FindingTemplate.
type FindingTemplate struct {
	Cvssv3            *string    `json:"cvssv3"`
	Cwe               *int       `json:"cwe"`
	Description       *string    `json:"description"`
	Id                int        `json:"id"`
	Impact            *string    `json:"impact"`
	LastUsed          *time.Time `json:"last_used"`
	Mitigation        *string    `json:"mitigation"`
	NumericalSeverity *string    `json:"numerical_severity"`
	References        *string    `json:"references"`
	Severity          *string    `json:"severity"`
	Tags              *[]string  `json:"tags,omitempty"`

	// Enables this template for matching remediation advice. Match will be applied to all active, verified findings by CWE.
	TemplateMatch *bool `json:"template_match,omitempty"`

	// Matches by title text (contains search) and CWE.
	TemplateMatchTitle *bool                      `json:"template_match_title,omitempty"`
	Title              string                     `json:"title"`
	VulnerabilityIds   *[]VulnerabilityIdTemplate `json:"vulnerability_ids,omitempty"`
}

// FindingTemplateRequest defines model for FindingTemplateRequest.
type FindingTemplateRequest struct {
	Cvssv3      *string   `json:"cvssv3"`
	Cwe         *int      `json:"cwe"`
	Description *string   `json:"description"`
	Impact      *string   `json:"impact"`
	Mitigation  *string   `json:"mitigation"`
	References  *string   `json:"references"`
	Severity    *string   `json:"severity"`
	Tags        *[]string `json:"tags,omitempty"`

	// Enables this template for matching remediation advice. Match will be applied to all active, verified findings by CWE.
	TemplateMatch *bool `json:"template_match,omitempty"`

	// Matches by title text (contains search) and CWE.
	TemplateMatchTitle *bool                             `json:"template_match_title,omitempty"`
	Title              string                            `json:"title"`
	VulnerabilityIds   *[]VulnerabilityIdTemplateRequest `json:"vulnerability_ids,omitempty"`
}

// FindingTest defines model for FindingTest.
type FindingTest struct {
	// Tag or branch that was tested, a reimport may update this field.
	BranchTag *string `json:"branch_tag"`

	// Build ID that was tested, a reimport may update this field.
	BuildId *string `json:"build_id"`

	// Commit hash tested, a reimport may update this field.
	CommitHash  *string             `json:"commit_hash"`
	Engagement  *FindingEngagement  `json:"engagement,omitempty"`
	Environment *FindingEnvironment `json:"environment,omitempty"`
	Id          int                 `json:"id"`
	TestType    *FindingTestType    `json:"test_type,omitempty"`
	Title       *string             `json:"title"`
	Version     *string             `json:"version"`
}

// FindingTestType defines model for FindingTestType.
type FindingTestType struct {
	Id   int    `json:"id"`
	Name string `json:"name"`
}

// FindingToFiles defines model for FindingToFiles.
type FindingToFiles struct {
	Files     []File `json:"files"`
	FindingId *int   `json:"finding_id"`
}

// FindingToNotes defines model for FindingToNotes.
type FindingToNotes struct {
	FindingId *int   `json:"finding_id"`
	Notes     []Note `json:"notes"`
}

// GlobalRole defines model for GlobalRole.
type GlobalRole struct {
	Group *int `json:"group"`
	Id    int  `json:"id"`

	// The global role will be applied to all product types and products.
	Role *int `json:"role"`
	User *int `json:"user"`
}

// GlobalRoleRequest defines model for GlobalRoleRequest.
type GlobalRoleRequest struct {
	Group *int `json:"group"`

	// The global role will be applied to all product types and products.
	Role *int `json:"role"`
	User *int `json:"user"`
}

// ImportLanguages defines model for ImportLanguages.
type ImportLanguages struct {
	File    string `json:"file"`
	Product int    `json:"product"`
}

// ImportLanguagesRequest defines model for ImportLanguagesRequest.
type ImportLanguagesRequest struct {
	File    string `json:"file"`
	Product int    `json:"product"`
}

// ImportScan defines model for ImportScan.
type ImportScan struct {
	// Select if these findings are currently active.
	Active               *bool `json:"active,omitempty"`
	ApiScanConfiguration *int  `json:"api_scan_configuration"`
	AutoCreateContext    *bool `json:"auto_create_context,omitempty"`

	// Branch or Tag that was scanned.
	BranchTag *string `json:"branch_tag,omitempty"`

	// ID of the build that was scanned.
	BuildId *string `json:"build_id,omitempty"`

	// Select if old findings no longer present in the report get closed as mitigated when importing. If service has been set, only the findings for this service will be closed.
	CloseOldFindings *bool `json:"close_old_findings,omitempty"`

	// Select if close_old_findings applies to all findings of the same type in the product. By default, it is false meaning that only old findings of the same type in the engagement are in scope.
	CloseOldFindingsProductScope *bool `json:"close_old_findings_product_scope,omitempty"`

	// Commit that was scanned.
	CommitHash *string `json:"commit_hash,omitempty"`

	// If set to false, finding groups will only be created when there is more than one grouped finding
	CreateFindingGroupsForAllFindings *bool `json:"create_finding_groups_for_all_findings,omitempty"`
	DeduplicationOnEngagement         *bool `json:"deduplication_on_engagement,omitempty"`

	// The IP address, host name or full URL. It must be valid
	EndpointToAdd *int `json:"endpoint_to_add,omitempty"`
	Engagement    *int `json:"engagement,omitempty"`

	// End Date for Engagement. Default is current time + 365 days. Required format year-month-day
	EngagementEndDate *openapi_types.Date `json:"engagement_end_date,omitempty"`
	EngagementId      int                 `json:"engagement_id"`
	EngagementName    *string             `json:"engagement_name,omitempty"`
	Environment       *string             `json:"environment,omitempty"`
	File              *string             `json:"file,omitempty"`

	// Choose an option to automatically group new findings by the chosen option.
	GroupBy *ImportScanGroupBy `json:"group_by,omitempty"`
	Lead    *int               `json:"lead"`

	// Minimum severity level to be imported
	MinimumSeverity *ImportScanMinimumSeverity `json:"minimum_severity,omitempty"`
	ProductId       int                        `json:"product_id"`
	ProductName     *string                    `json:"product_name,omitempty"`
	ProductTypeId   int                        `json:"product_type_id"`
	ProductTypeName *string                    `json:"product_type_name,omitempty"`
	PushToJira      *bool                      `json:"push_to_jira,omitempty"`

	// Scan completion date will be used on all findings.
	ScanDate *openapi_types.Date `json:"scan_date,omitempty"`
	ScanType ImportScanScanType  `json:"scan_type"`

	// A service is a self-contained piece of functionality within a Product. This is an optional field which is used in deduplication and closing of old findings when set. This affects the whole engagement/product depending on your deduplication scope.
	Service *string `json:"service,omitempty"`

	// Resource link to source code
	SourceCodeManagementUri *string `json:"source_code_management_uri,omitempty"`
	Statistics              struct {
		// Embedded struct due to allOf(#/components/schemas/ImportStatistics)
		ImportStatistics `yaml:",inline"`
	} `json:"statistics"`

	// Add tags that help describe this scan.
	Tags      *[]string `json:"tags,omitempty"`
	Test      int       `json:"test"`
	TestId    int       `json:"test_id"`
	TestTitle *string   `json:"test_title,omitempty"`

	// Select if these findings have been verified.
	Verified *bool `json:"verified,omitempty"`

	// Version that was scanned.
	Version *string `json:"version,omitempty"`
}

// Choose an option to automatically group new findings by the chosen option.
type ImportScanGroupBy string

// Minimum severity level to be imported
type ImportScanMinimumSeverity string

// ImportScanScanType defines model for ImportScan.ScanType.
type ImportScanScanType string

// ImportScanRequest defines model for ImportScanRequest.
type ImportScanRequest struct {
	// Select if these findings are currently active.
	Active               *bool `json:"active,omitempty"`
	ApiScanConfiguration *int  `json:"api_scan_configuration"`
	AutoCreateContext    *bool `json:"auto_create_context,omitempty"`

	// Branch or Tag that was scanned.
	BranchTag *string `json:"branch_tag,omitempty"`

	// ID of the build that was scanned.
	BuildId *string `json:"build_id,omitempty"`

	// Select if old findings no longer present in the report get closed as mitigated when importing. If service has been set, only the findings for this service will be closed.
	CloseOldFindings *bool `json:"close_old_findings,omitempty"`

	// Select if close_old_findings applies to all findings of the same type in the product. By default, it is false meaning that only old findings of the same type in the engagement are in scope.
	CloseOldFindingsProductScope *bool `json:"close_old_findings_product_scope,omitempty"`

	// Commit that was scanned.
	CommitHash *string `json:"commit_hash,omitempty"`

	// If set to false, finding groups will only be created when there is more than one grouped finding
	CreateFindingGroupsForAllFindings *bool `json:"create_finding_groups_for_all_findings,omitempty"`
	DeduplicationOnEngagement         *bool `json:"deduplication_on_engagement,omitempty"`

	// The IP address, host name or full URL. It must be valid
	EndpointToAdd *int `json:"endpoint_to_add,omitempty"`
	Engagement    *int `json:"engagement,omitempty"`

	// End Date for Engagement. Default is current time + 365 days. Required format year-month-day
	EngagementEndDate *openapi_types.Date `json:"engagement_end_date,omitempty"`
	EngagementName    *string             `json:"engagement_name,omitempty"`
	Environment       *string             `json:"environment,omitempty"`
	File              *string             `json:"file,omitempty"`

	// Choose an option to automatically group new findings by the chosen option.
	GroupBy *ImportScanRequestGroupBy `json:"group_by,omitempty"`
	Lead    *int                      `json:"lead"`

	// Minimum severity level to be imported
	MinimumSeverity *ImportScanRequestMinimumSeverity `json:"minimum_severity,omitempty"`
	ProductName     *string                           `json:"product_name,omitempty"`
	ProductTypeName *string                           `json:"product_type_name,omitempty"`
	PushToJira      *bool                             `json:"push_to_jira,omitempty"`

	// Scan completion date will be used on all findings.
	ScanDate *openapi_types.Date       `json:"scan_date,omitempty"`
	ScanType ImportScanRequestScanType `json:"scan_type"`

	// A service is a self-contained piece of functionality within a Product. This is an optional field which is used in deduplication and closing of old findings when set. This affects the whole engagement/product depending on your deduplication scope.
	Service *string `json:"service,omitempty"`

	// Resource link to source code
	SourceCodeManagementUri *string `json:"source_code_management_uri,omitempty"`

	// Add tags that help describe this scan.
	Tags      *[]string `json:"tags,omitempty"`
	TestTitle *string   `json:"test_title,omitempty"`

	// Select if these findings have been verified.
	Verified *bool `json:"verified,omitempty"`

	// Version that was scanned.
	Version *string `json:"version,omitempty"`
}

// Choose an option to automatically group new findings by the chosen option.
type ImportScanRequestGroupBy string

// Minimum severity level to be imported
type ImportScanRequestMinimumSeverity string

// ImportScanRequestScanType defines model for ImportScanRequest.ScanType.
type ImportScanRequestScanType string

// ImportStatistics defines model for ImportStatistics.
type ImportStatistics struct {
	// Finding statistics as stored in Defect Dojo after the import
	After struct {
		// Embedded struct due to allOf(#/components/schemas/SeverityStatusStatistics)
		SeverityStatusStatistics `yaml:",inline"`
	} `json:"after"`

	// Finding statistics as stored in Defect Dojo before the import
	Before *struct {
		// Embedded struct due to allOf(#/components/schemas/SeverityStatusStatistics)
		SeverityStatusStatistics `yaml:",inline"`
	} `json:"before,omitempty"`

	// Finding statistics of modifications made by the reimport. Only available when TRACK_IMPORT_HISTORY hass not disabled.
	Delta *struct {
		// Embedded struct due to allOf(#/components/schemas/DeltaStatistics)
		DeltaStatistics `yaml:",inline"`
	} `json:"delta,omitempty"`
}

// JIRAInstance defines model for JIRAInstance.
type JIRAInstance struct {
	// JIRA resolution names (comma-separated values) that maps to an Accepted Finding
	AcceptedMappingResolution *string `json:"accepted_mapping_resolution"`

	// Transition ID to Close JIRA issues, visit https://<YOUR JIRA URL>/rest/api/latest/issue/<ANY VALID ISSUE KEY>/transitions?expand=transitions.fields to find the ID for your JIRA instance
	CloseStatusKey int `json:"close_status_key"`

	// Enter a name to give to this configuration
	ConfigurationName *string `json:"configuration_name,omitempty"`

	// Maps to the 'Priority' field in Jira. For example: Critical
	CriticalMappingSeverity string `json:"critical_mapping_severity"`

	// You can define extra issue types in settings.py
	DefaultIssueType *JIRAInstanceDefaultIssueType `json:"default_issue_type,omitempty"`

	// To obtain the 'Epic name id' visit https://<YOUR JIRA URL>/rest/api/2/field and search for Epic Name. Copy the number out of cf[number] and paste it here.
	EpicNameId int `json:"epic_name_id"`

	// JIRA resolution names (comma-separated values) that maps to a False Positive Finding
	FalsePositiveMappingResolution *string `json:"false_positive_mapping_resolution"`

	// Additional text that will be added to the finding in Jira. For example including how the finding was created or who to contact for more information.
	FindingText *string `json:"finding_text"`

	// This setting can be overidden at the Product level
	GlobalJiraSlaNotification *bool `json:"global_jira_sla_notification,omitempty"`

	// Maps to the 'Priority' field in Jira. For example: High
	HighMappingSeverity string `json:"high_mapping_severity"`
	Id                  int    `json:"id"`

	// Maps to the 'Priority' field in Jira. For example: Info
	InfoMappingSeverity string `json:"info_mapping_severity"`

	// Choose the folder containing the Django templates used to render the JIRA issue description. These are stored in dojo/templates/issue-trackers. Leave empty to use the default jira_full templates.
	IssueTemplateDir *string `json:"issue_template_dir"`

	// Maps to the 'Priority' field in Jira. For example: Low
	LowMappingSeverity string `json:"low_mapping_severity"`

	// Maps to the 'Priority' field in Jira. For example: Medium
	MediumMappingSeverity string `json:"medium_mapping_severity"`

	// Transition ID to Re-Open JIRA issues, visit https://<YOUR JIRA URL>/rest/api/latest/issue/<ANY VALID ISSUE KEY>/transitions?expand=transitions.fields to find the ID for your JIRA instance
	OpenStatusKey int `json:"open_status_key"`

	// For more information how to configure Jira, read the DefectDojo documentation.
	Url      string `json:"url"`
	Username string `json:"username"`
}

// You can define extra issue types in settings.py
type JIRAInstanceDefaultIssueType string

// JIRAInstanceRequest defines model for JIRAInstanceRequest.
type JIRAInstanceRequest struct {
	// JIRA resolution names (comma-separated values) that maps to an Accepted Finding
	AcceptedMappingResolution *string `json:"accepted_mapping_resolution"`

	// Transition ID to Close JIRA issues, visit https://<YOUR JIRA URL>/rest/api/latest/issue/<ANY VALID ISSUE KEY>/transitions?expand=transitions.fields to find the ID for your JIRA instance
	CloseStatusKey int `json:"close_status_key"`

	// Enter a name to give to this configuration
	ConfigurationName *string `json:"configuration_name,omitempty"`

	// Maps to the 'Priority' field in Jira. For example: Critical
	CriticalMappingSeverity string `json:"critical_mapping_severity"`

	// You can define extra issue types in settings.py
	DefaultIssueType *JIRAInstanceRequestDefaultIssueType `json:"default_issue_type,omitempty"`

	// To obtain the 'Epic name id' visit https://<YOUR JIRA URL>/rest/api/2/field and search for Epic Name. Copy the number out of cf[number] and paste it here.
	EpicNameId int `json:"epic_name_id"`

	// JIRA resolution names (comma-separated values) that maps to a False Positive Finding
	FalsePositiveMappingResolution *string `json:"false_positive_mapping_resolution"`

	// Additional text that will be added to the finding in Jira. For example including how the finding was created or who to contact for more information.
	FindingText *string `json:"finding_text"`

	// This setting can be overidden at the Product level
	GlobalJiraSlaNotification *bool `json:"global_jira_sla_notification,omitempty"`

	// Maps to the 'Priority' field in Jira. For example: High
	HighMappingSeverity string `json:"high_mapping_severity"`

	// Maps to the 'Priority' field in Jira. For example: Info
	InfoMappingSeverity string `json:"info_mapping_severity"`

	// Choose the folder containing the Django templates used to render the JIRA issue description. These are stored in dojo/templates/issue-trackers. Leave empty to use the default jira_full templates.
	IssueTemplateDir *string `json:"issue_template_dir"`

	// Maps to the 'Priority' field in Jira. For example: Low
	LowMappingSeverity string `json:"low_mapping_severity"`

	// Maps to the 'Priority' field in Jira. For example: Medium
	MediumMappingSeverity string `json:"medium_mapping_severity"`

	// Transition ID to Re-Open JIRA issues, visit https://<YOUR JIRA URL>/rest/api/latest/issue/<ANY VALID ISSUE KEY>/transitions?expand=transitions.fields to find the ID for your JIRA instance
	OpenStatusKey int    `json:"open_status_key"`
	Password      string `json:"password"`

	// For more information how to configure Jira, read the DefectDojo documentation.
	Url      string `json:"url"`
	Username string `json:"username"`
}

// You can define extra issue types in settings.py
type JIRAInstanceRequestDefaultIssueType string

// JIRAIssue defines model for JIRAIssue.
type JIRAIssue struct {
	Engagement   *int `json:"engagement"`
	Finding      *int `json:"finding"`
	FindingGroup *int `json:"finding_group"`
	Id           int  `json:"id"`

	// The date the linked Jira issue was last modified.
	JiraChange *time.Time `json:"jira_change"`

	// The date a Jira issue was created from this finding.
	JiraCreation *time.Time `json:"jira_creation"`
	JiraId       string     `json:"jira_id"`
	JiraKey      string     `json:"jira_key"`
	JiraProject  *int       `json:"jira_project"`
	Url          string     `json:"url"`
}

// JIRAIssueRequest defines model for JIRAIssueRequest.
type JIRAIssueRequest struct {
	Engagement   *int `json:"engagement"`
	Finding      *int `json:"finding"`
	FindingGroup *int `json:"finding_group"`

	// The date the linked Jira issue was last modified.
	JiraChange *time.Time `json:"jira_change"`

	// The date a Jira issue was created from this finding.
	JiraCreation *time.Time `json:"jira_creation"`
	JiraId       string     `json:"jira_id"`
	JiraKey      string     `json:"jira_key"`
	JiraProject  *int       `json:"jira_project"`
}

// JIRAProject defines model for JIRAProject.
type JIRAProject struct {
	AddVulnerabilityIdToJiraLabel *bool   `json:"add_vulnerability_id_to_jira_label,omitempty"`
	Component                     *string `json:"component,omitempty"`

	// JIRA custom field JSON mapping of Id to value, e.g. {"customfield_10122": [{"name": "8.0.1"}]}
	CustomFields *JIRAProject_CustomFields `json:"custom_fields"`

	// JIRA default assignee (name). If left blank then it defaults to whatever is configured in JIRA.
	DefaultAssignee             *string `json:"default_assignee"`
	EnableEngagementEpicMapping *bool   `json:"enable_engagement_epic_mapping,omitempty"`
	Engagement                  *int    `json:"engagement"`
	Id                          int     `json:"id"`

	// Choose the folder containing the Django templates used to render the JIRA issue description. These are stored in dojo/templates/issue-trackers. Leave empty to use the default jira_full templates.
	IssueTemplateDir *string `json:"issue_template_dir"`
	JiraInstance     *int    `json:"jira_instance"`

	// JIRA issue labels space seperated
	JiraLabels                 *string `json:"jira_labels"`
	Product                    *int    `json:"product"`
	ProductJiraSlaNotification *bool   `json:"product_jira_sla_notification,omitempty"`
	ProjectKey                 *string `json:"project_key,omitempty"`

	// Automatically maintain parity with JIRA. Always create and update JIRA tickets for findings in this Product.
	PushAllIssues                        *bool `json:"push_all_issues,omitempty"`
	PushNotes                            *bool `json:"push_notes,omitempty"`
	RiskAcceptanceExpirationNotification *bool `json:"risk_acceptance_expiration_notification,omitempty"`
}

// JIRA custom field JSON mapping of Id to value, e.g. {"customfield_10122": [{"name": "8.0.1"}]}
type JIRAProject_CustomFields struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// JIRAProjectRequest defines model for JIRAProjectRequest.
type JIRAProjectRequest struct {
	AddVulnerabilityIdToJiraLabel *bool   `json:"add_vulnerability_id_to_jira_label,omitempty"`
	Component                     *string `json:"component,omitempty"`

	// JIRA custom field JSON mapping of Id to value, e.g. {"customfield_10122": [{"name": "8.0.1"}]}
	CustomFields *JIRAProjectRequest_CustomFields `json:"custom_fields"`

	// JIRA default assignee (name). If left blank then it defaults to whatever is configured in JIRA.
	DefaultAssignee             *string `json:"default_assignee"`
	EnableEngagementEpicMapping *bool   `json:"enable_engagement_epic_mapping,omitempty"`
	Engagement                  *int    `json:"engagement"`

	// Choose the folder containing the Django templates used to render the JIRA issue description. These are stored in dojo/templates/issue-trackers. Leave empty to use the default jira_full templates.
	IssueTemplateDir *string `json:"issue_template_dir"`
	JiraInstance     *int    `json:"jira_instance"`

	// JIRA issue labels space seperated
	JiraLabels                 *string `json:"jira_labels"`
	Product                    *int    `json:"product"`
	ProductJiraSlaNotification *bool   `json:"product_jira_sla_notification,omitempty"`
	ProjectKey                 *string `json:"project_key,omitempty"`

	// Automatically maintain parity with JIRA. Always create and update JIRA tickets for findings in this Product.
	PushAllIssues                        *bool `json:"push_all_issues,omitempty"`
	PushNotes                            *bool `json:"push_notes,omitempty"`
	RiskAcceptanceExpirationNotification *bool `json:"risk_acceptance_expiration_notification,omitempty"`
}

// JIRA custom field JSON mapping of Id to value, e.g. {"customfield_10122": [{"name": "8.0.1"}]}
type JIRAProjectRequest_CustomFields struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Language defines model for Language.
type Language struct {
	Blank    *int      `json:"blank"`
	Code     *int      `json:"code"`
	Comment  *int      `json:"comment"`
	Created  time.Time `json:"created"`
	Files    *int      `json:"files"`
	Id       int       `json:"id"`
	Language int       `json:"language"`
	Prefetch *struct {
		Language *Language_Prefetch_Language `json:"language,omitempty"`
		Product  *Language_Prefetch_Product  `json:"product,omitempty"`
		User     *Language_Prefetch_User     `json:"user,omitempty"`
	} `json:"prefetch,omitempty"`
	Product int  `json:"product"`
	User    *int `json:"user"`
}

// Language_Prefetch_Language defines model for Language.Prefetch.Language.
type Language_Prefetch_Language struct {
	AdditionalProperties map[string]LanguageType `json:"-"`
}

// Language_Prefetch_Product defines model for Language.Prefetch.Product.
type Language_Prefetch_Product struct {
	AdditionalProperties map[string]Product `json:"-"`
}

// Language_Prefetch_User defines model for Language.Prefetch.User.
type Language_Prefetch_User struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// LanguageRequest defines model for LanguageRequest.
type LanguageRequest struct {
	Blank    *int `json:"blank"`
	Code     *int `json:"code"`
	Comment  *int `json:"comment"`
	Files    *int `json:"files"`
	Language int  `json:"language"`
	Product  int  `json:"product"`
	User     *int `json:"user"`
}

// LanguageType defines model for LanguageType.
type LanguageType struct {
	Color    *string `json:"color"`
	Id       int     `json:"id"`
	Language string  `json:"language"`
}

// LanguageTypeRequest defines model for LanguageTypeRequest.
type LanguageTypeRequest struct {
	Color    *string `json:"color"`
	Language string  `json:"language"`
}

// Meta defines model for Meta.
type Meta struct {
	Endpoint *int   `json:"endpoint"`
	Finding  *int   `json:"finding"`
	Id       int    `json:"id"`
	Name     string `json:"name"`
	Prefetch *struct {
		Endpoint *Meta_Prefetch_Endpoint `json:"endpoint,omitempty"`
		Finding  *Meta_Prefetch_Finding  `json:"finding,omitempty"`
		Product  *Meta_Prefetch_Product  `json:"product,omitempty"`
	} `json:"prefetch,omitempty"`
	Product *int   `json:"product"`
	Value   string `json:"value"`
}

// Meta_Prefetch_Endpoint defines model for Meta.Prefetch.Endpoint.
type Meta_Prefetch_Endpoint struct {
	AdditionalProperties map[string]Endpoint `json:"-"`
}

// Meta_Prefetch_Finding defines model for Meta.Prefetch.Finding.
type Meta_Prefetch_Finding struct {
	AdditionalProperties map[string]Finding `json:"-"`
}

// Meta_Prefetch_Product defines model for Meta.Prefetch.Product.
type Meta_Prefetch_Product struct {
	AdditionalProperties map[string]Product `json:"-"`
}

// MetaRequest defines model for MetaRequest.
type MetaRequest struct {
	Endpoint *int   `json:"endpoint"`
	Finding  *int   `json:"finding"`
	Name     string `json:"name"`
	Product  *int   `json:"product"`
	Value    string `json:"value"`
}

// NetworkLocations defines model for NetworkLocations.
type NetworkLocations struct {
	Id int `json:"id"`

	// Location of network testing: Examples: VPN, Internet or Internal.
	Location string `json:"location"`
}

// NetworkLocationsRequest defines model for NetworkLocationsRequest.
type NetworkLocationsRequest struct {
	// Location of network testing: Examples: VPN, Internet or Internal.
	Location string `json:"location"`
}

// Note defines model for Note.
type Note struct {
	Author struct {
		// Embedded struct due to allOf(#/components/schemas/UserStub)
		UserStub `yaml:",inline"`
	} `json:"author"`
	Date     time.Time  `json:"date"`
	EditTime *time.Time `json:"edit_time"`
	Edited   *bool      `json:"edited,omitempty"`
	Editor   *struct {
		// Embedded struct due to allOf(#/components/schemas/UserStub)
		UserStub `yaml:",inline"`
	} `json:"editor"`
	Entry    string        `json:"entry"`
	History  []NoteHistory `json:"history"`
	Id       int           `json:"id"`
	NoteType *int          `json:"note_type"`
	Private  *bool         `json:"private,omitempty"`
}

// NoteHistory defines model for NoteHistory.
type NoteHistory struct {
	CurrentEditor struct {
		// Embedded struct due to allOf(#/components/schemas/UserStub)
		UserStub `yaml:",inline"`
	} `json:"current_editor"`
	Data     string     `json:"data"`
	Id       int        `json:"id"`
	NoteType *int       `json:"note_type"`
	Time     *time.Time `json:"time"`
}

// NoteRequest defines model for NoteRequest.
type NoteRequest struct {
	Edited   *bool  `json:"edited,omitempty"`
	Entry    string `json:"entry"`
	NoteType *int   `json:"note_type"`
	Private  *bool  `json:"private,omitempty"`
}

// NoteType defines model for NoteType.
type NoteType struct {
	Description string `json:"description"`
	Id          int    `json:"id"`
	IsActive    *bool  `json:"is_active,omitempty"`
	IsMandatory *bool  `json:"is_mandatory,omitempty"`
	IsSingle    *bool  `json:"is_single,omitempty"`
	Name        string `json:"name"`
}

// NoteTypeRequest defines model for NoteTypeRequest.
type NoteTypeRequest struct {
	Description string `json:"description"`
	IsActive    *bool  `json:"is_active,omitempty"`
	IsMandatory *bool  `json:"is_mandatory,omitempty"`
	IsSingle    *bool  `json:"is_single,omitempty"`
	Name        string `json:"name"`
}

// Notifications defines model for Notifications.
type Notifications struct {
	AutoCloseEngagement *[]NotificationsAutoCloseEngagement `json:"auto_close_engagement,omitempty"`
	CloseEngagement     *[]NotificationsCloseEngagement     `json:"close_engagement,omitempty"`
	CodeReview          *[]NotificationsCodeReview          `json:"code_review,omitempty"`
	EngagementAdded     *[]NotificationsEngagementAdded     `json:"engagement_added,omitempty"`
	Id                  int                                 `json:"id"`
	JiraUpdate          *[]NotificationsJiraUpdate          `json:"jira_update,omitempty"`
	Other               *[]NotificationsOther               `json:"other,omitempty"`
	Prefetch            *struct {
		Product *Notifications_Prefetch_Product `json:"product,omitempty"`
		User    *Notifications_Prefetch_User    `json:"user,omitempty"`
	} `json:"prefetch,omitempty"`
	Product                  *int                                     `json:"product"`
	ProductAdded             *[]NotificationsProductAdded             `json:"product_added,omitempty"`
	ProductTypeAdded         *[]NotificationsProductTypeAdded         `json:"product_type_added,omitempty"`
	ReviewRequested          *[]NotificationsReviewRequested          `json:"review_requested,omitempty"`
	RiskAcceptanceExpiration *[]NotificationsRiskAcceptanceExpiration `json:"risk_acceptance_expiration,omitempty"`
	ScanAdded                *[]NotificationsScanAdded                `json:"scan_added,omitempty"`
	SlaBreach                *[]NotificationsSlaBreach                `json:"sla_breach,omitempty"`
	StaleEngagement          *[]NotificationsStaleEngagement          `json:"stale_engagement,omitempty"`
	Template                 *bool                                    `json:"template,omitempty"`
	TestAdded                *[]NotificationsTestAdded                `json:"test_added,omitempty"`
	UpcomingEngagement       *[]NotificationsUpcomingEngagement       `json:"upcoming_engagement,omitempty"`
	User                     *int                                     `json:"user"`
	UserMentioned            *[]NotificationsUserMentioned            `json:"user_mentioned,omitempty"`
}

// NotificationsAutoCloseEngagement defines model for Notifications.AutoCloseEngagement.
type NotificationsAutoCloseEngagement string

// NotificationsCloseEngagement defines model for Notifications.CloseEngagement.
type NotificationsCloseEngagement string

// NotificationsCodeReview defines model for Notifications.CodeReview.
type NotificationsCodeReview string

// NotificationsEngagementAdded defines model for Notifications.EngagementAdded.
type NotificationsEngagementAdded string

// NotificationsJiraUpdate defines model for Notifications.JiraUpdate.
type NotificationsJiraUpdate string

// NotificationsOther defines model for Notifications.Other.
type NotificationsOther string

// Notifications_Prefetch_Product defines model for Notifications.Prefetch.Product.
type Notifications_Prefetch_Product struct {
	AdditionalProperties map[string]Product `json:"-"`
}

// Notifications_Prefetch_User defines model for Notifications.Prefetch.User.
type Notifications_Prefetch_User struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// NotificationsProductAdded defines model for Notifications.ProductAdded.
type NotificationsProductAdded string

// NotificationsProductTypeAdded defines model for Notifications.ProductTypeAdded.
type NotificationsProductTypeAdded string

// NotificationsReviewRequested defines model for Notifications.ReviewRequested.
type NotificationsReviewRequested string

// NotificationsRiskAcceptanceExpiration defines model for Notifications.RiskAcceptanceExpiration.
type NotificationsRiskAcceptanceExpiration string

// NotificationsScanAdded defines model for Notifications.ScanAdded.
type NotificationsScanAdded string

// NotificationsSlaBreach defines model for Notifications.SlaBreach.
type NotificationsSlaBreach string

// NotificationsStaleEngagement defines model for Notifications.StaleEngagement.
type NotificationsStaleEngagement string

// NotificationsTestAdded defines model for Notifications.TestAdded.
type NotificationsTestAdded string

// NotificationsUpcomingEngagement defines model for Notifications.UpcomingEngagement.
type NotificationsUpcomingEngagement string

// NotificationsUserMentioned defines model for Notifications.UserMentioned.
type NotificationsUserMentioned string

// NotificationsRequest defines model for NotificationsRequest.
type NotificationsRequest struct {
	AutoCloseEngagement      *[]NotificationsRequestAutoCloseEngagement      `json:"auto_close_engagement,omitempty"`
	CloseEngagement          *[]NotificationsRequestCloseEngagement          `json:"close_engagement,omitempty"`
	CodeReview               *[]NotificationsRequestCodeReview               `json:"code_review,omitempty"`
	EngagementAdded          *[]NotificationsRequestEngagementAdded          `json:"engagement_added,omitempty"`
	JiraUpdate               *[]NotificationsRequestJiraUpdate               `json:"jira_update,omitempty"`
	Other                    *[]NotificationsRequestOther                    `json:"other,omitempty"`
	Product                  *int                                            `json:"product"`
	ProductAdded             *[]NotificationsRequestProductAdded             `json:"product_added,omitempty"`
	ProductTypeAdded         *[]NotificationsRequestProductTypeAdded         `json:"product_type_added,omitempty"`
	ReviewRequested          *[]NotificationsRequestReviewRequested          `json:"review_requested,omitempty"`
	RiskAcceptanceExpiration *[]NotificationsRequestRiskAcceptanceExpiration `json:"risk_acceptance_expiration,omitempty"`
	ScanAdded                *[]NotificationsRequestScanAdded                `json:"scan_added,omitempty"`
	SlaBreach                *[]NotificationsRequestSlaBreach                `json:"sla_breach,omitempty"`
	StaleEngagement          *[]NotificationsRequestStaleEngagement          `json:"stale_engagement,omitempty"`
	Template                 *bool                                           `json:"template,omitempty"`
	TestAdded                *[]NotificationsRequestTestAdded                `json:"test_added,omitempty"`
	UpcomingEngagement       *[]NotificationsRequestUpcomingEngagement       `json:"upcoming_engagement,omitempty"`
	User                     *int                                            `json:"user"`
	UserMentioned            *[]NotificationsRequestUserMentioned            `json:"user_mentioned,omitempty"`
}

// NotificationsRequestAutoCloseEngagement defines model for NotificationsRequest.AutoCloseEngagement.
type NotificationsRequestAutoCloseEngagement string

// NotificationsRequestCloseEngagement defines model for NotificationsRequest.CloseEngagement.
type NotificationsRequestCloseEngagement string

// NotificationsRequestCodeReview defines model for NotificationsRequest.CodeReview.
type NotificationsRequestCodeReview string

// NotificationsRequestEngagementAdded defines model for NotificationsRequest.EngagementAdded.
type NotificationsRequestEngagementAdded string

// NotificationsRequestJiraUpdate defines model for NotificationsRequest.JiraUpdate.
type NotificationsRequestJiraUpdate string

// NotificationsRequestOther defines model for NotificationsRequest.Other.
type NotificationsRequestOther string

// NotificationsRequestProductAdded defines model for NotificationsRequest.ProductAdded.
type NotificationsRequestProductAdded string

// NotificationsRequestProductTypeAdded defines model for NotificationsRequest.ProductTypeAdded.
type NotificationsRequestProductTypeAdded string

// NotificationsRequestReviewRequested defines model for NotificationsRequest.ReviewRequested.
type NotificationsRequestReviewRequested string

// NotificationsRequestRiskAcceptanceExpiration defines model for NotificationsRequest.RiskAcceptanceExpiration.
type NotificationsRequestRiskAcceptanceExpiration string

// NotificationsRequestScanAdded defines model for NotificationsRequest.ScanAdded.
type NotificationsRequestScanAdded string

// NotificationsRequestSlaBreach defines model for NotificationsRequest.SlaBreach.
type NotificationsRequestSlaBreach string

// NotificationsRequestStaleEngagement defines model for NotificationsRequest.StaleEngagement.
type NotificationsRequestStaleEngagement string

// NotificationsRequestTestAdded defines model for NotificationsRequest.TestAdded.
type NotificationsRequestTestAdded string

// NotificationsRequestUpcomingEngagement defines model for NotificationsRequest.UpcomingEngagement.
type NotificationsRequestUpcomingEngagement string

// NotificationsRequestUserMentioned defines model for NotificationsRequest.UserMentioned.
type NotificationsRequestUserMentioned string

// PaginatedAppAnalysisList defines model for PaginatedAppAnalysisList.
type PaginatedAppAnalysisList struct {
	Count    *int           `json:"count,omitempty"`
	Next     *string        `json:"next"`
	Previous *string        `json:"previous"`
	Results  *[]AppAnalysis `json:"results,omitempty"`
}

// PaginatedConfigurationPermissionList defines model for PaginatedConfigurationPermissionList.
type PaginatedConfigurationPermissionList struct {
	Count    *int                       `json:"count,omitempty"`
	Next     *string                    `json:"next"`
	Previous *string                    `json:"previous"`
	Results  *[]ConfigurationPermission `json:"results,omitempty"`
}

// PaginatedDeletePreviewList defines model for PaginatedDeletePreviewList.
type PaginatedDeletePreviewList struct {
	Count    *int             `json:"count,omitempty"`
	Next     *string          `json:"next"`
	Previous *string          `json:"previous"`
	Results  *[]DeletePreview `json:"results,omitempty"`
}

// PaginatedDevelopmentEnvironmentList defines model for PaginatedDevelopmentEnvironmentList.
type PaginatedDevelopmentEnvironmentList struct {
	Count    *int                      `json:"count,omitempty"`
	Next     *string                   `json:"next"`
	Previous *string                   `json:"previous"`
	Results  *[]DevelopmentEnvironment `json:"results,omitempty"`
}

// PaginatedDojoGroupList defines model for PaginatedDojoGroupList.
type PaginatedDojoGroupList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		ProductGroups     *PaginatedDojoGroupList_Prefetch_ProductGroups     `json:"product_groups,omitempty"`
		ProductTypeGroups *PaginatedDojoGroupList_Prefetch_ProductTypeGroups `json:"product_type_groups,omitempty"`
		Users             *PaginatedDojoGroupList_Prefetch_Users             `json:"users,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string      `json:"previous"`
	Results  *[]DojoGroup `json:"results,omitempty"`
}

// PaginatedDojoGroupList_Prefetch_ProductGroups defines model for PaginatedDojoGroupList.Prefetch.ProductGroups.
type PaginatedDojoGroupList_Prefetch_ProductGroups struct {
	AdditionalProperties map[string]Product `json:"-"`
}

// PaginatedDojoGroupList_Prefetch_ProductTypeGroups defines model for PaginatedDojoGroupList.Prefetch.ProductTypeGroups.
type PaginatedDojoGroupList_Prefetch_ProductTypeGroups struct {
	AdditionalProperties map[string]ProductType `json:"-"`
}

// PaginatedDojoGroupList_Prefetch_Users defines model for PaginatedDojoGroupList.Prefetch.Users.
type PaginatedDojoGroupList_Prefetch_Users struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedDojoGroupMemberList defines model for PaginatedDojoGroupMemberList.
type PaginatedDojoGroupMemberList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		Group *PaginatedDojoGroupMemberList_Prefetch_Group `json:"group,omitempty"`
		Role  *PaginatedDojoGroupMemberList_Prefetch_Role  `json:"role,omitempty"`
		User  *PaginatedDojoGroupMemberList_Prefetch_User  `json:"user,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string            `json:"previous"`
	Results  *[]DojoGroupMember `json:"results,omitempty"`
}

// PaginatedDojoGroupMemberList_Prefetch_Group defines model for PaginatedDojoGroupMemberList.Prefetch.Group.
type PaginatedDojoGroupMemberList_Prefetch_Group struct {
	AdditionalProperties map[string]DojoGroup `json:"-"`
}

// PaginatedDojoGroupMemberList_Prefetch_Role defines model for PaginatedDojoGroupMemberList.Prefetch.Role.
type PaginatedDojoGroupMemberList_Prefetch_Role struct {
	AdditionalProperties map[string]Role `json:"-"`
}

// PaginatedDojoGroupMemberList_Prefetch_User defines model for PaginatedDojoGroupMemberList.Prefetch.User.
type PaginatedDojoGroupMemberList_Prefetch_User struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedEndpointList defines model for PaginatedEndpointList.
type PaginatedEndpointList struct {
	Count    *int        `json:"count,omitempty"`
	Next     *string     `json:"next"`
	Previous *string     `json:"previous"`
	Results  *[]Endpoint `json:"results,omitempty"`
}

// PaginatedEndpointStatusList defines model for PaginatedEndpointStatusList.
type PaginatedEndpointStatusList struct {
	Count    *int              `json:"count,omitempty"`
	Next     *string           `json:"next"`
	Previous *string           `json:"previous"`
	Results  *[]EndpointStatus `json:"results,omitempty"`
}

// PaginatedEngagementList defines model for PaginatedEngagementList.
type PaginatedEngagementList struct {
	Count    *int          `json:"count,omitempty"`
	Next     *string       `json:"next"`
	Previous *string       `json:"previous"`
	Results  *[]Engagement `json:"results,omitempty"`
}

// PaginatedEngagementPresetsList defines model for PaginatedEngagementPresetsList.
type PaginatedEngagementPresetsList struct {
	Count    *int                 `json:"count,omitempty"`
	Next     *string              `json:"next"`
	Previous *string              `json:"previous"`
	Results  *[]EngagementPresets `json:"results,omitempty"`
}

// PaginatedFindingList defines model for PaginatedFindingList.
type PaginatedFindingList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		DefectReviewRequestedBy *PaginatedFindingList_Prefetch_DefectReviewRequestedBy `json:"defect_review_requested_by,omitempty"`
		DuplicateFinding        *PaginatedFindingList_Prefetch_DuplicateFinding        `json:"duplicate_finding,omitempty"`
		EndpointSet             *PaginatedFindingList_Prefetch_EndpointSet             `json:"endpoint_set,omitempty"`
		Endpoints               *PaginatedFindingList_Prefetch_Endpoints               `json:"endpoints,omitempty"`
		Files                   *PaginatedFindingList_Prefetch_Files                   `json:"files,omitempty"`
		FindingGroupSet         *PaginatedFindingList_Prefetch_FindingGroupSet         `json:"finding_group_set,omitempty"`
		FoundBy                 *PaginatedFindingList_Prefetch_FoundBy                 `json:"found_by,omitempty"`
		LastReviewedBy          *PaginatedFindingList_Prefetch_LastReviewedBy          `json:"last_reviewed_by,omitempty"`
		MitigatedBy             *PaginatedFindingList_Prefetch_MitigatedBy             `json:"mitigated_by,omitempty"`
		Notes                   *PaginatedFindingList_Prefetch_Notes                   `json:"notes,omitempty"`
		Reporter                *PaginatedFindingList_Prefetch_Reporter                `json:"reporter,omitempty"`
		ReviewRequestedBy       *PaginatedFindingList_Prefetch_ReviewRequestedBy       `json:"review_requested_by,omitempty"`
		Reviewers               *PaginatedFindingList_Prefetch_Reviewers               `json:"reviewers,omitempty"`
		RiskAcceptanceSet       *PaginatedFindingList_Prefetch_RiskAcceptanceSet       `json:"risk_acceptance_set,omitempty"`
		SonarqubeIssue          *PaginatedFindingList_Prefetch_SonarqubeIssue          `json:"sonarqube_issue,omitempty"`
		Test                    *PaginatedFindingList_Prefetch_Test                    `json:"test,omitempty"`
		TestImportSet           *PaginatedFindingList_Prefetch_TestImportSet           `json:"test_import_set,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string    `json:"previous"`
	Results  *[]Finding `json:"results,omitempty"`
}

// PaginatedFindingList_Prefetch_DefectReviewRequestedBy defines model for PaginatedFindingList.Prefetch.DefectReviewRequestedBy.
type PaginatedFindingList_Prefetch_DefectReviewRequestedBy struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedFindingList_Prefetch_DuplicateFinding defines model for PaginatedFindingList.Prefetch.DuplicateFinding.
type PaginatedFindingList_Prefetch_DuplicateFinding struct {
	AdditionalProperties map[string]Finding `json:"-"`
}

// PaginatedFindingList_Prefetch_EndpointSet defines model for PaginatedFindingList.Prefetch.EndpointSet.
type PaginatedFindingList_Prefetch_EndpointSet struct {
	AdditionalProperties map[string]Endpoint `json:"-"`
}

// PaginatedFindingList_Prefetch_Endpoints defines model for PaginatedFindingList.Prefetch.Endpoints.
type PaginatedFindingList_Prefetch_Endpoints struct {
	AdditionalProperties map[string]Endpoint `json:"-"`
}

// PaginatedFindingList_Prefetch_Files defines model for PaginatedFindingList.Prefetch.Files.
type PaginatedFindingList_Prefetch_Files struct {
	AdditionalProperties map[string]File `json:"-"`
}

// PaginatedFindingList_Prefetch_FindingGroupSet defines model for PaginatedFindingList.Prefetch.FindingGroupSet.
type PaginatedFindingList_Prefetch_FindingGroupSet struct {
	AdditionalProperties map[string]FindingGroup `json:"-"`
}

// PaginatedFindingList_Prefetch_FoundBy defines model for PaginatedFindingList.Prefetch.FoundBy.
type PaginatedFindingList_Prefetch_FoundBy struct {
	AdditionalProperties map[string]TestType `json:"-"`
}

// PaginatedFindingList_Prefetch_LastReviewedBy defines model for PaginatedFindingList.Prefetch.LastReviewedBy.
type PaginatedFindingList_Prefetch_LastReviewedBy struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedFindingList_Prefetch_MitigatedBy defines model for PaginatedFindingList.Prefetch.MitigatedBy.
type PaginatedFindingList_Prefetch_MitigatedBy struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedFindingList_Prefetch_Notes defines model for PaginatedFindingList.Prefetch.Notes.
type PaginatedFindingList_Prefetch_Notes struct {
	AdditionalProperties map[string]Note `json:"-"`
}

// PaginatedFindingList_Prefetch_Reporter defines model for PaginatedFindingList.Prefetch.Reporter.
type PaginatedFindingList_Prefetch_Reporter struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedFindingList_Prefetch_ReviewRequestedBy defines model for PaginatedFindingList.Prefetch.ReviewRequestedBy.
type PaginatedFindingList_Prefetch_ReviewRequestedBy struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedFindingList_Prefetch_Reviewers defines model for PaginatedFindingList.Prefetch.Reviewers.
type PaginatedFindingList_Prefetch_Reviewers struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedFindingList_Prefetch_RiskAcceptanceSet defines model for PaginatedFindingList.Prefetch.RiskAcceptanceSet.
type PaginatedFindingList_Prefetch_RiskAcceptanceSet struct {
	AdditionalProperties map[string]RiskAcceptance `json:"-"`
}

// PaginatedFindingList_Prefetch_SonarqubeIssue defines model for PaginatedFindingList.Prefetch.SonarqubeIssue.
type PaginatedFindingList_Prefetch_SonarqubeIssue struct {
	AdditionalProperties map[string]SonarqubeIssue `json:"-"`
}

// PaginatedFindingList_Prefetch_Test defines model for PaginatedFindingList.Prefetch.Test.
type PaginatedFindingList_Prefetch_Test struct {
	AdditionalProperties map[string]Test `json:"-"`
}

// PaginatedFindingList_Prefetch_TestImportSet defines model for PaginatedFindingList.Prefetch.TestImportSet.
type PaginatedFindingList_Prefetch_TestImportSet struct {
	AdditionalProperties map[string]TestImport `json:"-"`
}

// PaginatedFindingTemplateList defines model for PaginatedFindingTemplateList.
type PaginatedFindingTemplateList struct {
	Count    *int               `json:"count,omitempty"`
	Next     *string            `json:"next"`
	Previous *string            `json:"previous"`
	Results  *[]FindingTemplate `json:"results,omitempty"`
}

// PaginatedGlobalRoleList defines model for PaginatedGlobalRoleList.
type PaginatedGlobalRoleList struct {
	Count    *int          `json:"count,omitempty"`
	Next     *string       `json:"next"`
	Previous *string       `json:"previous"`
	Results  *[]GlobalRole `json:"results,omitempty"`
}

// PaginatedJIRAInstanceList defines model for PaginatedJIRAInstanceList.
type PaginatedJIRAInstanceList struct {
	Count    *int            `json:"count,omitempty"`
	Next     *string         `json:"next"`
	Previous *string         `json:"previous"`
	Results  *[]JIRAInstance `json:"results,omitempty"`
}

// PaginatedJIRAIssueList defines model for PaginatedJIRAIssueList.
type PaginatedJIRAIssueList struct {
	Count    *int         `json:"count,omitempty"`
	Next     *string      `json:"next"`
	Previous *string      `json:"previous"`
	Results  *[]JIRAIssue `json:"results,omitempty"`
}

// PaginatedJIRAProjectList defines model for PaginatedJIRAProjectList.
type PaginatedJIRAProjectList struct {
	Count    *int           `json:"count,omitempty"`
	Next     *string        `json:"next"`
	Previous *string        `json:"previous"`
	Results  *[]JIRAProject `json:"results,omitempty"`
}

// PaginatedLanguageList defines model for PaginatedLanguageList.
type PaginatedLanguageList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		Language *PaginatedLanguageList_Prefetch_Language `json:"language,omitempty"`
		Product  *PaginatedLanguageList_Prefetch_Product  `json:"product,omitempty"`
		User     *PaginatedLanguageList_Prefetch_User     `json:"user,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string     `json:"previous"`
	Results  *[]Language `json:"results,omitempty"`
}

// PaginatedLanguageList_Prefetch_Language defines model for PaginatedLanguageList.Prefetch.Language.
type PaginatedLanguageList_Prefetch_Language struct {
	AdditionalProperties map[string]LanguageType `json:"-"`
}

// PaginatedLanguageList_Prefetch_Product defines model for PaginatedLanguageList.Prefetch.Product.
type PaginatedLanguageList_Prefetch_Product struct {
	AdditionalProperties map[string]Product `json:"-"`
}

// PaginatedLanguageList_Prefetch_User defines model for PaginatedLanguageList.Prefetch.User.
type PaginatedLanguageList_Prefetch_User struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedLanguageTypeList defines model for PaginatedLanguageTypeList.
type PaginatedLanguageTypeList struct {
	Count    *int            `json:"count,omitempty"`
	Next     *string         `json:"next"`
	Previous *string         `json:"previous"`
	Results  *[]LanguageType `json:"results,omitempty"`
}

// PaginatedMetaList defines model for PaginatedMetaList.
type PaginatedMetaList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		Endpoint *PaginatedMetaList_Prefetch_Endpoint `json:"endpoint,omitempty"`
		Finding  *PaginatedMetaList_Prefetch_Finding  `json:"finding,omitempty"`
		Product  *PaginatedMetaList_Prefetch_Product  `json:"product,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string `json:"previous"`
	Results  *[]Meta `json:"results,omitempty"`
}

// PaginatedMetaList_Prefetch_Endpoint defines model for PaginatedMetaList.Prefetch.Endpoint.
type PaginatedMetaList_Prefetch_Endpoint struct {
	AdditionalProperties map[string]Endpoint `json:"-"`
}

// PaginatedMetaList_Prefetch_Finding defines model for PaginatedMetaList.Prefetch.Finding.
type PaginatedMetaList_Prefetch_Finding struct {
	AdditionalProperties map[string]Finding `json:"-"`
}

// PaginatedMetaList_Prefetch_Product defines model for PaginatedMetaList.Prefetch.Product.
type PaginatedMetaList_Prefetch_Product struct {
	AdditionalProperties map[string]Product `json:"-"`
}

// PaginatedNetworkLocationsList defines model for PaginatedNetworkLocationsList.
type PaginatedNetworkLocationsList struct {
	Count    *int                `json:"count,omitempty"`
	Next     *string             `json:"next"`
	Previous *string             `json:"previous"`
	Results  *[]NetworkLocations `json:"results,omitempty"`
}

// PaginatedNoteList defines model for PaginatedNoteList.
type PaginatedNoteList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Previous *string `json:"previous"`
	Results  *[]Note `json:"results,omitempty"`
}

// PaginatedNoteTypeList defines model for PaginatedNoteTypeList.
type PaginatedNoteTypeList struct {
	Count    *int        `json:"count,omitempty"`
	Next     *string     `json:"next"`
	Previous *string     `json:"previous"`
	Results  *[]NoteType `json:"results,omitempty"`
}

// PaginatedNotificationsList defines model for PaginatedNotificationsList.
type PaginatedNotificationsList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		Product *PaginatedNotificationsList_Prefetch_Product `json:"product,omitempty"`
		User    *PaginatedNotificationsList_Prefetch_User    `json:"user,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string          `json:"previous"`
	Results  *[]Notifications `json:"results,omitempty"`
}

// PaginatedNotificationsList_Prefetch_Product defines model for PaginatedNotificationsList.Prefetch.Product.
type PaginatedNotificationsList_Prefetch_Product struct {
	AdditionalProperties map[string]Product `json:"-"`
}

// PaginatedNotificationsList_Prefetch_User defines model for PaginatedNotificationsList.Prefetch.User.
type PaginatedNotificationsList_Prefetch_User struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedProductAPIScanConfigurationList defines model for PaginatedProductAPIScanConfigurationList.
type PaginatedProductAPIScanConfigurationList struct {
	Count    *int                           `json:"count,omitempty"`
	Next     *string                        `json:"next"`
	Previous *string                        `json:"previous"`
	Results  *[]ProductAPIScanConfiguration `json:"results,omitempty"`
}

// PaginatedProductGroupList defines model for PaginatedProductGroupList.
type PaginatedProductGroupList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		Group   *PaginatedProductGroupList_Prefetch_Group   `json:"group,omitempty"`
		Product *PaginatedProductGroupList_Prefetch_Product `json:"product,omitempty"`
		Role    *PaginatedProductGroupList_Prefetch_Role    `json:"role,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string         `json:"previous"`
	Results  *[]ProductGroup `json:"results,omitempty"`
}

// PaginatedProductGroupList_Prefetch_Group defines model for PaginatedProductGroupList.Prefetch.Group.
type PaginatedProductGroupList_Prefetch_Group struct {
	AdditionalProperties map[string]DojoGroup `json:"-"`
}

// PaginatedProductGroupList_Prefetch_Product defines model for PaginatedProductGroupList.Prefetch.Product.
type PaginatedProductGroupList_Prefetch_Product struct {
	AdditionalProperties map[string]Product `json:"-"`
}

// PaginatedProductGroupList_Prefetch_Role defines model for PaginatedProductGroupList.Prefetch.Role.
type PaginatedProductGroupList_Prefetch_Role struct {
	AdditionalProperties map[string]Role `json:"-"`
}

// PaginatedProductList defines model for PaginatedProductList.
type PaginatedProductList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		AuthorizationGroups *PaginatedProductList_Prefetch_AuthorizationGroups `json:"authorization_groups,omitempty"`
		Members             *PaginatedProductList_Prefetch_Members             `json:"members,omitempty"`
		ProdType            *PaginatedProductList_Prefetch_ProdType            `json:"prod_type,omitempty"`
		ProductManager      *PaginatedProductList_Prefetch_ProductManager      `json:"product_manager,omitempty"`
		Regulations         *PaginatedProductList_Prefetch_Regulations         `json:"regulations,omitempty"`
		SlaConfiguration    *PaginatedProductList_Prefetch_SlaConfiguration    `json:"sla_configuration,omitempty"`
		TeamManager         *PaginatedProductList_Prefetch_TeamManager         `json:"team_manager,omitempty"`
		TechnicalContact    *PaginatedProductList_Prefetch_TechnicalContact    `json:"technical_contact,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string    `json:"previous"`
	Results  *[]Product `json:"results,omitempty"`
}

// PaginatedProductList_Prefetch_AuthorizationGroups defines model for PaginatedProductList.Prefetch.AuthorizationGroups.
type PaginatedProductList_Prefetch_AuthorizationGroups struct {
	AdditionalProperties map[string]DojoGroup `json:"-"`
}

// PaginatedProductList_Prefetch_Members defines model for PaginatedProductList.Prefetch.Members.
type PaginatedProductList_Prefetch_Members struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedProductList_Prefetch_ProdType defines model for PaginatedProductList.Prefetch.ProdType.
type PaginatedProductList_Prefetch_ProdType struct {
	AdditionalProperties map[string]ProductType `json:"-"`
}

// PaginatedProductList_Prefetch_ProductManager defines model for PaginatedProductList.Prefetch.ProductManager.
type PaginatedProductList_Prefetch_ProductManager struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedProductList_Prefetch_Regulations defines model for PaginatedProductList.Prefetch.Regulations.
type PaginatedProductList_Prefetch_Regulations struct {
	AdditionalProperties map[string]Regulation `json:"-"`
}

// PaginatedProductList_Prefetch_SlaConfiguration defines model for PaginatedProductList.Prefetch.SlaConfiguration.
type PaginatedProductList_Prefetch_SlaConfiguration struct {
	AdditionalProperties map[string]SLAConfiguration `json:"-"`
}

// PaginatedProductList_Prefetch_TeamManager defines model for PaginatedProductList.Prefetch.TeamManager.
type PaginatedProductList_Prefetch_TeamManager struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedProductList_Prefetch_TechnicalContact defines model for PaginatedProductList.Prefetch.TechnicalContact.
type PaginatedProductList_Prefetch_TechnicalContact struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedProductMemberList defines model for PaginatedProductMemberList.
type PaginatedProductMemberList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		Product *PaginatedProductMemberList_Prefetch_Product `json:"product,omitempty"`
		Role    *PaginatedProductMemberList_Prefetch_Role    `json:"role,omitempty"`
		User    *PaginatedProductMemberList_Prefetch_User    `json:"user,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string          `json:"previous"`
	Results  *[]ProductMember `json:"results,omitempty"`
}

// PaginatedProductMemberList_Prefetch_Product defines model for PaginatedProductMemberList.Prefetch.Product.
type PaginatedProductMemberList_Prefetch_Product struct {
	AdditionalProperties map[string]Product `json:"-"`
}

// PaginatedProductMemberList_Prefetch_Role defines model for PaginatedProductMemberList.Prefetch.Role.
type PaginatedProductMemberList_Prefetch_Role struct {
	AdditionalProperties map[string]Role `json:"-"`
}

// PaginatedProductMemberList_Prefetch_User defines model for PaginatedProductMemberList.Prefetch.User.
type PaginatedProductMemberList_Prefetch_User struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedProductTypeGroupList defines model for PaginatedProductTypeGroupList.
type PaginatedProductTypeGroupList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		Group       *PaginatedProductTypeGroupList_Prefetch_Group       `json:"group,omitempty"`
		ProductType *PaginatedProductTypeGroupList_Prefetch_ProductType `json:"product_type,omitempty"`
		Role        *PaginatedProductTypeGroupList_Prefetch_Role        `json:"role,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string             `json:"previous"`
	Results  *[]ProductTypeGroup `json:"results,omitempty"`
}

// PaginatedProductTypeGroupList_Prefetch_Group defines model for PaginatedProductTypeGroupList.Prefetch.Group.
type PaginatedProductTypeGroupList_Prefetch_Group struct {
	AdditionalProperties map[string]DojoGroup `json:"-"`
}

// PaginatedProductTypeGroupList_Prefetch_ProductType defines model for PaginatedProductTypeGroupList.Prefetch.ProductType.
type PaginatedProductTypeGroupList_Prefetch_ProductType struct {
	AdditionalProperties map[string]ProductType `json:"-"`
}

// PaginatedProductTypeGroupList_Prefetch_Role defines model for PaginatedProductTypeGroupList.Prefetch.Role.
type PaginatedProductTypeGroupList_Prefetch_Role struct {
	AdditionalProperties map[string]Role `json:"-"`
}

// PaginatedProductTypeList defines model for PaginatedProductTypeList.
type PaginatedProductTypeList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		AuthorizationGroups *PaginatedProductTypeList_Prefetch_AuthorizationGroups `json:"authorization_groups,omitempty"`
		Members             *PaginatedProductTypeList_Prefetch_Members             `json:"members,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string        `json:"previous"`
	Results  *[]ProductType `json:"results,omitempty"`
}

// PaginatedProductTypeList_Prefetch_AuthorizationGroups defines model for PaginatedProductTypeList.Prefetch.AuthorizationGroups.
type PaginatedProductTypeList_Prefetch_AuthorizationGroups struct {
	AdditionalProperties map[string]DojoGroup `json:"-"`
}

// PaginatedProductTypeList_Prefetch_Members defines model for PaginatedProductTypeList.Prefetch.Members.
type PaginatedProductTypeList_Prefetch_Members struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedProductTypeMemberList defines model for PaginatedProductTypeMemberList.
type PaginatedProductTypeMemberList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		ProductType *PaginatedProductTypeMemberList_Prefetch_ProductType `json:"product_type,omitempty"`
		Role        *PaginatedProductTypeMemberList_Prefetch_Role        `json:"role,omitempty"`
		User        *PaginatedProductTypeMemberList_Prefetch_User        `json:"user,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string              `json:"previous"`
	Results  *[]ProductTypeMember `json:"results,omitempty"`
}

// PaginatedProductTypeMemberList_Prefetch_ProductType defines model for PaginatedProductTypeMemberList.Prefetch.ProductType.
type PaginatedProductTypeMemberList_Prefetch_ProductType struct {
	AdditionalProperties map[string]ProductType `json:"-"`
}

// PaginatedProductTypeMemberList_Prefetch_Role defines model for PaginatedProductTypeMemberList.Prefetch.Role.
type PaginatedProductTypeMemberList_Prefetch_Role struct {
	AdditionalProperties map[string]Role `json:"-"`
}

// PaginatedProductTypeMemberList_Prefetch_User defines model for PaginatedProductTypeMemberList.Prefetch.User.
type PaginatedProductTypeMemberList_Prefetch_User struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedRegulationList defines model for PaginatedRegulationList.
type PaginatedRegulationList struct {
	Count    *int          `json:"count,omitempty"`
	Next     *string       `json:"next"`
	Previous *string       `json:"previous"`
	Results  *[]Regulation `json:"results,omitempty"`
}

// PaginatedRiskAcceptanceList defines model for PaginatedRiskAcceptanceList.
type PaginatedRiskAcceptanceList struct {
	Count    *int              `json:"count,omitempty"`
	Next     *string           `json:"next"`
	Previous *string           `json:"previous"`
	Results  *[]RiskAcceptance `json:"results,omitempty"`
}

// PaginatedRoleList defines model for PaginatedRoleList.
type PaginatedRoleList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Previous *string `json:"previous"`
	Results  *[]Role `json:"results,omitempty"`
}

// PaginatedSLAConfigurationList defines model for PaginatedSLAConfigurationList.
type PaginatedSLAConfigurationList struct {
	Count    *int                `json:"count,omitempty"`
	Next     *string             `json:"next"`
	Previous *string             `json:"previous"`
	Results  *[]SLAConfiguration `json:"results,omitempty"`
}

// PaginatedSonarqubeIssueList defines model for PaginatedSonarqubeIssueList.
type PaginatedSonarqubeIssueList struct {
	Count    *int              `json:"count,omitempty"`
	Next     *string           `json:"next"`
	Previous *string           `json:"previous"`
	Results  *[]SonarqubeIssue `json:"results,omitempty"`
}

// PaginatedSonarqubeIssueTransitionList defines model for PaginatedSonarqubeIssueTransitionList.
type PaginatedSonarqubeIssueTransitionList struct {
	Count    *int                        `json:"count,omitempty"`
	Next     *string                     `json:"next"`
	Previous *string                     `json:"previous"`
	Results  *[]SonarqubeIssueTransition `json:"results,omitempty"`
}

// PaginatedStubFindingList defines model for PaginatedStubFindingList.
type PaginatedStubFindingList struct {
	Count    *int           `json:"count,omitempty"`
	Next     *string        `json:"next"`
	Previous *string        `json:"previous"`
	Results  *[]StubFinding `json:"results,omitempty"`
}

// PaginatedSystemSettingsList defines model for PaginatedSystemSettingsList.
type PaginatedSystemSettingsList struct {
	Count    *int              `json:"count,omitempty"`
	Next     *string           `json:"next"`
	Previous *string           `json:"previous"`
	Results  *[]SystemSettings `json:"results,omitempty"`
}

// PaginatedTestImportList defines model for PaginatedTestImportList.
type PaginatedTestImportList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		FindingsAffected *PaginatedTestImportList_Prefetch_FindingsAffected `json:"findings_affected,omitempty"`
		Test             *PaginatedTestImportList_Prefetch_Test             `json:"test,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string       `json:"previous"`
	Results  *[]TestImport `json:"results,omitempty"`
}

// PaginatedTestImportList_Prefetch_FindingsAffected defines model for PaginatedTestImportList.Prefetch.FindingsAffected.
type PaginatedTestImportList_Prefetch_FindingsAffected struct {
	AdditionalProperties map[string]Finding `json:"-"`
}

// PaginatedTestImportList_Prefetch_Test defines model for PaginatedTestImportList.Prefetch.Test.
type PaginatedTestImportList_Prefetch_Test struct {
	AdditionalProperties map[string]Test `json:"-"`
}

// PaginatedTestList defines model for PaginatedTestList.
type PaginatedTestList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Previous *string `json:"previous"`
	Results  *[]Test `json:"results,omitempty"`
}

// PaginatedTestTypeList defines model for PaginatedTestTypeList.
type PaginatedTestTypeList struct {
	Count    *int        `json:"count,omitempty"`
	Next     *string     `json:"next"`
	Previous *string     `json:"previous"`
	Results  *[]TestType `json:"results,omitempty"`
}

// PaginatedToolConfigurationList defines model for PaginatedToolConfigurationList.
type PaginatedToolConfigurationList struct {
	Count    *int                 `json:"count,omitempty"`
	Next     *string              `json:"next"`
	Previous *string              `json:"previous"`
	Results  *[]ToolConfiguration `json:"results,omitempty"`
}

// PaginatedToolProductSettingsList defines model for PaginatedToolProductSettingsList.
type PaginatedToolProductSettingsList struct {
	Count    *int                   `json:"count,omitempty"`
	Next     *string                `json:"next"`
	Previous *string                `json:"previous"`
	Results  *[]ToolProductSettings `json:"results,omitempty"`
}

// PaginatedToolTypeList defines model for PaginatedToolTypeList.
type PaginatedToolTypeList struct {
	Count    *int        `json:"count,omitempty"`
	Next     *string     `json:"next"`
	Previous *string     `json:"previous"`
	Results  *[]ToolType `json:"results,omitempty"`
}

// PaginatedUserContactInfoList defines model for PaginatedUserContactInfoList.
type PaginatedUserContactInfoList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Prefetch *struct {
		User *PaginatedUserContactInfoList_Prefetch_User `json:"user,omitempty"`
	} `json:"prefetch,omitempty"`
	Previous *string            `json:"previous"`
	Results  *[]UserContactInfo `json:"results,omitempty"`
}

// PaginatedUserContactInfoList_Prefetch_User defines model for PaginatedUserContactInfoList.Prefetch.User.
type PaginatedUserContactInfoList_Prefetch_User struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// PaginatedUserList defines model for PaginatedUserList.
type PaginatedUserList struct {
	Count    *int    `json:"count,omitempty"`
	Next     *string `json:"next"`
	Previous *string `json:"previous"`
	Results  *[]User `json:"results,omitempty"`
}

// PatchedAppAnalysisRequest defines model for PatchedAppAnalysisRequest.
type PatchedAppAnalysisRequest struct {
	Confidence   *int      `json:"confidence"`
	Icon         *string   `json:"icon"`
	Name         *string   `json:"name,omitempty"`
	Product      *int      `json:"product,omitempty"`
	Tags         *[]string `json:"tags,omitempty"`
	User         *int      `json:"user,omitempty"`
	Version      *string   `json:"version"`
	Website      *string   `json:"website"`
	WebsiteFound *string   `json:"website_found"`
}

// PatchedDevelopmentEnvironmentRequest defines model for PatchedDevelopmentEnvironmentRequest.
type PatchedDevelopmentEnvironmentRequest struct {
	Name *string `json:"name,omitempty"`
}

// PatchedDojoGroupMemberRequest defines model for PatchedDojoGroupMemberRequest.
type PatchedDojoGroupMemberRequest struct {
	Group *int `json:"group,omitempty"`

	// This role determines the permissions of the user to manage the group.
	Role *int `json:"role,omitempty"`
	User *int `json:"user,omitempty"`
}

// PatchedDojoGroupRequest defines model for PatchedDojoGroupRequest.
type PatchedDojoGroupRequest struct {
	ConfigurationPermissions *[]int  `json:"configuration_permissions,omitempty"`
	Description              *string `json:"description"`
	Name                     *string `json:"name,omitempty"`

	// Group imported from a social provider.
	SocialProvider *PatchedDojoGroupRequestSocialProvider `json:"social_provider"`
}

// Group imported from a social provider.
type PatchedDojoGroupRequestSocialProvider string

// PatchedEndpointRequest defines model for PatchedEndpointRequest.
type PatchedEndpointRequest struct {
	// The fragment identifier which follows the hash mark. The hash mark should be omitted. For example 'section-13', 'paragraph-2'.
	Fragment *string `json:"fragment"`

	// The host name or IP address. It must not include the port number. For example '127.0.0.1', 'localhost', 'yourdomain.com'.
	Host *string `json:"host"`

	// The location of the resource, it must not start with a '/'. For example endpoint/420/edit
	Path *string `json:"path"`

	// The network port associated with the endpoint.
	Port    *int `json:"port"`
	Product *int `json:"product"`

	// The communication protocol/scheme such as 'http', 'ftp', 'dns', etc.
	Protocol *string `json:"protocol"`

	// The query string, the question mark should be omitted.For example 'group=4&team=8'
	Query *string   `json:"query"`
	Tags  *[]string `json:"tags,omitempty"`

	// User info as 'alice', 'bob', etc.
	Userinfo *string `json:"userinfo"`
}

// PatchedEndpointStatusRequest defines model for PatchedEndpointStatusRequest.
type PatchedEndpointStatusRequest struct {
	Date          *openapi_types.Date `json:"date,omitempty"`
	Endpoint      *int                `json:"endpoint,omitempty"`
	FalsePositive *bool               `json:"false_positive,omitempty"`
	Finding       *int                `json:"finding,omitempty"`
	Mitigated     *bool               `json:"mitigated,omitempty"`
	MitigatedBy   *int                `json:"mitigated_by"`
	OutOfScope    *bool               `json:"out_of_scope,omitempty"`
	RiskAccepted  *bool               `json:"risk_accepted,omitempty"`
}

// PatchedEngagementPresetsRequest defines model for PatchedEngagementPresetsRequest.
type PatchedEngagementPresetsRequest struct {
	NetworkLocations *[]int `json:"network_locations,omitempty"`

	// Description of what needs to be tested or setting up environment for testing
	Notes   *string `json:"notes"`
	Product *int    `json:"product,omitempty"`

	// Scope of Engagement testing, IP's/Resources/URL's)
	Scope    *string `json:"scope,omitempty"`
	TestType *[]int  `json:"test_type,omitempty"`

	// Brief description of preset.
	Title *string `json:"title,omitempty"`
}

// PatchedEngagementRequest defines model for PatchedEngagementRequest.
type PatchedEngagementRequest struct {
	ApiTest *bool `json:"api_test,omitempty"`

	// Tag or branch of the product the engagement tested.
	BranchTag *string `json:"branch_tag"`

	// Build ID of the product the engagement tested.
	BuildId *string `json:"build_id"`

	// Build server responsible for CI/CD test
	BuildServer *int  `json:"build_server"`
	CheckList   *bool `json:"check_list,omitempty"`

	// Commit hash from repo
	CommitHash *string `json:"commit_hash"`

	// If enabled deduplication will only mark a finding in this engagement as duplicate of another finding if both findings are in this engagement. If disabled, deduplication is on the product level.
	DeduplicationOnEngagement *bool                                   `json:"deduplication_on_engagement,omitempty"`
	Description               *string                                 `json:"description"`
	EngagementType            *PatchedEngagementRequestEngagementType `json:"engagement_type"`
	FirstContacted            *openapi_types.Date                     `json:"first_contacted"`
	Lead                      *int                                    `json:"lead"`
	Name                      *string                                 `json:"name"`

	// Orchestration service responsible for CI/CD test
	OrchestrationEngine *int  `json:"orchestration_engine"`
	PenTest             *bool `json:"pen_test,omitempty"`

	// Settings and notes for performing this engagement.
	Preset     *int    `json:"preset"`
	Product    *int    `json:"product,omitempty"`
	Reason     *string `json:"reason"`
	ReportType *int    `json:"report_type"`
	Requester  *int    `json:"requester"`

	// Source code server for CI/CD test
	SourceCodeManagementServer *int `json:"source_code_management_server"`

	// Resource link to source code
	SourceCodeManagementUri *string                         `json:"source_code_management_uri"`
	Status                  *PatchedEngagementRequestStatus `json:"status"`
	Tags                    *[]string                       `json:"tags,omitempty"`
	TargetEnd               *openapi_types.Date             `json:"target_end,omitempty"`
	TargetStart             *openapi_types.Date             `json:"target_start,omitempty"`
	TestStrategy            *string                         `json:"test_strategy"`
	ThreatModel             *bool                           `json:"threat_model,omitempty"`

	// Link to epic or ticket system with changes to version.
	Tracker *string `json:"tracker"`

	// Version of the product the engagement tested.
	Version *string `json:"version"`
}

// PatchedEngagementRequestEngagementType defines model for PatchedEngagementRequest.EngagementType.
type PatchedEngagementRequestEngagementType string

// PatchedEngagementRequestStatus defines model for PatchedEngagementRequest.Status.
type PatchedEngagementRequestStatus string

// PatchedFindingNoteRequest defines model for PatchedFindingNoteRequest.
type PatchedFindingNoteRequest struct {
	NoteId *int `json:"note_id,omitempty"`
}

// PatchedFindingRequest defines model for PatchedFindingRequest.
type PatchedFindingRequest struct {
	// Denotes if this flaw is active or not.
	Active *bool `json:"active,omitempty"`

	// Name of the affected component (library name, part of a system, ...).
	ComponentName *string `json:"component_name"`

	// Version of the affected component.
	ComponentVersion *string `json:"component_version"`

	// Common Vulnerability Scoring System version 3 (CVSSv3) score associated with this flaw.
	Cvssv3 *string `json:"cvssv3"`

	// Numerical CVSSv3 score for the vulnerability. If the vector is given, the score is updated while saving the finding
	Cvssv3Score *float64 `json:"cvssv3_score"`

	// The CWE number associated with this flaw.
	Cwe *int `json:"cwe"`

	// The date the flaw was discovered.
	Date *openapi_types.Date `json:"date,omitempty"`

	// Documents who requested a defect review for this flaw.
	DefectReviewRequestedBy *int `json:"defect_review_requested_by"`

	// Longer more descriptive information about the flaw.
	Description *string `json:"description,omitempty"`

	// Denotes if this flaw is a duplicate of other flaws reported.
	Duplicate *bool `json:"duplicate,omitempty"`

	// Flaw has been detected from a Dynamic Application Security Testing tool (DAST).
	DynamicFinding *bool `json:"dynamic_finding,omitempty"`

	// Denotes if this flaw has been deemed a false positive by the tester.
	FalseP *bool `json:"false_p,omitempty"`

	// Identified file(s) containing the flaw.
	FilePath *string `json:"file_path"`

	// Text describing the impact this flaw has on systems, products, enterprise, etc.
	Impact *string `json:"impact"`

	// Denotes if this flaw has been fixed.
	IsMitigated *bool `json:"is_mitigated,omitempty"`

	// Source line number of the attack vector.
	Line *int `json:"line"`

	// Text describing how to best fix the flaw.
	Mitigation *string `json:"mitigation"`

	// Number of occurences in the source tool when several vulnerabilites were found and aggregated by the scanner.
	NbOccurences *int `json:"nb_occurences"`

	// The numerical representation of the severity (S0, S1, S2, S3, S4).
	NumericalSeverity *string `json:"numerical_severity,omitempty"`

	// Denotes if this flaw falls outside the scope of the test and/or engagement.
	OutOfScope *bool `json:"out_of_scope,omitempty"`

	// The date the flaw is expected to be remediated.
	PlannedRemediationDate *openapi_types.Date `json:"planned_remediation_date"`

	// Date when this vulnerability was made publicly available.
	PublishDate *openapi_types.Date `json:"publish_date"`
	PushToJira  *bool               `json:"push_to_jira,omitempty"`

	// The external documentation available for this flaw.
	References *string `json:"references"`

	// Documents who requested a review for this finding.
	ReviewRequestedBy *int `json:"review_requested_by"`

	// Documents who reviewed the flaw.
	Reviewers *[]int `json:"reviewers,omitempty"`

	// Denotes if this finding has been marked as an accepted risk.
	RiskAccepted *bool `json:"risk_accepted,omitempty"`

	// Sink object (variable, function...) of the attack vector.
	SastSinkObject *string `json:"sast_sink_object"`

	// Source file path of the attack vector.
	SastSourceFilePath *string `json:"sast_source_file_path"`

	// Source line number of the attack vector.
	SastSourceLine *int `json:"sast_source_line"`

	// Source object (variable, function...) of the attack vector.
	SastSourceObject *string `json:"sast_source_object"`

	// A service is a self-contained piece of functionality within a Product. This is an optional field which is used in deduplication of findings when set.
	Service *string `json:"service"`

	// The severity level of this flaw (Critical, High, Medium, Low, Informational).
	Severity *string `json:"severity,omitempty"`

	// Text describing why a certain severity was associated with this flaw.
	SeverityJustification *string `json:"severity_justification"`

	// (readonly)The date used as start date for SLA calculation. Set by expiring risk acceptances. Empty by default, causing a fallback to 'date'.
	SlaStartDate *openapi_types.Date `json:"sla_start_date"`

	// The SonarQube issue associated with this finding.
	SonarqubeIssue *int `json:"sonarqube_issue"`

	// Flaw has been detected from a Static Application Security Testing tool (SAST).
	StaticFinding *bool `json:"static_finding,omitempty"`

	// Text describing the steps that must be followed in order to reproduce the flaw / bug.
	StepsToReproduce *string   `json:"steps_to_reproduce"`
	Tags             *[]string `json:"tags,omitempty"`

	// A short description of the flaw.
	Title *string `json:"title,omitempty"`

	// Denotes if this finding is under defect review.
	UnderDefectReview *bool `json:"under_defect_review,omitempty"`

	// Denotes is this flaw is currently being reviewed.
	UnderReview *bool `json:"under_review,omitempty"`

	// Vulnerability technical id from the source tool. Allows to track unique vulnerabilities.
	UniqueIdFromTool *string `json:"unique_id_from_tool"`

	// Denotes if this flaw has been manually verified by the tester.
	Verified *bool `json:"verified,omitempty"`

	// Non-unique technical id from the source tool associated with the vulnerability type.
	VulnIdFromTool   *string                   `json:"vuln_id_from_tool"`
	VulnerabilityIds *[]VulnerabilityIdRequest `json:"vulnerability_ids,omitempty"`
}

// PatchedFindingTemplateRequest defines model for PatchedFindingTemplateRequest.
type PatchedFindingTemplateRequest struct {
	Cvssv3      *string   `json:"cvssv3"`
	Cwe         *int      `json:"cwe"`
	Description *string   `json:"description"`
	Impact      *string   `json:"impact"`
	Mitigation  *string   `json:"mitigation"`
	References  *string   `json:"references"`
	Severity    *string   `json:"severity"`
	Tags        *[]string `json:"tags,omitempty"`

	// Enables this template for matching remediation advice. Match will be applied to all active, verified findings by CWE.
	TemplateMatch *bool `json:"template_match,omitempty"`

	// Matches by title text (contains search) and CWE.
	TemplateMatchTitle *bool                             `json:"template_match_title,omitempty"`
	Title              *string                           `json:"title,omitempty"`
	VulnerabilityIds   *[]VulnerabilityIdTemplateRequest `json:"vulnerability_ids,omitempty"`
}

// PatchedGlobalRoleRequest defines model for PatchedGlobalRoleRequest.
type PatchedGlobalRoleRequest struct {
	Group *int `json:"group"`

	// The global role will be applied to all product types and products.
	Role *int `json:"role"`
	User *int `json:"user"`
}

// PatchedJIRAInstanceRequest defines model for PatchedJIRAInstanceRequest.
type PatchedJIRAInstanceRequest struct {
	// JIRA resolution names (comma-separated values) that maps to an Accepted Finding
	AcceptedMappingResolution *string `json:"accepted_mapping_resolution"`

	// Transition ID to Close JIRA issues, visit https://<YOUR JIRA URL>/rest/api/latest/issue/<ANY VALID ISSUE KEY>/transitions?expand=transitions.fields to find the ID for your JIRA instance
	CloseStatusKey *int `json:"close_status_key,omitempty"`

	// Enter a name to give to this configuration
	ConfigurationName *string `json:"configuration_name,omitempty"`

	// Maps to the 'Priority' field in Jira. For example: Critical
	CriticalMappingSeverity *string `json:"critical_mapping_severity,omitempty"`

	// You can define extra issue types in settings.py
	DefaultIssueType *PatchedJIRAInstanceRequestDefaultIssueType `json:"default_issue_type,omitempty"`

	// To obtain the 'Epic name id' visit https://<YOUR JIRA URL>/rest/api/2/field and search for Epic Name. Copy the number out of cf[number] and paste it here.
	EpicNameId *int `json:"epic_name_id,omitempty"`

	// JIRA resolution names (comma-separated values) that maps to a False Positive Finding
	FalsePositiveMappingResolution *string `json:"false_positive_mapping_resolution"`

	// Additional text that will be added to the finding in Jira. For example including how the finding was created or who to contact for more information.
	FindingText *string `json:"finding_text"`

	// This setting can be overidden at the Product level
	GlobalJiraSlaNotification *bool `json:"global_jira_sla_notification,omitempty"`

	// Maps to the 'Priority' field in Jira. For example: High
	HighMappingSeverity *string `json:"high_mapping_severity,omitempty"`

	// Maps to the 'Priority' field in Jira. For example: Info
	InfoMappingSeverity *string `json:"info_mapping_severity,omitempty"`

	// Choose the folder containing the Django templates used to render the JIRA issue description. These are stored in dojo/templates/issue-trackers. Leave empty to use the default jira_full templates.
	IssueTemplateDir *string `json:"issue_template_dir"`

	// Maps to the 'Priority' field in Jira. For example: Low
	LowMappingSeverity *string `json:"low_mapping_severity,omitempty"`

	// Maps to the 'Priority' field in Jira. For example: Medium
	MediumMappingSeverity *string `json:"medium_mapping_severity,omitempty"`

	// Transition ID to Re-Open JIRA issues, visit https://<YOUR JIRA URL>/rest/api/latest/issue/<ANY VALID ISSUE KEY>/transitions?expand=transitions.fields to find the ID for your JIRA instance
	OpenStatusKey *int    `json:"open_status_key,omitempty"`
	Password      *string `json:"password,omitempty"`

	// For more information how to configure Jira, read the DefectDojo documentation.
	Url      *string `json:"url,omitempty"`
	Username *string `json:"username,omitempty"`
}

// You can define extra issue types in settings.py
type PatchedJIRAInstanceRequestDefaultIssueType string

// PatchedJIRAIssueRequest defines model for PatchedJIRAIssueRequest.
type PatchedJIRAIssueRequest struct {
	Engagement   *int `json:"engagement"`
	Finding      *int `json:"finding"`
	FindingGroup *int `json:"finding_group"`

	// The date the linked Jira issue was last modified.
	JiraChange *time.Time `json:"jira_change"`

	// The date a Jira issue was created from this finding.
	JiraCreation *time.Time `json:"jira_creation"`
	JiraId       *string    `json:"jira_id,omitempty"`
	JiraKey      *string    `json:"jira_key,omitempty"`
	JiraProject  *int       `json:"jira_project"`
}

// PatchedJIRAProjectRequest defines model for PatchedJIRAProjectRequest.
type PatchedJIRAProjectRequest struct {
	AddVulnerabilityIdToJiraLabel *bool   `json:"add_vulnerability_id_to_jira_label,omitempty"`
	Component                     *string `json:"component,omitempty"`

	// JIRA custom field JSON mapping of Id to value, e.g. {"customfield_10122": [{"name": "8.0.1"}]}
	CustomFields *PatchedJIRAProjectRequest_CustomFields `json:"custom_fields"`

	// JIRA default assignee (name). If left blank then it defaults to whatever is configured in JIRA.
	DefaultAssignee             *string `json:"default_assignee"`
	EnableEngagementEpicMapping *bool   `json:"enable_engagement_epic_mapping,omitempty"`
	Engagement                  *int    `json:"engagement"`

	// Choose the folder containing the Django templates used to render the JIRA issue description. These are stored in dojo/templates/issue-trackers. Leave empty to use the default jira_full templates.
	IssueTemplateDir *string `json:"issue_template_dir"`
	JiraInstance     *int    `json:"jira_instance"`

	// JIRA issue labels space seperated
	JiraLabels                 *string `json:"jira_labels"`
	Product                    *int    `json:"product"`
	ProductJiraSlaNotification *bool   `json:"product_jira_sla_notification,omitempty"`
	ProjectKey                 *string `json:"project_key,omitempty"`

	// Automatically maintain parity with JIRA. Always create and update JIRA tickets for findings in this Product.
	PushAllIssues                        *bool `json:"push_all_issues,omitempty"`
	PushNotes                            *bool `json:"push_notes,omitempty"`
	RiskAcceptanceExpirationNotification *bool `json:"risk_acceptance_expiration_notification,omitempty"`
}

// JIRA custom field JSON mapping of Id to value, e.g. {"customfield_10122": [{"name": "8.0.1"}]}
type PatchedJIRAProjectRequest_CustomFields struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PatchedLanguageRequest defines model for PatchedLanguageRequest.
type PatchedLanguageRequest struct {
	Blank    *int `json:"blank"`
	Code     *int `json:"code"`
	Comment  *int `json:"comment"`
	Files    *int `json:"files"`
	Language *int `json:"language,omitempty"`
	Product  *int `json:"product,omitempty"`
	User     *int `json:"user"`
}

// PatchedLanguageTypeRequest defines model for PatchedLanguageTypeRequest.
type PatchedLanguageTypeRequest struct {
	Color    *string `json:"color"`
	Language *string `json:"language,omitempty"`
}

// PatchedMetaRequest defines model for PatchedMetaRequest.
type PatchedMetaRequest struct {
	Endpoint *int    `json:"endpoint"`
	Finding  *int    `json:"finding"`
	Name     *string `json:"name,omitempty"`
	Product  *int    `json:"product"`
	Value    *string `json:"value,omitempty"`
}

// PatchedNetworkLocationsRequest defines model for PatchedNetworkLocationsRequest.
type PatchedNetworkLocationsRequest struct {
	// Location of network testing: Examples: VPN, Internet or Internal.
	Location *string `json:"location,omitempty"`
}

// PatchedNoteRequest defines model for PatchedNoteRequest.
type PatchedNoteRequest struct {
	Edited   *bool   `json:"edited,omitempty"`
	Entry    *string `json:"entry,omitempty"`
	NoteType *int    `json:"note_type"`
	Private  *bool   `json:"private,omitempty"`
}

// PatchedNoteTypeRequest defines model for PatchedNoteTypeRequest.
type PatchedNoteTypeRequest struct {
	Description *string `json:"description,omitempty"`
	IsActive    *bool   `json:"is_active,omitempty"`
	IsMandatory *bool   `json:"is_mandatory,omitempty"`
	IsSingle    *bool   `json:"is_single,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// PatchedNotificationsRequest defines model for PatchedNotificationsRequest.
type PatchedNotificationsRequest struct {
	AutoCloseEngagement      *[]PatchedNotificationsRequestAutoCloseEngagement      `json:"auto_close_engagement,omitempty"`
	CloseEngagement          *[]PatchedNotificationsRequestCloseEngagement          `json:"close_engagement,omitempty"`
	CodeReview               *[]PatchedNotificationsRequestCodeReview               `json:"code_review,omitempty"`
	EngagementAdded          *[]PatchedNotificationsRequestEngagementAdded          `json:"engagement_added,omitempty"`
	JiraUpdate               *[]PatchedNotificationsRequestJiraUpdate               `json:"jira_update,omitempty"`
	Other                    *[]PatchedNotificationsRequestOther                    `json:"other,omitempty"`
	Product                  *int                                                   `json:"product"`
	ProductAdded             *[]PatchedNotificationsRequestProductAdded             `json:"product_added,omitempty"`
	ProductTypeAdded         *[]PatchedNotificationsRequestProductTypeAdded         `json:"product_type_added,omitempty"`
	ReviewRequested          *[]PatchedNotificationsRequestReviewRequested          `json:"review_requested,omitempty"`
	RiskAcceptanceExpiration *[]PatchedNotificationsRequestRiskAcceptanceExpiration `json:"risk_acceptance_expiration,omitempty"`
	ScanAdded                *[]PatchedNotificationsRequestScanAdded                `json:"scan_added,omitempty"`
	SlaBreach                *[]PatchedNotificationsRequestSlaBreach                `json:"sla_breach,omitempty"`
	StaleEngagement          *[]PatchedNotificationsRequestStaleEngagement          `json:"stale_engagement,omitempty"`
	Template                 *bool                                                  `json:"template,omitempty"`
	TestAdded                *[]PatchedNotificationsRequestTestAdded                `json:"test_added,omitempty"`
	UpcomingEngagement       *[]PatchedNotificationsRequestUpcomingEngagement       `json:"upcoming_engagement,omitempty"`
	User                     *int                                                   `json:"user"`
	UserMentioned            *[]PatchedNotificationsRequestUserMentioned            `json:"user_mentioned,omitempty"`
}

// PatchedNotificationsRequestAutoCloseEngagement defines model for PatchedNotificationsRequest.AutoCloseEngagement.
type PatchedNotificationsRequestAutoCloseEngagement string

// PatchedNotificationsRequestCloseEngagement defines model for PatchedNotificationsRequest.CloseEngagement.
type PatchedNotificationsRequestCloseEngagement string

// PatchedNotificationsRequestCodeReview defines model for PatchedNotificationsRequest.CodeReview.
type PatchedNotificationsRequestCodeReview string

// PatchedNotificationsRequestEngagementAdded defines model for PatchedNotificationsRequest.EngagementAdded.
type PatchedNotificationsRequestEngagementAdded string

// PatchedNotificationsRequestJiraUpdate defines model for PatchedNotificationsRequest.JiraUpdate.
type PatchedNotificationsRequestJiraUpdate string

// PatchedNotificationsRequestOther defines model for PatchedNotificationsRequest.Other.
type PatchedNotificationsRequestOther string

// PatchedNotificationsRequestProductAdded defines model for PatchedNotificationsRequest.ProductAdded.
type PatchedNotificationsRequestProductAdded string

// PatchedNotificationsRequestProductTypeAdded defines model for PatchedNotificationsRequest.ProductTypeAdded.
type PatchedNotificationsRequestProductTypeAdded string

// PatchedNotificationsRequestReviewRequested defines model for PatchedNotificationsRequest.ReviewRequested.
type PatchedNotificationsRequestReviewRequested string

// PatchedNotificationsRequestRiskAcceptanceExpiration defines model for PatchedNotificationsRequest.RiskAcceptanceExpiration.
type PatchedNotificationsRequestRiskAcceptanceExpiration string

// PatchedNotificationsRequestScanAdded defines model for PatchedNotificationsRequest.ScanAdded.
type PatchedNotificationsRequestScanAdded string

// PatchedNotificationsRequestSlaBreach defines model for PatchedNotificationsRequest.SlaBreach.
type PatchedNotificationsRequestSlaBreach string

// PatchedNotificationsRequestStaleEngagement defines model for PatchedNotificationsRequest.StaleEngagement.
type PatchedNotificationsRequestStaleEngagement string

// PatchedNotificationsRequestTestAdded defines model for PatchedNotificationsRequest.TestAdded.
type PatchedNotificationsRequestTestAdded string

// PatchedNotificationsRequestUpcomingEngagement defines model for PatchedNotificationsRequest.UpcomingEngagement.
type PatchedNotificationsRequestUpcomingEngagement string

// PatchedNotificationsRequestUserMentioned defines model for PatchedNotificationsRequest.UserMentioned.
type PatchedNotificationsRequestUserMentioned string

// PatchedProductAPIScanConfigurationRequest defines model for PatchedProductAPIScanConfigurationRequest.
type PatchedProductAPIScanConfigurationRequest struct {
	Product           *int    `json:"product,omitempty"`
	ServiceKey1       *string `json:"service_key_1"`
	ServiceKey2       *string `json:"service_key_2"`
	ServiceKey3       *string `json:"service_key_3"`
	ToolConfiguration *int    `json:"tool_configuration,omitempty"`
}

// PatchedProductRequest defines model for PatchedProductRequest.
type PatchedProductRequest struct {
	BusinessCriticality *PatchedProductRequestBusinessCriticality `json:"business_criticality"`
	Description         *string                                   `json:"description,omitempty"`

	// Allows full risk acceptance using a risk acceptance form, expiration date, uploaded proof, etc.
	EnableFullRiskAcceptance *bool `json:"enable_full_risk_acceptance,omitempty"`

	// Allows simple risk acceptance by checking/unchecking a checkbox.
	EnableSimpleRiskAcceptance *bool `json:"enable_simple_risk_acceptance,omitempty"`

	// Specify if the application is used by people outside the organization.
	ExternalAudience *bool `json:"external_audience,omitempty"`

	// Specify if the application is accessible from the public internet.
	InternetAccessible *bool                           `json:"internet_accessible,omitempty"`
	Lifecycle          *PatchedProductRequestLifecycle `json:"lifecycle"`
	Name               *string                         `json:"name,omitempty"`
	Origin             *PatchedProductRequestOrigin    `json:"origin"`
	Platform           *PatchedProductRequestPlatform  `json:"platform"`
	ProdNumericGrade   *int                            `json:"prod_numeric_grade"`
	ProdType           *int                            `json:"prod_type,omitempty"`
	ProductManager     *int                            `json:"product_manager"`
	Regulations        *[]int                          `json:"regulations,omitempty"`

	// Estimate the application's revenue.
	Revenue          *string   `json:"revenue"`
	SlaConfiguration *int      `json:"sla_configuration,omitempty"`
	Tags             *[]string `json:"tags,omitempty"`
	TeamManager      *int      `json:"team_manager"`
	TechnicalContact *int      `json:"technical_contact"`

	// Estimate the number of user records within the application.
	UserRecords *int `json:"user_records"`
}

// PatchedProductRequestBusinessCriticality defines model for PatchedProductRequest.BusinessCriticality.
type PatchedProductRequestBusinessCriticality string

// PatchedProductRequestLifecycle defines model for PatchedProductRequest.Lifecycle.
type PatchedProductRequestLifecycle string

// PatchedProductRequestOrigin defines model for PatchedProductRequest.Origin.
type PatchedProductRequestOrigin string

// PatchedProductRequestPlatform defines model for PatchedProductRequest.Platform.
type PatchedProductRequestPlatform string

// PatchedProductTypeRequest defines model for PatchedProductTypeRequest.
type PatchedProductTypeRequest struct {
	CriticalProduct *bool   `json:"critical_product,omitempty"`
	Description     *string `json:"description"`
	KeyProduct      *bool   `json:"key_product,omitempty"`
	Name            *string `json:"name,omitempty"`
}

// PatchedRegulationRequest defines model for PatchedRegulationRequest.
type PatchedRegulationRequest struct {
	// A shortened representation of the name.
	Acronym *string `json:"acronym,omitempty"`

	// The subject of the regulation.
	Category *PatchedRegulationRequestCategory `json:"category,omitempty"`

	// Information about the regulation's purpose.
	Description *string `json:"description,omitempty"`

	// The territory over which the regulation applies.
	Jurisdiction *string `json:"jurisdiction,omitempty"`

	// The name of the regulation.
	Name *string `json:"name,omitempty"`

	// An external URL for more information.
	Reference *string `json:"reference,omitempty"`
}

// The subject of the regulation.
type PatchedRegulationRequestCategory string

// PatchedSLAConfigurationRequest defines model for PatchedSLAConfigurationRequest.
type PatchedSLAConfigurationRequest struct {
	// number of days to remediate a critical finding.
	Critical    *int    `json:"critical,omitempty"`
	Description *string `json:"description"`

	// number of days to remediate a high finding.
	High *int `json:"high,omitempty"`

	// number of days to remediate a low finding.
	Low *int `json:"low,omitempty"`

	// number of days to remediate a medium finding.
	Medium *int `json:"medium,omitempty"`

	// A unique name for the set of SLAs.
	Name *string `json:"name,omitempty"`
}

// PatchedSonarqubeIssueRequest defines model for PatchedSonarqubeIssueRequest.
type PatchedSonarqubeIssueRequest struct {
	// SonarQube issue key
	Key *string `json:"key,omitempty"`

	// SonarQube issue status
	Status *string `json:"status,omitempty"`

	// SonarQube issue type
	Type *string `json:"type,omitempty"`
}

// PatchedSonarqubeIssueTransitionRequest defines model for PatchedSonarqubeIssueTransitionRequest.
type PatchedSonarqubeIssueTransitionRequest struct {
	FindingStatus   *string `json:"finding_status,omitempty"`
	SonarqubeIssue  *int    `json:"sonarqube_issue,omitempty"`
	SonarqubeStatus *string `json:"sonarqube_status,omitempty"`
	Transitions     *string `json:"transitions,omitempty"`
}

// PatchedStubFindingRequest defines model for PatchedStubFindingRequest.
type PatchedStubFindingRequest struct {
	Date        *openapi_types.Date `json:"date,omitempty"`
	Description *string             `json:"description"`
	Severity    *string             `json:"severity"`
	Title       *string             `json:"title,omitempty"`
}

// PatchedSystemSettingsRequest defines model for PatchedSystemSettingsRequest.
type PatchedSystemSettingsRequest struct {
	AddVulnerabilityIdToJiraLabel *bool `json:"add_vulnerability_id_to_jira_label,omitempty"`

	// Enable anyone with a link to the survey to answer a survey
	AllowAnonymousSurveyRepsonse *bool   `json:"allow_anonymous_survey_repsonse,omitempty"`
	ColumnWidths                 *string `json:"column_widths,omitempty"`
	Credentials                  *string `json:"credentials,omitempty"`

	// New users will be assigned to this group.
	DefaultGroup *int `json:"default_group"`

	// New users will only be assigned to the default group, when their email address matches this regex pattern. This is optional condition.
	DefaultGroupEmailPattern *string `json:"default_group_email_pattern,omitempty"`

	// New users will be assigned to their default group with this role.
	DefaultGroupRole *int `json:"default_group_role"`

	// Requires next setting: maximum number of duplicates to retain.
	DeleteDuplicates *bool `json:"delete_duplicates,omitempty"`

	// Allows incoming requests without a secret (discouraged legacy behaviour)
	DisableJiraWebhookSecret *bool `json:"disable_jira_webhook_secret,omitempty"`

	// Include this custom disclaimer on all notifications and generated reports
	Disclaimer    *string              `json:"disclaimer,omitempty"`
	DriveFolderID *string              `json:"drive_folder_ID,omitempty"`
	EmailAddress  *openapi_types.Email `json:"email_address,omitempty"`
	EmailFrom     *string              `json:"email_from,omitempty"`

	// With this setting turned on, Dojo maintains an audit log of changes made to entities (Findings, Tests, Engagements, Procuts, ...)If you run big import you may want to disable this because the way django-auditlog currently works, there's a big performance hit. Especially during (re-)imports.
	EnableAuditlog *bool `json:"enable_auditlog,omitempty"`

	// Enables Benchmarks such as the OWASP ASVS (Application Security Verification Standard)
	EnableBenchmark *bool `json:"enable_benchmark,omitempty"`

	// With this setting turned off, the Calendar will be disabled in the user interface.
	EnableCalendar *bool `json:"enable_calendar,omitempty"`

	// With this setting turned off, checklists will be disabled in the user interface.
	EnableChecklists *bool `json:"enable_checklists,omitempty"`

	// With this setting turned off, credentials will be disabled in the user interface.
	EnableCredentials *bool `json:"enable_credentials,omitempty"`

	// With this setting turned on, Dojo deduplicates findings by comparing endpoints, cwe fields, and titles. If two findings share a URL and have the same CWE or title, Dojo marks the less recent finding as a duplicate. When deduplication is enabled, a list of deduplicated findings is added to the engagement view.
	EnableDeduplication *bool `json:"enable_deduplication,omitempty"`

	// With this setting turned off, endpoint metadata import will be disabled in the user interface.
	EnableEndpointMetadataImport *bool `json:"enable_endpoint_metadata_import,omitempty"`

	// With this setting turned off, the Finding Groups will be disabled.
	EnableFindingGroups *bool `json:"enable_finding_groups,omitempty"`

	// Enables Finding SLA's for time to remediate.
	EnableFindingSla *bool `json:"enable_finding_sla,omitempty"`
	EnableGithub     *bool `json:"enable_github,omitempty"`

	// With this setting turned off, the Google sheets integration will be disabled in the user interface.
	EnableGoogleSheets *bool `json:"enable_google_sheets,omitempty"`
	EnableJira         *bool `json:"enable_jira,omitempty"`

	// Please note: It is strongly recommended to use a secret below and / or IP whitelist the JIRA server using a proxy such as Nginx.
	EnableJiraWebHook          *bool `json:"enable_jira_web_hook,omitempty"`
	EnableMailNotifications    *bool `json:"enable_mail_notifications,omitempty"`
	EnableMsteamsNotifications *bool `json:"enable_msteams_notifications,omitempty"`

	// Enables Notify when time to remediate according to Finding SLA's is breached for active Findings.
	EnableNotifySlaActive *bool `json:"enable_notify_sla_active,omitempty"`

	// Enables Notify when time to remediate according to Finding SLA's is breached for active, verified Findings.
	EnableNotifySlaActiveVerified *bool `json:"enable_notify_sla_active_verified,omitempty"`

	// Enables Notify when time to remediate according to Finding SLA's is breached for Findings that are linked to JIRA issues.
	EnableNotifySlaJiraOnly *bool `json:"enable_notify_sla_jira_only,omitempty"`

	// Displays a grade letter next to a product to show the overall health.
	EnableProductGrade *bool `json:"enable_product_grade,omitempty"`

	// With this setting turned off, the product tracking files will be disabled in the user interface.
	EnableProductTrackingFiles *bool `json:"enable_product_tracking_files,omitempty"`

	// With this setting turned off, questionnaires will be disabled in the user interface.
	EnableQuestionnaires *bool `json:"enable_questionnaires,omitempty"`

	// With this setting turned off, the rules framwork will be disabled in the user interface.
	EnableRulesFramework     *bool `json:"enable_rules_framework,omitempty"`
	EnableSlackNotifications *bool `json:"enable_slack_notifications,omitempty"`

	// Enables global remediation advice and matching on CWE and Title. The text will be replaced for mitigation, impact and references on a finding. Useful for providing consistent impact and remediation advice regardless of the scanner.
	EnableTemplateMatch *bool `json:"enable_template_match,omitempty"`

	// When turned on users can edit their profiles
	EnableUserProfileEditable *bool `json:"enable_user_profile_editable,omitempty"`

	// Closes an engagement after 3 days (default) past due date including last update.
	EngagementAutoClose *bool `json:"engagement_auto_close,omitempty"`

	// Closes an engagement after the specified number of days past due date including last update.
	EngagementAutoCloseDays *int `json:"engagement_auto_close_days,omitempty"`

	// DefectDojo will automatically mark the finding as a false positive if the finding has been previously marked as a false positive. Not needed when using deduplication, advised to not combine these two.
	FalsePositiveHistory *bool `json:"false_positive_history,omitempty"`

	// JIRA issue labels space seperated
	JiraLabels          *string                                          `json:"jira_labels"`
	JiraMinimumSeverity *PatchedSystemSettingsRequestJiraMinimumSeverity `json:"jira_minimum_severity"`

	// Secret needed in URL for incoming JIRA Webhook
	JiraWebhookSecret *string `json:"jira_webhook_secret"`

	// Requires user passwords to contain at least one lowercase letter (a-z).
	LowercaseCharacterRequired *bool   `json:"lowercase_character_required,omitempty"`
	MailNotificationsTo        *string `json:"mail_notifications_to,omitempty"`

	// When enabled, if a single issue reaches the maximum number of duplicates, the oldest will be deleted. Duplicate will not be deleted when left empty. A value of 0 will remove all duplicates.
	MaxDupes *int `json:"max_dupes"`

	// Requires user to set passwords less than maximum length.
	MaximumPasswordLength *int `json:"maximum_password_length,omitempty"`

	// Requires user to set passwords greater than minimum length.
	MinimumPasswordLength *int `json:"minimum_password_length,omitempty"`

	// The full URL of the incoming webhook
	MsteamsUrl *string `json:"msteams_url,omitempty"`

	// Requires user passwords to contain at least one digit (0-9).
	NumberCharacterRequired *bool   `json:"number_character_required,omitempty"`
	ProductGrade            *string `json:"product_grade,omitempty"`

	// Percentage score for an 'A' >=
	ProductGradeA *int `json:"product_grade_a,omitempty"`

	// Percentage score for a 'B' >=
	ProductGradeB *int `json:"product_grade_b,omitempty"`

	// Percentage score for a 'C' >=
	ProductGradeC *int `json:"product_grade_c,omitempty"`

	// Percentage score for a 'D' >=
	ProductGradeD *int `json:"product_grade_d,omitempty"`

	// Percentage score for an 'F' <=
	ProductGradeF *int `json:"product_grade_f,omitempty"`

	// Default expiry period for risk acceptance form.
	RiskAcceptanceFormDefaultDays *int `json:"risk_acceptance_form_default_days"`

	// Notify X days before risk acceptance expires. Leave empty to disable.
	RiskAcceptanceNotifyBeforeExpiration *int `json:"risk_acceptance_notify_before_expiration"`

	// Optional. Needed if you want to send global notifications.
	SlackChannel *string `json:"slack_channel,omitempty"`

	// Token required for interacting with Slack. Get one at https://api.slack.com/tokens
	SlackToken *string `json:"slack_token,omitempty"`

	// Optional. Will take your bot name otherwise.
	SlackUsername *string `json:"slack_username,omitempty"`

	// Requires user passwords to contain at least one special character (()[]{}|\`~!@#$%^&*_-+=;:'",<>./?).
	SpecialCharacterRequired *bool                                 `json:"special_character_required,omitempty"`
	TeamName                 *string                               `json:"team_name,omitempty"`
	TimeZone                 *PatchedSystemSettingsRequestTimeZone `json:"time_zone,omitempty"`

	// Requires user passwords to contain at least one uppercase letter (A-Z).
	UppercaseCharacterRequired *bool `json:"uppercase_character_required,omitempty"`

	// URL prefix if DefectDojo is installed in it's own virtual subdirectory.
	UrlPrefix *string `json:"url_prefix,omitempty"`
}

// PatchedSystemSettingsRequestJiraMinimumSeverity defines model for PatchedSystemSettingsRequest.JiraMinimumSeverity.
type PatchedSystemSettingsRequestJiraMinimumSeverity string

// PatchedSystemSettingsRequestTimeZone defines model for PatchedSystemSettingsRequest.TimeZone.
type PatchedSystemSettingsRequestTimeZone string

// PatchedTagRequest defines model for PatchedTagRequest.
type PatchedTagRequest struct {
	Tags *[]string `json:"tags,omitempty"`
}

// PatchedTestImportRequest defines model for PatchedTestImportRequest.
type PatchedTestImportRequest struct {
	// Tag or branch that was tested, a reimport may update this field.
	BranchTag *string `json:"branch_tag"`

	// Build ID that was tested, a reimport may update this field.
	BuildId *string `json:"build_id"`

	// Commit hash tested, a reimport may update this field.
	CommitHash     *string                                  `json:"commit_hash"`
	ImportSettings *PatchedTestImportRequest_ImportSettings `json:"import_settings"`
	Type           *string                                  `json:"type,omitempty"`
	Version        *string                                  `json:"version"`
}

// PatchedTestImportRequest_ImportSettings defines model for PatchedTestImportRequest.ImportSettings.
type PatchedTestImportRequest_ImportSettings struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PatchedTestRequest defines model for PatchedTestRequest.
type PatchedTestRequest struct {
	ApiScanConfiguration *int `json:"api_scan_configuration"`

	// Tag or branch that was tested, a reimport may update this field.
	BranchTag *string `json:"branch_tag"`

	// Build ID that was tested, a reimport may update this field.
	BuildId *string `json:"build_id"`

	// Commit hash tested, a reimport may update this field.
	CommitHash      *string    `json:"commit_hash"`
	Description     *string    `json:"description"`
	Environment     *int       `json:"environment"`
	Lead            *int       `json:"lead"`
	PercentComplete *int       `json:"percent_complete"`
	ScanType        *string    `json:"scan_type"`
	Tags            *[]string  `json:"tags,omitempty"`
	TargetEnd       *time.Time `json:"target_end,omitempty"`
	TargetStart     *time.Time `json:"target_start,omitempty"`
	TestType        *int       `json:"test_type,omitempty"`
	Title           *string    `json:"title"`
	Version         *string    `json:"version"`
}

// PatchedTestTypeRequest defines model for PatchedTestTypeRequest.
type PatchedTestTypeRequest struct {
	Active      *bool     `json:"active,omitempty"`
	DynamicTool *bool     `json:"dynamic_tool,omitempty"`
	Name        *string   `json:"name,omitempty"`
	StaticTool  *bool     `json:"static_tool,omitempty"`
	Tags        *[]string `json:"tags,omitempty"`
}

// PatchedToolConfigurationRequest defines model for PatchedToolConfigurationRequest.
type PatchedToolConfigurationRequest struct {
	ApiKey             *string                                            `json:"api_key"`
	AuthTitle          *string                                            `json:"auth_title"`
	AuthenticationType *PatchedToolConfigurationRequestAuthenticationType `json:"authentication_type"`
	Description        *string                                            `json:"description"`

	// Additional definitions that will be consumed by scanner
	Extras   *string `json:"extras"`
	Name     *string `json:"name,omitempty"`
	Password *string `json:"password"`
	Ssh      *string `json:"ssh"`
	ToolType *int    `json:"tool_type,omitempty"`
	Url      *string `json:"url"`
	Username *string `json:"username"`
}

// PatchedToolConfigurationRequestAuthenticationType defines model for PatchedToolConfigurationRequest.AuthenticationType.
type PatchedToolConfigurationRequestAuthenticationType string

// PatchedToolProductSettingsRequest defines model for PatchedToolProductSettingsRequest.
type PatchedToolProductSettingsRequest struct {
	Description       *string `json:"description"`
	Name              *string `json:"name,omitempty"`
	Product           *int    `json:"product,omitempty"`
	SettingUrl        *string `json:"setting_url,omitempty"`
	ToolConfiguration *int    `json:"tool_configuration,omitempty"`
	ToolProjectId     *string `json:"tool_project_id"`
	Url               *string `json:"url"`
}

// PatchedToolTypeRequest defines model for PatchedToolTypeRequest.
type PatchedToolTypeRequest struct {
	Description *string `json:"description"`
	Name        *string `json:"name,omitempty"`
}

// PatchedUserContactInfoRequest defines model for PatchedUserContactInfoRequest.
type PatchedUserContactInfoRequest struct {
	// Instead of async deduping a finding the findings will be deduped synchronously and will 'block' the user until completion.
	BlockExecution *bool `json:"block_execution,omitempty"`

	// Phone number must be entered in the format: '+999999999'. Up to 15 digits allowed.
	CellNumber *string `json:"cell_number,omitempty"`

	// Forces this user to reset their password on next login.
	ForcePasswordReset *bool   `json:"force_password_reset,omitempty"`
	GithubUsername     *string `json:"github_username"`

	// Phone number must be entered in the format: '+999999999'. Up to 15 digits allowed.
	PhoneNumber *string `json:"phone_number,omitempty"`
	SlackUserId *string `json:"slack_user_id"`

	// Email address associated with your slack account
	SlackUsername   *string `json:"slack_username"`
	Title           *string `json:"title"`
	TwitterUsername *string `json:"twitter_username"`
	User            *int    `json:"user,omitempty"`
}

// PatchedUserRequest defines model for PatchedUserRequest.
type PatchedUserRequest struct {
	ConfigurationPermissions *[]int               `json:"configuration_permissions,omitempty"`
	Email                    *openapi_types.Email `json:"email,omitempty"`
	FirstName                *string              `json:"first_name,omitempty"`

	// Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
	IsActive *bool `json:"is_active,omitempty"`

	// Designates that this user has all permissions without explicitly assigning them.
	IsSuperuser *bool   `json:"is_superuser,omitempty"`
	LastName    *string `json:"last_name,omitempty"`
	Password    *string `json:"password,omitempty"`

	// Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
	Username *string `json:"username,omitempty"`
}

// Product defines model for Product.
type Product struct {
	AuthorizationGroups []int                       `json:"authorization_groups"`
	BusinessCriticality *ProductBusinessCriticality `json:"business_criticality"`
	Created             *time.Time                  `json:"created"`
	Description         string                      `json:"description"`

	// Allows full risk acceptance using a risk acceptance form, expiration date, uploaded proof, etc.
	EnableFullRiskAcceptance *bool `json:"enable_full_risk_acceptance,omitempty"`

	// Allows simple risk acceptance by checking/unchecking a checkbox.
	EnableSimpleRiskAcceptance *bool `json:"enable_simple_risk_acceptance,omitempty"`

	// Specify if the application is used by people outside the organization.
	ExternalAudience *bool `json:"external_audience,omitempty"`
	FindingsCount    int   `json:"findings_count"`
	FindingsList     []int `json:"findings_list"`
	Id               int   `json:"id"`

	// Specify if the application is accessible from the public internet.
	InternetAccessible *bool             `json:"internet_accessible,omitempty"`
	Lifecycle          *ProductLifecycle `json:"lifecycle"`
	Members            []int             `json:"members"`
	Name               string            `json:"name"`
	Origin             *ProductOrigin    `json:"origin"`
	Platform           *ProductPlatform  `json:"platform"`
	Prefetch           *struct {
		AuthorizationGroups *Product_Prefetch_AuthorizationGroups `json:"authorization_groups,omitempty"`
		Members             *Product_Prefetch_Members             `json:"members,omitempty"`
		ProdType            *Product_Prefetch_ProdType            `json:"prod_type,omitempty"`
		ProductManager      *Product_Prefetch_ProductManager      `json:"product_manager,omitempty"`
		Regulations         *Product_Prefetch_Regulations         `json:"regulations,omitempty"`
		SlaConfiguration    *Product_Prefetch_SlaConfiguration    `json:"sla_configuration,omitempty"`
		TeamManager         *Product_Prefetch_TeamManager         `json:"team_manager,omitempty"`
		TechnicalContact    *Product_Prefetch_TechnicalContact    `json:"technical_contact,omitempty"`
	} `json:"prefetch,omitempty"`
	ProdNumericGrade *int          `json:"prod_numeric_grade"`
	ProdType         int           `json:"prod_type"`
	ProductManager   *int          `json:"product_manager"`
	ProductMeta      []ProductMeta `json:"product_meta"`
	Regulations      *[]int        `json:"regulations,omitempty"`

	// Estimate the application's revenue.
	Revenue          *string   `json:"revenue"`
	SlaConfiguration *int      `json:"sla_configuration,omitempty"`
	Tags             *[]string `json:"tags,omitempty"`
	TeamManager      *int      `json:"team_manager"`
	TechnicalContact *int      `json:"technical_contact"`

	// Estimate the number of user records within the application.
	UserRecords *int `json:"user_records"`
}

// ProductBusinessCriticality defines model for Product.BusinessCriticality.
type ProductBusinessCriticality string

// ProductLifecycle defines model for Product.Lifecycle.
type ProductLifecycle string

// ProductOrigin defines model for Product.Origin.
type ProductOrigin string

// ProductPlatform defines model for Product.Platform.
type ProductPlatform string

// Product_Prefetch_AuthorizationGroups defines model for Product.Prefetch.AuthorizationGroups.
type Product_Prefetch_AuthorizationGroups struct {
	AdditionalProperties map[string]DojoGroup `json:"-"`
}

// Product_Prefetch_Members defines model for Product.Prefetch.Members.
type Product_Prefetch_Members struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// Product_Prefetch_ProdType defines model for Product.Prefetch.ProdType.
type Product_Prefetch_ProdType struct {
	AdditionalProperties map[string]ProductType `json:"-"`
}

// Product_Prefetch_ProductManager defines model for Product.Prefetch.ProductManager.
type Product_Prefetch_ProductManager struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// Product_Prefetch_Regulations defines model for Product.Prefetch.Regulations.
type Product_Prefetch_Regulations struct {
	AdditionalProperties map[string]Regulation `json:"-"`
}

// Product_Prefetch_SlaConfiguration defines model for Product.Prefetch.SlaConfiguration.
type Product_Prefetch_SlaConfiguration struct {
	AdditionalProperties map[string]SLAConfiguration `json:"-"`
}

// Product_Prefetch_TeamManager defines model for Product.Prefetch.TeamManager.
type Product_Prefetch_TeamManager struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// Product_Prefetch_TechnicalContact defines model for Product.Prefetch.TechnicalContact.
type Product_Prefetch_TechnicalContact struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// ProductAPIScanConfiguration defines model for ProductAPIScanConfiguration.
type ProductAPIScanConfiguration struct {
	Id                int     `json:"id"`
	Product           int     `json:"product"`
	ServiceKey1       *string `json:"service_key_1"`
	ServiceKey2       *string `json:"service_key_2"`
	ServiceKey3       *string `json:"service_key_3"`
	ToolConfiguration int     `json:"tool_configuration"`
}

// ProductAPIScanConfigurationRequest defines model for ProductAPIScanConfigurationRequest.
type ProductAPIScanConfigurationRequest struct {
	Product           int     `json:"product"`
	ServiceKey1       *string `json:"service_key_1"`
	ServiceKey2       *string `json:"service_key_2"`
	ServiceKey3       *string `json:"service_key_3"`
	ToolConfiguration int     `json:"tool_configuration"`
}

// ProductGroup defines model for ProductGroup.
type ProductGroup struct {
	Group    int `json:"group"`
	Id       int `json:"id"`
	Prefetch *struct {
		Group   *ProductGroup_Prefetch_Group   `json:"group,omitempty"`
		Product *ProductGroup_Prefetch_Product `json:"product,omitempty"`
		Role    *ProductGroup_Prefetch_Role    `json:"role,omitempty"`
	} `json:"prefetch,omitempty"`
	Product int `json:"product"`
	Role    int `json:"role"`
}

// ProductGroup_Prefetch_Group defines model for ProductGroup.Prefetch.Group.
type ProductGroup_Prefetch_Group struct {
	AdditionalProperties map[string]DojoGroup `json:"-"`
}

// ProductGroup_Prefetch_Product defines model for ProductGroup.Prefetch.Product.
type ProductGroup_Prefetch_Product struct {
	AdditionalProperties map[string]Product `json:"-"`
}

// ProductGroup_Prefetch_Role defines model for ProductGroup.Prefetch.Role.
type ProductGroup_Prefetch_Role struct {
	AdditionalProperties map[string]Role `json:"-"`
}

// ProductGroupRequest defines model for ProductGroupRequest.
type ProductGroupRequest struct {
	Group   int `json:"group"`
	Product int `json:"product"`
	Role    int `json:"role"`
}

// ProductMember defines model for ProductMember.
type ProductMember struct {
	Id       int `json:"id"`
	Prefetch *struct {
		Product *ProductMember_Prefetch_Product `json:"product,omitempty"`
		Role    *ProductMember_Prefetch_Role    `json:"role,omitempty"`
		User    *ProductMember_Prefetch_User    `json:"user,omitempty"`
	} `json:"prefetch,omitempty"`
	Product int `json:"product"`
	Role    int `json:"role"`
	User    int `json:"user"`
}

// ProductMember_Prefetch_Product defines model for ProductMember.Prefetch.Product.
type ProductMember_Prefetch_Product struct {
	AdditionalProperties map[string]Product `json:"-"`
}

// ProductMember_Prefetch_Role defines model for ProductMember.Prefetch.Role.
type ProductMember_Prefetch_Role struct {
	AdditionalProperties map[string]Role `json:"-"`
}

// ProductMember_Prefetch_User defines model for ProductMember.Prefetch.User.
type ProductMember_Prefetch_User struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// ProductMemberRequest defines model for ProductMemberRequest.
type ProductMemberRequest struct {
	Product int `json:"product"`
	Role    int `json:"role"`
	User    int `json:"user"`
}

// ProductMeta defines model for ProductMeta.
type ProductMeta struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// ProductRequest defines model for ProductRequest.
type ProductRequest struct {
	BusinessCriticality *ProductRequestBusinessCriticality `json:"business_criticality"`
	Description         string                             `json:"description"`

	// Allows full risk acceptance using a risk acceptance form, expiration date, uploaded proof, etc.
	EnableFullRiskAcceptance *bool `json:"enable_full_risk_acceptance,omitempty"`

	// Allows simple risk acceptance by checking/unchecking a checkbox.
	EnableSimpleRiskAcceptance *bool `json:"enable_simple_risk_acceptance,omitempty"`

	// Specify if the application is used by people outside the organization.
	ExternalAudience *bool `json:"external_audience,omitempty"`

	// Specify if the application is accessible from the public internet.
	InternetAccessible *bool                    `json:"internet_accessible,omitempty"`
	Lifecycle          *ProductRequestLifecycle `json:"lifecycle"`
	Name               string                   `json:"name"`
	Origin             *ProductRequestOrigin    `json:"origin"`
	Platform           *ProductRequestPlatform  `json:"platform"`
	ProdNumericGrade   *int                     `json:"prod_numeric_grade"`
	ProdType           int                      `json:"prod_type"`
	ProductManager     *int                     `json:"product_manager"`
	Regulations        *[]int                   `json:"regulations,omitempty"`

	// Estimate the application's revenue.
	Revenue          *string   `json:"revenue"`
	SlaConfiguration *int      `json:"sla_configuration,omitempty"`
	Tags             *[]string `json:"tags,omitempty"`
	TeamManager      *int      `json:"team_manager"`
	TechnicalContact *int      `json:"technical_contact"`

	// Estimate the number of user records within the application.
	UserRecords *int `json:"user_records"`
}

// ProductRequestBusinessCriticality defines model for ProductRequest.BusinessCriticality.
type ProductRequestBusinessCriticality string

// ProductRequestLifecycle defines model for ProductRequest.Lifecycle.
type ProductRequestLifecycle string

// ProductRequestOrigin defines model for ProductRequest.Origin.
type ProductRequestOrigin string

// ProductRequestPlatform defines model for ProductRequest.Platform.
type ProductRequestPlatform string

// ProductType defines model for ProductType.
type ProductType struct {
	AuthorizationGroups []int      `json:"authorization_groups"`
	Created             *time.Time `json:"created"`
	CriticalProduct     *bool      `json:"critical_product,omitempty"`
	Description         *string    `json:"description"`
	Id                  int        `json:"id"`
	KeyProduct          *bool      `json:"key_product,omitempty"`
	Members             []int      `json:"members"`
	Name                string     `json:"name"`
	Prefetch            *struct {
		AuthorizationGroups *ProductType_Prefetch_AuthorizationGroups `json:"authorization_groups,omitempty"`
		Members             *ProductType_Prefetch_Members             `json:"members,omitempty"`
	} `json:"prefetch,omitempty"`
	Updated *time.Time `json:"updated"`
}

// ProductType_Prefetch_AuthorizationGroups defines model for ProductType.Prefetch.AuthorizationGroups.
type ProductType_Prefetch_AuthorizationGroups struct {
	AdditionalProperties map[string]DojoGroup `json:"-"`
}

// ProductType_Prefetch_Members defines model for ProductType.Prefetch.Members.
type ProductType_Prefetch_Members struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// ProductTypeGroup defines model for ProductTypeGroup.
type ProductTypeGroup struct {
	Group    int `json:"group"`
	Id       int `json:"id"`
	Prefetch *struct {
		Group       *ProductTypeGroup_Prefetch_Group       `json:"group,omitempty"`
		ProductType *ProductTypeGroup_Prefetch_ProductType `json:"product_type,omitempty"`
		Role        *ProductTypeGroup_Prefetch_Role        `json:"role,omitempty"`
	} `json:"prefetch,omitempty"`
	ProductType int `json:"product_type"`
	Role        int `json:"role"`
}

// ProductTypeGroup_Prefetch_Group defines model for ProductTypeGroup.Prefetch.Group.
type ProductTypeGroup_Prefetch_Group struct {
	AdditionalProperties map[string]DojoGroup `json:"-"`
}

// ProductTypeGroup_Prefetch_ProductType defines model for ProductTypeGroup.Prefetch.ProductType.
type ProductTypeGroup_Prefetch_ProductType struct {
	AdditionalProperties map[string]ProductType `json:"-"`
}

// ProductTypeGroup_Prefetch_Role defines model for ProductTypeGroup.Prefetch.Role.
type ProductTypeGroup_Prefetch_Role struct {
	AdditionalProperties map[string]Role `json:"-"`
}

// ProductTypeGroupRequest defines model for ProductTypeGroupRequest.
type ProductTypeGroupRequest struct {
	Group       int `json:"group"`
	ProductType int `json:"product_type"`
	Role        int `json:"role"`
}

// ProductTypeMember defines model for ProductTypeMember.
type ProductTypeMember struct {
	Id       int `json:"id"`
	Prefetch *struct {
		ProductType *ProductTypeMember_Prefetch_ProductType `json:"product_type,omitempty"`
		Role        *ProductTypeMember_Prefetch_Role        `json:"role,omitempty"`
		User        *ProductTypeMember_Prefetch_User        `json:"user,omitempty"`
	} `json:"prefetch,omitempty"`
	ProductType int `json:"product_type"`
	Role        int `json:"role"`
	User        int `json:"user"`
}

// ProductTypeMember_Prefetch_ProductType defines model for ProductTypeMember.Prefetch.ProductType.
type ProductTypeMember_Prefetch_ProductType struct {
	AdditionalProperties map[string]ProductType `json:"-"`
}

// ProductTypeMember_Prefetch_Role defines model for ProductTypeMember.Prefetch.Role.
type ProductTypeMember_Prefetch_Role struct {
	AdditionalProperties map[string]Role `json:"-"`
}

// ProductTypeMember_Prefetch_User defines model for ProductTypeMember.Prefetch.User.
type ProductTypeMember_Prefetch_User struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// ProductTypeMemberRequest defines model for ProductTypeMemberRequest.
type ProductTypeMemberRequest struct {
	ProductType int `json:"product_type"`
	Role        int `json:"role"`
	User        int `json:"user"`
}

// ProductTypeRequest defines model for ProductTypeRequest.
type ProductTypeRequest struct {
	CriticalProduct *bool   `json:"critical_product,omitempty"`
	Description     *string `json:"description"`
	KeyProduct      *bool   `json:"key_product,omitempty"`
	Name            string  `json:"name"`
}

// ReImportScan defines model for ReImportScan.
type ReImportScan struct {
	// Select if these findings are currently active.
	Active               *bool `json:"active,omitempty"`
	ApiScanConfiguration *int  `json:"api_scan_configuration"`
	AutoCreateContext    *bool `json:"auto_create_context,omitempty"`

	// Branch or Tag that was scanned.
	BranchTag *string `json:"branch_tag,omitempty"`

	// ID of the build that was scanned.
	BuildId *string `json:"build_id,omitempty"`

	// Select if old findings no longer present in the report get closed as mitigated when importing.
	CloseOldFindings *bool `json:"close_old_findings,omitempty"`

	// Select if close_old_findings applies to all findings of the same type in the product. By default, it is false meaning that only old findings of the same type in the engagement are in scope. Note that this only applies on the first call to reimport-scan.
	CloseOldFindingsProductScope *bool `json:"close_old_findings_product_scope,omitempty"`

	// Commit that was scanned.
	CommitHash *string `json:"commit_hash,omitempty"`

	// If set to false, finding groups will only be created when there is more than one grouped finding
	CreateFindingGroupsForAllFindings *bool `json:"create_finding_groups_for_all_findings,omitempty"`
	DeduplicationOnEngagement         *bool `json:"deduplication_on_engagement,omitempty"`

	// Select if the import should ignore active findings from the report, useful for triage-less scanners. Will keep existing findings closed, without reactivating them. For more information check the docs.
	DoNotReactivate *bool `json:"do_not_reactivate,omitempty"`
	EndpointToAdd   *int  `json:"endpoint_to_add,omitempty"`

	// End Date for Engagement. Default is current time + 365 days. Required format year-month-day
	EngagementEndDate *openapi_types.Date `json:"engagement_end_date,omitempty"`
	EngagementId      int                 `json:"engagement_id"`
	EngagementName    *string             `json:"engagement_name,omitempty"`
	Environment       *string             `json:"environment,omitempty"`
	File              *string             `json:"file,omitempty"`

	// Choose an option to automatically group new findings by the chosen option.
	GroupBy *ReImportScanGroupBy `json:"group_by,omitempty"`
	Lead    *int                 `json:"lead"`

	// Minimum severity level to be imported
	MinimumSeverity *ReImportScanMinimumSeverity `json:"minimum_severity,omitempty"`
	ProductId       int                          `json:"product_id"`
	ProductName     *string                      `json:"product_name,omitempty"`
	ProductTypeId   int                          `json:"product_type_id"`
	ProductTypeName *string                      `json:"product_type_name,omitempty"`
	PushToJira      *bool                        `json:"push_to_jira,omitempty"`

	// Scan completion date will be used on all findings.
	ScanDate *openapi_types.Date  `json:"scan_date,omitempty"`
	ScanType ReImportScanScanType `json:"scan_type"`

	// A service is a self-contained piece of functionality within a Product. This is an optional field which is used in deduplication and closing of old findings when set. This affects the whole engagement/product depending on your deduplication scope.
	Service *string `json:"service,omitempty"`

	// Resource link to source code
	SourceCodeManagementUri *string `json:"source_code_management_uri,omitempty"`
	Statistics              struct {
		// Embedded struct due to allOf(#/components/schemas/ImportStatistics)
		ImportStatistics `yaml:",inline"`
	} `json:"statistics"`

	// Modify existing tags that help describe this scan.
	Tags      *[]string `json:"tags,omitempty"`
	Test      *int      `json:"test,omitempty"`
	TestId    int       `json:"test_id"`
	TestTitle *string   `json:"test_title,omitempty"`

	// Select if these findings have been verified.
	Verified *bool `json:"verified,omitempty"`

	// Version that will be set on existing Test object. Leave empty to leave existing value in place.
	Version *string `json:"version,omitempty"`
}

// Choose an option to automatically group new findings by the chosen option.
type ReImportScanGroupBy string

// Minimum severity level to be imported
type ReImportScanMinimumSeverity string

// ReImportScanScanType defines model for ReImportScan.ScanType.
type ReImportScanScanType string

// ReImportScanRequest defines model for ReImportScanRequest.
type ReImportScanRequest struct {
	// Select if these findings are currently active.
	Active               *bool `json:"active,omitempty"`
	ApiScanConfiguration *int  `json:"api_scan_configuration"`
	AutoCreateContext    *bool `json:"auto_create_context,omitempty"`

	// Branch or Tag that was scanned.
	BranchTag *string `json:"branch_tag,omitempty"`

	// ID of the build that was scanned.
	BuildId *string `json:"build_id,omitempty"`

	// Select if old findings no longer present in the report get closed as mitigated when importing.
	CloseOldFindings *bool `json:"close_old_findings,omitempty"`

	// Select if close_old_findings applies to all findings of the same type in the product. By default, it is false meaning that only old findings of the same type in the engagement are in scope. Note that this only applies on the first call to reimport-scan.
	CloseOldFindingsProductScope *bool `json:"close_old_findings_product_scope,omitempty"`

	// Commit that was scanned.
	CommitHash *string `json:"commit_hash,omitempty"`

	// If set to false, finding groups will only be created when there is more than one grouped finding
	CreateFindingGroupsForAllFindings *bool `json:"create_finding_groups_for_all_findings,omitempty"`
	DeduplicationOnEngagement         *bool `json:"deduplication_on_engagement,omitempty"`

	// Select if the import should ignore active findings from the report, useful for triage-less scanners. Will keep existing findings closed, without reactivating them. For more information check the docs.
	DoNotReactivate *bool `json:"do_not_reactivate,omitempty"`
	EndpointToAdd   *int  `json:"endpoint_to_add,omitempty"`

	// End Date for Engagement. Default is current time + 365 days. Required format year-month-day
	EngagementEndDate *openapi_types.Date `json:"engagement_end_date,omitempty"`
	EngagementName    *string             `json:"engagement_name,omitempty"`
	Environment       *string             `json:"environment,omitempty"`
	File              *string             `json:"file,omitempty"`

	// Choose an option to automatically group new findings by the chosen option.
	GroupBy *ReImportScanRequestGroupBy `json:"group_by,omitempty"`
	Lead    *int                        `json:"lead"`

	// Minimum severity level to be imported
	MinimumSeverity *ReImportScanRequestMinimumSeverity `json:"minimum_severity,omitempty"`
	ProductName     *string                             `json:"product_name,omitempty"`
	ProductTypeName *string                             `json:"product_type_name,omitempty"`
	PushToJira      *bool                               `json:"push_to_jira,omitempty"`

	// Scan completion date will be used on all findings.
	ScanDate *openapi_types.Date         `json:"scan_date,omitempty"`
	ScanType ReImportScanRequestScanType `json:"scan_type"`

	// A service is a self-contained piece of functionality within a Product. This is an optional field which is used in deduplication and closing of old findings when set. This affects the whole engagement/product depending on your deduplication scope.
	Service *string `json:"service,omitempty"`

	// Resource link to source code
	SourceCodeManagementUri *string `json:"source_code_management_uri,omitempty"`

	// Modify existing tags that help describe this scan.
	Tags      *[]string `json:"tags,omitempty"`
	Test      *int      `json:"test,omitempty"`
	TestTitle *string   `json:"test_title,omitempty"`

	// Select if these findings have been verified.
	Verified *bool `json:"verified,omitempty"`

	// Version that will be set on existing Test object. Leave empty to leave existing value in place.
	Version *string `json:"version,omitempty"`
}

// Choose an option to automatically group new findings by the chosen option.
type ReImportScanRequestGroupBy string

// Minimum severity level to be imported
type ReImportScanRequestMinimumSeverity string

// ReImportScanRequestScanType defines model for ReImportScanRequest.ScanType.
type ReImportScanRequestScanType string

// Regulation defines model for Regulation.
type Regulation struct {
	// A shortened representation of the name.
	Acronym string `json:"acronym"`

	// The subject of the regulation.
	Category RegulationCategory `json:"category"`

	// Information about the regulation's purpose.
	Description *string `json:"description,omitempty"`
	Id          int     `json:"id"`

	// The territory over which the regulation applies.
	Jurisdiction string `json:"jurisdiction"`

	// The name of the regulation.
	Name string `json:"name"`

	// An external URL for more information.
	Reference *string `json:"reference,omitempty"`
}

// The subject of the regulation.
type RegulationCategory string

// RegulationRequest defines model for RegulationRequest.
type RegulationRequest struct {
	// A shortened representation of the name.
	Acronym string `json:"acronym"`

	// The subject of the regulation.
	Category RegulationRequestCategory `json:"category"`

	// Information about the regulation's purpose.
	Description *string `json:"description,omitempty"`

	// The territory over which the regulation applies.
	Jurisdiction string `json:"jurisdiction"`

	// The name of the regulation.
	Name string `json:"name"`

	// An external URL for more information.
	Reference *string `json:"reference,omitempty"`
}

// The subject of the regulation.
type RegulationRequestCategory string

// ReportGenerate defines model for ReportGenerate.
type ReportGenerate struct {
	Endpoint struct {
		// Embedded struct due to allOf(#/components/schemas/Endpoint)
		Endpoint `yaml:",inline"`
	} `json:"endpoint"`
	Endpoints  []Endpoint `json:"endpoints"`
	Engagement struct {
		// Embedded struct due to allOf(#/components/schemas/Engagement)
		Engagement `yaml:",inline"`
	} `json:"engagement"`
	ExecutiveSummary *struct {
		// Embedded struct due to allOf(#/components/schemas/ExecutiveSummary)
		ExecutiveSummary `yaml:",inline"`
	} `json:"executive_summary"`
	FindingNotes *[]FindingToNotes `json:"finding_notes"`
	Findings     []Finding         `json:"findings"`
	Host         string            `json:"host"`
	Product      struct {
		// Embedded struct due to allOf(#/components/schemas/Product)
		Product `yaml:",inline"`
	} `json:"product"`
	ProductType struct {
		// Embedded struct due to allOf(#/components/schemas/ProductType)
		ProductType `yaml:",inline"`
	} `json:"product_type"`
	ReportInfo string `json:"report_info"`
	ReportName string `json:"report_name"`
	TeamName   string `json:"team_name"`
	Test       struct {
		// Embedded struct due to allOf(#/components/schemas/Test)
		Test `yaml:",inline"`
	} `json:"test"`
	Title string `json:"title"`
	User  struct {
		// Embedded struct due to allOf(#/components/schemas/UserStub)
		UserStub `yaml:",inline"`
	} `json:"user"`
	UserId int `json:"user_id"`
}

// ReportGenerateOptionRequest defines model for ReportGenerateOptionRequest.
type ReportGenerateOptionRequest struct {
	IncludeExecutiveSummary *bool `json:"include_executive_summary,omitempty"`
	IncludeFindingImages    *bool `json:"include_finding_images,omitempty"`
	IncludeFindingNotes     *bool `json:"include_finding_notes,omitempty"`
	IncludeTableOfContents  *bool `json:"include_table_of_contents,omitempty"`
}

// RiskAcceptance defines model for RiskAcceptance.
type RiskAcceptance struct {
	// The person that accepts the risk, can be outside of DefectDojo.
	AcceptedBy       *string   `json:"accepted_by"`
	AcceptedFindings []int     `json:"accepted_findings"`
	Created          time.Time `json:"created"`

	// Risk treatment decision by risk owner
	Decision *RiskAcceptanceDecision `json:"decision,omitempty"`

	// If a compensating control exists to mitigate the finding or reduce risk, then list the compensating control(s).
	DecisionDetails *string `json:"decision_details"`

	// When the risk acceptance expires, the findings will be reactivated (unless disabled below).
	ExpirationDate *time.Time `json:"expiration_date"`

	// (readonly) When the risk acceptance expiration was handled (manually or by the daily job).
	ExpirationDateHandled *time.Time `json:"expiration_date_handled"`

	// (readonly) Date at which notice about the risk acceptance expiration was sent.
	ExpirationDateWarned *time.Time `json:"expiration_date_warned"`
	Id                   int        `json:"id"`

	// Descriptive name which in the future may also be used to group risk acceptances together across engagements and products
	Name  string `json:"name"`
	Notes []int  `json:"notes"`

	// User in DefectDojo owning this acceptance. Only the owner and staff users can edit the risk acceptance.
	Owner int     `json:"owner"`
	Path  *string `json:"path"`

	// Reactivate findings when risk acceptance expires?
	ReactivateExpired *bool `json:"reactivate_expired,omitempty"`

	// Recommendation from the security team.
	Recommendation *RiskAcceptanceRecommendation `json:"recommendation,omitempty"`

	// Explanation of security recommendation
	RecommendationDetails *string `json:"recommendation_details"`

	// When enabled, the SLA for findings is restarted when the risk acceptance expires.
	RestartSlaExpired *bool     `json:"restart_sla_expired,omitempty"`
	Updated           time.Time `json:"updated"`
}

// Risk treatment decision by risk owner
type RiskAcceptanceDecision string

// Recommendation from the security team.
type RiskAcceptanceRecommendation string

// Role defines model for Role.
type Role struct {
	Id      int    `json:"id"`
	IsOwner *bool  `json:"is_owner,omitempty"`
	Name    string `json:"name"`
}

// SLAConfiguration defines model for SLAConfiguration.
type SLAConfiguration struct {
	// number of days to remediate a critical finding.
	Critical    *int    `json:"critical,omitempty"`
	Description *string `json:"description"`

	// number of days to remediate a high finding.
	High *int `json:"high,omitempty"`
	Id   int  `json:"id"`

	// number of days to remediate a low finding.
	Low *int `json:"low,omitempty"`

	// number of days to remediate a medium finding.
	Medium *int `json:"medium,omitempty"`

	// A unique name for the set of SLAs.
	Name string `json:"name"`
}

// SLAConfigurationRequest defines model for SLAConfigurationRequest.
type SLAConfigurationRequest struct {
	// number of days to remediate a critical finding.
	Critical    *int    `json:"critical,omitempty"`
	Description *string `json:"description"`

	// number of days to remediate a high finding.
	High *int `json:"high,omitempty"`

	// number of days to remediate a low finding.
	Low *int `json:"low,omitempty"`

	// number of days to remediate a medium finding.
	Medium *int `json:"medium,omitempty"`

	// A unique name for the set of SLAs.
	Name string `json:"name"`
}

// SeverityStatusStatistics defines model for SeverityStatusStatistics.
type SeverityStatusStatistics struct {
	Critical StatusStatistics `json:"critical"`
	High     StatusStatistics `json:"high"`
	Info     StatusStatistics `json:"info"`
	Low      StatusStatistics `json:"low"`
	Medium   StatusStatistics `json:"medium"`
	Total    StatusStatistics `json:"total"`
}

// SonarqubeIssue defines model for SonarqubeIssue.
type SonarqubeIssue struct {
	Id int `json:"id"`

	// SonarQube issue key
	Key string `json:"key"`

	// SonarQube issue status
	Status string `json:"status"`

	// SonarQube issue type
	Type string `json:"type"`
}

// SonarqubeIssueRequest defines model for SonarqubeIssueRequest.
type SonarqubeIssueRequest struct {
	// SonarQube issue key
	Key string `json:"key"`

	// SonarQube issue status
	Status string `json:"status"`

	// SonarQube issue type
	Type string `json:"type"`
}

// SonarqubeIssueTransition defines model for SonarqubeIssueTransition.
type SonarqubeIssueTransition struct {
	Created         time.Time `json:"created"`
	FindingStatus   string    `json:"finding_status"`
	Id              int       `json:"id"`
	SonarqubeIssue  int       `json:"sonarqube_issue"`
	SonarqubeStatus string    `json:"sonarqube_status"`
	Transitions     string    `json:"transitions"`
}

// SonarqubeIssueTransitionRequest defines model for SonarqubeIssueTransitionRequest.
type SonarqubeIssueTransitionRequest struct {
	FindingStatus   string `json:"finding_status"`
	SonarqubeIssue  int    `json:"sonarqube_issue"`
	SonarqubeStatus string `json:"sonarqube_status"`
	Transitions     string `json:"transitions"`
}

// StatusStatistics defines model for StatusStatistics.
type StatusStatistics struct {
	Active       int `json:"active"`
	Duplicate    int `json:"duplicate"`
	FalseP       int `json:"false_p"`
	IsMitigated  int `json:"is_mitigated"`
	OutOfScope   int `json:"out_of_scope"`
	RiskAccepted int `json:"risk_accepted"`
	Total        int `json:"total"`
	Verified     int `json:"verified"`
}

// StubFinding defines model for StubFinding.
type StubFinding struct {
	Date        *openapi_types.Date `json:"date,omitempty"`
	Description *string             `json:"description"`
	Id          int                 `json:"id"`
	Reporter    int                 `json:"reporter"`
	Severity    *string             `json:"severity"`
	Test        int                 `json:"test"`
	Title       string              `json:"title"`
}

// StubFindingCreate defines model for StubFindingCreate.
type StubFindingCreate struct {
	Date        *openapi_types.Date `json:"date,omitempty"`
	Description *string             `json:"description"`
	Id          int                 `json:"id"`
	Reporter    int                 `json:"reporter"`
	Severity    *string             `json:"severity"`
	Test        int                 `json:"test"`
	Title       string              `json:"title"`
}

// StubFindingCreateRequest defines model for StubFindingCreateRequest.
type StubFindingCreateRequest struct {
	Date        *openapi_types.Date `json:"date,omitempty"`
	Description *string             `json:"description"`
	Severity    *string             `json:"severity"`
	Test        int                 `json:"test"`
	Title       string              `json:"title"`
}

// StubFindingRequest defines model for StubFindingRequest.
type StubFindingRequest struct {
	Date        *openapi_types.Date `json:"date,omitempty"`
	Description *string             `json:"description"`
	Severity    *string             `json:"severity"`
	Title       string              `json:"title"`
}

// SystemSettings defines model for SystemSettings.
type SystemSettings struct {
	AddVulnerabilityIdToJiraLabel *bool `json:"add_vulnerability_id_to_jira_label,omitempty"`

	// Enable anyone with a link to the survey to answer a survey
	AllowAnonymousSurveyRepsonse *bool   `json:"allow_anonymous_survey_repsonse,omitempty"`
	ColumnWidths                 *string `json:"column_widths,omitempty"`
	Credentials                  *string `json:"credentials,omitempty"`

	// New users will be assigned to this group.
	DefaultGroup *int `json:"default_group"`

	// New users will only be assigned to the default group, when their email address matches this regex pattern. This is optional condition.
	DefaultGroupEmailPattern *string `json:"default_group_email_pattern,omitempty"`

	// New users will be assigned to their default group with this role.
	DefaultGroupRole *int `json:"default_group_role"`

	// Requires next setting: maximum number of duplicates to retain.
	DeleteDuplicates *bool `json:"delete_duplicates,omitempty"`

	// Allows incoming requests without a secret (discouraged legacy behaviour)
	DisableJiraWebhookSecret *bool `json:"disable_jira_webhook_secret,omitempty"`

	// Include this custom disclaimer on all notifications and generated reports
	Disclaimer    *string              `json:"disclaimer,omitempty"`
	DriveFolderID *string              `json:"drive_folder_ID,omitempty"`
	EmailAddress  *openapi_types.Email `json:"email_address,omitempty"`
	EmailFrom     *string              `json:"email_from,omitempty"`

	// With this setting turned on, Dojo maintains an audit log of changes made to entities (Findings, Tests, Engagements, Procuts, ...)If you run big import you may want to disable this because the way django-auditlog currently works, there's a big performance hit. Especially during (re-)imports.
	EnableAuditlog *bool `json:"enable_auditlog,omitempty"`

	// Enables Benchmarks such as the OWASP ASVS (Application Security Verification Standard)
	EnableBenchmark *bool `json:"enable_benchmark,omitempty"`

	// With this setting turned off, the Calendar will be disabled in the user interface.
	EnableCalendar *bool `json:"enable_calendar,omitempty"`

	// With this setting turned off, checklists will be disabled in the user interface.
	EnableChecklists *bool `json:"enable_checklists,omitempty"`

	// With this setting turned off, credentials will be disabled in the user interface.
	EnableCredentials *bool `json:"enable_credentials,omitempty"`

	// With this setting turned on, Dojo deduplicates findings by comparing endpoints, cwe fields, and titles. If two findings share a URL and have the same CWE or title, Dojo marks the less recent finding as a duplicate. When deduplication is enabled, a list of deduplicated findings is added to the engagement view.
	EnableDeduplication *bool `json:"enable_deduplication,omitempty"`

	// With this setting turned off, endpoint metadata import will be disabled in the user interface.
	EnableEndpointMetadataImport *bool `json:"enable_endpoint_metadata_import,omitempty"`

	// With this setting turned off, the Finding Groups will be disabled.
	EnableFindingGroups *bool `json:"enable_finding_groups,omitempty"`

	// Enables Finding SLA's for time to remediate.
	EnableFindingSla *bool `json:"enable_finding_sla,omitempty"`
	EnableGithub     *bool `json:"enable_github,omitempty"`

	// With this setting turned off, the Google sheets integration will be disabled in the user interface.
	EnableGoogleSheets *bool `json:"enable_google_sheets,omitempty"`
	EnableJira         *bool `json:"enable_jira,omitempty"`

	// Please note: It is strongly recommended to use a secret below and / or IP whitelist the JIRA server using a proxy such as Nginx.
	EnableJiraWebHook          *bool `json:"enable_jira_web_hook,omitempty"`
	EnableMailNotifications    *bool `json:"enable_mail_notifications,omitempty"`
	EnableMsteamsNotifications *bool `json:"enable_msteams_notifications,omitempty"`

	// Enables Notify when time to remediate according to Finding SLA's is breached for active Findings.
	EnableNotifySlaActive *bool `json:"enable_notify_sla_active,omitempty"`

	// Enables Notify when time to remediate according to Finding SLA's is breached for active, verified Findings.
	EnableNotifySlaActiveVerified *bool `json:"enable_notify_sla_active_verified,omitempty"`

	// Enables Notify when time to remediate according to Finding SLA's is breached for Findings that are linked to JIRA issues.
	EnableNotifySlaJiraOnly *bool `json:"enable_notify_sla_jira_only,omitempty"`

	// Displays a grade letter next to a product to show the overall health.
	EnableProductGrade *bool `json:"enable_product_grade,omitempty"`

	// With this setting turned off, the product tracking files will be disabled in the user interface.
	EnableProductTrackingFiles *bool `json:"enable_product_tracking_files,omitempty"`

	// With this setting turned off, questionnaires will be disabled in the user interface.
	EnableQuestionnaires *bool `json:"enable_questionnaires,omitempty"`

	// With this setting turned off, the rules framwork will be disabled in the user interface.
	EnableRulesFramework     *bool `json:"enable_rules_framework,omitempty"`
	EnableSlackNotifications *bool `json:"enable_slack_notifications,omitempty"`

	// Enables global remediation advice and matching on CWE and Title. The text will be replaced for mitigation, impact and references on a finding. Useful for providing consistent impact and remediation advice regardless of the scanner.
	EnableTemplateMatch *bool `json:"enable_template_match,omitempty"`

	// When turned on users can edit their profiles
	EnableUserProfileEditable *bool `json:"enable_user_profile_editable,omitempty"`

	// Closes an engagement after 3 days (default) past due date including last update.
	EngagementAutoClose *bool `json:"engagement_auto_close,omitempty"`

	// Closes an engagement after the specified number of days past due date including last update.
	EngagementAutoCloseDays *int `json:"engagement_auto_close_days,omitempty"`

	// DefectDojo will automatically mark the finding as a false positive if the finding has been previously marked as a false positive. Not needed when using deduplication, advised to not combine these two.
	FalsePositiveHistory *bool `json:"false_positive_history,omitempty"`
	Id                   int   `json:"id"`

	// JIRA issue labels space seperated
	JiraLabels          *string                            `json:"jira_labels"`
	JiraMinimumSeverity *SystemSettingsJiraMinimumSeverity `json:"jira_minimum_severity"`

	// Secret needed in URL for incoming JIRA Webhook
	JiraWebhookSecret *string `json:"jira_webhook_secret"`

	// Requires user passwords to contain at least one lowercase letter (a-z).
	LowercaseCharacterRequired *bool   `json:"lowercase_character_required,omitempty"`
	MailNotificationsTo        *string `json:"mail_notifications_to,omitempty"`

	// When enabled, if a single issue reaches the maximum number of duplicates, the oldest will be deleted. Duplicate will not be deleted when left empty. A value of 0 will remove all duplicates.
	MaxDupes *int `json:"max_dupes"`

	// Requires user to set passwords less than maximum length.
	MaximumPasswordLength *int `json:"maximum_password_length,omitempty"`

	// Requires user to set passwords greater than minimum length.
	MinimumPasswordLength *int `json:"minimum_password_length,omitempty"`

	// The full URL of the incoming webhook
	MsteamsUrl *string `json:"msteams_url,omitempty"`

	// Requires user passwords to contain at least one digit (0-9).
	NumberCharacterRequired *bool   `json:"number_character_required,omitempty"`
	ProductGrade            *string `json:"product_grade,omitempty"`

	// Percentage score for an 'A' >=
	ProductGradeA *int `json:"product_grade_a,omitempty"`

	// Percentage score for a 'B' >=
	ProductGradeB *int `json:"product_grade_b,omitempty"`

	// Percentage score for a 'C' >=
	ProductGradeC *int `json:"product_grade_c,omitempty"`

	// Percentage score for a 'D' >=
	ProductGradeD *int `json:"product_grade_d,omitempty"`

	// Percentage score for an 'F' <=
	ProductGradeF *int `json:"product_grade_f,omitempty"`

	// Default expiry period for risk acceptance form.
	RiskAcceptanceFormDefaultDays *int `json:"risk_acceptance_form_default_days"`

	// Notify X days before risk acceptance expires. Leave empty to disable.
	RiskAcceptanceNotifyBeforeExpiration *int `json:"risk_acceptance_notify_before_expiration"`

	// Optional. Needed if you want to send global notifications.
	SlackChannel *string `json:"slack_channel,omitempty"`

	// Token required for interacting with Slack. Get one at https://api.slack.com/tokens
	SlackToken *string `json:"slack_token,omitempty"`

	// Optional. Will take your bot name otherwise.
	SlackUsername *string `json:"slack_username,omitempty"`

	// Requires user passwords to contain at least one special character (()[]{}|\`~!@#$%^&*_-+=;:'",<>./?).
	SpecialCharacterRequired *bool                   `json:"special_character_required,omitempty"`
	TeamName                 *string                 `json:"team_name,omitempty"`
	TimeZone                 *SystemSettingsTimeZone `json:"time_zone,omitempty"`

	// Requires user passwords to contain at least one uppercase letter (A-Z).
	UppercaseCharacterRequired *bool `json:"uppercase_character_required,omitempty"`

	// URL prefix if DefectDojo is installed in it's own virtual subdirectory.
	UrlPrefix *string `json:"url_prefix,omitempty"`
}

// SystemSettingsJiraMinimumSeverity defines model for SystemSettings.JiraMinimumSeverity.
type SystemSettingsJiraMinimumSeverity string

// SystemSettingsTimeZone defines model for SystemSettings.TimeZone.
type SystemSettingsTimeZone string

// SystemSettingsRequest defines model for SystemSettingsRequest.
type SystemSettingsRequest struct {
	AddVulnerabilityIdToJiraLabel *bool `json:"add_vulnerability_id_to_jira_label,omitempty"`

	// Enable anyone with a link to the survey to answer a survey
	AllowAnonymousSurveyRepsonse *bool   `json:"allow_anonymous_survey_repsonse,omitempty"`
	ColumnWidths                 *string `json:"column_widths,omitempty"`
	Credentials                  *string `json:"credentials,omitempty"`

	// New users will be assigned to this group.
	DefaultGroup *int `json:"default_group"`

	// New users will only be assigned to the default group, when their email address matches this regex pattern. This is optional condition.
	DefaultGroupEmailPattern *string `json:"default_group_email_pattern,omitempty"`

	// New users will be assigned to their default group with this role.
	DefaultGroupRole *int `json:"default_group_role"`

	// Requires next setting: maximum number of duplicates to retain.
	DeleteDuplicates *bool `json:"delete_duplicates,omitempty"`

	// Allows incoming requests without a secret (discouraged legacy behaviour)
	DisableJiraWebhookSecret *bool `json:"disable_jira_webhook_secret,omitempty"`

	// Include this custom disclaimer on all notifications and generated reports
	Disclaimer    *string              `json:"disclaimer,omitempty"`
	DriveFolderID *string              `json:"drive_folder_ID,omitempty"`
	EmailAddress  *openapi_types.Email `json:"email_address,omitempty"`
	EmailFrom     *string              `json:"email_from,omitempty"`

	// With this setting turned on, Dojo maintains an audit log of changes made to entities (Findings, Tests, Engagements, Procuts, ...)If you run big import you may want to disable this because the way django-auditlog currently works, there's a big performance hit. Especially during (re-)imports.
	EnableAuditlog *bool `json:"enable_auditlog,omitempty"`

	// Enables Benchmarks such as the OWASP ASVS (Application Security Verification Standard)
	EnableBenchmark *bool `json:"enable_benchmark,omitempty"`

	// With this setting turned off, the Calendar will be disabled in the user interface.
	EnableCalendar *bool `json:"enable_calendar,omitempty"`

	// With this setting turned off, checklists will be disabled in the user interface.
	EnableChecklists *bool `json:"enable_checklists,omitempty"`

	// With this setting turned off, credentials will be disabled in the user interface.
	EnableCredentials *bool `json:"enable_credentials,omitempty"`

	// With this setting turned on, Dojo deduplicates findings by comparing endpoints, cwe fields, and titles. If two findings share a URL and have the same CWE or title, Dojo marks the less recent finding as a duplicate. When deduplication is enabled, a list of deduplicated findings is added to the engagement view.
	EnableDeduplication *bool `json:"enable_deduplication,omitempty"`

	// With this setting turned off, endpoint metadata import will be disabled in the user interface.
	EnableEndpointMetadataImport *bool `json:"enable_endpoint_metadata_import,omitempty"`

	// With this setting turned off, the Finding Groups will be disabled.
	EnableFindingGroups *bool `json:"enable_finding_groups,omitempty"`

	// Enables Finding SLA's for time to remediate.
	EnableFindingSla *bool `json:"enable_finding_sla,omitempty"`
	EnableGithub     *bool `json:"enable_github,omitempty"`

	// With this setting turned off, the Google sheets integration will be disabled in the user interface.
	EnableGoogleSheets *bool `json:"enable_google_sheets,omitempty"`
	EnableJira         *bool `json:"enable_jira,omitempty"`

	// Please note: It is strongly recommended to use a secret below and / or IP whitelist the JIRA server using a proxy such as Nginx.
	EnableJiraWebHook          *bool `json:"enable_jira_web_hook,omitempty"`
	EnableMailNotifications    *bool `json:"enable_mail_notifications,omitempty"`
	EnableMsteamsNotifications *bool `json:"enable_msteams_notifications,omitempty"`

	// Enables Notify when time to remediate according to Finding SLA's is breached for active Findings.
	EnableNotifySlaActive *bool `json:"enable_notify_sla_active,omitempty"`

	// Enables Notify when time to remediate according to Finding SLA's is breached for active, verified Findings.
	EnableNotifySlaActiveVerified *bool `json:"enable_notify_sla_active_verified,omitempty"`

	// Enables Notify when time to remediate according to Finding SLA's is breached for Findings that are linked to JIRA issues.
	EnableNotifySlaJiraOnly *bool `json:"enable_notify_sla_jira_only,omitempty"`

	// Displays a grade letter next to a product to show the overall health.
	EnableProductGrade *bool `json:"enable_product_grade,omitempty"`

	// With this setting turned off, the product tracking files will be disabled in the user interface.
	EnableProductTrackingFiles *bool `json:"enable_product_tracking_files,omitempty"`

	// With this setting turned off, questionnaires will be disabled in the user interface.
	EnableQuestionnaires *bool `json:"enable_questionnaires,omitempty"`

	// With this setting turned off, the rules framwork will be disabled in the user interface.
	EnableRulesFramework     *bool `json:"enable_rules_framework,omitempty"`
	EnableSlackNotifications *bool `json:"enable_slack_notifications,omitempty"`

	// Enables global remediation advice and matching on CWE and Title. The text will be replaced for mitigation, impact and references on a finding. Useful for providing consistent impact and remediation advice regardless of the scanner.
	EnableTemplateMatch *bool `json:"enable_template_match,omitempty"`

	// When turned on users can edit their profiles
	EnableUserProfileEditable *bool `json:"enable_user_profile_editable,omitempty"`

	// Closes an engagement after 3 days (default) past due date including last update.
	EngagementAutoClose *bool `json:"engagement_auto_close,omitempty"`

	// Closes an engagement after the specified number of days past due date including last update.
	EngagementAutoCloseDays *int `json:"engagement_auto_close_days,omitempty"`

	// DefectDojo will automatically mark the finding as a false positive if the finding has been previously marked as a false positive. Not needed when using deduplication, advised to not combine these two.
	FalsePositiveHistory *bool `json:"false_positive_history,omitempty"`

	// JIRA issue labels space seperated
	JiraLabels          *string                                   `json:"jira_labels"`
	JiraMinimumSeverity *SystemSettingsRequestJiraMinimumSeverity `json:"jira_minimum_severity"`

	// Secret needed in URL for incoming JIRA Webhook
	JiraWebhookSecret *string `json:"jira_webhook_secret"`

	// Requires user passwords to contain at least one lowercase letter (a-z).
	LowercaseCharacterRequired *bool   `json:"lowercase_character_required,omitempty"`
	MailNotificationsTo        *string `json:"mail_notifications_to,omitempty"`

	// When enabled, if a single issue reaches the maximum number of duplicates, the oldest will be deleted. Duplicate will not be deleted when left empty. A value of 0 will remove all duplicates.
	MaxDupes *int `json:"max_dupes"`

	// Requires user to set passwords less than maximum length.
	MaximumPasswordLength *int `json:"maximum_password_length,omitempty"`

	// Requires user to set passwords greater than minimum length.
	MinimumPasswordLength *int `json:"minimum_password_length,omitempty"`

	// The full URL of the incoming webhook
	MsteamsUrl *string `json:"msteams_url,omitempty"`

	// Requires user passwords to contain at least one digit (0-9).
	NumberCharacterRequired *bool   `json:"number_character_required,omitempty"`
	ProductGrade            *string `json:"product_grade,omitempty"`

	// Percentage score for an 'A' >=
	ProductGradeA *int `json:"product_grade_a,omitempty"`

	// Percentage score for a 'B' >=
	ProductGradeB *int `json:"product_grade_b,omitempty"`

	// Percentage score for a 'C' >=
	ProductGradeC *int `json:"product_grade_c,omitempty"`

	// Percentage score for a 'D' >=
	ProductGradeD *int `json:"product_grade_d,omitempty"`

	// Percentage score for an 'F' <=
	ProductGradeF *int `json:"product_grade_f,omitempty"`

	// Default expiry period for risk acceptance form.
	RiskAcceptanceFormDefaultDays *int `json:"risk_acceptance_form_default_days"`

	// Notify X days before risk acceptance expires. Leave empty to disable.
	RiskAcceptanceNotifyBeforeExpiration *int `json:"risk_acceptance_notify_before_expiration"`

	// Optional. Needed if you want to send global notifications.
	SlackChannel *string `json:"slack_channel,omitempty"`

	// Token required for interacting with Slack. Get one at https://api.slack.com/tokens
	SlackToken *string `json:"slack_token,omitempty"`

	// Optional. Will take your bot name otherwise.
	SlackUsername *string `json:"slack_username,omitempty"`

	// Requires user passwords to contain at least one special character (()[]{}|\`~!@#$%^&*_-+=;:'",<>./?).
	SpecialCharacterRequired *bool                          `json:"special_character_required,omitempty"`
	TeamName                 *string                        `json:"team_name,omitempty"`
	TimeZone                 *SystemSettingsRequestTimeZone `json:"time_zone,omitempty"`

	// Requires user passwords to contain at least one uppercase letter (A-Z).
	UppercaseCharacterRequired *bool `json:"uppercase_character_required,omitempty"`

	// URL prefix if DefectDojo is installed in it's own virtual subdirectory.
	UrlPrefix *string `json:"url_prefix,omitempty"`
}

// SystemSettingsRequestJiraMinimumSeverity defines model for SystemSettingsRequest.JiraMinimumSeverity.
type SystemSettingsRequestJiraMinimumSeverity string

// SystemSettingsRequestTimeZone defines model for SystemSettingsRequest.TimeZone.
type SystemSettingsRequestTimeZone string

// Tag defines model for Tag.
type Tag struct {
	Tags []string `json:"tags"`
}

// TagRequest defines model for TagRequest.
type TagRequest struct {
	Tags []string `json:"tags"`
}

// Test defines model for Test.
type Test struct {
	ActualTime           *string `json:"actual_time"`
	ApiScanConfiguration *int    `json:"api_scan_configuration"`

	// Tag or branch that was tested, a reimport may update this field.
	BranchTag *string `json:"branch_tag"`

	// Build ID that was tested, a reimport may update this field.
	BuildId *string `json:"build_id"`

	// Commit hash tested, a reimport may update this field.
	CommitHash      *string        `json:"commit_hash"`
	Created         *time.Time     `json:"created"`
	Description     *string        `json:"description"`
	Engagement      int            `json:"engagement"`
	Environment     *int           `json:"environment"`
	EstimatedTime   *string        `json:"estimated_time"`
	Files           []File         `json:"files"`
	FindingGroups   []FindingGroup `json:"finding_groups"`
	Id              int            `json:"id"`
	Lead            *int           `json:"lead"`
	Notes           []Note         `json:"notes"`
	PercentComplete *int           `json:"percent_complete"`
	ScanType        *string        `json:"scan_type"`
	Tags            *[]string      `json:"tags,omitempty"`
	TargetEnd       time.Time      `json:"target_end"`
	TargetStart     time.Time      `json:"target_start"`
	TestType        int            `json:"test_type"`
	TestTypeName    string         `json:"test_type_name"`
	Title           *string        `json:"title"`
	Updated         *time.Time     `json:"updated"`
	Version         *string        `json:"version"`
}

// TestCreate defines model for TestCreate.
type TestCreate struct {
	ActualTime           *string `json:"actual_time"`
	ApiScanConfiguration *int    `json:"api_scan_configuration"`

	// Tag or branch that was tested, a reimport may update this field.
	BranchTag *string `json:"branch_tag"`

	// Build ID that was tested, a reimport may update this field.
	BuildId *string `json:"build_id"`

	// Commit hash tested, a reimport may update this field.
	CommitHash      *string    `json:"commit_hash"`
	Created         *time.Time `json:"created"`
	Description     *string    `json:"description"`
	Engagement      int        `json:"engagement"`
	Environment     *int       `json:"environment"`
	EstimatedTime   *string    `json:"estimated_time"`
	Files           []int      `json:"files"`
	Id              int        `json:"id"`
	Lead            *int       `json:"lead"`
	Notes           *[]int     `json:"notes,omitempty"`
	PercentComplete *int       `json:"percent_complete"`
	ScanType        *string    `json:"scan_type"`
	Tags            *[]string  `json:"tags,omitempty"`
	TargetEnd       time.Time  `json:"target_end"`
	TargetStart     time.Time  `json:"target_start"`
	TestType        int        `json:"test_type"`
	Title           *string    `json:"title"`
	Updated         *time.Time `json:"updated"`
	Version         *string    `json:"version"`
}

// TestCreateRequest defines model for TestCreateRequest.
type TestCreateRequest struct {
	ApiScanConfiguration *int `json:"api_scan_configuration"`

	// Tag or branch that was tested, a reimport may update this field.
	BranchTag *string `json:"branch_tag"`

	// Build ID that was tested, a reimport may update this field.
	BuildId *string `json:"build_id"`

	// Commit hash tested, a reimport may update this field.
	CommitHash      *string   `json:"commit_hash"`
	Description     *string   `json:"description"`
	Engagement      int       `json:"engagement"`
	Environment     *int      `json:"environment"`
	Lead            *int      `json:"lead"`
	Notes           *[]int    `json:"notes,omitempty"`
	PercentComplete *int      `json:"percent_complete"`
	ScanType        *string   `json:"scan_type"`
	Tags            *[]string `json:"tags,omitempty"`
	TargetEnd       time.Time `json:"target_end"`
	TargetStart     time.Time `json:"target_start"`
	TestType        int       `json:"test_type"`
	Title           *string   `json:"title"`
	Version         *string   `json:"version"`
}

// TestImport defines model for TestImport.
type TestImport struct {
	// Tag or branch that was tested, a reimport may update this field.
	BranchTag *string `json:"branch_tag"`

	// Build ID that was tested, a reimport may update this field.
	BuildId *string `json:"build_id"`

	// Commit hash tested, a reimport may update this field.
	CommitHash       *string                    `json:"commit_hash"`
	Created          time.Time                  `json:"created"`
	FindingsAffected []int                      `json:"findings_affected"`
	Id               int                        `json:"id"`
	ImportSettings   *TestImport_ImportSettings `json:"import_settings"`
	Modified         time.Time                  `json:"modified"`
	Prefetch         *struct {
		FindingsAffected *TestImport_Prefetch_FindingsAffected `json:"findings_affected,omitempty"`
		Test             *TestImport_Prefetch_Test             `json:"test,omitempty"`
	} `json:"prefetch,omitempty"`
	Test                       int                       `json:"test"`
	TestImportFindingActionSet []TestImportFindingAction `json:"test_import_finding_action_set"`
	Type                       *string                   `json:"type,omitempty"`
	Version                    *string                   `json:"version"`
}

// TestImport_ImportSettings defines model for TestImport.ImportSettings.
type TestImport_ImportSettings struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// TestImport_Prefetch_FindingsAffected defines model for TestImport.Prefetch.FindingsAffected.
type TestImport_Prefetch_FindingsAffected struct {
	AdditionalProperties map[string]Finding `json:"-"`
}

// TestImport_Prefetch_Test defines model for TestImport.Prefetch.Test.
type TestImport_Prefetch_Test struct {
	AdditionalProperties map[string]Test `json:"-"`
}

// TestImportFindingAction defines model for TestImportFindingAction.
type TestImportFindingAction struct {
	Action     *TestImportFindingActionAction `json:"action"`
	Created    time.Time                      `json:"created"`
	Finding    int                            `json:"finding"`
	Id         int                            `json:"id"`
	Modified   time.Time                      `json:"modified"`
	TestImport int                            `json:"test_import"`
}

// TestImportFindingActionAction defines model for TestImportFindingAction.Action.
type TestImportFindingActionAction string

// TestImportRequest defines model for TestImportRequest.
type TestImportRequest struct {
	// Tag or branch that was tested, a reimport may update this field.
	BranchTag *string `json:"branch_tag"`

	// Build ID that was tested, a reimport may update this field.
	BuildId *string `json:"build_id"`

	// Commit hash tested, a reimport may update this field.
	CommitHash     *string                           `json:"commit_hash"`
	ImportSettings *TestImportRequest_ImportSettings `json:"import_settings"`
	Type           *string                           `json:"type,omitempty"`
	Version        *string                           `json:"version"`
}

// TestImportRequest_ImportSettings defines model for TestImportRequest.ImportSettings.
type TestImportRequest_ImportSettings struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// TestRequest defines model for TestRequest.
type TestRequest struct {
	ApiScanConfiguration *int `json:"api_scan_configuration"`

	// Tag or branch that was tested, a reimport may update this field.
	BranchTag *string `json:"branch_tag"`

	// Build ID that was tested, a reimport may update this field.
	BuildId *string `json:"build_id"`

	// Commit hash tested, a reimport may update this field.
	CommitHash      *string   `json:"commit_hash"`
	Description     *string   `json:"description"`
	Environment     *int      `json:"environment"`
	Lead            *int      `json:"lead"`
	PercentComplete *int      `json:"percent_complete"`
	ScanType        *string   `json:"scan_type"`
	Tags            *[]string `json:"tags,omitempty"`
	TargetEnd       time.Time `json:"target_end"`
	TargetStart     time.Time `json:"target_start"`
	TestType        int       `json:"test_type"`
	Title           *string   `json:"title"`
	Version         *string   `json:"version"`
}

// TestToFiles defines model for TestToFiles.
type TestToFiles struct {
	Files  []File `json:"files"`
	TestId *int   `json:"test_id"`
}

// TestToNotes defines model for TestToNotes.
type TestToNotes struct {
	Notes  []Note `json:"notes"`
	TestId *int   `json:"test_id"`
}

// TestType defines model for TestType.
type TestType struct {
	Active      *bool     `json:"active,omitempty"`
	DynamicTool *bool     `json:"dynamic_tool,omitempty"`
	Id          int       `json:"id"`
	Name        string    `json:"name"`
	StaticTool  *bool     `json:"static_tool,omitempty"`
	Tags        *[]string `json:"tags,omitempty"`
}

// TestTypeRequest defines model for TestTypeRequest.
type TestTypeRequest struct {
	Active      *bool     `json:"active,omitempty"`
	DynamicTool *bool     `json:"dynamic_tool,omitempty"`
	Name        string    `json:"name"`
	StaticTool  *bool     `json:"static_tool,omitempty"`
	Tags        *[]string `json:"tags,omitempty"`
}

// ToolConfiguration defines model for ToolConfiguration.
type ToolConfiguration struct {
	AuthTitle          *string                              `json:"auth_title"`
	AuthenticationType *ToolConfigurationAuthenticationType `json:"authentication_type"`
	Description        *string                              `json:"description"`

	// Additional definitions that will be consumed by scanner
	Extras   *string `json:"extras"`
	Id       int     `json:"id"`
	Name     string  `json:"name"`
	ToolType int     `json:"tool_type"`
	Url      *string `json:"url"`
	Username *string `json:"username"`
}

// ToolConfigurationAuthenticationType defines model for ToolConfiguration.AuthenticationType.
type ToolConfigurationAuthenticationType string

// ToolConfigurationRequest defines model for ToolConfigurationRequest.
type ToolConfigurationRequest struct {
	ApiKey             *string                                     `json:"api_key"`
	AuthTitle          *string                                     `json:"auth_title"`
	AuthenticationType *ToolConfigurationRequestAuthenticationType `json:"authentication_type"`
	Description        *string                                     `json:"description"`

	// Additional definitions that will be consumed by scanner
	Extras   *string `json:"extras"`
	Name     string  `json:"name"`
	Password *string `json:"password"`
	Ssh      *string `json:"ssh"`
	ToolType int     `json:"tool_type"`
	Url      *string `json:"url"`
	Username *string `json:"username"`
}

// ToolConfigurationRequestAuthenticationType defines model for ToolConfigurationRequest.AuthenticationType.
type ToolConfigurationRequestAuthenticationType string

// ToolProductSettings defines model for ToolProductSettings.
type ToolProductSettings struct {
	Description       *string `json:"description"`
	Id                int     `json:"id"`
	Name              string  `json:"name"`
	Notes             []int   `json:"notes"`
	Product           int     `json:"product"`
	SettingUrl        string  `json:"setting_url"`
	ToolConfiguration int     `json:"tool_configuration"`
	ToolProjectId     *string `json:"tool_project_id"`
	Url               *string `json:"url"`
}

// ToolProductSettingsRequest defines model for ToolProductSettingsRequest.
type ToolProductSettingsRequest struct {
	Description       *string `json:"description"`
	Name              string  `json:"name"`
	Product           int     `json:"product"`
	SettingUrl        string  `json:"setting_url"`
	ToolConfiguration int     `json:"tool_configuration"`
	ToolProjectId     *string `json:"tool_project_id"`
	Url               *string `json:"url"`
}

// ToolType defines model for ToolType.
type ToolType struct {
	Description *string `json:"description"`
	Id          int     `json:"id"`
	Name        string  `json:"name"`
}

// ToolTypeRequest defines model for ToolTypeRequest.
type ToolTypeRequest struct {
	Description *string `json:"description"`
	Name        string  `json:"name"`
}

// User defines model for User.
type User struct {
	ConfigurationPermissions *[]int               `json:"configuration_permissions,omitempty"`
	Email                    *openapi_types.Email `json:"email,omitempty"`
	FirstName                *string              `json:"first_name,omitempty"`
	Id                       int                  `json:"id"`

	// Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
	IsActive *bool `json:"is_active,omitempty"`

	// Designates that this user has all permissions without explicitly assigning them.
	IsSuperuser *bool     `json:"is_superuser,omitempty"`
	LastLogin   time.Time `json:"last_login"`
	LastName    *string   `json:"last_name,omitempty"`

	// Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
	Username string `json:"username"`
}

// UserContactInfo defines model for UserContactInfo.
type UserContactInfo struct {
	// Instead of async deduping a finding the findings will be deduped synchronously and will 'block' the user until completion.
	BlockExecution *bool `json:"block_execution,omitempty"`

	// Phone number must be entered in the format: '+999999999'. Up to 15 digits allowed.
	CellNumber *string `json:"cell_number,omitempty"`

	// Forces this user to reset their password on next login.
	ForcePasswordReset *bool   `json:"force_password_reset,omitempty"`
	GithubUsername     *string `json:"github_username"`
	Id                 int     `json:"id"`

	// Phone number must be entered in the format: '+999999999'. Up to 15 digits allowed.
	PhoneNumber *string `json:"phone_number,omitempty"`
	Prefetch    *struct {
		User *UserContactInfo_Prefetch_User `json:"user,omitempty"`
	} `json:"prefetch,omitempty"`
	SlackUserId *string `json:"slack_user_id"`

	// Email address associated with your slack account
	SlackUsername   *string `json:"slack_username"`
	Title           *string `json:"title"`
	TwitterUsername *string `json:"twitter_username"`
	User            int     `json:"user"`
}

// UserContactInfo_Prefetch_User defines model for UserContactInfo.Prefetch.User.
type UserContactInfo_Prefetch_User struct {
	AdditionalProperties map[string]UserStub `json:"-"`
}

// UserContactInfoRequest defines model for UserContactInfoRequest.
type UserContactInfoRequest struct {
	// Instead of async deduping a finding the findings will be deduped synchronously and will 'block' the user until completion.
	BlockExecution *bool `json:"block_execution,omitempty"`

	// Phone number must be entered in the format: '+999999999'. Up to 15 digits allowed.
	CellNumber *string `json:"cell_number,omitempty"`

	// Forces this user to reset their password on next login.
	ForcePasswordReset *bool   `json:"force_password_reset,omitempty"`
	GithubUsername     *string `json:"github_username"`

	// Phone number must be entered in the format: '+999999999'. Up to 15 digits allowed.
	PhoneNumber *string `json:"phone_number,omitempty"`
	SlackUserId *string `json:"slack_user_id"`

	// Email address associated with your slack account
	SlackUsername   *string `json:"slack_username"`
	Title           *string `json:"title"`
	TwitterUsername *string `json:"twitter_username"`
	User            int     `json:"user"`
}

// UserProfile defines model for UserProfile.
type UserProfile struct {
	DojoGroupMember   []DojoGroupMember   `json:"dojo_group_member"`
	GlobalRole        GlobalRole          `json:"global_role"`
	ProductMember     []ProductMember     `json:"product_member"`
	ProductTypeMember []ProductTypeMember `json:"product_type_member"`
	User              User                `json:"user"`
	UserContactInfo   UserContactInfo     `json:"user_contact_info"`
}

// UserRequest defines model for UserRequest.
type UserRequest struct {
	ConfigurationPermissions *[]int               `json:"configuration_permissions,omitempty"`
	Email                    *openapi_types.Email `json:"email,omitempty"`
	FirstName                *string              `json:"first_name,omitempty"`

	// Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
	IsActive *bool `json:"is_active,omitempty"`

	// Designates that this user has all permissions without explicitly assigning them.
	IsSuperuser *bool   `json:"is_superuser,omitempty"`
	LastName    *string `json:"last_name,omitempty"`
	Password    *string `json:"password,omitempty"`

	// Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
	Username string `json:"username"`
}

// UserStub defines model for UserStub.
type UserStub struct {
	FirstName *string `json:"first_name,omitempty"`
	Id        int     `json:"id"`
	LastName  *string `json:"last_name,omitempty"`

	// Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
	Username string `json:"username"`
}

// VulnerabilityId defines model for VulnerabilityId.
type VulnerabilityId struct {
	VulnerabilityId string `json:"vulnerability_id"`
}

// VulnerabilityIdRequest defines model for VulnerabilityIdRequest.
type VulnerabilityIdRequest struct {
	VulnerabilityId string `json:"vulnerability_id"`
}

// VulnerabilityIdTemplate defines model for VulnerabilityIdTemplate.
type VulnerabilityIdTemplate struct {
	VulnerabilityId string `json:"vulnerability_id"`
}

// VulnerabilityIdTemplateRequest defines model for VulnerabilityIdTemplateRequest.
type VulnerabilityIdTemplateRequest struct {
	VulnerabilityId string `json:"vulnerability_id"`
}

// ApiTokenAuthCreateJSONBody defines parameters for ApiTokenAuthCreate.
type ApiTokenAuthCreateJSONBody AuthTokenRequest

// ConfigurationPermissionsListParams defines parameters for ConfigurationPermissionsList.
type ConfigurationPermissionsListParams struct {
	Codename *string `json:"codename,omitempty"`
	Id       *int    `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// DevelopmentEnvironmentsListParams defines parameters for DevelopmentEnvironmentsList.
type DevelopmentEnvironmentsListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// DevelopmentEnvironmentsCreateJSONBody defines parameters for DevelopmentEnvironmentsCreate.
type DevelopmentEnvironmentsCreateJSONBody DevelopmentEnvironmentRequest

// DevelopmentEnvironmentsPartialUpdateJSONBody defines parameters for DevelopmentEnvironmentsPartialUpdate.
type DevelopmentEnvironmentsPartialUpdateJSONBody PatchedDevelopmentEnvironmentRequest

// DevelopmentEnvironmentsUpdateJSONBody defines parameters for DevelopmentEnvironmentsUpdate.
type DevelopmentEnvironmentsUpdateJSONBody DevelopmentEnvironmentRequest

// DevelopmentEnvironmentsDeletePreviewListParams defines parameters for DevelopmentEnvironmentsDeletePreviewList.
type DevelopmentEnvironmentsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// DojoGroupMembersListParams defines parameters for DojoGroupMembersList.
type DojoGroupMembersListParams struct {
	GroupId *int `json:"group_id,omitempty"`
	Id      *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]DojoGroupMembersListParamsPrefetch `json:"prefetch,omitempty"`
	UserId   *int                                  `json:"user_id,omitempty"`
}

// DojoGroupMembersListParamsPrefetch defines parameters for DojoGroupMembersList.
type DojoGroupMembersListParamsPrefetch string

// DojoGroupMembersCreateJSONBody defines parameters for DojoGroupMembersCreate.
type DojoGroupMembersCreateJSONBody DojoGroupMemberRequest

// DojoGroupMembersRetrieveParams defines parameters for DojoGroupMembersRetrieve.
type DojoGroupMembersRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]DojoGroupMembersRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// DojoGroupMembersRetrieveParamsPrefetch defines parameters for DojoGroupMembersRetrieve.
type DojoGroupMembersRetrieveParamsPrefetch string

// DojoGroupMembersPartialUpdateJSONBody defines parameters for DojoGroupMembersPartialUpdate.
type DojoGroupMembersPartialUpdateJSONBody PatchedDojoGroupMemberRequest

// DojoGroupMembersUpdateJSONBody defines parameters for DojoGroupMembersUpdate.
type DojoGroupMembersUpdateJSONBody DojoGroupMemberRequest

// DojoGroupMembersDeletePreviewListParams defines parameters for DojoGroupMembersDeletePreviewList.
type DojoGroupMembersDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// DojoGroupsListParams defines parameters for DojoGroupsList.
type DojoGroupsListParams struct {
	Id *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]DojoGroupsListParamsPrefetch `json:"prefetch,omitempty"`

	// Group imported from a social provider.
	SocialProvider *DojoGroupsListParamsSocialProvider `json:"social_provider,omitempty"`
}

// DojoGroupsListParamsPrefetch defines parameters for DojoGroupsList.
type DojoGroupsListParamsPrefetch string

// DojoGroupsListParamsSocialProvider defines parameters for DojoGroupsList.
type DojoGroupsListParamsSocialProvider string

// DojoGroupsCreateJSONBody defines parameters for DojoGroupsCreate.
type DojoGroupsCreateJSONBody DojoGroupRequest

// DojoGroupsRetrieveParams defines parameters for DojoGroupsRetrieve.
type DojoGroupsRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]DojoGroupsRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// DojoGroupsRetrieveParamsPrefetch defines parameters for DojoGroupsRetrieve.
type DojoGroupsRetrieveParamsPrefetch string

// DojoGroupsPartialUpdateJSONBody defines parameters for DojoGroupsPartialUpdate.
type DojoGroupsPartialUpdateJSONBody PatchedDojoGroupRequest

// DojoGroupsUpdateJSONBody defines parameters for DojoGroupsUpdate.
type DojoGroupsUpdateJSONBody DojoGroupRequest

// DojoGroupsDeletePreviewListParams defines parameters for DojoGroupsDeletePreviewList.
type DojoGroupsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// EndpointStatusListParams defines parameters for EndpointStatusList.
type EndpointStatusListParams struct {
	Endpoint      *int  `json:"endpoint,omitempty"`
	FalsePositive *bool `json:"false_positive,omitempty"`
	Finding       *int  `json:"finding,omitempty"`

	// Number of results to return per page.
	Limit       *int  `json:"limit,omitempty"`
	Mitigated   *bool `json:"mitigated,omitempty"`
	MitigatedBy *int  `json:"mitigated_by,omitempty"`

	// The initial index from which to return the results.
	Offset       *int  `json:"offset,omitempty"`
	OutOfScope   *bool `json:"out_of_scope,omitempty"`
	RiskAccepted *bool `json:"risk_accepted,omitempty"`
}

// EndpointStatusCreateJSONBody defines parameters for EndpointStatusCreate.
type EndpointStatusCreateJSONBody EndpointStatusRequest

// EndpointStatusPartialUpdateJSONBody defines parameters for EndpointStatusPartialUpdate.
type EndpointStatusPartialUpdateJSONBody PatchedEndpointStatusRequest

// EndpointStatusUpdateJSONBody defines parameters for EndpointStatusUpdate.
type EndpointStatusUpdateJSONBody EndpointStatusRequest

// EndpointStatusDeletePreviewListParams defines parameters for EndpointStatusDeletePreviewList.
type EndpointStatusDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// EndpointsListParams defines parameters for EndpointsList.
type EndpointsListParams struct {
	Fragment *string `json:"fragment,omitempty"`
	Host     *string `json:"host,omitempty"`
	Id       *int    `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// Not Tag name contains
	NotTag *string `json:"not_tag,omitempty"`

	// Comma seperated list of exact tags not present on model
	NotTags *[]string `json:"not_tags,omitempty"`

	// Ordering
	O *[]EndpointsListParamsO `json:"o,omitempty"`

	// The initial index from which to return the results.
	Offset   *int    `json:"offset,omitempty"`
	Path     *string `json:"path,omitempty"`
	Port     *int    `json:"port,omitempty"`
	Product  *int    `json:"product,omitempty"`
	Protocol *string `json:"protocol,omitempty"`
	Query    *string `json:"query,omitempty"`

	// Tag name contains
	Tag *string `json:"tag,omitempty"`

	// Comma seperated list of exact tags
	Tags     *[]string `json:"tags,omitempty"`
	Userinfo *string   `json:"userinfo,omitempty"`
}

// EndpointsListParamsO defines parameters for EndpointsList.
type EndpointsListParamsO string

// EndpointsCreateJSONBody defines parameters for EndpointsCreate.
type EndpointsCreateJSONBody EndpointRequest

// EndpointsPartialUpdateJSONBody defines parameters for EndpointsPartialUpdate.
type EndpointsPartialUpdateJSONBody PatchedEndpointRequest

// EndpointsUpdateJSONBody defines parameters for EndpointsUpdate.
type EndpointsUpdateJSONBody EndpointRequest

// EndpointsDeletePreviewListParams defines parameters for EndpointsDeletePreviewList.
type EndpointsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// EndpointsGenerateReportCreateJSONBody defines parameters for EndpointsGenerateReportCreate.
type EndpointsGenerateReportCreateJSONBody ReportGenerateOptionRequest

// EngagementPresetsListParams defines parameters for EngagementPresetsList.
type EngagementPresetsListParams struct {
	Id *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset  *int    `json:"offset,omitempty"`
	Product *int    `json:"product,omitempty"`
	Title   *string `json:"title,omitempty"`
}

// EngagementPresetsCreateJSONBody defines parameters for EngagementPresetsCreate.
type EngagementPresetsCreateJSONBody EngagementPresetsRequest

// EngagementPresetsPartialUpdateJSONBody defines parameters for EngagementPresetsPartialUpdate.
type EngagementPresetsPartialUpdateJSONBody PatchedEngagementPresetsRequest

// EngagementPresetsUpdateJSONBody defines parameters for EngagementPresetsUpdate.
type EngagementPresetsUpdateJSONBody EngagementPresetsRequest

// EngagementPresetsDeletePreviewListParams defines parameters for EngagementPresetsDeletePreviewList.
type EngagementPresetsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// EngagementsListParams defines parameters for EngagementsList.
type EngagementsListParams struct {
	Active  *bool `json:"active,omitempty"`
	ApiTest *bool `json:"api_test,omitempty"`
	Id      *int  `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// Comma seperated list of exact tags not present on product
	NotProductTagsName *[]string `json:"not_product__tags__name,omitempty"`

	// Not Tag name contains
	NotTag *string `json:"not_tag,omitempty"`

	// Comma seperated list of exact tags not present on model
	NotTags *[]string `json:"not_tags,omitempty"`

	// Ordering
	O *[]EngagementsListParamsO `json:"o,omitempty"`

	// The initial index from which to return the results.
	Offset  *int  `json:"offset,omitempty"`
	PenTest *bool `json:"pen_test,omitempty"`
	Product *int  `json:"product,omitempty"`

	// Multiple values may be separated by commas.
	ProductProdType *[]int `json:"product__prod_type,omitempty"`

	// Comma seperated list of exact tags present on product
	ProductTagsName *[]string                    `json:"product__tags__name,omitempty"`
	ReportType      *int                         `json:"report_type,omitempty"`
	Requester       *int                         `json:"requester,omitempty"`
	Status          *EngagementsListParamsStatus `json:"status,omitempty"`

	// Tag name contains
	Tag *string `json:"tag,omitempty"`

	// Comma seperated list of exact tags
	Tags        *[]string           `json:"tags,omitempty"`
	TargetEnd   *openapi_types.Date `json:"target_end,omitempty"`
	TargetStart *openapi_types.Date `json:"target_start,omitempty"`
	ThreatModel *bool               `json:"threat_model,omitempty"`
	Updated     *time.Time          `json:"updated,omitempty"`
	Version     *string             `json:"version,omitempty"`
}

// EngagementsListParamsO defines parameters for EngagementsList.
type EngagementsListParamsO string

// EngagementsListParamsStatus defines parameters for EngagementsList.
type EngagementsListParamsStatus string

// EngagementsCreateJSONBody defines parameters for EngagementsCreate.
type EngagementsCreateJSONBody EngagementRequest

// EngagementsPartialUpdateJSONBody defines parameters for EngagementsPartialUpdate.
type EngagementsPartialUpdateJSONBody PatchedEngagementRequest

// EngagementsUpdateJSONBody defines parameters for EngagementsUpdate.
type EngagementsUpdateJSONBody EngagementRequest

// EngagementsAcceptRisksCreateJSONBody defines parameters for EngagementsAcceptRisksCreate.
type EngagementsAcceptRisksCreateJSONBody []AcceptedRiskRequest

// EngagementsDeletePreviewListParams defines parameters for EngagementsDeletePreviewList.
type EngagementsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// EngagementsGenerateReportCreateJSONBody defines parameters for EngagementsGenerateReportCreate.
type EngagementsGenerateReportCreateJSONBody ReportGenerateOptionRequest

// EngagementsNotesCreateJSONBody defines parameters for EngagementsNotesCreate.
type EngagementsNotesCreateJSONBody AddNewNoteOptionRequest

// FindingTemplatesListParams defines parameters for FindingTemplatesList.
type FindingTemplatesListParams struct {
	Cwe         *int    `json:"cwe,omitempty"`
	Description *string `json:"description,omitempty"`
	Id          *int    `json:"id,omitempty"`

	// Number of results to return per page.
	Limit      *int    `json:"limit,omitempty"`
	Mitigation *string `json:"mitigation,omitempty"`

	// Not Tag name contains
	NotTag *string `json:"not_tag,omitempty"`

	// Comma seperated list of exact tags not present on model
	NotTags *[]string `json:"not_tags,omitempty"`

	// Ordering
	O *[]FindingTemplatesListParamsO `json:"o,omitempty"`

	// The initial index from which to return the results.
	Offset   *int    `json:"offset,omitempty"`
	Severity *string `json:"severity,omitempty"`

	// Tag name contains
	Tag *string `json:"tag,omitempty"`

	// Comma seperated list of exact tags
	Tags  *[]string `json:"tags,omitempty"`
	Title *string   `json:"title,omitempty"`
}

// FindingTemplatesListParamsO defines parameters for FindingTemplatesList.
type FindingTemplatesListParamsO string

// FindingTemplatesCreateJSONBody defines parameters for FindingTemplatesCreate.
type FindingTemplatesCreateJSONBody FindingTemplateRequest

// FindingTemplatesPartialUpdateJSONBody defines parameters for FindingTemplatesPartialUpdate.
type FindingTemplatesPartialUpdateJSONBody PatchedFindingTemplateRequest

// FindingTemplatesUpdateJSONBody defines parameters for FindingTemplatesUpdate.
type FindingTemplatesUpdateJSONBody FindingTemplateRequest

// FindingTemplatesDeletePreviewListParams defines parameters for FindingTemplatesDeletePreviewList.
type FindingTemplatesDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// FindingsListParams defines parameters for FindingsList.
type FindingsListParams struct {
	Active           *bool   `json:"active,omitempty"`
	ComponentName    *string `json:"component_name,omitempty"`
	ComponentVersion *string `json:"component_version,omitempty"`

	// The date the finding was created inside DefectDojo.
	Created     *FindingsListParamsCreated `json:"created,omitempty"`
	Cvssv3      *string                    `json:"cvssv3,omitempty"`
	Cvssv3Score *float32                   `json:"cvssv3_score,omitempty"`

	// Multiple values may be separated by commas.
	Cwe *[]int `json:"cwe,omitempty"`

	// The date the flaw was discovered.
	Date *FindingsListParamsDate `json:"date,omitempty"`

	// Multiple values may be separated by commas.
	DefectReviewRequestedBy *[]int  `json:"defect_review_requested_by,omitempty"`
	Description             *string `json:"description,omitempty"`
	Duplicate               *bool   `json:"duplicate,omitempty"`
	DuplicateFinding        *int    `json:"duplicate_finding,omitempty"`
	DynamicFinding          *bool   `json:"dynamic_finding,omitempty"`

	// Multiple values may be separated by commas.
	Endpoints *[]int  `json:"endpoints,omitempty"`
	FalseP    *bool   `json:"false_p,omitempty"`
	FilePath  *string `json:"file_path,omitempty"`

	// Multiple values may be separated by commas.
	FindingGroup *[]float32 `json:"finding_group,omitempty"`

	// Multiple values may be separated by commas.
	FoundBy  *[]int  `json:"found_by,omitempty"`
	HasJira  *bool   `json:"has_jira,omitempty"`
	HashCode *string `json:"hash_code,omitempty"`

	// Multiple values may be separated by commas.
	Id          *[]int  `json:"id,omitempty"`
	Impact      *string `json:"impact,omitempty"`
	IsMitigated *bool   `json:"is_mitigated,omitempty"`

	// The date the linked Jira issue was last modified.
	JiraChange *FindingsListParamsJiraChange `json:"jira_change,omitempty"`

	// The date a Jira issue was created from this finding.
	JiraCreation *FindingsListParamsJiraCreation `json:"jira_creation,omitempty"`

	// Provides the date the flaw was last 'touched' by a tester.
	LastReviewed *FindingsListParamsLastReviewed `json:"last_reviewed,omitempty"`

	// Multiple values may be separated by commas.
	LastReviewedBy   *[]int     `json:"last_reviewed_by,omitempty"`
	LastStatusUpdate *time.Time `json:"last_status_update,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// Denotes if this flaw has been fixed by storing the date it was fixed.
	Mitigated *FindingsListParamsMitigated `json:"mitigated,omitempty"`

	// Multiple values may be separated by commas.
	MitigatedBy *[]int  `json:"mitigated_by,omitempty"`
	Mitigation  *string `json:"mitigation,omitempty"`

	// Multiple values may be separated by commas.
	NbOccurences *[]int `json:"nb_occurences,omitempty"`

	// Not Tag name contains
	NotTag *string `json:"not_tag,omitempty"`

	// Comma seperated list of exact tags not present on model
	NotTags *[]string `json:"not_tags,omitempty"`

	// Comma seperated list of exact tags not present on product
	NotTestEngagementProductTagsName *[]string `json:"not_test__engagement__product__tags__name,omitempty"`

	// Comma seperated list of exact tags not present on engagement
	NotTestEngagementTags *[]string `json:"not_test__engagement__tags,omitempty"`

	// Comma seperated list of exact tags not present on test
	NotTestTags       *[]string `json:"not_test__tags,omitempty"`
	NumericalSeverity *string   `json:"numerical_severity,omitempty"`

	// Ordering
	O *[]FindingsListParamsO `json:"o,omitempty"`

	// The initial index from which to return the results.
	Offset                 *int                `json:"offset,omitempty"`
	OutOfScope             *bool               `json:"out_of_scope,omitempty"`
	Param                  *string             `json:"param,omitempty"`
	Payload                *string             `json:"payload,omitempty"`
	PlannedRemediationDate *openapi_types.Date `json:"planned_remediation_date,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch    *[]FindingsListParamsPrefetch `json:"prefetch,omitempty"`
	PublishDate *openapi_types.Date           `json:"publish_date,omitempty"`
	References  *string                       `json:"references,omitempty"`

	// Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)
	RelatedFields *bool `json:"related_fields,omitempty"`

	// Multiple values may be separated by commas.
	Reporter *[]int `json:"reporter,omitempty"`

	// Multiple values may be separated by commas.
	ReviewRequestedBy *[]int `json:"review_requested_by,omitempty"`

	// Multiple values may be separated by commas.
	Reviewers          *[]int   `json:"reviewers,omitempty"`
	RiskAcceptance     *float32 `json:"risk_acceptance,omitempty"`
	RiskAccepted       *bool    `json:"risk_accepted,omitempty"`
	SastSinkObject     *string  `json:"sast_sink_object,omitempty"`
	SastSourceFilePath *string  `json:"sast_source_file_path,omitempty"`

	// Multiple values may be separated by commas.
	SastSourceLine   *[]int  `json:"sast_source_line,omitempty"`
	SastSourceObject *string `json:"sast_source_object,omitempty"`

	// Multiple values may be separated by commas.
	ScannerConfidence     *[]int              `json:"scanner_confidence,omitempty"`
	Service               *string             `json:"service,omitempty"`
	Severity              *string             `json:"severity,omitempty"`
	SeverityJustification *string             `json:"severity_justification,omitempty"`
	SlaStartDate          *openapi_types.Date `json:"sla_start_date,omitempty"`

	// Multiple values may be separated by commas.
	SonarqubeIssue   *[]int  `json:"sonarqube_issue,omitempty"`
	StaticFinding    *bool   `json:"static_finding,omitempty"`
	StepsToReproduce *string `json:"steps_to_reproduce,omitempty"`

	// Tag name contains
	Tag *string `json:"tag,omitempty"`

	// Comma seperated list of exact tags
	Tags *[]string `json:"tags,omitempty"`
	Test *int      `json:"test,omitempty"`

	// Multiple values may be separated by commas.
	TestEngagement *[]int `json:"test__engagement,omitempty"`

	// Multiple values may be separated by commas.
	TestEngagementProduct *[]int `json:"test__engagement__product,omitempty"`

	// Multiple values may be separated by commas.
	TestEngagementProductProdType *[]int `json:"test__engagement__product__prod_type,omitempty"`

	// Comma seperated list of exact tags present on product
	TestEngagementProductTagsName *[]string `json:"test__engagement__product__tags__name,omitempty"`

	// Comma seperated list of exact tags present on engagement
	TestEngagementTags *[]string `json:"test__engagement__tags,omitempty"`

	// Comma seperated list of exact tags present on test
	TestTags *[]string `json:"test__tags,omitempty"`

	// Multiple values may be separated by commas.
	TestTestType      *[]int  `json:"test__test_type,omitempty"`
	Title             *string `json:"title,omitempty"`
	UnderDefectReview *bool   `json:"under_defect_review,omitempty"`
	UnderReview       *bool   `json:"under_review,omitempty"`
	UniqueIdFromTool  *string `json:"unique_id_from_tool,omitempty"`
	Verified          *bool   `json:"verified,omitempty"`
	VulnIdFromTool    *string `json:"vuln_id_from_tool,omitempty"`
	VulnerabilityId   *string `json:"vulnerability_id,omitempty"`
}

// FindingsListParamsCreated defines parameters for FindingsList.
type FindingsListParamsCreated time.Time

// FindingsListParamsDate defines parameters for FindingsList.
type FindingsListParamsDate openapi_types.Date

// FindingsListParamsJiraChange defines parameters for FindingsList.
type FindingsListParamsJiraChange time.Time

// FindingsListParamsJiraCreation defines parameters for FindingsList.
type FindingsListParamsJiraCreation time.Time

// FindingsListParamsLastReviewed defines parameters for FindingsList.
type FindingsListParamsLastReviewed time.Time

// FindingsListParamsMitigated defines parameters for FindingsList.
type FindingsListParamsMitigated time.Time

// FindingsListParamsO defines parameters for FindingsList.
type FindingsListParamsO string

// FindingsListParamsPrefetch defines parameters for FindingsList.
type FindingsListParamsPrefetch string

// FindingsCreateJSONBody defines parameters for FindingsCreate.
type FindingsCreateJSONBody FindingCreateRequest

// FindingsAcceptRisksCreateJSONBody defines parameters for FindingsAcceptRisksCreate.
type FindingsAcceptRisksCreateJSONBody []AcceptedRiskRequest

// FindingsAcceptRisksCreateParams defines parameters for FindingsAcceptRisksCreate.
type FindingsAcceptRisksCreateParams struct {
	Active           *bool   `json:"active,omitempty"`
	ComponentName    *string `json:"component_name,omitempty"`
	ComponentVersion *string `json:"component_version,omitempty"`

	// The date the finding was created inside DefectDojo.
	Created     *FindingsAcceptRisksCreateParamsCreated `json:"created,omitempty"`
	Cvssv3      *string                                 `json:"cvssv3,omitempty"`
	Cvssv3Score *float32                                `json:"cvssv3_score,omitempty"`

	// Multiple values may be separated by commas.
	Cwe *[]int `json:"cwe,omitempty"`

	// The date the flaw was discovered.
	Date *FindingsAcceptRisksCreateParamsDate `json:"date,omitempty"`

	// Multiple values may be separated by commas.
	DefectReviewRequestedBy *[]int  `json:"defect_review_requested_by,omitempty"`
	Description             *string `json:"description,omitempty"`
	Duplicate               *bool   `json:"duplicate,omitempty"`
	DuplicateFinding        *int    `json:"duplicate_finding,omitempty"`
	DynamicFinding          *bool   `json:"dynamic_finding,omitempty"`

	// Multiple values may be separated by commas.
	Endpoints *[]int  `json:"endpoints,omitempty"`
	FalseP    *bool   `json:"false_p,omitempty"`
	FilePath  *string `json:"file_path,omitempty"`

	// Multiple values may be separated by commas.
	FindingGroup *[]float32 `json:"finding_group,omitempty"`

	// Multiple values may be separated by commas.
	FoundBy  *[]int  `json:"found_by,omitempty"`
	HasJira  *bool   `json:"has_jira,omitempty"`
	HashCode *string `json:"hash_code,omitempty"`

	// Multiple values may be separated by commas.
	Id          *[]int  `json:"id,omitempty"`
	Impact      *string `json:"impact,omitempty"`
	IsMitigated *bool   `json:"is_mitigated,omitempty"`

	// The date the linked Jira issue was last modified.
	JiraChange *FindingsAcceptRisksCreateParamsJiraChange `json:"jira_change,omitempty"`

	// The date a Jira issue was created from this finding.
	JiraCreation *FindingsAcceptRisksCreateParamsJiraCreation `json:"jira_creation,omitempty"`

	// Provides the date the flaw was last 'touched' by a tester.
	LastReviewed *FindingsAcceptRisksCreateParamsLastReviewed `json:"last_reviewed,omitempty"`

	// Multiple values may be separated by commas.
	LastReviewedBy   *[]int     `json:"last_reviewed_by,omitempty"`
	LastStatusUpdate *time.Time `json:"last_status_update,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// Denotes if this flaw has been fixed by storing the date it was fixed.
	Mitigated *FindingsAcceptRisksCreateParamsMitigated `json:"mitigated,omitempty"`

	// Multiple values may be separated by commas.
	MitigatedBy *[]int  `json:"mitigated_by,omitempty"`
	Mitigation  *string `json:"mitigation,omitempty"`

	// Multiple values may be separated by commas.
	NbOccurences *[]int `json:"nb_occurences,omitempty"`

	// Not Tag name contains
	NotTag *string `json:"not_tag,omitempty"`

	// Comma seperated list of exact tags not present on model
	NotTags *[]string `json:"not_tags,omitempty"`

	// Comma seperated list of exact tags not present on product
	NotTestEngagementProductTagsName *[]string `json:"not_test__engagement__product__tags__name,omitempty"`

	// Comma seperated list of exact tags not present on engagement
	NotTestEngagementTags *[]string `json:"not_test__engagement__tags,omitempty"`

	// Comma seperated list of exact tags not present on test
	NotTestTags       *[]string `json:"not_test__tags,omitempty"`
	NumericalSeverity *string   `json:"numerical_severity,omitempty"`

	// Ordering
	O *[]FindingsAcceptRisksCreateParamsO `json:"o,omitempty"`

	// The initial index from which to return the results.
	Offset                 *int                `json:"offset,omitempty"`
	OutOfScope             *bool               `json:"out_of_scope,omitempty"`
	Param                  *string             `json:"param,omitempty"`
	Payload                *string             `json:"payload,omitempty"`
	PlannedRemediationDate *openapi_types.Date `json:"planned_remediation_date,omitempty"`
	PublishDate            *openapi_types.Date `json:"publish_date,omitempty"`
	References             *string             `json:"references,omitempty"`

	// Multiple values may be separated by commas.
	Reporter *[]int `json:"reporter,omitempty"`

	// Multiple values may be separated by commas.
	ReviewRequestedBy *[]int `json:"review_requested_by,omitempty"`

	// Multiple values may be separated by commas.
	Reviewers          *[]int   `json:"reviewers,omitempty"`
	RiskAcceptance     *float32 `json:"risk_acceptance,omitempty"`
	RiskAccepted       *bool    `json:"risk_accepted,omitempty"`
	SastSinkObject     *string  `json:"sast_sink_object,omitempty"`
	SastSourceFilePath *string  `json:"sast_source_file_path,omitempty"`

	// Multiple values may be separated by commas.
	SastSourceLine   *[]int  `json:"sast_source_line,omitempty"`
	SastSourceObject *string `json:"sast_source_object,omitempty"`

	// Multiple values may be separated by commas.
	ScannerConfidence     *[]int              `json:"scanner_confidence,omitempty"`
	Service               *string             `json:"service,omitempty"`
	Severity              *string             `json:"severity,omitempty"`
	SeverityJustification *string             `json:"severity_justification,omitempty"`
	SlaStartDate          *openapi_types.Date `json:"sla_start_date,omitempty"`

	// Multiple values may be separated by commas.
	SonarqubeIssue   *[]int  `json:"sonarqube_issue,omitempty"`
	StaticFinding    *bool   `json:"static_finding,omitempty"`
	StepsToReproduce *string `json:"steps_to_reproduce,omitempty"`

	// Tag name contains
	Tag *string `json:"tag,omitempty"`

	// Comma seperated list of exact tags
	Tags *[]string `json:"tags,omitempty"`
	Test *int      `json:"test,omitempty"`

	// Multiple values may be separated by commas.
	TestEngagement *[]int `json:"test__engagement,omitempty"`

	// Multiple values may be separated by commas.
	TestEngagementProduct *[]int `json:"test__engagement__product,omitempty"`

	// Multiple values may be separated by commas.
	TestEngagementProductProdType *[]int `json:"test__engagement__product__prod_type,omitempty"`

	// Comma seperated list of exact tags present on product
	TestEngagementProductTagsName *[]string `json:"test__engagement__product__tags__name,omitempty"`

	// Comma seperated list of exact tags present on engagement
	TestEngagementTags *[]string `json:"test__engagement__tags,omitempty"`

	// Comma seperated list of exact tags present on test
	TestTags *[]string `json:"test__tags,omitempty"`

	// Multiple values may be separated by commas.
	TestTestType      *[]int  `json:"test__test_type,omitempty"`
	Title             *string `json:"title,omitempty"`
	UnderDefectReview *bool   `json:"under_defect_review,omitempty"`
	UnderReview       *bool   `json:"under_review,omitempty"`
	UniqueIdFromTool  *string `json:"unique_id_from_tool,omitempty"`
	Verified          *bool   `json:"verified,omitempty"`
	VulnIdFromTool    *string `json:"vuln_id_from_tool,omitempty"`
	VulnerabilityId   *string `json:"vulnerability_id,omitempty"`
}

// FindingsAcceptRisksCreateParamsCreated defines parameters for FindingsAcceptRisksCreate.
type FindingsAcceptRisksCreateParamsCreated time.Time

// FindingsAcceptRisksCreateParamsDate defines parameters for FindingsAcceptRisksCreate.
type FindingsAcceptRisksCreateParamsDate openapi_types.Date

// FindingsAcceptRisksCreateParamsJiraChange defines parameters for FindingsAcceptRisksCreate.
type FindingsAcceptRisksCreateParamsJiraChange time.Time

// FindingsAcceptRisksCreateParamsJiraCreation defines parameters for FindingsAcceptRisksCreate.
type FindingsAcceptRisksCreateParamsJiraCreation time.Time

// FindingsAcceptRisksCreateParamsLastReviewed defines parameters for FindingsAcceptRisksCreate.
type FindingsAcceptRisksCreateParamsLastReviewed time.Time

// FindingsAcceptRisksCreateParamsMitigated defines parameters for FindingsAcceptRisksCreate.
type FindingsAcceptRisksCreateParamsMitigated time.Time

// FindingsAcceptRisksCreateParamsO defines parameters for FindingsAcceptRisksCreate.
type FindingsAcceptRisksCreateParamsO string

// FindingsGenerateReportCreateJSONBody defines parameters for FindingsGenerateReportCreate.
type FindingsGenerateReportCreateJSONBody ReportGenerateOptionRequest

// FindingsRetrieveParams defines parameters for FindingsRetrieve.
type FindingsRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]FindingsRetrieveParamsPrefetch `json:"prefetch,omitempty"`

	// Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)
	RelatedFields *bool `json:"related_fields,omitempty"`
}

// FindingsRetrieveParamsPrefetch defines parameters for FindingsRetrieve.
type FindingsRetrieveParamsPrefetch string

// FindingsPartialUpdateJSONBody defines parameters for FindingsPartialUpdate.
type FindingsPartialUpdateJSONBody PatchedFindingRequest

// FindingsUpdateJSONBody defines parameters for FindingsUpdate.
type FindingsUpdateJSONBody FindingRequest

// FindingsCloseCreateJSONBody defines parameters for FindingsCloseCreate.
type FindingsCloseCreateJSONBody FindingCloseRequest

// FindingsDeletePreviewListParams defines parameters for FindingsDeletePreviewList.
type FindingsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// FindingsMetadataDestroyParams defines parameters for FindingsMetadataDestroy.
type FindingsMetadataDestroyParams struct {
	// name of the metadata to retrieve. If name is empty, return all the                                     metadata associated with the finding
	Name int `json:"name"`
}

// FindingsMetadataCreateJSONBody defines parameters for FindingsMetadataCreate.
type FindingsMetadataCreateJSONBody FindingMetaRequest

// FindingsMetadataUpdateJSONBody defines parameters for FindingsMetadataUpdate.
type FindingsMetadataUpdateJSONBody FindingMetaRequest

// FindingsNotesCreateJSONBody defines parameters for FindingsNotesCreate.
type FindingsNotesCreateJSONBody AddNewNoteOptionRequest

// FindingsRemoveNotePartialUpdateJSONBody defines parameters for FindingsRemoveNotePartialUpdate.
type FindingsRemoveNotePartialUpdateJSONBody PatchedFindingNoteRequest

// FindingsRemoveTagsPartialUpdateJSONBody defines parameters for FindingsRemoveTagsPartialUpdate.
type FindingsRemoveTagsPartialUpdateJSONBody PatchedTagRequest

// FindingsRemoveTagsUpdateJSONBody defines parameters for FindingsRemoveTagsUpdate.
type FindingsRemoveTagsUpdateJSONBody TagRequest

// FindingsRequestResponseCreateJSONBody defines parameters for FindingsRequestResponseCreate.
type FindingsRequestResponseCreateJSONBody BurpRawRequestResponseRequest

// FindingsTagsCreateJSONBody defines parameters for FindingsTagsCreate.
type FindingsTagsCreateJSONBody TagRequest

// GlobalRolesListParams defines parameters for GlobalRolesList.
type GlobalRolesListParams struct {
	Group *int `json:"group,omitempty"`
	Id    *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
	Role   *int `json:"role,omitempty"`
	User   *int `json:"user,omitempty"`
}

// GlobalRolesCreateJSONBody defines parameters for GlobalRolesCreate.
type GlobalRolesCreateJSONBody GlobalRoleRequest

// GlobalRolesPartialUpdateJSONBody defines parameters for GlobalRolesPartialUpdate.
type GlobalRolesPartialUpdateJSONBody PatchedGlobalRoleRequest

// GlobalRolesUpdateJSONBody defines parameters for GlobalRolesUpdate.
type GlobalRolesUpdateJSONBody GlobalRoleRequest

// GlobalRolesDeletePreviewListParams defines parameters for GlobalRolesDeletePreviewList.
type GlobalRolesDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// JiraConfigurationsListParams defines parameters for JiraConfigurationsList.
type JiraConfigurationsListParams struct {
	Id *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int    `json:"offset,omitempty"`
	Url    *string `json:"url,omitempty"`
}

// JiraConfigurationsCreateJSONBody defines parameters for JiraConfigurationsCreate.
type JiraConfigurationsCreateJSONBody JIRAInstanceRequest

// JiraConfigurationsPartialUpdateJSONBody defines parameters for JiraConfigurationsPartialUpdate.
type JiraConfigurationsPartialUpdateJSONBody PatchedJIRAInstanceRequest

// JiraConfigurationsUpdateJSONBody defines parameters for JiraConfigurationsUpdate.
type JiraConfigurationsUpdateJSONBody JIRAInstanceRequest

// JiraConfigurationsDeletePreviewListParams defines parameters for JiraConfigurationsDeletePreviewList.
type JiraConfigurationsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// JiraFindingMappingsListParams defines parameters for JiraFindingMappingsList.
type JiraFindingMappingsListParams struct {
	Engagement   *int    `json:"engagement,omitempty"`
	Finding      *int    `json:"finding,omitempty"`
	FindingGroup *int    `json:"finding_group,omitempty"`
	Id           *int    `json:"id,omitempty"`
	JiraId       *string `json:"jira_id,omitempty"`
	JiraKey      *string `json:"jira_key,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// JiraFindingMappingsCreateJSONBody defines parameters for JiraFindingMappingsCreate.
type JiraFindingMappingsCreateJSONBody JIRAIssueRequest

// JiraFindingMappingsPartialUpdateJSONBody defines parameters for JiraFindingMappingsPartialUpdate.
type JiraFindingMappingsPartialUpdateJSONBody PatchedJIRAIssueRequest

// JiraFindingMappingsUpdateJSONBody defines parameters for JiraFindingMappingsUpdate.
type JiraFindingMappingsUpdateJSONBody JIRAIssueRequest

// JiraFindingMappingsDeletePreviewListParams defines parameters for JiraFindingMappingsDeletePreviewList.
type JiraFindingMappingsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// JiraInstancesListParams defines parameters for JiraInstancesList.
type JiraInstancesListParams struct {
	Id *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int    `json:"offset,omitempty"`
	Url    *string `json:"url,omitempty"`
}

// JiraInstancesCreateJSONBody defines parameters for JiraInstancesCreate.
type JiraInstancesCreateJSONBody JIRAInstanceRequest

// JiraInstancesPartialUpdateJSONBody defines parameters for JiraInstancesPartialUpdate.
type JiraInstancesPartialUpdateJSONBody PatchedJIRAInstanceRequest

// JiraInstancesUpdateJSONBody defines parameters for JiraInstancesUpdate.
type JiraInstancesUpdateJSONBody JIRAInstanceRequest

// JiraInstancesDeletePreviewListParams defines parameters for JiraInstancesDeletePreviewList.
type JiraInstancesDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// JiraProductConfigurationsListParams defines parameters for JiraProductConfigurationsList.
type JiraProductConfigurationsListParams struct {
	Component                   *string `json:"component,omitempty"`
	EnableEngagementEpicMapping *bool   `json:"enable_engagement_epic_mapping,omitempty"`
	Engagement                  *int    `json:"engagement,omitempty"`
	Id                          *int    `json:"id,omitempty"`
	JiraInstance                *int    `json:"jira_instance,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset        *int    `json:"offset,omitempty"`
	Product       *int    `json:"product,omitempty"`
	ProjectKey    *string `json:"project_key,omitempty"`
	PushAllIssues *bool   `json:"push_all_issues,omitempty"`
	PushNotes     *bool   `json:"push_notes,omitempty"`
}

// JiraProductConfigurationsCreateJSONBody defines parameters for JiraProductConfigurationsCreate.
type JiraProductConfigurationsCreateJSONBody JIRAProjectRequest

// JiraProductConfigurationsPartialUpdateJSONBody defines parameters for JiraProductConfigurationsPartialUpdate.
type JiraProductConfigurationsPartialUpdateJSONBody PatchedJIRAProjectRequest

// JiraProductConfigurationsUpdateJSONBody defines parameters for JiraProductConfigurationsUpdate.
type JiraProductConfigurationsUpdateJSONBody JIRAProjectRequest

// JiraProductConfigurationsDeletePreviewListParams defines parameters for JiraProductConfigurationsDeletePreviewList.
type JiraProductConfigurationsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// JiraProjectsListParams defines parameters for JiraProjectsList.
type JiraProjectsListParams struct {
	Component                   *string `json:"component,omitempty"`
	EnableEngagementEpicMapping *bool   `json:"enable_engagement_epic_mapping,omitempty"`
	Engagement                  *int    `json:"engagement,omitempty"`
	Id                          *int    `json:"id,omitempty"`
	JiraInstance                *int    `json:"jira_instance,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset        *int    `json:"offset,omitempty"`
	Product       *int    `json:"product,omitempty"`
	ProjectKey    *string `json:"project_key,omitempty"`
	PushAllIssues *bool   `json:"push_all_issues,omitempty"`
	PushNotes     *bool   `json:"push_notes,omitempty"`
}

// JiraProjectsCreateJSONBody defines parameters for JiraProjectsCreate.
type JiraProjectsCreateJSONBody JIRAProjectRequest

// JiraProjectsPartialUpdateJSONBody defines parameters for JiraProjectsPartialUpdate.
type JiraProjectsPartialUpdateJSONBody PatchedJIRAProjectRequest

// JiraProjectsUpdateJSONBody defines parameters for JiraProjectsUpdate.
type JiraProjectsUpdateJSONBody JIRAProjectRequest

// JiraProjectsDeletePreviewListParams defines parameters for JiraProjectsDeletePreviewList.
type JiraProjectsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// LanguageTypesListParams defines parameters for LanguageTypesList.
type LanguageTypesListParams struct {
	Color    *string `json:"color,omitempty"`
	Id       *int    `json:"id,omitempty"`
	Language *string `json:"language,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// LanguageTypesCreateJSONBody defines parameters for LanguageTypesCreate.
type LanguageTypesCreateJSONBody LanguageTypeRequest

// LanguageTypesPartialUpdateJSONBody defines parameters for LanguageTypesPartialUpdate.
type LanguageTypesPartialUpdateJSONBody PatchedLanguageTypeRequest

// LanguageTypesUpdateJSONBody defines parameters for LanguageTypesUpdate.
type LanguageTypesUpdateJSONBody LanguageTypeRequest

// LanguageTypesDeletePreviewListParams defines parameters for LanguageTypesDeletePreviewList.
type LanguageTypesDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// LanguagesListParams defines parameters for LanguagesList.
type LanguagesListParams struct {
	Id       *int `json:"id,omitempty"`
	Language *int `json:"language,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]LanguagesListParamsPrefetch `json:"prefetch,omitempty"`
	Product  *int                           `json:"product,omitempty"`
}

// LanguagesListParamsPrefetch defines parameters for LanguagesList.
type LanguagesListParamsPrefetch string

// LanguagesCreateJSONBody defines parameters for LanguagesCreate.
type LanguagesCreateJSONBody LanguageRequest

// LanguagesRetrieveParams defines parameters for LanguagesRetrieve.
type LanguagesRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]LanguagesRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// LanguagesRetrieveParamsPrefetch defines parameters for LanguagesRetrieve.
type LanguagesRetrieveParamsPrefetch string

// LanguagesPartialUpdateJSONBody defines parameters for LanguagesPartialUpdate.
type LanguagesPartialUpdateJSONBody PatchedLanguageRequest

// LanguagesUpdateJSONBody defines parameters for LanguagesUpdate.
type LanguagesUpdateJSONBody LanguageRequest

// LanguagesDeletePreviewListParams defines parameters for LanguagesDeletePreviewList.
type LanguagesDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// MetadataListParams defines parameters for MetadataList.
type MetadataListParams struct {
	Endpoint *int `json:"endpoint,omitempty"`
	Finding  *int `json:"finding,omitempty"`
	Id       *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]MetadataListParamsPrefetch `json:"prefetch,omitempty"`
	Product  *int                          `json:"product,omitempty"`
	Value    *string                       `json:"value,omitempty"`
}

// MetadataListParamsPrefetch defines parameters for MetadataList.
type MetadataListParamsPrefetch string

// MetadataCreateJSONBody defines parameters for MetadataCreate.
type MetadataCreateJSONBody MetaRequest

// MetadataRetrieveParams defines parameters for MetadataRetrieve.
type MetadataRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]MetadataRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// MetadataRetrieveParamsPrefetch defines parameters for MetadataRetrieve.
type MetadataRetrieveParamsPrefetch string

// MetadataPartialUpdateJSONBody defines parameters for MetadataPartialUpdate.
type MetadataPartialUpdateJSONBody PatchedMetaRequest

// MetadataUpdateJSONBody defines parameters for MetadataUpdate.
type MetadataUpdateJSONBody MetaRequest

// MetadataDeletePreviewListParams defines parameters for MetadataDeletePreviewList.
type MetadataDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// NetworkLocationsListParams defines parameters for NetworkLocationsList.
type NetworkLocationsListParams struct {
	Id *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit    *int    `json:"limit,omitempty"`
	Location *string `json:"location,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// NetworkLocationsCreateJSONBody defines parameters for NetworkLocationsCreate.
type NetworkLocationsCreateJSONBody NetworkLocationsRequest

// NetworkLocationsPartialUpdateJSONBody defines parameters for NetworkLocationsPartialUpdate.
type NetworkLocationsPartialUpdateJSONBody PatchedNetworkLocationsRequest

// NetworkLocationsUpdateJSONBody defines parameters for NetworkLocationsUpdate.
type NetworkLocationsUpdateJSONBody NetworkLocationsRequest

// NetworkLocationsDeletePreviewListParams defines parameters for NetworkLocationsDeletePreviewList.
type NetworkLocationsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// NoteTypeListParams defines parameters for NoteTypeList.
type NoteTypeListParams struct {
	Description *string `json:"description,omitempty"`
	Id          *int    `json:"id,omitempty"`
	IsActive    *bool   `json:"is_active,omitempty"`
	IsMandatory *bool   `json:"is_mandatory,omitempty"`
	IsSingle    *bool   `json:"is_single,omitempty"`

	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// NoteTypeCreateJSONBody defines parameters for NoteTypeCreate.
type NoteTypeCreateJSONBody NoteTypeRequest

// NoteTypePartialUpdateJSONBody defines parameters for NoteTypePartialUpdate.
type NoteTypePartialUpdateJSONBody PatchedNoteTypeRequest

// NoteTypeUpdateJSONBody defines parameters for NoteTypeUpdate.
type NoteTypeUpdateJSONBody NoteTypeRequest

// NoteTypeDeletePreviewListParams defines parameters for NoteTypeDeletePreviewList.
type NoteTypeDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// NotesListParams defines parameters for NotesList.
type NotesListParams struct {
	Author   *int       `json:"author,omitempty"`
	Date     *time.Time `json:"date,omitempty"`
	EditTime *time.Time `json:"edit_time,omitempty"`
	Edited   *bool      `json:"edited,omitempty"`
	Editor   *int       `json:"editor,omitempty"`
	Entry    *string    `json:"entry,omitempty"`
	Id       *int       `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset  *int  `json:"offset,omitempty"`
	Private *bool `json:"private,omitempty"`
}

// NotesPartialUpdateJSONBody defines parameters for NotesPartialUpdate.
type NotesPartialUpdateJSONBody PatchedNoteRequest

// NotesUpdateJSONBody defines parameters for NotesUpdate.
type NotesUpdateJSONBody NoteRequest

// NotificationsListParams defines parameters for NotificationsList.
type NotificationsListParams struct {
	Id *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]NotificationsListParamsPrefetch `json:"prefetch,omitempty"`
	Product  *int                               `json:"product,omitempty"`
	Template *bool                              `json:"template,omitempty"`
	User     *int                               `json:"user,omitempty"`
}

// NotificationsListParamsPrefetch defines parameters for NotificationsList.
type NotificationsListParamsPrefetch string

// NotificationsCreateJSONBody defines parameters for NotificationsCreate.
type NotificationsCreateJSONBody NotificationsRequest

// NotificationsRetrieveParams defines parameters for NotificationsRetrieve.
type NotificationsRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]NotificationsRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// NotificationsRetrieveParamsPrefetch defines parameters for NotificationsRetrieve.
type NotificationsRetrieveParamsPrefetch string

// NotificationsPartialUpdateJSONBody defines parameters for NotificationsPartialUpdate.
type NotificationsPartialUpdateJSONBody PatchedNotificationsRequest

// NotificationsUpdateJSONBody defines parameters for NotificationsUpdate.
type NotificationsUpdateJSONBody NotificationsRequest

// NotificationsDeletePreviewListParams defines parameters for NotificationsDeletePreviewList.
type NotificationsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// Oa3SchemaRetrieveParams defines parameters for Oa3SchemaRetrieve.
type Oa3SchemaRetrieveParams struct {
	Format *Oa3SchemaRetrieveParamsFormat `json:"format,omitempty"`
	Lang   *Oa3SchemaRetrieveParamsLang   `json:"lang,omitempty"`
}

// Oa3SchemaRetrieveParamsFormat defines parameters for Oa3SchemaRetrieve.
type Oa3SchemaRetrieveParamsFormat string

// Oa3SchemaRetrieveParamsLang defines parameters for Oa3SchemaRetrieve.
type Oa3SchemaRetrieveParamsLang string

// ProductApiScanConfigurationsListParams defines parameters for ProductApiScanConfigurationsList.
type ProductApiScanConfigurationsListParams struct {
	Id *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset            *int    `json:"offset,omitempty"`
	Product           *int    `json:"product,omitempty"`
	ServiceKey1       *string `json:"service_key_1,omitempty"`
	ServiceKey2       *string `json:"service_key_2,omitempty"`
	ServiceKey3       *string `json:"service_key_3,omitempty"`
	ToolConfiguration *int    `json:"tool_configuration,omitempty"`
}

// ProductApiScanConfigurationsCreateJSONBody defines parameters for ProductApiScanConfigurationsCreate.
type ProductApiScanConfigurationsCreateJSONBody ProductAPIScanConfigurationRequest

// ProductApiScanConfigurationsPartialUpdateJSONBody defines parameters for ProductApiScanConfigurationsPartialUpdate.
type ProductApiScanConfigurationsPartialUpdateJSONBody PatchedProductAPIScanConfigurationRequest

// ProductApiScanConfigurationsUpdateJSONBody defines parameters for ProductApiScanConfigurationsUpdate.
type ProductApiScanConfigurationsUpdateJSONBody ProductAPIScanConfigurationRequest

// ProductApiScanConfigurationsDeletePreviewListParams defines parameters for ProductApiScanConfigurationsDeletePreviewList.
type ProductApiScanConfigurationsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// ProductGroupsListParams defines parameters for ProductGroupsList.
type ProductGroupsListParams struct {
	GroupId *int `json:"group_id,omitempty"`
	Id      *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch  *[]ProductGroupsListParamsPrefetch `json:"prefetch,omitempty"`
	ProductId *int                               `json:"product_id,omitempty"`
}

// ProductGroupsListParamsPrefetch defines parameters for ProductGroupsList.
type ProductGroupsListParamsPrefetch string

// ProductGroupsCreateJSONBody defines parameters for ProductGroupsCreate.
type ProductGroupsCreateJSONBody ProductGroupRequest

// ProductGroupsRetrieveParams defines parameters for ProductGroupsRetrieve.
type ProductGroupsRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]ProductGroupsRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// ProductGroupsRetrieveParamsPrefetch defines parameters for ProductGroupsRetrieve.
type ProductGroupsRetrieveParamsPrefetch string

// ProductGroupsUpdateJSONBody defines parameters for ProductGroupsUpdate.
type ProductGroupsUpdateJSONBody ProductGroupRequest

// ProductGroupsDeletePreviewListParams defines parameters for ProductGroupsDeletePreviewList.
type ProductGroupsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// ProductMembersListParams defines parameters for ProductMembersList.
type ProductMembersListParams struct {
	Id *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch  *[]ProductMembersListParamsPrefetch `json:"prefetch,omitempty"`
	ProductId *int                                `json:"product_id,omitempty"`
	UserId    *int                                `json:"user_id,omitempty"`
}

// ProductMembersListParamsPrefetch defines parameters for ProductMembersList.
type ProductMembersListParamsPrefetch string

// ProductMembersCreateJSONBody defines parameters for ProductMembersCreate.
type ProductMembersCreateJSONBody ProductMemberRequest

// ProductMembersRetrieveParams defines parameters for ProductMembersRetrieve.
type ProductMembersRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]ProductMembersRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// ProductMembersRetrieveParamsPrefetch defines parameters for ProductMembersRetrieve.
type ProductMembersRetrieveParamsPrefetch string

// ProductMembersUpdateJSONBody defines parameters for ProductMembersUpdate.
type ProductMembersUpdateJSONBody ProductMemberRequest

// ProductMembersDeletePreviewListParams defines parameters for ProductMembersDeletePreviewList.
type ProductMembersDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// ProductTypeGroupsListParams defines parameters for ProductTypeGroupsList.
type ProductTypeGroupsListParams struct {
	GroupId *int `json:"group_id,omitempty"`
	Id      *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch      *[]ProductTypeGroupsListParamsPrefetch `json:"prefetch,omitempty"`
	ProductTypeId *int                                   `json:"product_type_id,omitempty"`
}

// ProductTypeGroupsListParamsPrefetch defines parameters for ProductTypeGroupsList.
type ProductTypeGroupsListParamsPrefetch string

// ProductTypeGroupsCreateJSONBody defines parameters for ProductTypeGroupsCreate.
type ProductTypeGroupsCreateJSONBody ProductTypeGroupRequest

// ProductTypeGroupsRetrieveParams defines parameters for ProductTypeGroupsRetrieve.
type ProductTypeGroupsRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]ProductTypeGroupsRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// ProductTypeGroupsRetrieveParamsPrefetch defines parameters for ProductTypeGroupsRetrieve.
type ProductTypeGroupsRetrieveParamsPrefetch string

// ProductTypeGroupsUpdateJSONBody defines parameters for ProductTypeGroupsUpdate.
type ProductTypeGroupsUpdateJSONBody ProductTypeGroupRequest

// ProductTypeGroupsDeletePreviewListParams defines parameters for ProductTypeGroupsDeletePreviewList.
type ProductTypeGroupsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// ProductTypeMembersListParams defines parameters for ProductTypeMembersList.
type ProductTypeMembersListParams struct {
	Id *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch      *[]ProductTypeMembersListParamsPrefetch `json:"prefetch,omitempty"`
	ProductTypeId *int                                    `json:"product_type_id,omitempty"`
	UserId        *int                                    `json:"user_id,omitempty"`
}

// ProductTypeMembersListParamsPrefetch defines parameters for ProductTypeMembersList.
type ProductTypeMembersListParamsPrefetch string

// ProductTypeMembersCreateJSONBody defines parameters for ProductTypeMembersCreate.
type ProductTypeMembersCreateJSONBody ProductTypeMemberRequest

// ProductTypeMembersRetrieveParams defines parameters for ProductTypeMembersRetrieve.
type ProductTypeMembersRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]ProductTypeMembersRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// ProductTypeMembersRetrieveParamsPrefetch defines parameters for ProductTypeMembersRetrieve.
type ProductTypeMembersRetrieveParamsPrefetch string

// ProductTypeMembersUpdateJSONBody defines parameters for ProductTypeMembersUpdate.
type ProductTypeMembersUpdateJSONBody ProductTypeMemberRequest

// ProductTypeMembersDeletePreviewListParams defines parameters for ProductTypeMembersDeletePreviewList.
type ProductTypeMembersDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// ProductTypesListParams defines parameters for ProductTypesList.
type ProductTypesListParams struct {
	Created         *time.Time `json:"created,omitempty"`
	CriticalProduct *bool      `json:"critical_product,omitempty"`
	Id              *int       `json:"id,omitempty"`
	KeyProduct      *bool      `json:"key_product,omitempty"`

	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]ProductTypesListParamsPrefetch `json:"prefetch,omitempty"`
	Updated  *time.Time                        `json:"updated,omitempty"`
}

// ProductTypesListParamsPrefetch defines parameters for ProductTypesList.
type ProductTypesListParamsPrefetch string

// ProductTypesCreateJSONBody defines parameters for ProductTypesCreate.
type ProductTypesCreateJSONBody ProductTypeRequest

// ProductTypesRetrieveParams defines parameters for ProductTypesRetrieve.
type ProductTypesRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]ProductTypesRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// ProductTypesRetrieveParamsPrefetch defines parameters for ProductTypesRetrieve.
type ProductTypesRetrieveParamsPrefetch string

// ProductTypesPartialUpdateJSONBody defines parameters for ProductTypesPartialUpdate.
type ProductTypesPartialUpdateJSONBody PatchedProductTypeRequest

// ProductTypesUpdateJSONBody defines parameters for ProductTypesUpdate.
type ProductTypesUpdateJSONBody ProductTypeRequest

// ProductTypesDeletePreviewListParams defines parameters for ProductTypesDeletePreviewList.
type ProductTypesDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// ProductTypesGenerateReportCreateJSONBody defines parameters for ProductTypesGenerateReportCreate.
type ProductTypesGenerateReportCreateJSONBody ReportGenerateOptionRequest

// ProductsListParams defines parameters for ProductsList.
type ProductsListParams struct {
	BusinessCriticality *string                    `json:"business_criticality,omitempty"`
	Created             *ProductsListParamsCreated `json:"created,omitempty"`
	Description         *string                    `json:"description,omitempty"`
	ExternalAudience    *bool                      `json:"external_audience,omitempty"`

	// Multiple values may be separated by commas.
	Id                 *[]int  `json:"id,omitempty"`
	InternetAccessible *bool   `json:"internet_accessible,omitempty"`
	Lifecycle          *string `json:"lifecycle,omitempty"`

	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// Not Tag name contains
	NotTag *string `json:"not_tag,omitempty"`

	// Comma seperated list of exact tags not present on product
	NotTags *[]string `json:"not_tags,omitempty"`

	// Ordering
	O *[]ProductsListParamsO `json:"o,omitempty"`

	// The initial index from which to return the results.
	Offset   *int    `json:"offset,omitempty"`
	Origin   *string `json:"origin,omitempty"`
	Platform *string `json:"platform,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]ProductsListParamsPrefetch `json:"prefetch,omitempty"`

	// Multiple values may be separated by commas.
	ProdNumericGrade *[]int `json:"prod_numeric_grade,omitempty"`

	// Multiple values may be separated by commas.
	ProdType *[]int `json:"prod_type,omitempty"`

	// Multiple values may be separated by commas.
	ProductManager *[]int `json:"product_manager,omitempty"`

	// Multiple values may be separated by commas.
	Regulations *[]int   `json:"regulations,omitempty"`
	Revenue     *float32 `json:"revenue,omitempty"`

	// Tag name contains
	Tag *string `json:"tag,omitempty"`

	// Comma seperated list of exact tags
	Tags *[]string `json:"tags,omitempty"`

	// Multiple values may be separated by commas.
	TeamManager *[]int `json:"team_manager,omitempty"`

	// Multiple values may be separated by commas.
	TechnicalContact *[]int `json:"technical_contact,omitempty"`

	// Multiple values may be separated by commas.
	Tid     *[]int                     `json:"tid,omitempty"`
	Updated *ProductsListParamsUpdated `json:"updated,omitempty"`

	// Multiple values may be separated by commas.
	UserRecords *[]int `json:"user_records,omitempty"`
}

// ProductsListParamsCreated defines parameters for ProductsList.
type ProductsListParamsCreated time.Time

// ProductsListParamsO defines parameters for ProductsList.
type ProductsListParamsO string

// ProductsListParamsPrefetch defines parameters for ProductsList.
type ProductsListParamsPrefetch string

// ProductsListParamsUpdated defines parameters for ProductsList.
type ProductsListParamsUpdated time.Time

// ProductsCreateJSONBody defines parameters for ProductsCreate.
type ProductsCreateJSONBody ProductRequest

// ProductsRetrieveParams defines parameters for ProductsRetrieve.
type ProductsRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]ProductsRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// ProductsRetrieveParamsPrefetch defines parameters for ProductsRetrieve.
type ProductsRetrieveParamsPrefetch string

// ProductsPartialUpdateJSONBody defines parameters for ProductsPartialUpdate.
type ProductsPartialUpdateJSONBody PatchedProductRequest

// ProductsUpdateJSONBody defines parameters for ProductsUpdate.
type ProductsUpdateJSONBody ProductRequest

// ProductsDeletePreviewListParams defines parameters for ProductsDeletePreviewList.
type ProductsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// ProductsGenerateReportCreateJSONBody defines parameters for ProductsGenerateReportCreate.
type ProductsGenerateReportCreateJSONBody ReportGenerateOptionRequest

// RegulationsListParams defines parameters for RegulationsList.
type RegulationsListParams struct {
	Description *string `json:"description,omitempty"`
	Id          *int    `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// RegulationsCreateJSONBody defines parameters for RegulationsCreate.
type RegulationsCreateJSONBody RegulationRequest

// RegulationsPartialUpdateJSONBody defines parameters for RegulationsPartialUpdate.
type RegulationsPartialUpdateJSONBody PatchedRegulationRequest

// RegulationsUpdateJSONBody defines parameters for RegulationsUpdate.
type RegulationsUpdateJSONBody RegulationRequest

// RegulationsDeletePreviewListParams defines parameters for RegulationsDeletePreviewList.
type RegulationsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// RolesListParams defines parameters for RolesList.
type RolesListParams struct {
	Id *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// SlaConfigurationsListParams defines parameters for SlaConfigurationsList.
type SlaConfigurationsListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// SlaConfigurationsCreateJSONBody defines parameters for SlaConfigurationsCreate.
type SlaConfigurationsCreateJSONBody SLAConfigurationRequest

// SlaConfigurationsPartialUpdateJSONBody defines parameters for SlaConfigurationsPartialUpdate.
type SlaConfigurationsPartialUpdateJSONBody PatchedSLAConfigurationRequest

// SlaConfigurationsUpdateJSONBody defines parameters for SlaConfigurationsUpdate.
type SlaConfigurationsUpdateJSONBody SLAConfigurationRequest

// SonarqubeIssuesListParams defines parameters for SonarqubeIssuesList.
type SonarqubeIssuesListParams struct {
	Id  *int    `json:"id,omitempty"`
	Key *string `json:"key,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int    `json:"offset,omitempty"`
	Status *string `json:"status,omitempty"`
	Type   *string `json:"type,omitempty"`
}

// SonarqubeIssuesCreateJSONBody defines parameters for SonarqubeIssuesCreate.
type SonarqubeIssuesCreateJSONBody SonarqubeIssueRequest

// SonarqubeIssuesPartialUpdateJSONBody defines parameters for SonarqubeIssuesPartialUpdate.
type SonarqubeIssuesPartialUpdateJSONBody PatchedSonarqubeIssueRequest

// SonarqubeIssuesUpdateJSONBody defines parameters for SonarqubeIssuesUpdate.
type SonarqubeIssuesUpdateJSONBody SonarqubeIssueRequest

// SonarqubeIssuesDeletePreviewListParams defines parameters for SonarqubeIssuesDeletePreviewList.
type SonarqubeIssuesDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// SonarqubeTransitionsListParams defines parameters for SonarqubeTransitionsList.
type SonarqubeTransitionsListParams struct {
	FindingStatus *string `json:"finding_status,omitempty"`
	Id            *int    `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset          *int    `json:"offset,omitempty"`
	SonarqubeIssue  *int    `json:"sonarqube_issue,omitempty"`
	SonarqubeStatus *string `json:"sonarqube_status,omitempty"`
	Transitions     *string `json:"transitions,omitempty"`
}

// SonarqubeTransitionsCreateJSONBody defines parameters for SonarqubeTransitionsCreate.
type SonarqubeTransitionsCreateJSONBody SonarqubeIssueTransitionRequest

// SonarqubeTransitionsPartialUpdateJSONBody defines parameters for SonarqubeTransitionsPartialUpdate.
type SonarqubeTransitionsPartialUpdateJSONBody PatchedSonarqubeIssueTransitionRequest

// SonarqubeTransitionsUpdateJSONBody defines parameters for SonarqubeTransitionsUpdate.
type SonarqubeTransitionsUpdateJSONBody SonarqubeIssueTransitionRequest

// SonarqubeTransitionsDeletePreviewListParams defines parameters for SonarqubeTransitionsDeletePreviewList.
type SonarqubeTransitionsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// StubFindingsListParams defines parameters for StubFindingsList.
type StubFindingsListParams struct {
	Date        *openapi_types.Date `json:"date,omitempty"`
	Description *string             `json:"description,omitempty"`
	Id          *int                `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset   *int    `json:"offset,omitempty"`
	Severity *string `json:"severity,omitempty"`
	Title    *string `json:"title,omitempty"`
}

// StubFindingsCreateJSONBody defines parameters for StubFindingsCreate.
type StubFindingsCreateJSONBody StubFindingCreateRequest

// StubFindingsPartialUpdateJSONBody defines parameters for StubFindingsPartialUpdate.
type StubFindingsPartialUpdateJSONBody PatchedStubFindingRequest

// StubFindingsUpdateJSONBody defines parameters for StubFindingsUpdate.
type StubFindingsUpdateJSONBody StubFindingRequest

// StubFindingsDeletePreviewListParams defines parameters for StubFindingsDeletePreviewList.
type StubFindingsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// SystemSettingsListParams defines parameters for SystemSettingsList.
type SystemSettingsListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// SystemSettingsPartialUpdateJSONBody defines parameters for SystemSettingsPartialUpdate.
type SystemSettingsPartialUpdateJSONBody PatchedSystemSettingsRequest

// SystemSettingsUpdateJSONBody defines parameters for SystemSettingsUpdate.
type SystemSettingsUpdateJSONBody SystemSettingsRequest

// TechnologiesListParams defines parameters for TechnologiesList.
type TechnologiesListParams struct {
	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// Not Tag name contains
	NotTag *string `json:"not_tag,omitempty"`

	// Comma seperated list of exact tags not present on model
	NotTags *[]string `json:"not_tags,omitempty"`

	// The initial index from which to return the results.
	Offset  *int `json:"offset,omitempty"`
	Product *int `json:"product,omitempty"`

	// Tag name contains
	Tag *string `json:"tag,omitempty"`

	// Comma seperated list of exact tags
	Tags    *[]string `json:"tags,omitempty"`
	User    *int      `json:"user,omitempty"`
	Version *string   `json:"version,omitempty"`
}

// TechnologiesCreateJSONBody defines parameters for TechnologiesCreate.
type TechnologiesCreateJSONBody AppAnalysisRequest

// TechnologiesPartialUpdateJSONBody defines parameters for TechnologiesPartialUpdate.
type TechnologiesPartialUpdateJSONBody PatchedAppAnalysisRequest

// TechnologiesUpdateJSONBody defines parameters for TechnologiesUpdate.
type TechnologiesUpdateJSONBody AppAnalysisRequest

// TechnologiesDeletePreviewListParams defines parameters for TechnologiesDeletePreviewList.
type TechnologiesDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// TestImportsListParams defines parameters for TestImportsList.
type TestImportsListParams struct {
	BranchTag        *string `json:"branch_tag,omitempty"`
	BuildId          *string `json:"build_id,omitempty"`
	CommitHash       *string `json:"commit_hash,omitempty"`
	FindingsAffected *[]int  `json:"findings_affected,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch                       *[]TestImportsListParamsPrefetch                    `json:"prefetch,omitempty"`
	Test                           *int                                                `json:"test,omitempty"`
	TestImportFindingActionAction  *TestImportsListParamsTestImportFindingActionAction `json:"test_import_finding_action__action,omitempty"`
	TestImportFindingActionCreated *time.Time                                          `json:"test_import_finding_action__created,omitempty"`
	TestImportFindingActionFinding *int                                                `json:"test_import_finding_action__finding,omitempty"`
	Version                        *string                                             `json:"version,omitempty"`
}

// TestImportsListParamsPrefetch defines parameters for TestImportsList.
type TestImportsListParamsPrefetch string

// TestImportsListParamsTestImportFindingActionAction defines parameters for TestImportsList.
type TestImportsListParamsTestImportFindingActionAction string

// TestImportsCreateJSONBody defines parameters for TestImportsCreate.
type TestImportsCreateJSONBody TestImportRequest

// TestImportsRetrieveParams defines parameters for TestImportsRetrieve.
type TestImportsRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]TestImportsRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// TestImportsRetrieveParamsPrefetch defines parameters for TestImportsRetrieve.
type TestImportsRetrieveParamsPrefetch string

// TestImportsPartialUpdateJSONBody defines parameters for TestImportsPartialUpdate.
type TestImportsPartialUpdateJSONBody PatchedTestImportRequest

// TestImportsUpdateJSONBody defines parameters for TestImportsUpdate.
type TestImportsUpdateJSONBody TestImportRequest

// TestImportsDeletePreviewListParams defines parameters for TestImportsDeletePreviewList.
type TestImportsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// TestTypesListParams defines parameters for TestTypesList.
type TestTypesListParams struct {
	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// TestTypesCreateJSONBody defines parameters for TestTypesCreate.
type TestTypesCreateJSONBody TestTypeRequest

// TestTypesPartialUpdateJSONBody defines parameters for TestTypesPartialUpdate.
type TestTypesPartialUpdateJSONBody PatchedTestTypeRequest

// TestTypesUpdateJSONBody defines parameters for TestTypesUpdate.
type TestTypesUpdateJSONBody TestTypeRequest

// TestsListParams defines parameters for TestsList.
type TestsListParams struct {
	ActualTime           *string `json:"actual_time,omitempty"`
	ApiScanConfiguration *int    `json:"api_scan_configuration,omitempty"`
	BranchTag            *string `json:"branch_tag,omitempty"`
	BuildId              *string `json:"build_id,omitempty"`
	CommitHash           *string `json:"commit_hash,omitempty"`
	Engagement           *int    `json:"engagement,omitempty"`

	// Comma seperated list of exact tags present on product
	EngagementProductTagsName *[]string `json:"engagement__product__tags__name,omitempty"`

	// Comma seperated list of exact tags present on engagement
	EngagementTags *[]string `json:"engagement__tags,omitempty"`
	Id             *int      `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// Comma seperated list of exact tags not present on product
	NotEngagementProductTagsName *[]string `json:"not_engagement__product__tags__name,omitempty"`

	// Comma seperated list of exact tags not present on engagement
	NotEngagementTags *[]string `json:"not_engagement__tags,omitempty"`

	// Not Tag name contains
	NotTag *string `json:"not_tag,omitempty"`

	// Comma seperated list of exact tags not present on model
	NotTags *[]string `json:"not_tags,omitempty"`
	Notes   *[]int    `json:"notes,omitempty"`

	// Ordering
	O *[]TestsListParamsO `json:"o,omitempty"`

	// The initial index from which to return the results.
	Offset          *int `json:"offset,omitempty"`
	PercentComplete *int `json:"percent_complete,omitempty"`

	// Tag name contains
	Tag *string `json:"tag,omitempty"`

	// Comma seperated list of exact tags
	Tags        *[]string  `json:"tags,omitempty"`
	TargetEnd   *time.Time `json:"target_end,omitempty"`
	TargetStart *time.Time `json:"target_start,omitempty"`
	TestType    *int       `json:"test_type,omitempty"`
	Title       *string    `json:"title,omitempty"`
	Version     *string    `json:"version,omitempty"`
}

// TestsListParamsO defines parameters for TestsList.
type TestsListParamsO string

// TestsCreateJSONBody defines parameters for TestsCreate.
type TestsCreateJSONBody TestCreateRequest

// TestsPartialUpdateJSONBody defines parameters for TestsPartialUpdate.
type TestsPartialUpdateJSONBody PatchedTestRequest

// TestsUpdateJSONBody defines parameters for TestsUpdate.
type TestsUpdateJSONBody TestRequest

// TestsAcceptRisksCreateJSONBody defines parameters for TestsAcceptRisksCreate.
type TestsAcceptRisksCreateJSONBody []AcceptedRiskRequest

// TestsDeletePreviewListParams defines parameters for TestsDeletePreviewList.
type TestsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// TestsGenerateReportCreateJSONBody defines parameters for TestsGenerateReportCreate.
type TestsGenerateReportCreateJSONBody ReportGenerateOptionRequest

// TestsNotesCreateJSONBody defines parameters for TestsNotesCreate.
type TestsNotesCreateJSONBody AddNewNoteOptionRequest

// ToolConfigurationsListParams defines parameters for ToolConfigurationsList.
type ToolConfigurationsListParams struct {
	AuthenticationType *ToolConfigurationsListParamsAuthenticationType `json:"authentication_type,omitempty"`
	Id                 *int                                            `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// The initial index from which to return the results.
	Offset   *int    `json:"offset,omitempty"`
	ToolType *int    `json:"tool_type,omitempty"`
	Url      *string `json:"url,omitempty"`
}

// ToolConfigurationsListParamsAuthenticationType defines parameters for ToolConfigurationsList.
type ToolConfigurationsListParamsAuthenticationType string

// ToolConfigurationsCreateJSONBody defines parameters for ToolConfigurationsCreate.
type ToolConfigurationsCreateJSONBody ToolConfigurationRequest

// ToolConfigurationsPartialUpdateJSONBody defines parameters for ToolConfigurationsPartialUpdate.
type ToolConfigurationsPartialUpdateJSONBody PatchedToolConfigurationRequest

// ToolConfigurationsUpdateJSONBody defines parameters for ToolConfigurationsUpdate.
type ToolConfigurationsUpdateJSONBody ToolConfigurationRequest

// ToolConfigurationsDeletePreviewListParams defines parameters for ToolConfigurationsDeletePreviewList.
type ToolConfigurationsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// ToolProductSettingsListParams defines parameters for ToolProductSettingsList.
type ToolProductSettingsListParams struct {
	Id *int `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// The initial index from which to return the results.
	Offset            *int    `json:"offset,omitempty"`
	Product           *int    `json:"product,omitempty"`
	ToolConfiguration *int    `json:"tool_configuration,omitempty"`
	ToolProjectId     *string `json:"tool_project_id,omitempty"`
	Url               *string `json:"url,omitempty"`
}

// ToolProductSettingsCreateJSONBody defines parameters for ToolProductSettingsCreate.
type ToolProductSettingsCreateJSONBody ToolProductSettingsRequest

// ToolProductSettingsPartialUpdateJSONBody defines parameters for ToolProductSettingsPartialUpdate.
type ToolProductSettingsPartialUpdateJSONBody PatchedToolProductSettingsRequest

// ToolProductSettingsUpdateJSONBody defines parameters for ToolProductSettingsUpdate.
type ToolProductSettingsUpdateJSONBody ToolProductSettingsRequest

// ToolProductSettingsDeletePreviewListParams defines parameters for ToolProductSettingsDeletePreviewList.
type ToolProductSettingsDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// ToolTypesListParams defines parameters for ToolTypesList.
type ToolTypesListParams struct {
	Description *string `json:"description,omitempty"`
	Id          *int    `json:"id,omitempty"`

	// Number of results to return per page.
	Limit *int    `json:"limit,omitempty"`
	Name  *string `json:"name,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// ToolTypesCreateJSONBody defines parameters for ToolTypesCreate.
type ToolTypesCreateJSONBody ToolTypeRequest

// ToolTypesPartialUpdateJSONBody defines parameters for ToolTypesPartialUpdate.
type ToolTypesPartialUpdateJSONBody PatchedToolTypeRequest

// ToolTypesUpdateJSONBody defines parameters for ToolTypesUpdate.
type ToolTypesUpdateJSONBody ToolTypeRequest

// ToolTypesDeletePreviewListParams defines parameters for ToolTypesDeletePreviewList.
type ToolTypesDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// UserContactInfosListParams defines parameters for UserContactInfosList.
type UserContactInfosListParams struct {
	BlockExecution     *bool   `json:"block_execution,omitempty"`
	CellNumber         *string `json:"cell_number,omitempty"`
	ForcePasswordReset *bool   `json:"force_password_reset,omitempty"`
	GithubUsername     *string `json:"github_username,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset      *int    `json:"offset,omitempty"`
	PhoneNumber *string `json:"phone_number,omitempty"`

	// List of fields for which to prefetch model instances and add those to the response
	Prefetch        *[]UserContactInfosListParamsPrefetch `json:"prefetch,omitempty"`
	SlackUserId     *string                               `json:"slack_user_id,omitempty"`
	SlackUsername   *string                               `json:"slack_username,omitempty"`
	Title           *string                               `json:"title,omitempty"`
	TwitterUsername *string                               `json:"twitter_username,omitempty"`
	User            *int                                  `json:"user,omitempty"`
}

// UserContactInfosListParamsPrefetch defines parameters for UserContactInfosList.
type UserContactInfosListParamsPrefetch string

// UserContactInfosCreateJSONBody defines parameters for UserContactInfosCreate.
type UserContactInfosCreateJSONBody UserContactInfoRequest

// UserContactInfosRetrieveParams defines parameters for UserContactInfosRetrieve.
type UserContactInfosRetrieveParams struct {
	// List of fields for which to prefetch model instances and add those to the response
	Prefetch *[]UserContactInfosRetrieveParamsPrefetch `json:"prefetch,omitempty"`
}

// UserContactInfosRetrieveParamsPrefetch defines parameters for UserContactInfosRetrieve.
type UserContactInfosRetrieveParamsPrefetch string

// UserContactInfosPartialUpdateJSONBody defines parameters for UserContactInfosPartialUpdate.
type UserContactInfosPartialUpdateJSONBody PatchedUserContactInfoRequest

// UserContactInfosUpdateJSONBody defines parameters for UserContactInfosUpdate.
type UserContactInfosUpdateJSONBody UserContactInfoRequest

// UserContactInfosDeletePreviewListParams defines parameters for UserContactInfosDeletePreviewList.
type UserContactInfosDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// UsersListParams defines parameters for UsersList.
type UsersListParams struct {
	Email       *string `json:"email,omitempty"`
	FirstName   *string `json:"first_name,omitempty"`
	Id          *int    `json:"id,omitempty"`
	IsActive    *bool   `json:"is_active,omitempty"`
	IsSuperuser *bool   `json:"is_superuser,omitempty"`
	LastName    *string `json:"last_name,omitempty"`

	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset   *int    `json:"offset,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UsersCreateJSONBody defines parameters for UsersCreate.
type UsersCreateJSONBody UserRequest

// UsersPartialUpdateJSONBody defines parameters for UsersPartialUpdate.
type UsersPartialUpdateJSONBody PatchedUserRequest

// UsersUpdateJSONBody defines parameters for UsersUpdate.
type UsersUpdateJSONBody UserRequest

// UsersDeletePreviewListParams defines parameters for UsersDeletePreviewList.
type UsersDeletePreviewListParams struct {
	// Number of results to return per page.
	Limit *int `json:"limit,omitempty"`

	// The initial index from which to return the results.
	Offset *int `json:"offset,omitempty"`
}

// ApiTokenAuthCreateJSONRequestBody defines body for ApiTokenAuthCreate for application/json ContentType.
type ApiTokenAuthCreateJSONRequestBody ApiTokenAuthCreateJSONBody

// DevelopmentEnvironmentsCreateJSONRequestBody defines body for DevelopmentEnvironmentsCreate for application/json ContentType.
type DevelopmentEnvironmentsCreateJSONRequestBody DevelopmentEnvironmentsCreateJSONBody

// DevelopmentEnvironmentsPartialUpdateJSONRequestBody defines body for DevelopmentEnvironmentsPartialUpdate for application/json ContentType.
type DevelopmentEnvironmentsPartialUpdateJSONRequestBody DevelopmentEnvironmentsPartialUpdateJSONBody

// DevelopmentEnvironmentsUpdateJSONRequestBody defines body for DevelopmentEnvironmentsUpdate for application/json ContentType.
type DevelopmentEnvironmentsUpdateJSONRequestBody DevelopmentEnvironmentsUpdateJSONBody

// DojoGroupMembersCreateJSONRequestBody defines body for DojoGroupMembersCreate for application/json ContentType.
type DojoGroupMembersCreateJSONRequestBody DojoGroupMembersCreateJSONBody

// DojoGroupMembersPartialUpdateJSONRequestBody defines body for DojoGroupMembersPartialUpdate for application/json ContentType.
type DojoGroupMembersPartialUpdateJSONRequestBody DojoGroupMembersPartialUpdateJSONBody

// DojoGroupMembersUpdateJSONRequestBody defines body for DojoGroupMembersUpdate for application/json ContentType.
type DojoGroupMembersUpdateJSONRequestBody DojoGroupMembersUpdateJSONBody

// DojoGroupsCreateJSONRequestBody defines body for DojoGroupsCreate for application/json ContentType.
type DojoGroupsCreateJSONRequestBody DojoGroupsCreateJSONBody

// DojoGroupsPartialUpdateJSONRequestBody defines body for DojoGroupsPartialUpdate for application/json ContentType.
type DojoGroupsPartialUpdateJSONRequestBody DojoGroupsPartialUpdateJSONBody

// DojoGroupsUpdateJSONRequestBody defines body for DojoGroupsUpdate for application/json ContentType.
type DojoGroupsUpdateJSONRequestBody DojoGroupsUpdateJSONBody

// EndpointStatusCreateJSONRequestBody defines body for EndpointStatusCreate for application/json ContentType.
type EndpointStatusCreateJSONRequestBody EndpointStatusCreateJSONBody

// EndpointStatusPartialUpdateJSONRequestBody defines body for EndpointStatusPartialUpdate for application/json ContentType.
type EndpointStatusPartialUpdateJSONRequestBody EndpointStatusPartialUpdateJSONBody

// EndpointStatusUpdateJSONRequestBody defines body for EndpointStatusUpdate for application/json ContentType.
type EndpointStatusUpdateJSONRequestBody EndpointStatusUpdateJSONBody

// EndpointsCreateJSONRequestBody defines body for EndpointsCreate for application/json ContentType.
type EndpointsCreateJSONRequestBody EndpointsCreateJSONBody

// EndpointsPartialUpdateJSONRequestBody defines body for EndpointsPartialUpdate for application/json ContentType.
type EndpointsPartialUpdateJSONRequestBody EndpointsPartialUpdateJSONBody

// EndpointsUpdateJSONRequestBody defines body for EndpointsUpdate for application/json ContentType.
type EndpointsUpdateJSONRequestBody EndpointsUpdateJSONBody

// EndpointsGenerateReportCreateJSONRequestBody defines body for EndpointsGenerateReportCreate for application/json ContentType.
type EndpointsGenerateReportCreateJSONRequestBody EndpointsGenerateReportCreateJSONBody

// EngagementPresetsCreateJSONRequestBody defines body for EngagementPresetsCreate for application/json ContentType.
type EngagementPresetsCreateJSONRequestBody EngagementPresetsCreateJSONBody

// EngagementPresetsPartialUpdateJSONRequestBody defines body for EngagementPresetsPartialUpdate for application/json ContentType.
type EngagementPresetsPartialUpdateJSONRequestBody EngagementPresetsPartialUpdateJSONBody

// EngagementPresetsUpdateJSONRequestBody defines body for EngagementPresetsUpdate for application/json ContentType.
type EngagementPresetsUpdateJSONRequestBody EngagementPresetsUpdateJSONBody

// EngagementsCreateJSONRequestBody defines body for EngagementsCreate for application/json ContentType.
type EngagementsCreateJSONRequestBody EngagementsCreateJSONBody

// EngagementsPartialUpdateJSONRequestBody defines body for EngagementsPartialUpdate for application/json ContentType.
type EngagementsPartialUpdateJSONRequestBody EngagementsPartialUpdateJSONBody

// EngagementsUpdateJSONRequestBody defines body for EngagementsUpdate for application/json ContentType.
type EngagementsUpdateJSONRequestBody EngagementsUpdateJSONBody

// EngagementsAcceptRisksCreateJSONRequestBody defines body for EngagementsAcceptRisksCreate for application/json ContentType.
type EngagementsAcceptRisksCreateJSONRequestBody EngagementsAcceptRisksCreateJSONBody

// EngagementsGenerateReportCreateJSONRequestBody defines body for EngagementsGenerateReportCreate for application/json ContentType.
type EngagementsGenerateReportCreateJSONRequestBody EngagementsGenerateReportCreateJSONBody

// EngagementsNotesCreateJSONRequestBody defines body for EngagementsNotesCreate for application/json ContentType.
type EngagementsNotesCreateJSONRequestBody EngagementsNotesCreateJSONBody

// FindingTemplatesCreateJSONRequestBody defines body for FindingTemplatesCreate for application/json ContentType.
type FindingTemplatesCreateJSONRequestBody FindingTemplatesCreateJSONBody

// FindingTemplatesPartialUpdateJSONRequestBody defines body for FindingTemplatesPartialUpdate for application/json ContentType.
type FindingTemplatesPartialUpdateJSONRequestBody FindingTemplatesPartialUpdateJSONBody

// FindingTemplatesUpdateJSONRequestBody defines body for FindingTemplatesUpdate for application/json ContentType.
type FindingTemplatesUpdateJSONRequestBody FindingTemplatesUpdateJSONBody

// FindingsCreateJSONRequestBody defines body for FindingsCreate for application/json ContentType.
type FindingsCreateJSONRequestBody FindingsCreateJSONBody

// FindingsAcceptRisksCreateJSONRequestBody defines body for FindingsAcceptRisksCreate for application/json ContentType.
type FindingsAcceptRisksCreateJSONRequestBody FindingsAcceptRisksCreateJSONBody

// FindingsGenerateReportCreateJSONRequestBody defines body for FindingsGenerateReportCreate for application/json ContentType.
type FindingsGenerateReportCreateJSONRequestBody FindingsGenerateReportCreateJSONBody

// FindingsPartialUpdateJSONRequestBody defines body for FindingsPartialUpdate for application/json ContentType.
type FindingsPartialUpdateJSONRequestBody FindingsPartialUpdateJSONBody

// FindingsUpdateJSONRequestBody defines body for FindingsUpdate for application/json ContentType.
type FindingsUpdateJSONRequestBody FindingsUpdateJSONBody

// FindingsCloseCreateJSONRequestBody defines body for FindingsCloseCreate for application/json ContentType.
type FindingsCloseCreateJSONRequestBody FindingsCloseCreateJSONBody

// FindingsMetadataCreateJSONRequestBody defines body for FindingsMetadataCreate for application/json ContentType.
type FindingsMetadataCreateJSONRequestBody FindingsMetadataCreateJSONBody

// FindingsMetadataUpdateJSONRequestBody defines body for FindingsMetadataUpdate for application/json ContentType.
type FindingsMetadataUpdateJSONRequestBody FindingsMetadataUpdateJSONBody

// FindingsNotesCreateJSONRequestBody defines body for FindingsNotesCreate for application/json ContentType.
type FindingsNotesCreateJSONRequestBody FindingsNotesCreateJSONBody

// FindingsRemoveNotePartialUpdateJSONRequestBody defines body for FindingsRemoveNotePartialUpdate for application/json ContentType.
type FindingsRemoveNotePartialUpdateJSONRequestBody FindingsRemoveNotePartialUpdateJSONBody

// FindingsRemoveTagsPartialUpdateJSONRequestBody defines body for FindingsRemoveTagsPartialUpdate for application/json ContentType.
type FindingsRemoveTagsPartialUpdateJSONRequestBody FindingsRemoveTagsPartialUpdateJSONBody

// FindingsRemoveTagsUpdateJSONRequestBody defines body for FindingsRemoveTagsUpdate for application/json ContentType.
type FindingsRemoveTagsUpdateJSONRequestBody FindingsRemoveTagsUpdateJSONBody

// FindingsRequestResponseCreateJSONRequestBody defines body for FindingsRequestResponseCreate for application/json ContentType.
type FindingsRequestResponseCreateJSONRequestBody FindingsRequestResponseCreateJSONBody

// FindingsTagsCreateJSONRequestBody defines body for FindingsTagsCreate for application/json ContentType.
type FindingsTagsCreateJSONRequestBody FindingsTagsCreateJSONBody

// GlobalRolesCreateJSONRequestBody defines body for GlobalRolesCreate for application/json ContentType.
type GlobalRolesCreateJSONRequestBody GlobalRolesCreateJSONBody

// GlobalRolesPartialUpdateJSONRequestBody defines body for GlobalRolesPartialUpdate for application/json ContentType.
type GlobalRolesPartialUpdateJSONRequestBody GlobalRolesPartialUpdateJSONBody

// GlobalRolesUpdateJSONRequestBody defines body for GlobalRolesUpdate for application/json ContentType.
type GlobalRolesUpdateJSONRequestBody GlobalRolesUpdateJSONBody

// JiraConfigurationsCreateJSONRequestBody defines body for JiraConfigurationsCreate for application/json ContentType.
type JiraConfigurationsCreateJSONRequestBody JiraConfigurationsCreateJSONBody

// JiraConfigurationsPartialUpdateJSONRequestBody defines body for JiraConfigurationsPartialUpdate for application/json ContentType.
type JiraConfigurationsPartialUpdateJSONRequestBody JiraConfigurationsPartialUpdateJSONBody

// JiraConfigurationsUpdateJSONRequestBody defines body for JiraConfigurationsUpdate for application/json ContentType.
type JiraConfigurationsUpdateJSONRequestBody JiraConfigurationsUpdateJSONBody

// JiraFindingMappingsCreateJSONRequestBody defines body for JiraFindingMappingsCreate for application/json ContentType.
type JiraFindingMappingsCreateJSONRequestBody JiraFindingMappingsCreateJSONBody

// JiraFindingMappingsPartialUpdateJSONRequestBody defines body for JiraFindingMappingsPartialUpdate for application/json ContentType.
type JiraFindingMappingsPartialUpdateJSONRequestBody JiraFindingMappingsPartialUpdateJSONBody

// JiraFindingMappingsUpdateJSONRequestBody defines body for JiraFindingMappingsUpdate for application/json ContentType.
type JiraFindingMappingsUpdateJSONRequestBody JiraFindingMappingsUpdateJSONBody

// JiraInstancesCreateJSONRequestBody defines body for JiraInstancesCreate for application/json ContentType.
type JiraInstancesCreateJSONRequestBody JiraInstancesCreateJSONBody

// JiraInstancesPartialUpdateJSONRequestBody defines body for JiraInstancesPartialUpdate for application/json ContentType.
type JiraInstancesPartialUpdateJSONRequestBody JiraInstancesPartialUpdateJSONBody

// JiraInstancesUpdateJSONRequestBody defines body for JiraInstancesUpdate for application/json ContentType.
type JiraInstancesUpdateJSONRequestBody JiraInstancesUpdateJSONBody

// JiraProductConfigurationsCreateJSONRequestBody defines body for JiraProductConfigurationsCreate for application/json ContentType.
type JiraProductConfigurationsCreateJSONRequestBody JiraProductConfigurationsCreateJSONBody

// JiraProductConfigurationsPartialUpdateJSONRequestBody defines body for JiraProductConfigurationsPartialUpdate for application/json ContentType.
type JiraProductConfigurationsPartialUpdateJSONRequestBody JiraProductConfigurationsPartialUpdateJSONBody

// JiraProductConfigurationsUpdateJSONRequestBody defines body for JiraProductConfigurationsUpdate for application/json ContentType.
type JiraProductConfigurationsUpdateJSONRequestBody JiraProductConfigurationsUpdateJSONBody

// JiraProjectsCreateJSONRequestBody defines body for JiraProjectsCreate for application/json ContentType.
type JiraProjectsCreateJSONRequestBody JiraProjectsCreateJSONBody

// JiraProjectsPartialUpdateJSONRequestBody defines body for JiraProjectsPartialUpdate for application/json ContentType.
type JiraProjectsPartialUpdateJSONRequestBody JiraProjectsPartialUpdateJSONBody

// JiraProjectsUpdateJSONRequestBody defines body for JiraProjectsUpdate for application/json ContentType.
type JiraProjectsUpdateJSONRequestBody JiraProjectsUpdateJSONBody

// LanguageTypesCreateJSONRequestBody defines body for LanguageTypesCreate for application/json ContentType.
type LanguageTypesCreateJSONRequestBody LanguageTypesCreateJSONBody

// LanguageTypesPartialUpdateJSONRequestBody defines body for LanguageTypesPartialUpdate for application/json ContentType.
type LanguageTypesPartialUpdateJSONRequestBody LanguageTypesPartialUpdateJSONBody

// LanguageTypesUpdateJSONRequestBody defines body for LanguageTypesUpdate for application/json ContentType.
type LanguageTypesUpdateJSONRequestBody LanguageTypesUpdateJSONBody

// LanguagesCreateJSONRequestBody defines body for LanguagesCreate for application/json ContentType.
type LanguagesCreateJSONRequestBody LanguagesCreateJSONBody

// LanguagesPartialUpdateJSONRequestBody defines body for LanguagesPartialUpdate for application/json ContentType.
type LanguagesPartialUpdateJSONRequestBody LanguagesPartialUpdateJSONBody

// LanguagesUpdateJSONRequestBody defines body for LanguagesUpdate for application/json ContentType.
type LanguagesUpdateJSONRequestBody LanguagesUpdateJSONBody

// MetadataCreateJSONRequestBody defines body for MetadataCreate for application/json ContentType.
type MetadataCreateJSONRequestBody MetadataCreateJSONBody

// MetadataPartialUpdateJSONRequestBody defines body for MetadataPartialUpdate for application/json ContentType.
type MetadataPartialUpdateJSONRequestBody MetadataPartialUpdateJSONBody

// MetadataUpdateJSONRequestBody defines body for MetadataUpdate for application/json ContentType.
type MetadataUpdateJSONRequestBody MetadataUpdateJSONBody

// NetworkLocationsCreateJSONRequestBody defines body for NetworkLocationsCreate for application/json ContentType.
type NetworkLocationsCreateJSONRequestBody NetworkLocationsCreateJSONBody

// NetworkLocationsPartialUpdateJSONRequestBody defines body for NetworkLocationsPartialUpdate for application/json ContentType.
type NetworkLocationsPartialUpdateJSONRequestBody NetworkLocationsPartialUpdateJSONBody

// NetworkLocationsUpdateJSONRequestBody defines body for NetworkLocationsUpdate for application/json ContentType.
type NetworkLocationsUpdateJSONRequestBody NetworkLocationsUpdateJSONBody

// NoteTypeCreateJSONRequestBody defines body for NoteTypeCreate for application/json ContentType.
type NoteTypeCreateJSONRequestBody NoteTypeCreateJSONBody

// NoteTypePartialUpdateJSONRequestBody defines body for NoteTypePartialUpdate for application/json ContentType.
type NoteTypePartialUpdateJSONRequestBody NoteTypePartialUpdateJSONBody

// NoteTypeUpdateJSONRequestBody defines body for NoteTypeUpdate for application/json ContentType.
type NoteTypeUpdateJSONRequestBody NoteTypeUpdateJSONBody

// NotesPartialUpdateJSONRequestBody defines body for NotesPartialUpdate for application/json ContentType.
type NotesPartialUpdateJSONRequestBody NotesPartialUpdateJSONBody

// NotesUpdateJSONRequestBody defines body for NotesUpdate for application/json ContentType.
type NotesUpdateJSONRequestBody NotesUpdateJSONBody

// NotificationsCreateJSONRequestBody defines body for NotificationsCreate for application/json ContentType.
type NotificationsCreateJSONRequestBody NotificationsCreateJSONBody

// NotificationsPartialUpdateJSONRequestBody defines body for NotificationsPartialUpdate for application/json ContentType.
type NotificationsPartialUpdateJSONRequestBody NotificationsPartialUpdateJSONBody

// NotificationsUpdateJSONRequestBody defines body for NotificationsUpdate for application/json ContentType.
type NotificationsUpdateJSONRequestBody NotificationsUpdateJSONBody

// ProductApiScanConfigurationsCreateJSONRequestBody defines body for ProductApiScanConfigurationsCreate for application/json ContentType.
type ProductApiScanConfigurationsCreateJSONRequestBody ProductApiScanConfigurationsCreateJSONBody

// ProductApiScanConfigurationsPartialUpdateJSONRequestBody defines body for ProductApiScanConfigurationsPartialUpdate for application/json ContentType.
type ProductApiScanConfigurationsPartialUpdateJSONRequestBody ProductApiScanConfigurationsPartialUpdateJSONBody

// ProductApiScanConfigurationsUpdateJSONRequestBody defines body for ProductApiScanConfigurationsUpdate for application/json ContentType.
type ProductApiScanConfigurationsUpdateJSONRequestBody ProductApiScanConfigurationsUpdateJSONBody

// ProductGroupsCreateJSONRequestBody defines body for ProductGroupsCreate for application/json ContentType.
type ProductGroupsCreateJSONRequestBody ProductGroupsCreateJSONBody

// ProductGroupsUpdateJSONRequestBody defines body for ProductGroupsUpdate for application/json ContentType.
type ProductGroupsUpdateJSONRequestBody ProductGroupsUpdateJSONBody

// ProductMembersCreateJSONRequestBody defines body for ProductMembersCreate for application/json ContentType.
type ProductMembersCreateJSONRequestBody ProductMembersCreateJSONBody

// ProductMembersUpdateJSONRequestBody defines body for ProductMembersUpdate for application/json ContentType.
type ProductMembersUpdateJSONRequestBody ProductMembersUpdateJSONBody

// ProductTypeGroupsCreateJSONRequestBody defines body for ProductTypeGroupsCreate for application/json ContentType.
type ProductTypeGroupsCreateJSONRequestBody ProductTypeGroupsCreateJSONBody

// ProductTypeGroupsUpdateJSONRequestBody defines body for ProductTypeGroupsUpdate for application/json ContentType.
type ProductTypeGroupsUpdateJSONRequestBody ProductTypeGroupsUpdateJSONBody

// ProductTypeMembersCreateJSONRequestBody defines body for ProductTypeMembersCreate for application/json ContentType.
type ProductTypeMembersCreateJSONRequestBody ProductTypeMembersCreateJSONBody

// ProductTypeMembersUpdateJSONRequestBody defines body for ProductTypeMembersUpdate for application/json ContentType.
type ProductTypeMembersUpdateJSONRequestBody ProductTypeMembersUpdateJSONBody

// ProductTypesCreateJSONRequestBody defines body for ProductTypesCreate for application/json ContentType.
type ProductTypesCreateJSONRequestBody ProductTypesCreateJSONBody

// ProductTypesPartialUpdateJSONRequestBody defines body for ProductTypesPartialUpdate for application/json ContentType.
type ProductTypesPartialUpdateJSONRequestBody ProductTypesPartialUpdateJSONBody

// ProductTypesUpdateJSONRequestBody defines body for ProductTypesUpdate for application/json ContentType.
type ProductTypesUpdateJSONRequestBody ProductTypesUpdateJSONBody

// ProductTypesGenerateReportCreateJSONRequestBody defines body for ProductTypesGenerateReportCreate for application/json ContentType.
type ProductTypesGenerateReportCreateJSONRequestBody ProductTypesGenerateReportCreateJSONBody

// ProductsCreateJSONRequestBody defines body for ProductsCreate for application/json ContentType.
type ProductsCreateJSONRequestBody ProductsCreateJSONBody

// ProductsPartialUpdateJSONRequestBody defines body for ProductsPartialUpdate for application/json ContentType.
type ProductsPartialUpdateJSONRequestBody ProductsPartialUpdateJSONBody

// ProductsUpdateJSONRequestBody defines body for ProductsUpdate for application/json ContentType.
type ProductsUpdateJSONRequestBody ProductsUpdateJSONBody

// ProductsGenerateReportCreateJSONRequestBody defines body for ProductsGenerateReportCreate for application/json ContentType.
type ProductsGenerateReportCreateJSONRequestBody ProductsGenerateReportCreateJSONBody

// RegulationsCreateJSONRequestBody defines body for RegulationsCreate for application/json ContentType.
type RegulationsCreateJSONRequestBody RegulationsCreateJSONBody

// RegulationsPartialUpdateJSONRequestBody defines body for RegulationsPartialUpdate for application/json ContentType.
type RegulationsPartialUpdateJSONRequestBody RegulationsPartialUpdateJSONBody

// RegulationsUpdateJSONRequestBody defines body for RegulationsUpdate for application/json ContentType.
type RegulationsUpdateJSONRequestBody RegulationsUpdateJSONBody

// SlaConfigurationsCreateJSONRequestBody defines body for SlaConfigurationsCreate for application/json ContentType.
type SlaConfigurationsCreateJSONRequestBody SlaConfigurationsCreateJSONBody

// SlaConfigurationsPartialUpdateJSONRequestBody defines body for SlaConfigurationsPartialUpdate for application/json ContentType.
type SlaConfigurationsPartialUpdateJSONRequestBody SlaConfigurationsPartialUpdateJSONBody

// SlaConfigurationsUpdateJSONRequestBody defines body for SlaConfigurationsUpdate for application/json ContentType.
type SlaConfigurationsUpdateJSONRequestBody SlaConfigurationsUpdateJSONBody

// SonarqubeIssuesCreateJSONRequestBody defines body for SonarqubeIssuesCreate for application/json ContentType.
type SonarqubeIssuesCreateJSONRequestBody SonarqubeIssuesCreateJSONBody

// SonarqubeIssuesPartialUpdateJSONRequestBody defines body for SonarqubeIssuesPartialUpdate for application/json ContentType.
type SonarqubeIssuesPartialUpdateJSONRequestBody SonarqubeIssuesPartialUpdateJSONBody

// SonarqubeIssuesUpdateJSONRequestBody defines body for SonarqubeIssuesUpdate for application/json ContentType.
type SonarqubeIssuesUpdateJSONRequestBody SonarqubeIssuesUpdateJSONBody

// SonarqubeTransitionsCreateJSONRequestBody defines body for SonarqubeTransitionsCreate for application/json ContentType.
type SonarqubeTransitionsCreateJSONRequestBody SonarqubeTransitionsCreateJSONBody

// SonarqubeTransitionsPartialUpdateJSONRequestBody defines body for SonarqubeTransitionsPartialUpdate for application/json ContentType.
type SonarqubeTransitionsPartialUpdateJSONRequestBody SonarqubeTransitionsPartialUpdateJSONBody

// SonarqubeTransitionsUpdateJSONRequestBody defines body for SonarqubeTransitionsUpdate for application/json ContentType.
type SonarqubeTransitionsUpdateJSONRequestBody SonarqubeTransitionsUpdateJSONBody

// StubFindingsCreateJSONRequestBody defines body for StubFindingsCreate for application/json ContentType.
type StubFindingsCreateJSONRequestBody StubFindingsCreateJSONBody

// StubFindingsPartialUpdateJSONRequestBody defines body for StubFindingsPartialUpdate for application/json ContentType.
type StubFindingsPartialUpdateJSONRequestBody StubFindingsPartialUpdateJSONBody

// StubFindingsUpdateJSONRequestBody defines body for StubFindingsUpdate for application/json ContentType.
type StubFindingsUpdateJSONRequestBody StubFindingsUpdateJSONBody

// SystemSettingsPartialUpdateJSONRequestBody defines body for SystemSettingsPartialUpdate for application/json ContentType.
type SystemSettingsPartialUpdateJSONRequestBody SystemSettingsPartialUpdateJSONBody

// SystemSettingsUpdateJSONRequestBody defines body for SystemSettingsUpdate for application/json ContentType.
type SystemSettingsUpdateJSONRequestBody SystemSettingsUpdateJSONBody

// TechnologiesCreateJSONRequestBody defines body for TechnologiesCreate for application/json ContentType.
type TechnologiesCreateJSONRequestBody TechnologiesCreateJSONBody

// TechnologiesPartialUpdateJSONRequestBody defines body for TechnologiesPartialUpdate for application/json ContentType.
type TechnologiesPartialUpdateJSONRequestBody TechnologiesPartialUpdateJSONBody

// TechnologiesUpdateJSONRequestBody defines body for TechnologiesUpdate for application/json ContentType.
type TechnologiesUpdateJSONRequestBody TechnologiesUpdateJSONBody

// TestImportsCreateJSONRequestBody defines body for TestImportsCreate for application/json ContentType.
type TestImportsCreateJSONRequestBody TestImportsCreateJSONBody

// TestImportsPartialUpdateJSONRequestBody defines body for TestImportsPartialUpdate for application/json ContentType.
type TestImportsPartialUpdateJSONRequestBody TestImportsPartialUpdateJSONBody

// TestImportsUpdateJSONRequestBody defines body for TestImportsUpdate for application/json ContentType.
type TestImportsUpdateJSONRequestBody TestImportsUpdateJSONBody

// TestTypesCreateJSONRequestBody defines body for TestTypesCreate for application/json ContentType.
type TestTypesCreateJSONRequestBody TestTypesCreateJSONBody

// TestTypesPartialUpdateJSONRequestBody defines body for TestTypesPartialUpdate for application/json ContentType.
type TestTypesPartialUpdateJSONRequestBody TestTypesPartialUpdateJSONBody

// TestTypesUpdateJSONRequestBody defines body for TestTypesUpdate for application/json ContentType.
type TestTypesUpdateJSONRequestBody TestTypesUpdateJSONBody

// TestsCreateJSONRequestBody defines body for TestsCreate for application/json ContentType.
type TestsCreateJSONRequestBody TestsCreateJSONBody

// TestsPartialUpdateJSONRequestBody defines body for TestsPartialUpdate for application/json ContentType.
type TestsPartialUpdateJSONRequestBody TestsPartialUpdateJSONBody

// TestsUpdateJSONRequestBody defines body for TestsUpdate for application/json ContentType.
type TestsUpdateJSONRequestBody TestsUpdateJSONBody

// TestsAcceptRisksCreateJSONRequestBody defines body for TestsAcceptRisksCreate for application/json ContentType.
type TestsAcceptRisksCreateJSONRequestBody TestsAcceptRisksCreateJSONBody

// TestsGenerateReportCreateJSONRequestBody defines body for TestsGenerateReportCreate for application/json ContentType.
type TestsGenerateReportCreateJSONRequestBody TestsGenerateReportCreateJSONBody

// TestsNotesCreateJSONRequestBody defines body for TestsNotesCreate for application/json ContentType.
type TestsNotesCreateJSONRequestBody TestsNotesCreateJSONBody

// ToolConfigurationsCreateJSONRequestBody defines body for ToolConfigurationsCreate for application/json ContentType.
type ToolConfigurationsCreateJSONRequestBody ToolConfigurationsCreateJSONBody

// ToolConfigurationsPartialUpdateJSONRequestBody defines body for ToolConfigurationsPartialUpdate for application/json ContentType.
type ToolConfigurationsPartialUpdateJSONRequestBody ToolConfigurationsPartialUpdateJSONBody

// ToolConfigurationsUpdateJSONRequestBody defines body for ToolConfigurationsUpdate for application/json ContentType.
type ToolConfigurationsUpdateJSONRequestBody ToolConfigurationsUpdateJSONBody

// ToolProductSettingsCreateJSONRequestBody defines body for ToolProductSettingsCreate for application/json ContentType.
type ToolProductSettingsCreateJSONRequestBody ToolProductSettingsCreateJSONBody

// ToolProductSettingsPartialUpdateJSONRequestBody defines body for ToolProductSettingsPartialUpdate for application/json ContentType.
type ToolProductSettingsPartialUpdateJSONRequestBody ToolProductSettingsPartialUpdateJSONBody

// ToolProductSettingsUpdateJSONRequestBody defines body for ToolProductSettingsUpdate for application/json ContentType.
type ToolProductSettingsUpdateJSONRequestBody ToolProductSettingsUpdateJSONBody

// ToolTypesCreateJSONRequestBody defines body for ToolTypesCreate for application/json ContentType.
type ToolTypesCreateJSONRequestBody ToolTypesCreateJSONBody

// ToolTypesPartialUpdateJSONRequestBody defines body for ToolTypesPartialUpdate for application/json ContentType.
type ToolTypesPartialUpdateJSONRequestBody ToolTypesPartialUpdateJSONBody

// ToolTypesUpdateJSONRequestBody defines body for ToolTypesUpdate for application/json ContentType.
type ToolTypesUpdateJSONRequestBody ToolTypesUpdateJSONBody

// UserContactInfosCreateJSONRequestBody defines body for UserContactInfosCreate for application/json ContentType.
type UserContactInfosCreateJSONRequestBody UserContactInfosCreateJSONBody

// UserContactInfosPartialUpdateJSONRequestBody defines body for UserContactInfosPartialUpdate for application/json ContentType.
type UserContactInfosPartialUpdateJSONRequestBody UserContactInfosPartialUpdateJSONBody

// UserContactInfosUpdateJSONRequestBody defines body for UserContactInfosUpdate for application/json ContentType.
type UserContactInfosUpdateJSONRequestBody UserContactInfosUpdateJSONBody

// UsersCreateJSONRequestBody defines body for UsersCreate for application/json ContentType.
type UsersCreateJSONRequestBody UsersCreateJSONBody

// UsersPartialUpdateJSONRequestBody defines body for UsersPartialUpdate for application/json ContentType.
type UsersPartialUpdateJSONRequestBody UsersPartialUpdateJSONBody

// UsersUpdateJSONRequestBody defines body for UsersUpdate for application/json ContentType.
type UsersUpdateJSONRequestBody UsersUpdateJSONBody

// Getter for additional properties for DojoGroup_Prefetch_ProductGroups. Returns the specified
// element and whether it was found
func (a DojoGroup_Prefetch_ProductGroups) Get(fieldName string) (value Product, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DojoGroup_Prefetch_ProductGroups
func (a *DojoGroup_Prefetch_ProductGroups) Set(fieldName string, value Product) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Product)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DojoGroup_Prefetch_ProductGroups to handle AdditionalProperties
func (a *DojoGroup_Prefetch_ProductGroups) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Product)
		for fieldName, fieldBuf := range object {
			var fieldVal Product
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DojoGroup_Prefetch_ProductGroups to handle AdditionalProperties
func (a DojoGroup_Prefetch_ProductGroups) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DojoGroup_Prefetch_ProductTypeGroups. Returns the specified
// element and whether it was found
func (a DojoGroup_Prefetch_ProductTypeGroups) Get(fieldName string) (value ProductType, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DojoGroup_Prefetch_ProductTypeGroups
func (a *DojoGroup_Prefetch_ProductTypeGroups) Set(fieldName string, value ProductType) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ProductType)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DojoGroup_Prefetch_ProductTypeGroups to handle AdditionalProperties
func (a *DojoGroup_Prefetch_ProductTypeGroups) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ProductType)
		for fieldName, fieldBuf := range object {
			var fieldVal ProductType
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DojoGroup_Prefetch_ProductTypeGroups to handle AdditionalProperties
func (a DojoGroup_Prefetch_ProductTypeGroups) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DojoGroup_Prefetch_Users. Returns the specified
// element and whether it was found
func (a DojoGroup_Prefetch_Users) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DojoGroup_Prefetch_Users
func (a *DojoGroup_Prefetch_Users) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DojoGroup_Prefetch_Users to handle AdditionalProperties
func (a *DojoGroup_Prefetch_Users) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DojoGroup_Prefetch_Users to handle AdditionalProperties
func (a DojoGroup_Prefetch_Users) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DojoGroupMember_Prefetch_Group. Returns the specified
// element and whether it was found
func (a DojoGroupMember_Prefetch_Group) Get(fieldName string) (value DojoGroup, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DojoGroupMember_Prefetch_Group
func (a *DojoGroupMember_Prefetch_Group) Set(fieldName string, value DojoGroup) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DojoGroup)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DojoGroupMember_Prefetch_Group to handle AdditionalProperties
func (a *DojoGroupMember_Prefetch_Group) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DojoGroup)
		for fieldName, fieldBuf := range object {
			var fieldVal DojoGroup
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DojoGroupMember_Prefetch_Group to handle AdditionalProperties
func (a DojoGroupMember_Prefetch_Group) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DojoGroupMember_Prefetch_Role. Returns the specified
// element and whether it was found
func (a DojoGroupMember_Prefetch_Role) Get(fieldName string) (value Role, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DojoGroupMember_Prefetch_Role
func (a *DojoGroupMember_Prefetch_Role) Set(fieldName string, value Role) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Role)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DojoGroupMember_Prefetch_Role to handle AdditionalProperties
func (a *DojoGroupMember_Prefetch_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Role)
		for fieldName, fieldBuf := range object {
			var fieldVal Role
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DojoGroupMember_Prefetch_Role to handle AdditionalProperties
func (a DojoGroupMember_Prefetch_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DojoGroupMember_Prefetch_User. Returns the specified
// element and whether it was found
func (a DojoGroupMember_Prefetch_User) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DojoGroupMember_Prefetch_User
func (a *DojoGroupMember_Prefetch_User) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DojoGroupMember_Prefetch_User to handle AdditionalProperties
func (a *DojoGroupMember_Prefetch_User) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DojoGroupMember_Prefetch_User to handle AdditionalProperties
func (a DojoGroupMember_Prefetch_User) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_DefectReviewRequestedBy. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_DefectReviewRequestedBy) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_DefectReviewRequestedBy
func (a *Finding_Prefetch_DefectReviewRequestedBy) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_DefectReviewRequestedBy to handle AdditionalProperties
func (a *Finding_Prefetch_DefectReviewRequestedBy) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_DefectReviewRequestedBy to handle AdditionalProperties
func (a Finding_Prefetch_DefectReviewRequestedBy) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_DuplicateFinding. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_DuplicateFinding) Get(fieldName string) (value Finding, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_DuplicateFinding
func (a *Finding_Prefetch_DuplicateFinding) Set(fieldName string, value Finding) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Finding)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_DuplicateFinding to handle AdditionalProperties
func (a *Finding_Prefetch_DuplicateFinding) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Finding)
		for fieldName, fieldBuf := range object {
			var fieldVal Finding
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_DuplicateFinding to handle AdditionalProperties
func (a Finding_Prefetch_DuplicateFinding) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_EndpointSet. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_EndpointSet) Get(fieldName string) (value Endpoint, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_EndpointSet
func (a *Finding_Prefetch_EndpointSet) Set(fieldName string, value Endpoint) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Endpoint)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_EndpointSet to handle AdditionalProperties
func (a *Finding_Prefetch_EndpointSet) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Endpoint)
		for fieldName, fieldBuf := range object {
			var fieldVal Endpoint
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_EndpointSet to handle AdditionalProperties
func (a Finding_Prefetch_EndpointSet) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_Endpoints. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_Endpoints) Get(fieldName string) (value Endpoint, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_Endpoints
func (a *Finding_Prefetch_Endpoints) Set(fieldName string, value Endpoint) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Endpoint)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_Endpoints to handle AdditionalProperties
func (a *Finding_Prefetch_Endpoints) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Endpoint)
		for fieldName, fieldBuf := range object {
			var fieldVal Endpoint
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_Endpoints to handle AdditionalProperties
func (a Finding_Prefetch_Endpoints) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_Files. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_Files) Get(fieldName string) (value File, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_Files
func (a *Finding_Prefetch_Files) Set(fieldName string, value File) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]File)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_Files to handle AdditionalProperties
func (a *Finding_Prefetch_Files) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]File)
		for fieldName, fieldBuf := range object {
			var fieldVal File
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_Files to handle AdditionalProperties
func (a Finding_Prefetch_Files) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_FindingGroupSet. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_FindingGroupSet) Get(fieldName string) (value FindingGroup, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_FindingGroupSet
func (a *Finding_Prefetch_FindingGroupSet) Set(fieldName string, value FindingGroup) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]FindingGroup)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_FindingGroupSet to handle AdditionalProperties
func (a *Finding_Prefetch_FindingGroupSet) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]FindingGroup)
		for fieldName, fieldBuf := range object {
			var fieldVal FindingGroup
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_FindingGroupSet to handle AdditionalProperties
func (a Finding_Prefetch_FindingGroupSet) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_FoundBy. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_FoundBy) Get(fieldName string) (value TestType, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_FoundBy
func (a *Finding_Prefetch_FoundBy) Set(fieldName string, value TestType) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]TestType)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_FoundBy to handle AdditionalProperties
func (a *Finding_Prefetch_FoundBy) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]TestType)
		for fieldName, fieldBuf := range object {
			var fieldVal TestType
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_FoundBy to handle AdditionalProperties
func (a Finding_Prefetch_FoundBy) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_LastReviewedBy. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_LastReviewedBy) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_LastReviewedBy
func (a *Finding_Prefetch_LastReviewedBy) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_LastReviewedBy to handle AdditionalProperties
func (a *Finding_Prefetch_LastReviewedBy) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_LastReviewedBy to handle AdditionalProperties
func (a Finding_Prefetch_LastReviewedBy) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_MitigatedBy. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_MitigatedBy) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_MitigatedBy
func (a *Finding_Prefetch_MitigatedBy) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_MitigatedBy to handle AdditionalProperties
func (a *Finding_Prefetch_MitigatedBy) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_MitigatedBy to handle AdditionalProperties
func (a Finding_Prefetch_MitigatedBy) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_Notes. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_Notes) Get(fieldName string) (value Note, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_Notes
func (a *Finding_Prefetch_Notes) Set(fieldName string, value Note) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Note)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_Notes to handle AdditionalProperties
func (a *Finding_Prefetch_Notes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Note)
		for fieldName, fieldBuf := range object {
			var fieldVal Note
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_Notes to handle AdditionalProperties
func (a Finding_Prefetch_Notes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_Reporter. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_Reporter) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_Reporter
func (a *Finding_Prefetch_Reporter) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_Reporter to handle AdditionalProperties
func (a *Finding_Prefetch_Reporter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_Reporter to handle AdditionalProperties
func (a Finding_Prefetch_Reporter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_ReviewRequestedBy. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_ReviewRequestedBy) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_ReviewRequestedBy
func (a *Finding_Prefetch_ReviewRequestedBy) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_ReviewRequestedBy to handle AdditionalProperties
func (a *Finding_Prefetch_ReviewRequestedBy) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_ReviewRequestedBy to handle AdditionalProperties
func (a Finding_Prefetch_ReviewRequestedBy) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_Reviewers. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_Reviewers) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_Reviewers
func (a *Finding_Prefetch_Reviewers) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_Reviewers to handle AdditionalProperties
func (a *Finding_Prefetch_Reviewers) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_Reviewers to handle AdditionalProperties
func (a Finding_Prefetch_Reviewers) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_RiskAcceptanceSet. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_RiskAcceptanceSet) Get(fieldName string) (value RiskAcceptance, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_RiskAcceptanceSet
func (a *Finding_Prefetch_RiskAcceptanceSet) Set(fieldName string, value RiskAcceptance) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]RiskAcceptance)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_RiskAcceptanceSet to handle AdditionalProperties
func (a *Finding_Prefetch_RiskAcceptanceSet) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]RiskAcceptance)
		for fieldName, fieldBuf := range object {
			var fieldVal RiskAcceptance
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_RiskAcceptanceSet to handle AdditionalProperties
func (a Finding_Prefetch_RiskAcceptanceSet) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_SonarqubeIssue. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_SonarqubeIssue) Get(fieldName string) (value SonarqubeIssue, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_SonarqubeIssue
func (a *Finding_Prefetch_SonarqubeIssue) Set(fieldName string, value SonarqubeIssue) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]SonarqubeIssue)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_SonarqubeIssue to handle AdditionalProperties
func (a *Finding_Prefetch_SonarqubeIssue) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]SonarqubeIssue)
		for fieldName, fieldBuf := range object {
			var fieldVal SonarqubeIssue
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_SonarqubeIssue to handle AdditionalProperties
func (a Finding_Prefetch_SonarqubeIssue) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_Test. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_Test) Get(fieldName string) (value Test, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_Test
func (a *Finding_Prefetch_Test) Set(fieldName string, value Test) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Test)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_Test to handle AdditionalProperties
func (a *Finding_Prefetch_Test) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Test)
		for fieldName, fieldBuf := range object {
			var fieldVal Test
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_Test to handle AdditionalProperties
func (a Finding_Prefetch_Test) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Finding_Prefetch_TestImportSet. Returns the specified
// element and whether it was found
func (a Finding_Prefetch_TestImportSet) Get(fieldName string) (value TestImport, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Finding_Prefetch_TestImportSet
func (a *Finding_Prefetch_TestImportSet) Set(fieldName string, value TestImport) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]TestImport)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Finding_Prefetch_TestImportSet to handle AdditionalProperties
func (a *Finding_Prefetch_TestImportSet) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]TestImport)
		for fieldName, fieldBuf := range object {
			var fieldVal TestImport
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Finding_Prefetch_TestImportSet to handle AdditionalProperties
func (a Finding_Prefetch_TestImportSet) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JIRAProject_CustomFields. Returns the specified
// element and whether it was found
func (a JIRAProject_CustomFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JIRAProject_CustomFields
func (a *JIRAProject_CustomFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JIRAProject_CustomFields to handle AdditionalProperties
func (a *JIRAProject_CustomFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JIRAProject_CustomFields to handle AdditionalProperties
func (a JIRAProject_CustomFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JIRAProjectRequest_CustomFields. Returns the specified
// element and whether it was found
func (a JIRAProjectRequest_CustomFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JIRAProjectRequest_CustomFields
func (a *JIRAProjectRequest_CustomFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JIRAProjectRequest_CustomFields to handle AdditionalProperties
func (a *JIRAProjectRequest_CustomFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JIRAProjectRequest_CustomFields to handle AdditionalProperties
func (a JIRAProjectRequest_CustomFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Language_Prefetch_Language. Returns the specified
// element and whether it was found
func (a Language_Prefetch_Language) Get(fieldName string) (value LanguageType, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Language_Prefetch_Language
func (a *Language_Prefetch_Language) Set(fieldName string, value LanguageType) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]LanguageType)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Language_Prefetch_Language to handle AdditionalProperties
func (a *Language_Prefetch_Language) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]LanguageType)
		for fieldName, fieldBuf := range object {
			var fieldVal LanguageType
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Language_Prefetch_Language to handle AdditionalProperties
func (a Language_Prefetch_Language) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Language_Prefetch_Product. Returns the specified
// element and whether it was found
func (a Language_Prefetch_Product) Get(fieldName string) (value Product, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Language_Prefetch_Product
func (a *Language_Prefetch_Product) Set(fieldName string, value Product) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Product)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Language_Prefetch_Product to handle AdditionalProperties
func (a *Language_Prefetch_Product) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Product)
		for fieldName, fieldBuf := range object {
			var fieldVal Product
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Language_Prefetch_Product to handle AdditionalProperties
func (a Language_Prefetch_Product) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Language_Prefetch_User. Returns the specified
// element and whether it was found
func (a Language_Prefetch_User) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Language_Prefetch_User
func (a *Language_Prefetch_User) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Language_Prefetch_User to handle AdditionalProperties
func (a *Language_Prefetch_User) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Language_Prefetch_User to handle AdditionalProperties
func (a Language_Prefetch_User) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Meta_Prefetch_Endpoint. Returns the specified
// element and whether it was found
func (a Meta_Prefetch_Endpoint) Get(fieldName string) (value Endpoint, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Meta_Prefetch_Endpoint
func (a *Meta_Prefetch_Endpoint) Set(fieldName string, value Endpoint) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Endpoint)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Meta_Prefetch_Endpoint to handle AdditionalProperties
func (a *Meta_Prefetch_Endpoint) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Endpoint)
		for fieldName, fieldBuf := range object {
			var fieldVal Endpoint
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Meta_Prefetch_Endpoint to handle AdditionalProperties
func (a Meta_Prefetch_Endpoint) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Meta_Prefetch_Finding. Returns the specified
// element and whether it was found
func (a Meta_Prefetch_Finding) Get(fieldName string) (value Finding, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Meta_Prefetch_Finding
func (a *Meta_Prefetch_Finding) Set(fieldName string, value Finding) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Finding)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Meta_Prefetch_Finding to handle AdditionalProperties
func (a *Meta_Prefetch_Finding) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Finding)
		for fieldName, fieldBuf := range object {
			var fieldVal Finding
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Meta_Prefetch_Finding to handle AdditionalProperties
func (a Meta_Prefetch_Finding) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Meta_Prefetch_Product. Returns the specified
// element and whether it was found
func (a Meta_Prefetch_Product) Get(fieldName string) (value Product, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Meta_Prefetch_Product
func (a *Meta_Prefetch_Product) Set(fieldName string, value Product) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Product)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Meta_Prefetch_Product to handle AdditionalProperties
func (a *Meta_Prefetch_Product) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Product)
		for fieldName, fieldBuf := range object {
			var fieldVal Product
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Meta_Prefetch_Product to handle AdditionalProperties
func (a Meta_Prefetch_Product) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Notifications_Prefetch_Product. Returns the specified
// element and whether it was found
func (a Notifications_Prefetch_Product) Get(fieldName string) (value Product, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Notifications_Prefetch_Product
func (a *Notifications_Prefetch_Product) Set(fieldName string, value Product) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Product)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Notifications_Prefetch_Product to handle AdditionalProperties
func (a *Notifications_Prefetch_Product) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Product)
		for fieldName, fieldBuf := range object {
			var fieldVal Product
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Notifications_Prefetch_Product to handle AdditionalProperties
func (a Notifications_Prefetch_Product) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Notifications_Prefetch_User. Returns the specified
// element and whether it was found
func (a Notifications_Prefetch_User) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Notifications_Prefetch_User
func (a *Notifications_Prefetch_User) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Notifications_Prefetch_User to handle AdditionalProperties
func (a *Notifications_Prefetch_User) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Notifications_Prefetch_User to handle AdditionalProperties
func (a Notifications_Prefetch_User) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedDojoGroupList_Prefetch_ProductGroups. Returns the specified
// element and whether it was found
func (a PaginatedDojoGroupList_Prefetch_ProductGroups) Get(fieldName string) (value Product, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedDojoGroupList_Prefetch_ProductGroups
func (a *PaginatedDojoGroupList_Prefetch_ProductGroups) Set(fieldName string, value Product) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Product)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedDojoGroupList_Prefetch_ProductGroups to handle AdditionalProperties
func (a *PaginatedDojoGroupList_Prefetch_ProductGroups) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Product)
		for fieldName, fieldBuf := range object {
			var fieldVal Product
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedDojoGroupList_Prefetch_ProductGroups to handle AdditionalProperties
func (a PaginatedDojoGroupList_Prefetch_ProductGroups) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedDojoGroupList_Prefetch_ProductTypeGroups. Returns the specified
// element and whether it was found
func (a PaginatedDojoGroupList_Prefetch_ProductTypeGroups) Get(fieldName string) (value ProductType, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedDojoGroupList_Prefetch_ProductTypeGroups
func (a *PaginatedDojoGroupList_Prefetch_ProductTypeGroups) Set(fieldName string, value ProductType) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ProductType)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedDojoGroupList_Prefetch_ProductTypeGroups to handle AdditionalProperties
func (a *PaginatedDojoGroupList_Prefetch_ProductTypeGroups) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ProductType)
		for fieldName, fieldBuf := range object {
			var fieldVal ProductType
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedDojoGroupList_Prefetch_ProductTypeGroups to handle AdditionalProperties
func (a PaginatedDojoGroupList_Prefetch_ProductTypeGroups) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedDojoGroupList_Prefetch_Users. Returns the specified
// element and whether it was found
func (a PaginatedDojoGroupList_Prefetch_Users) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedDojoGroupList_Prefetch_Users
func (a *PaginatedDojoGroupList_Prefetch_Users) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedDojoGroupList_Prefetch_Users to handle AdditionalProperties
func (a *PaginatedDojoGroupList_Prefetch_Users) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedDojoGroupList_Prefetch_Users to handle AdditionalProperties
func (a PaginatedDojoGroupList_Prefetch_Users) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedDojoGroupMemberList_Prefetch_Group. Returns the specified
// element and whether it was found
func (a PaginatedDojoGroupMemberList_Prefetch_Group) Get(fieldName string) (value DojoGroup, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedDojoGroupMemberList_Prefetch_Group
func (a *PaginatedDojoGroupMemberList_Prefetch_Group) Set(fieldName string, value DojoGroup) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DojoGroup)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedDojoGroupMemberList_Prefetch_Group to handle AdditionalProperties
func (a *PaginatedDojoGroupMemberList_Prefetch_Group) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DojoGroup)
		for fieldName, fieldBuf := range object {
			var fieldVal DojoGroup
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedDojoGroupMemberList_Prefetch_Group to handle AdditionalProperties
func (a PaginatedDojoGroupMemberList_Prefetch_Group) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedDojoGroupMemberList_Prefetch_Role. Returns the specified
// element and whether it was found
func (a PaginatedDojoGroupMemberList_Prefetch_Role) Get(fieldName string) (value Role, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedDojoGroupMemberList_Prefetch_Role
func (a *PaginatedDojoGroupMemberList_Prefetch_Role) Set(fieldName string, value Role) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Role)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedDojoGroupMemberList_Prefetch_Role to handle AdditionalProperties
func (a *PaginatedDojoGroupMemberList_Prefetch_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Role)
		for fieldName, fieldBuf := range object {
			var fieldVal Role
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedDojoGroupMemberList_Prefetch_Role to handle AdditionalProperties
func (a PaginatedDojoGroupMemberList_Prefetch_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedDojoGroupMemberList_Prefetch_User. Returns the specified
// element and whether it was found
func (a PaginatedDojoGroupMemberList_Prefetch_User) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedDojoGroupMemberList_Prefetch_User
func (a *PaginatedDojoGroupMemberList_Prefetch_User) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedDojoGroupMemberList_Prefetch_User to handle AdditionalProperties
func (a *PaginatedDojoGroupMemberList_Prefetch_User) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedDojoGroupMemberList_Prefetch_User to handle AdditionalProperties
func (a PaginatedDojoGroupMemberList_Prefetch_User) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_DefectReviewRequestedBy. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_DefectReviewRequestedBy) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_DefectReviewRequestedBy
func (a *PaginatedFindingList_Prefetch_DefectReviewRequestedBy) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_DefectReviewRequestedBy to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_DefectReviewRequestedBy) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_DefectReviewRequestedBy to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_DefectReviewRequestedBy) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_DuplicateFinding. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_DuplicateFinding) Get(fieldName string) (value Finding, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_DuplicateFinding
func (a *PaginatedFindingList_Prefetch_DuplicateFinding) Set(fieldName string, value Finding) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Finding)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_DuplicateFinding to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_DuplicateFinding) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Finding)
		for fieldName, fieldBuf := range object {
			var fieldVal Finding
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_DuplicateFinding to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_DuplicateFinding) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_EndpointSet. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_EndpointSet) Get(fieldName string) (value Endpoint, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_EndpointSet
func (a *PaginatedFindingList_Prefetch_EndpointSet) Set(fieldName string, value Endpoint) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Endpoint)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_EndpointSet to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_EndpointSet) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Endpoint)
		for fieldName, fieldBuf := range object {
			var fieldVal Endpoint
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_EndpointSet to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_EndpointSet) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_Endpoints. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_Endpoints) Get(fieldName string) (value Endpoint, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_Endpoints
func (a *PaginatedFindingList_Prefetch_Endpoints) Set(fieldName string, value Endpoint) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Endpoint)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_Endpoints to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_Endpoints) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Endpoint)
		for fieldName, fieldBuf := range object {
			var fieldVal Endpoint
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_Endpoints to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_Endpoints) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_Files. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_Files) Get(fieldName string) (value File, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_Files
func (a *PaginatedFindingList_Prefetch_Files) Set(fieldName string, value File) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]File)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_Files to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_Files) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]File)
		for fieldName, fieldBuf := range object {
			var fieldVal File
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_Files to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_Files) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_FindingGroupSet. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_FindingGroupSet) Get(fieldName string) (value FindingGroup, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_FindingGroupSet
func (a *PaginatedFindingList_Prefetch_FindingGroupSet) Set(fieldName string, value FindingGroup) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]FindingGroup)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_FindingGroupSet to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_FindingGroupSet) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]FindingGroup)
		for fieldName, fieldBuf := range object {
			var fieldVal FindingGroup
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_FindingGroupSet to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_FindingGroupSet) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_FoundBy. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_FoundBy) Get(fieldName string) (value TestType, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_FoundBy
func (a *PaginatedFindingList_Prefetch_FoundBy) Set(fieldName string, value TestType) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]TestType)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_FoundBy to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_FoundBy) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]TestType)
		for fieldName, fieldBuf := range object {
			var fieldVal TestType
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_FoundBy to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_FoundBy) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_LastReviewedBy. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_LastReviewedBy) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_LastReviewedBy
func (a *PaginatedFindingList_Prefetch_LastReviewedBy) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_LastReviewedBy to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_LastReviewedBy) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_LastReviewedBy to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_LastReviewedBy) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_MitigatedBy. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_MitigatedBy) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_MitigatedBy
func (a *PaginatedFindingList_Prefetch_MitigatedBy) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_MitigatedBy to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_MitigatedBy) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_MitigatedBy to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_MitigatedBy) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_Notes. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_Notes) Get(fieldName string) (value Note, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_Notes
func (a *PaginatedFindingList_Prefetch_Notes) Set(fieldName string, value Note) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Note)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_Notes to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_Notes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Note)
		for fieldName, fieldBuf := range object {
			var fieldVal Note
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_Notes to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_Notes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_Reporter. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_Reporter) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_Reporter
func (a *PaginatedFindingList_Prefetch_Reporter) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_Reporter to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_Reporter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_Reporter to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_Reporter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_ReviewRequestedBy. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_ReviewRequestedBy) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_ReviewRequestedBy
func (a *PaginatedFindingList_Prefetch_ReviewRequestedBy) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_ReviewRequestedBy to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_ReviewRequestedBy) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_ReviewRequestedBy to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_ReviewRequestedBy) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_Reviewers. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_Reviewers) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_Reviewers
func (a *PaginatedFindingList_Prefetch_Reviewers) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_Reviewers to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_Reviewers) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_Reviewers to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_Reviewers) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_RiskAcceptanceSet. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_RiskAcceptanceSet) Get(fieldName string) (value RiskAcceptance, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_RiskAcceptanceSet
func (a *PaginatedFindingList_Prefetch_RiskAcceptanceSet) Set(fieldName string, value RiskAcceptance) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]RiskAcceptance)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_RiskAcceptanceSet to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_RiskAcceptanceSet) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]RiskAcceptance)
		for fieldName, fieldBuf := range object {
			var fieldVal RiskAcceptance
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_RiskAcceptanceSet to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_RiskAcceptanceSet) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_SonarqubeIssue. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_SonarqubeIssue) Get(fieldName string) (value SonarqubeIssue, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_SonarqubeIssue
func (a *PaginatedFindingList_Prefetch_SonarqubeIssue) Set(fieldName string, value SonarqubeIssue) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]SonarqubeIssue)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_SonarqubeIssue to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_SonarqubeIssue) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]SonarqubeIssue)
		for fieldName, fieldBuf := range object {
			var fieldVal SonarqubeIssue
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_SonarqubeIssue to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_SonarqubeIssue) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_Test. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_Test) Get(fieldName string) (value Test, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_Test
func (a *PaginatedFindingList_Prefetch_Test) Set(fieldName string, value Test) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Test)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_Test to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_Test) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Test)
		for fieldName, fieldBuf := range object {
			var fieldVal Test
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_Test to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_Test) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedFindingList_Prefetch_TestImportSet. Returns the specified
// element and whether it was found
func (a PaginatedFindingList_Prefetch_TestImportSet) Get(fieldName string) (value TestImport, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedFindingList_Prefetch_TestImportSet
func (a *PaginatedFindingList_Prefetch_TestImportSet) Set(fieldName string, value TestImport) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]TestImport)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedFindingList_Prefetch_TestImportSet to handle AdditionalProperties
func (a *PaginatedFindingList_Prefetch_TestImportSet) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]TestImport)
		for fieldName, fieldBuf := range object {
			var fieldVal TestImport
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedFindingList_Prefetch_TestImportSet to handle AdditionalProperties
func (a PaginatedFindingList_Prefetch_TestImportSet) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedLanguageList_Prefetch_Language. Returns the specified
// element and whether it was found
func (a PaginatedLanguageList_Prefetch_Language) Get(fieldName string) (value LanguageType, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedLanguageList_Prefetch_Language
func (a *PaginatedLanguageList_Prefetch_Language) Set(fieldName string, value LanguageType) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]LanguageType)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedLanguageList_Prefetch_Language to handle AdditionalProperties
func (a *PaginatedLanguageList_Prefetch_Language) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]LanguageType)
		for fieldName, fieldBuf := range object {
			var fieldVal LanguageType
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedLanguageList_Prefetch_Language to handle AdditionalProperties
func (a PaginatedLanguageList_Prefetch_Language) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedLanguageList_Prefetch_Product. Returns the specified
// element and whether it was found
func (a PaginatedLanguageList_Prefetch_Product) Get(fieldName string) (value Product, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedLanguageList_Prefetch_Product
func (a *PaginatedLanguageList_Prefetch_Product) Set(fieldName string, value Product) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Product)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedLanguageList_Prefetch_Product to handle AdditionalProperties
func (a *PaginatedLanguageList_Prefetch_Product) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Product)
		for fieldName, fieldBuf := range object {
			var fieldVal Product
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedLanguageList_Prefetch_Product to handle AdditionalProperties
func (a PaginatedLanguageList_Prefetch_Product) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedLanguageList_Prefetch_User. Returns the specified
// element and whether it was found
func (a PaginatedLanguageList_Prefetch_User) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedLanguageList_Prefetch_User
func (a *PaginatedLanguageList_Prefetch_User) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedLanguageList_Prefetch_User to handle AdditionalProperties
func (a *PaginatedLanguageList_Prefetch_User) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedLanguageList_Prefetch_User to handle AdditionalProperties
func (a PaginatedLanguageList_Prefetch_User) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedMetaList_Prefetch_Endpoint. Returns the specified
// element and whether it was found
func (a PaginatedMetaList_Prefetch_Endpoint) Get(fieldName string) (value Endpoint, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedMetaList_Prefetch_Endpoint
func (a *PaginatedMetaList_Prefetch_Endpoint) Set(fieldName string, value Endpoint) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Endpoint)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedMetaList_Prefetch_Endpoint to handle AdditionalProperties
func (a *PaginatedMetaList_Prefetch_Endpoint) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Endpoint)
		for fieldName, fieldBuf := range object {
			var fieldVal Endpoint
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedMetaList_Prefetch_Endpoint to handle AdditionalProperties
func (a PaginatedMetaList_Prefetch_Endpoint) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedMetaList_Prefetch_Finding. Returns the specified
// element and whether it was found
func (a PaginatedMetaList_Prefetch_Finding) Get(fieldName string) (value Finding, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedMetaList_Prefetch_Finding
func (a *PaginatedMetaList_Prefetch_Finding) Set(fieldName string, value Finding) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Finding)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedMetaList_Prefetch_Finding to handle AdditionalProperties
func (a *PaginatedMetaList_Prefetch_Finding) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Finding)
		for fieldName, fieldBuf := range object {
			var fieldVal Finding
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedMetaList_Prefetch_Finding to handle AdditionalProperties
func (a PaginatedMetaList_Prefetch_Finding) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedMetaList_Prefetch_Product. Returns the specified
// element and whether it was found
func (a PaginatedMetaList_Prefetch_Product) Get(fieldName string) (value Product, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedMetaList_Prefetch_Product
func (a *PaginatedMetaList_Prefetch_Product) Set(fieldName string, value Product) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Product)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedMetaList_Prefetch_Product to handle AdditionalProperties
func (a *PaginatedMetaList_Prefetch_Product) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Product)
		for fieldName, fieldBuf := range object {
			var fieldVal Product
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedMetaList_Prefetch_Product to handle AdditionalProperties
func (a PaginatedMetaList_Prefetch_Product) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedNotificationsList_Prefetch_Product. Returns the specified
// element and whether it was found
func (a PaginatedNotificationsList_Prefetch_Product) Get(fieldName string) (value Product, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedNotificationsList_Prefetch_Product
func (a *PaginatedNotificationsList_Prefetch_Product) Set(fieldName string, value Product) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Product)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedNotificationsList_Prefetch_Product to handle AdditionalProperties
func (a *PaginatedNotificationsList_Prefetch_Product) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Product)
		for fieldName, fieldBuf := range object {
			var fieldVal Product
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedNotificationsList_Prefetch_Product to handle AdditionalProperties
func (a PaginatedNotificationsList_Prefetch_Product) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedNotificationsList_Prefetch_User. Returns the specified
// element and whether it was found
func (a PaginatedNotificationsList_Prefetch_User) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedNotificationsList_Prefetch_User
func (a *PaginatedNotificationsList_Prefetch_User) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedNotificationsList_Prefetch_User to handle AdditionalProperties
func (a *PaginatedNotificationsList_Prefetch_User) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedNotificationsList_Prefetch_User to handle AdditionalProperties
func (a PaginatedNotificationsList_Prefetch_User) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductGroupList_Prefetch_Group. Returns the specified
// element and whether it was found
func (a PaginatedProductGroupList_Prefetch_Group) Get(fieldName string) (value DojoGroup, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductGroupList_Prefetch_Group
func (a *PaginatedProductGroupList_Prefetch_Group) Set(fieldName string, value DojoGroup) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DojoGroup)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductGroupList_Prefetch_Group to handle AdditionalProperties
func (a *PaginatedProductGroupList_Prefetch_Group) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DojoGroup)
		for fieldName, fieldBuf := range object {
			var fieldVal DojoGroup
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductGroupList_Prefetch_Group to handle AdditionalProperties
func (a PaginatedProductGroupList_Prefetch_Group) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductGroupList_Prefetch_Product. Returns the specified
// element and whether it was found
func (a PaginatedProductGroupList_Prefetch_Product) Get(fieldName string) (value Product, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductGroupList_Prefetch_Product
func (a *PaginatedProductGroupList_Prefetch_Product) Set(fieldName string, value Product) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Product)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductGroupList_Prefetch_Product to handle AdditionalProperties
func (a *PaginatedProductGroupList_Prefetch_Product) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Product)
		for fieldName, fieldBuf := range object {
			var fieldVal Product
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductGroupList_Prefetch_Product to handle AdditionalProperties
func (a PaginatedProductGroupList_Prefetch_Product) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductGroupList_Prefetch_Role. Returns the specified
// element and whether it was found
func (a PaginatedProductGroupList_Prefetch_Role) Get(fieldName string) (value Role, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductGroupList_Prefetch_Role
func (a *PaginatedProductGroupList_Prefetch_Role) Set(fieldName string, value Role) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Role)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductGroupList_Prefetch_Role to handle AdditionalProperties
func (a *PaginatedProductGroupList_Prefetch_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Role)
		for fieldName, fieldBuf := range object {
			var fieldVal Role
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductGroupList_Prefetch_Role to handle AdditionalProperties
func (a PaginatedProductGroupList_Prefetch_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductList_Prefetch_AuthorizationGroups. Returns the specified
// element and whether it was found
func (a PaginatedProductList_Prefetch_AuthorizationGroups) Get(fieldName string) (value DojoGroup, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductList_Prefetch_AuthorizationGroups
func (a *PaginatedProductList_Prefetch_AuthorizationGroups) Set(fieldName string, value DojoGroup) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DojoGroup)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductList_Prefetch_AuthorizationGroups to handle AdditionalProperties
func (a *PaginatedProductList_Prefetch_AuthorizationGroups) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DojoGroup)
		for fieldName, fieldBuf := range object {
			var fieldVal DojoGroup
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductList_Prefetch_AuthorizationGroups to handle AdditionalProperties
func (a PaginatedProductList_Prefetch_AuthorizationGroups) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductList_Prefetch_Members. Returns the specified
// element and whether it was found
func (a PaginatedProductList_Prefetch_Members) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductList_Prefetch_Members
func (a *PaginatedProductList_Prefetch_Members) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductList_Prefetch_Members to handle AdditionalProperties
func (a *PaginatedProductList_Prefetch_Members) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductList_Prefetch_Members to handle AdditionalProperties
func (a PaginatedProductList_Prefetch_Members) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductList_Prefetch_ProdType. Returns the specified
// element and whether it was found
func (a PaginatedProductList_Prefetch_ProdType) Get(fieldName string) (value ProductType, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductList_Prefetch_ProdType
func (a *PaginatedProductList_Prefetch_ProdType) Set(fieldName string, value ProductType) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ProductType)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductList_Prefetch_ProdType to handle AdditionalProperties
func (a *PaginatedProductList_Prefetch_ProdType) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ProductType)
		for fieldName, fieldBuf := range object {
			var fieldVal ProductType
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductList_Prefetch_ProdType to handle AdditionalProperties
func (a PaginatedProductList_Prefetch_ProdType) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductList_Prefetch_ProductManager. Returns the specified
// element and whether it was found
func (a PaginatedProductList_Prefetch_ProductManager) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductList_Prefetch_ProductManager
func (a *PaginatedProductList_Prefetch_ProductManager) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductList_Prefetch_ProductManager to handle AdditionalProperties
func (a *PaginatedProductList_Prefetch_ProductManager) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductList_Prefetch_ProductManager to handle AdditionalProperties
func (a PaginatedProductList_Prefetch_ProductManager) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductList_Prefetch_Regulations. Returns the specified
// element and whether it was found
func (a PaginatedProductList_Prefetch_Regulations) Get(fieldName string) (value Regulation, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductList_Prefetch_Regulations
func (a *PaginatedProductList_Prefetch_Regulations) Set(fieldName string, value Regulation) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Regulation)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductList_Prefetch_Regulations to handle AdditionalProperties
func (a *PaginatedProductList_Prefetch_Regulations) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Regulation)
		for fieldName, fieldBuf := range object {
			var fieldVal Regulation
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductList_Prefetch_Regulations to handle AdditionalProperties
func (a PaginatedProductList_Prefetch_Regulations) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductList_Prefetch_SlaConfiguration. Returns the specified
// element and whether it was found
func (a PaginatedProductList_Prefetch_SlaConfiguration) Get(fieldName string) (value SLAConfiguration, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductList_Prefetch_SlaConfiguration
func (a *PaginatedProductList_Prefetch_SlaConfiguration) Set(fieldName string, value SLAConfiguration) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]SLAConfiguration)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductList_Prefetch_SlaConfiguration to handle AdditionalProperties
func (a *PaginatedProductList_Prefetch_SlaConfiguration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]SLAConfiguration)
		for fieldName, fieldBuf := range object {
			var fieldVal SLAConfiguration
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductList_Prefetch_SlaConfiguration to handle AdditionalProperties
func (a PaginatedProductList_Prefetch_SlaConfiguration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductList_Prefetch_TeamManager. Returns the specified
// element and whether it was found
func (a PaginatedProductList_Prefetch_TeamManager) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductList_Prefetch_TeamManager
func (a *PaginatedProductList_Prefetch_TeamManager) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductList_Prefetch_TeamManager to handle AdditionalProperties
func (a *PaginatedProductList_Prefetch_TeamManager) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductList_Prefetch_TeamManager to handle AdditionalProperties
func (a PaginatedProductList_Prefetch_TeamManager) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductList_Prefetch_TechnicalContact. Returns the specified
// element and whether it was found
func (a PaginatedProductList_Prefetch_TechnicalContact) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductList_Prefetch_TechnicalContact
func (a *PaginatedProductList_Prefetch_TechnicalContact) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductList_Prefetch_TechnicalContact to handle AdditionalProperties
func (a *PaginatedProductList_Prefetch_TechnicalContact) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductList_Prefetch_TechnicalContact to handle AdditionalProperties
func (a PaginatedProductList_Prefetch_TechnicalContact) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductMemberList_Prefetch_Product. Returns the specified
// element and whether it was found
func (a PaginatedProductMemberList_Prefetch_Product) Get(fieldName string) (value Product, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductMemberList_Prefetch_Product
func (a *PaginatedProductMemberList_Prefetch_Product) Set(fieldName string, value Product) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Product)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductMemberList_Prefetch_Product to handle AdditionalProperties
func (a *PaginatedProductMemberList_Prefetch_Product) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Product)
		for fieldName, fieldBuf := range object {
			var fieldVal Product
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductMemberList_Prefetch_Product to handle AdditionalProperties
func (a PaginatedProductMemberList_Prefetch_Product) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductMemberList_Prefetch_Role. Returns the specified
// element and whether it was found
func (a PaginatedProductMemberList_Prefetch_Role) Get(fieldName string) (value Role, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductMemberList_Prefetch_Role
func (a *PaginatedProductMemberList_Prefetch_Role) Set(fieldName string, value Role) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Role)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductMemberList_Prefetch_Role to handle AdditionalProperties
func (a *PaginatedProductMemberList_Prefetch_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Role)
		for fieldName, fieldBuf := range object {
			var fieldVal Role
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductMemberList_Prefetch_Role to handle AdditionalProperties
func (a PaginatedProductMemberList_Prefetch_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductMemberList_Prefetch_User. Returns the specified
// element and whether it was found
func (a PaginatedProductMemberList_Prefetch_User) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductMemberList_Prefetch_User
func (a *PaginatedProductMemberList_Prefetch_User) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductMemberList_Prefetch_User to handle AdditionalProperties
func (a *PaginatedProductMemberList_Prefetch_User) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductMemberList_Prefetch_User to handle AdditionalProperties
func (a PaginatedProductMemberList_Prefetch_User) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductTypeGroupList_Prefetch_Group. Returns the specified
// element and whether it was found
func (a PaginatedProductTypeGroupList_Prefetch_Group) Get(fieldName string) (value DojoGroup, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductTypeGroupList_Prefetch_Group
func (a *PaginatedProductTypeGroupList_Prefetch_Group) Set(fieldName string, value DojoGroup) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DojoGroup)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductTypeGroupList_Prefetch_Group to handle AdditionalProperties
func (a *PaginatedProductTypeGroupList_Prefetch_Group) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DojoGroup)
		for fieldName, fieldBuf := range object {
			var fieldVal DojoGroup
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductTypeGroupList_Prefetch_Group to handle AdditionalProperties
func (a PaginatedProductTypeGroupList_Prefetch_Group) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductTypeGroupList_Prefetch_ProductType. Returns the specified
// element and whether it was found
func (a PaginatedProductTypeGroupList_Prefetch_ProductType) Get(fieldName string) (value ProductType, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductTypeGroupList_Prefetch_ProductType
func (a *PaginatedProductTypeGroupList_Prefetch_ProductType) Set(fieldName string, value ProductType) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ProductType)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductTypeGroupList_Prefetch_ProductType to handle AdditionalProperties
func (a *PaginatedProductTypeGroupList_Prefetch_ProductType) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ProductType)
		for fieldName, fieldBuf := range object {
			var fieldVal ProductType
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductTypeGroupList_Prefetch_ProductType to handle AdditionalProperties
func (a PaginatedProductTypeGroupList_Prefetch_ProductType) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductTypeGroupList_Prefetch_Role. Returns the specified
// element and whether it was found
func (a PaginatedProductTypeGroupList_Prefetch_Role) Get(fieldName string) (value Role, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductTypeGroupList_Prefetch_Role
func (a *PaginatedProductTypeGroupList_Prefetch_Role) Set(fieldName string, value Role) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Role)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductTypeGroupList_Prefetch_Role to handle AdditionalProperties
func (a *PaginatedProductTypeGroupList_Prefetch_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Role)
		for fieldName, fieldBuf := range object {
			var fieldVal Role
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductTypeGroupList_Prefetch_Role to handle AdditionalProperties
func (a PaginatedProductTypeGroupList_Prefetch_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductTypeList_Prefetch_AuthorizationGroups. Returns the specified
// element and whether it was found
func (a PaginatedProductTypeList_Prefetch_AuthorizationGroups) Get(fieldName string) (value DojoGroup, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductTypeList_Prefetch_AuthorizationGroups
func (a *PaginatedProductTypeList_Prefetch_AuthorizationGroups) Set(fieldName string, value DojoGroup) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DojoGroup)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductTypeList_Prefetch_AuthorizationGroups to handle AdditionalProperties
func (a *PaginatedProductTypeList_Prefetch_AuthorizationGroups) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DojoGroup)
		for fieldName, fieldBuf := range object {
			var fieldVal DojoGroup
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductTypeList_Prefetch_AuthorizationGroups to handle AdditionalProperties
func (a PaginatedProductTypeList_Prefetch_AuthorizationGroups) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductTypeList_Prefetch_Members. Returns the specified
// element and whether it was found
func (a PaginatedProductTypeList_Prefetch_Members) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductTypeList_Prefetch_Members
func (a *PaginatedProductTypeList_Prefetch_Members) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductTypeList_Prefetch_Members to handle AdditionalProperties
func (a *PaginatedProductTypeList_Prefetch_Members) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductTypeList_Prefetch_Members to handle AdditionalProperties
func (a PaginatedProductTypeList_Prefetch_Members) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductTypeMemberList_Prefetch_ProductType. Returns the specified
// element and whether it was found
func (a PaginatedProductTypeMemberList_Prefetch_ProductType) Get(fieldName string) (value ProductType, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductTypeMemberList_Prefetch_ProductType
func (a *PaginatedProductTypeMemberList_Prefetch_ProductType) Set(fieldName string, value ProductType) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ProductType)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductTypeMemberList_Prefetch_ProductType to handle AdditionalProperties
func (a *PaginatedProductTypeMemberList_Prefetch_ProductType) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ProductType)
		for fieldName, fieldBuf := range object {
			var fieldVal ProductType
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductTypeMemberList_Prefetch_ProductType to handle AdditionalProperties
func (a PaginatedProductTypeMemberList_Prefetch_ProductType) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductTypeMemberList_Prefetch_Role. Returns the specified
// element and whether it was found
func (a PaginatedProductTypeMemberList_Prefetch_Role) Get(fieldName string) (value Role, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductTypeMemberList_Prefetch_Role
func (a *PaginatedProductTypeMemberList_Prefetch_Role) Set(fieldName string, value Role) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Role)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductTypeMemberList_Prefetch_Role to handle AdditionalProperties
func (a *PaginatedProductTypeMemberList_Prefetch_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Role)
		for fieldName, fieldBuf := range object {
			var fieldVal Role
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductTypeMemberList_Prefetch_Role to handle AdditionalProperties
func (a PaginatedProductTypeMemberList_Prefetch_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedProductTypeMemberList_Prefetch_User. Returns the specified
// element and whether it was found
func (a PaginatedProductTypeMemberList_Prefetch_User) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedProductTypeMemberList_Prefetch_User
func (a *PaginatedProductTypeMemberList_Prefetch_User) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedProductTypeMemberList_Prefetch_User to handle AdditionalProperties
func (a *PaginatedProductTypeMemberList_Prefetch_User) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedProductTypeMemberList_Prefetch_User to handle AdditionalProperties
func (a PaginatedProductTypeMemberList_Prefetch_User) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedTestImportList_Prefetch_FindingsAffected. Returns the specified
// element and whether it was found
func (a PaginatedTestImportList_Prefetch_FindingsAffected) Get(fieldName string) (value Finding, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedTestImportList_Prefetch_FindingsAffected
func (a *PaginatedTestImportList_Prefetch_FindingsAffected) Set(fieldName string, value Finding) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Finding)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedTestImportList_Prefetch_FindingsAffected to handle AdditionalProperties
func (a *PaginatedTestImportList_Prefetch_FindingsAffected) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Finding)
		for fieldName, fieldBuf := range object {
			var fieldVal Finding
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedTestImportList_Prefetch_FindingsAffected to handle AdditionalProperties
func (a PaginatedTestImportList_Prefetch_FindingsAffected) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedTestImportList_Prefetch_Test. Returns the specified
// element and whether it was found
func (a PaginatedTestImportList_Prefetch_Test) Get(fieldName string) (value Test, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedTestImportList_Prefetch_Test
func (a *PaginatedTestImportList_Prefetch_Test) Set(fieldName string, value Test) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Test)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedTestImportList_Prefetch_Test to handle AdditionalProperties
func (a *PaginatedTestImportList_Prefetch_Test) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Test)
		for fieldName, fieldBuf := range object {
			var fieldVal Test
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedTestImportList_Prefetch_Test to handle AdditionalProperties
func (a PaginatedTestImportList_Prefetch_Test) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PaginatedUserContactInfoList_Prefetch_User. Returns the specified
// element and whether it was found
func (a PaginatedUserContactInfoList_Prefetch_User) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PaginatedUserContactInfoList_Prefetch_User
func (a *PaginatedUserContactInfoList_Prefetch_User) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PaginatedUserContactInfoList_Prefetch_User to handle AdditionalProperties
func (a *PaginatedUserContactInfoList_Prefetch_User) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PaginatedUserContactInfoList_Prefetch_User to handle AdditionalProperties
func (a PaginatedUserContactInfoList_Prefetch_User) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PatchedJIRAProjectRequest_CustomFields. Returns the specified
// element and whether it was found
func (a PatchedJIRAProjectRequest_CustomFields) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PatchedJIRAProjectRequest_CustomFields
func (a *PatchedJIRAProjectRequest_CustomFields) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PatchedJIRAProjectRequest_CustomFields to handle AdditionalProperties
func (a *PatchedJIRAProjectRequest_CustomFields) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PatchedJIRAProjectRequest_CustomFields to handle AdditionalProperties
func (a PatchedJIRAProjectRequest_CustomFields) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PatchedTestImportRequest_ImportSettings. Returns the specified
// element and whether it was found
func (a PatchedTestImportRequest_ImportSettings) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PatchedTestImportRequest_ImportSettings
func (a *PatchedTestImportRequest_ImportSettings) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PatchedTestImportRequest_ImportSettings to handle AdditionalProperties
func (a *PatchedTestImportRequest_ImportSettings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PatchedTestImportRequest_ImportSettings to handle AdditionalProperties
func (a PatchedTestImportRequest_ImportSettings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Product_Prefetch_AuthorizationGroups. Returns the specified
// element and whether it was found
func (a Product_Prefetch_AuthorizationGroups) Get(fieldName string) (value DojoGroup, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Product_Prefetch_AuthorizationGroups
func (a *Product_Prefetch_AuthorizationGroups) Set(fieldName string, value DojoGroup) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DojoGroup)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Product_Prefetch_AuthorizationGroups to handle AdditionalProperties
func (a *Product_Prefetch_AuthorizationGroups) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DojoGroup)
		for fieldName, fieldBuf := range object {
			var fieldVal DojoGroup
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Product_Prefetch_AuthorizationGroups to handle AdditionalProperties
func (a Product_Prefetch_AuthorizationGroups) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Product_Prefetch_Members. Returns the specified
// element and whether it was found
func (a Product_Prefetch_Members) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Product_Prefetch_Members
func (a *Product_Prefetch_Members) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Product_Prefetch_Members to handle AdditionalProperties
func (a *Product_Prefetch_Members) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Product_Prefetch_Members to handle AdditionalProperties
func (a Product_Prefetch_Members) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Product_Prefetch_ProdType. Returns the specified
// element and whether it was found
func (a Product_Prefetch_ProdType) Get(fieldName string) (value ProductType, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Product_Prefetch_ProdType
func (a *Product_Prefetch_ProdType) Set(fieldName string, value ProductType) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ProductType)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Product_Prefetch_ProdType to handle AdditionalProperties
func (a *Product_Prefetch_ProdType) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ProductType)
		for fieldName, fieldBuf := range object {
			var fieldVal ProductType
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Product_Prefetch_ProdType to handle AdditionalProperties
func (a Product_Prefetch_ProdType) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Product_Prefetch_ProductManager. Returns the specified
// element and whether it was found
func (a Product_Prefetch_ProductManager) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Product_Prefetch_ProductManager
func (a *Product_Prefetch_ProductManager) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Product_Prefetch_ProductManager to handle AdditionalProperties
func (a *Product_Prefetch_ProductManager) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Product_Prefetch_ProductManager to handle AdditionalProperties
func (a Product_Prefetch_ProductManager) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Product_Prefetch_Regulations. Returns the specified
// element and whether it was found
func (a Product_Prefetch_Regulations) Get(fieldName string) (value Regulation, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Product_Prefetch_Regulations
func (a *Product_Prefetch_Regulations) Set(fieldName string, value Regulation) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Regulation)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Product_Prefetch_Regulations to handle AdditionalProperties
func (a *Product_Prefetch_Regulations) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Regulation)
		for fieldName, fieldBuf := range object {
			var fieldVal Regulation
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Product_Prefetch_Regulations to handle AdditionalProperties
func (a Product_Prefetch_Regulations) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Product_Prefetch_SlaConfiguration. Returns the specified
// element and whether it was found
func (a Product_Prefetch_SlaConfiguration) Get(fieldName string) (value SLAConfiguration, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Product_Prefetch_SlaConfiguration
func (a *Product_Prefetch_SlaConfiguration) Set(fieldName string, value SLAConfiguration) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]SLAConfiguration)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Product_Prefetch_SlaConfiguration to handle AdditionalProperties
func (a *Product_Prefetch_SlaConfiguration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]SLAConfiguration)
		for fieldName, fieldBuf := range object {
			var fieldVal SLAConfiguration
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Product_Prefetch_SlaConfiguration to handle AdditionalProperties
func (a Product_Prefetch_SlaConfiguration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Product_Prefetch_TeamManager. Returns the specified
// element and whether it was found
func (a Product_Prefetch_TeamManager) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Product_Prefetch_TeamManager
func (a *Product_Prefetch_TeamManager) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Product_Prefetch_TeamManager to handle AdditionalProperties
func (a *Product_Prefetch_TeamManager) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Product_Prefetch_TeamManager to handle AdditionalProperties
func (a Product_Prefetch_TeamManager) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Product_Prefetch_TechnicalContact. Returns the specified
// element and whether it was found
func (a Product_Prefetch_TechnicalContact) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Product_Prefetch_TechnicalContact
func (a *Product_Prefetch_TechnicalContact) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Product_Prefetch_TechnicalContact to handle AdditionalProperties
func (a *Product_Prefetch_TechnicalContact) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Product_Prefetch_TechnicalContact to handle AdditionalProperties
func (a Product_Prefetch_TechnicalContact) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductGroup_Prefetch_Group. Returns the specified
// element and whether it was found
func (a ProductGroup_Prefetch_Group) Get(fieldName string) (value DojoGroup, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductGroup_Prefetch_Group
func (a *ProductGroup_Prefetch_Group) Set(fieldName string, value DojoGroup) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DojoGroup)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductGroup_Prefetch_Group to handle AdditionalProperties
func (a *ProductGroup_Prefetch_Group) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DojoGroup)
		for fieldName, fieldBuf := range object {
			var fieldVal DojoGroup
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductGroup_Prefetch_Group to handle AdditionalProperties
func (a ProductGroup_Prefetch_Group) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductGroup_Prefetch_Product. Returns the specified
// element and whether it was found
func (a ProductGroup_Prefetch_Product) Get(fieldName string) (value Product, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductGroup_Prefetch_Product
func (a *ProductGroup_Prefetch_Product) Set(fieldName string, value Product) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Product)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductGroup_Prefetch_Product to handle AdditionalProperties
func (a *ProductGroup_Prefetch_Product) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Product)
		for fieldName, fieldBuf := range object {
			var fieldVal Product
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductGroup_Prefetch_Product to handle AdditionalProperties
func (a ProductGroup_Prefetch_Product) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductGroup_Prefetch_Role. Returns the specified
// element and whether it was found
func (a ProductGroup_Prefetch_Role) Get(fieldName string) (value Role, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductGroup_Prefetch_Role
func (a *ProductGroup_Prefetch_Role) Set(fieldName string, value Role) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Role)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductGroup_Prefetch_Role to handle AdditionalProperties
func (a *ProductGroup_Prefetch_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Role)
		for fieldName, fieldBuf := range object {
			var fieldVal Role
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductGroup_Prefetch_Role to handle AdditionalProperties
func (a ProductGroup_Prefetch_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductMember_Prefetch_Product. Returns the specified
// element and whether it was found
func (a ProductMember_Prefetch_Product) Get(fieldName string) (value Product, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductMember_Prefetch_Product
func (a *ProductMember_Prefetch_Product) Set(fieldName string, value Product) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Product)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductMember_Prefetch_Product to handle AdditionalProperties
func (a *ProductMember_Prefetch_Product) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Product)
		for fieldName, fieldBuf := range object {
			var fieldVal Product
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductMember_Prefetch_Product to handle AdditionalProperties
func (a ProductMember_Prefetch_Product) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductMember_Prefetch_Role. Returns the specified
// element and whether it was found
func (a ProductMember_Prefetch_Role) Get(fieldName string) (value Role, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductMember_Prefetch_Role
func (a *ProductMember_Prefetch_Role) Set(fieldName string, value Role) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Role)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductMember_Prefetch_Role to handle AdditionalProperties
func (a *ProductMember_Prefetch_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Role)
		for fieldName, fieldBuf := range object {
			var fieldVal Role
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductMember_Prefetch_Role to handle AdditionalProperties
func (a ProductMember_Prefetch_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductMember_Prefetch_User. Returns the specified
// element and whether it was found
func (a ProductMember_Prefetch_User) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductMember_Prefetch_User
func (a *ProductMember_Prefetch_User) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductMember_Prefetch_User to handle AdditionalProperties
func (a *ProductMember_Prefetch_User) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductMember_Prefetch_User to handle AdditionalProperties
func (a ProductMember_Prefetch_User) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductType_Prefetch_AuthorizationGroups. Returns the specified
// element and whether it was found
func (a ProductType_Prefetch_AuthorizationGroups) Get(fieldName string) (value DojoGroup, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductType_Prefetch_AuthorizationGroups
func (a *ProductType_Prefetch_AuthorizationGroups) Set(fieldName string, value DojoGroup) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DojoGroup)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductType_Prefetch_AuthorizationGroups to handle AdditionalProperties
func (a *ProductType_Prefetch_AuthorizationGroups) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DojoGroup)
		for fieldName, fieldBuf := range object {
			var fieldVal DojoGroup
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductType_Prefetch_AuthorizationGroups to handle AdditionalProperties
func (a ProductType_Prefetch_AuthorizationGroups) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductType_Prefetch_Members. Returns the specified
// element and whether it was found
func (a ProductType_Prefetch_Members) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductType_Prefetch_Members
func (a *ProductType_Prefetch_Members) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductType_Prefetch_Members to handle AdditionalProperties
func (a *ProductType_Prefetch_Members) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductType_Prefetch_Members to handle AdditionalProperties
func (a ProductType_Prefetch_Members) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductTypeGroup_Prefetch_Group. Returns the specified
// element and whether it was found
func (a ProductTypeGroup_Prefetch_Group) Get(fieldName string) (value DojoGroup, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductTypeGroup_Prefetch_Group
func (a *ProductTypeGroup_Prefetch_Group) Set(fieldName string, value DojoGroup) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DojoGroup)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductTypeGroup_Prefetch_Group to handle AdditionalProperties
func (a *ProductTypeGroup_Prefetch_Group) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DojoGroup)
		for fieldName, fieldBuf := range object {
			var fieldVal DojoGroup
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductTypeGroup_Prefetch_Group to handle AdditionalProperties
func (a ProductTypeGroup_Prefetch_Group) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductTypeGroup_Prefetch_ProductType. Returns the specified
// element and whether it was found
func (a ProductTypeGroup_Prefetch_ProductType) Get(fieldName string) (value ProductType, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductTypeGroup_Prefetch_ProductType
func (a *ProductTypeGroup_Prefetch_ProductType) Set(fieldName string, value ProductType) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ProductType)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductTypeGroup_Prefetch_ProductType to handle AdditionalProperties
func (a *ProductTypeGroup_Prefetch_ProductType) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ProductType)
		for fieldName, fieldBuf := range object {
			var fieldVal ProductType
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductTypeGroup_Prefetch_ProductType to handle AdditionalProperties
func (a ProductTypeGroup_Prefetch_ProductType) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductTypeGroup_Prefetch_Role. Returns the specified
// element and whether it was found
func (a ProductTypeGroup_Prefetch_Role) Get(fieldName string) (value Role, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductTypeGroup_Prefetch_Role
func (a *ProductTypeGroup_Prefetch_Role) Set(fieldName string, value Role) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Role)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductTypeGroup_Prefetch_Role to handle AdditionalProperties
func (a *ProductTypeGroup_Prefetch_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Role)
		for fieldName, fieldBuf := range object {
			var fieldVal Role
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductTypeGroup_Prefetch_Role to handle AdditionalProperties
func (a ProductTypeGroup_Prefetch_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductTypeMember_Prefetch_ProductType. Returns the specified
// element and whether it was found
func (a ProductTypeMember_Prefetch_ProductType) Get(fieldName string) (value ProductType, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductTypeMember_Prefetch_ProductType
func (a *ProductTypeMember_Prefetch_ProductType) Set(fieldName string, value ProductType) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ProductType)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductTypeMember_Prefetch_ProductType to handle AdditionalProperties
func (a *ProductTypeMember_Prefetch_ProductType) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ProductType)
		for fieldName, fieldBuf := range object {
			var fieldVal ProductType
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductTypeMember_Prefetch_ProductType to handle AdditionalProperties
func (a ProductTypeMember_Prefetch_ProductType) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductTypeMember_Prefetch_Role. Returns the specified
// element and whether it was found
func (a ProductTypeMember_Prefetch_Role) Get(fieldName string) (value Role, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductTypeMember_Prefetch_Role
func (a *ProductTypeMember_Prefetch_Role) Set(fieldName string, value Role) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Role)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductTypeMember_Prefetch_Role to handle AdditionalProperties
func (a *ProductTypeMember_Prefetch_Role) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Role)
		for fieldName, fieldBuf := range object {
			var fieldVal Role
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductTypeMember_Prefetch_Role to handle AdditionalProperties
func (a ProductTypeMember_Prefetch_Role) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProductTypeMember_Prefetch_User. Returns the specified
// element and whether it was found
func (a ProductTypeMember_Prefetch_User) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProductTypeMember_Prefetch_User
func (a *ProductTypeMember_Prefetch_User) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProductTypeMember_Prefetch_User to handle AdditionalProperties
func (a *ProductTypeMember_Prefetch_User) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProductTypeMember_Prefetch_User to handle AdditionalProperties
func (a ProductTypeMember_Prefetch_User) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TestImport_ImportSettings. Returns the specified
// element and whether it was found
func (a TestImport_ImportSettings) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TestImport_ImportSettings
func (a *TestImport_ImportSettings) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TestImport_ImportSettings to handle AdditionalProperties
func (a *TestImport_ImportSettings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TestImport_ImportSettings to handle AdditionalProperties
func (a TestImport_ImportSettings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TestImport_Prefetch_FindingsAffected. Returns the specified
// element and whether it was found
func (a TestImport_Prefetch_FindingsAffected) Get(fieldName string) (value Finding, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TestImport_Prefetch_FindingsAffected
func (a *TestImport_Prefetch_FindingsAffected) Set(fieldName string, value Finding) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Finding)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TestImport_Prefetch_FindingsAffected to handle AdditionalProperties
func (a *TestImport_Prefetch_FindingsAffected) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Finding)
		for fieldName, fieldBuf := range object {
			var fieldVal Finding
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TestImport_Prefetch_FindingsAffected to handle AdditionalProperties
func (a TestImport_Prefetch_FindingsAffected) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TestImport_Prefetch_Test. Returns the specified
// element and whether it was found
func (a TestImport_Prefetch_Test) Get(fieldName string) (value Test, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TestImport_Prefetch_Test
func (a *TestImport_Prefetch_Test) Set(fieldName string, value Test) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Test)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TestImport_Prefetch_Test to handle AdditionalProperties
func (a *TestImport_Prefetch_Test) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Test)
		for fieldName, fieldBuf := range object {
			var fieldVal Test
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TestImport_Prefetch_Test to handle AdditionalProperties
func (a TestImport_Prefetch_Test) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TestImportRequest_ImportSettings. Returns the specified
// element and whether it was found
func (a TestImportRequest_ImportSettings) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TestImportRequest_ImportSettings
func (a *TestImportRequest_ImportSettings) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TestImportRequest_ImportSettings to handle AdditionalProperties
func (a *TestImportRequest_ImportSettings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TestImportRequest_ImportSettings to handle AdditionalProperties
func (a TestImportRequest_ImportSettings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UserContactInfo_Prefetch_User. Returns the specified
// element and whether it was found
func (a UserContactInfo_Prefetch_User) Get(fieldName string) (value UserStub, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UserContactInfo_Prefetch_User
func (a *UserContactInfo_Prefetch_User) Set(fieldName string, value UserStub) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]UserStub)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UserContactInfo_Prefetch_User to handle AdditionalProperties
func (a *UserContactInfo_Prefetch_User) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]UserStub)
		for fieldName, fieldBuf := range object {
			var fieldVal UserStub
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UserContactInfo_Prefetch_User to handle AdditionalProperties
func (a UserContactInfo_Prefetch_User) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ApiTokenAuthCreate request with any body
	ApiTokenAuthCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApiTokenAuthCreate(ctx context.Context, body ApiTokenAuthCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigurationPermissionsList request
	ConfigurationPermissionsList(ctx context.Context, params *ConfigurationPermissionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigurationPermissionsRetrieve request
	ConfigurationPermissionsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevelopmentEnvironmentsList request
	DevelopmentEnvironmentsList(ctx context.Context, params *DevelopmentEnvironmentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevelopmentEnvironmentsCreate request with any body
	DevelopmentEnvironmentsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevelopmentEnvironmentsCreate(ctx context.Context, body DevelopmentEnvironmentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevelopmentEnvironmentsDestroy request
	DevelopmentEnvironmentsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevelopmentEnvironmentsRetrieve request
	DevelopmentEnvironmentsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevelopmentEnvironmentsPartialUpdate request with any body
	DevelopmentEnvironmentsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevelopmentEnvironmentsPartialUpdate(ctx context.Context, id int, body DevelopmentEnvironmentsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevelopmentEnvironmentsUpdate request with any body
	DevelopmentEnvironmentsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DevelopmentEnvironmentsUpdate(ctx context.Context, id int, body DevelopmentEnvironmentsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DevelopmentEnvironmentsDeletePreviewList request
	DevelopmentEnvironmentsDeletePreviewList(ctx context.Context, id int, params *DevelopmentEnvironmentsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupMembersList request
	DojoGroupMembersList(ctx context.Context, params *DojoGroupMembersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupMembersCreate request with any body
	DojoGroupMembersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DojoGroupMembersCreate(ctx context.Context, body DojoGroupMembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupMembersDestroy request
	DojoGroupMembersDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupMembersRetrieve request
	DojoGroupMembersRetrieve(ctx context.Context, id int, params *DojoGroupMembersRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupMembersPartialUpdate request with any body
	DojoGroupMembersPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DojoGroupMembersPartialUpdate(ctx context.Context, id int, body DojoGroupMembersPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupMembersUpdate request with any body
	DojoGroupMembersUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DojoGroupMembersUpdate(ctx context.Context, id int, body DojoGroupMembersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupMembersDeletePreviewList request
	DojoGroupMembersDeletePreviewList(ctx context.Context, id int, params *DojoGroupMembersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupsList request
	DojoGroupsList(ctx context.Context, params *DojoGroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupsCreate request with any body
	DojoGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DojoGroupsCreate(ctx context.Context, body DojoGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupsDestroy request
	DojoGroupsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupsRetrieve request
	DojoGroupsRetrieve(ctx context.Context, id int, params *DojoGroupsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupsPartialUpdate request with any body
	DojoGroupsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DojoGroupsPartialUpdate(ctx context.Context, id int, body DojoGroupsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupsUpdate request with any body
	DojoGroupsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DojoGroupsUpdate(ctx context.Context, id int, body DojoGroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DojoGroupsDeletePreviewList request
	DojoGroupsDeletePreviewList(ctx context.Context, id int, params *DojoGroupsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointMetaImportCreate request with any body
	EndpointMetaImportCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointStatusList request
	EndpointStatusList(ctx context.Context, params *EndpointStatusListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointStatusCreate request with any body
	EndpointStatusCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EndpointStatusCreate(ctx context.Context, body EndpointStatusCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointStatusDestroy request
	EndpointStatusDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointStatusRetrieve request
	EndpointStatusRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointStatusPartialUpdate request with any body
	EndpointStatusPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EndpointStatusPartialUpdate(ctx context.Context, id int, body EndpointStatusPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointStatusUpdate request with any body
	EndpointStatusUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EndpointStatusUpdate(ctx context.Context, id int, body EndpointStatusUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointStatusDeletePreviewList request
	EndpointStatusDeletePreviewList(ctx context.Context, id int, params *EndpointStatusDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointsList request
	EndpointsList(ctx context.Context, params *EndpointsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointsCreate request with any body
	EndpointsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EndpointsCreate(ctx context.Context, body EndpointsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointsDestroy request
	EndpointsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointsRetrieve request
	EndpointsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointsPartialUpdate request with any body
	EndpointsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EndpointsPartialUpdate(ctx context.Context, id int, body EndpointsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointsUpdate request with any body
	EndpointsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EndpointsUpdate(ctx context.Context, id int, body EndpointsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointsDeletePreviewList request
	EndpointsDeletePreviewList(ctx context.Context, id int, params *EndpointsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndpointsGenerateReportCreate request with any body
	EndpointsGenerateReportCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EndpointsGenerateReportCreate(ctx context.Context, id int, body EndpointsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementPresetsList request
	EngagementPresetsList(ctx context.Context, params *EngagementPresetsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementPresetsCreate request with any body
	EngagementPresetsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementPresetsCreate(ctx context.Context, body EngagementPresetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementPresetsDestroy request
	EngagementPresetsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementPresetsRetrieve request
	EngagementPresetsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementPresetsPartialUpdate request with any body
	EngagementPresetsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementPresetsPartialUpdate(ctx context.Context, id int, body EngagementPresetsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementPresetsUpdate request with any body
	EngagementPresetsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementPresetsUpdate(ctx context.Context, id int, body EngagementPresetsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementPresetsDeletePreviewList request
	EngagementPresetsDeletePreviewList(ctx context.Context, id int, params *EngagementPresetsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsList request
	EngagementsList(ctx context.Context, params *EngagementsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsCreate request with any body
	EngagementsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementsCreate(ctx context.Context, body EngagementsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsDestroy request
	EngagementsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsRetrieve request
	EngagementsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsPartialUpdate request with any body
	EngagementsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementsPartialUpdate(ctx context.Context, id int, body EngagementsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsUpdate request with any body
	EngagementsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementsUpdate(ctx context.Context, id int, body EngagementsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsAcceptRisksCreate request with any body
	EngagementsAcceptRisksCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementsAcceptRisksCreate(ctx context.Context, id int, body EngagementsAcceptRisksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsCloseCreate request
	EngagementsCloseCreate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsDeletePreviewList request
	EngagementsDeletePreviewList(ctx context.Context, id int, params *EngagementsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsFilesRetrieve request
	EngagementsFilesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsFilesCreate request with any body
	EngagementsFilesCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsGenerateReportCreate request with any body
	EngagementsGenerateReportCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementsGenerateReportCreate(ctx context.Context, id int, body EngagementsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsNotesRetrieve request
	EngagementsNotesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsNotesCreate request with any body
	EngagementsNotesCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngagementsNotesCreate(ctx context.Context, id int, body EngagementsNotesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngagementsReopenCreate request
	EngagementsReopenCreate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingTemplatesList request
	FindingTemplatesList(ctx context.Context, params *FindingTemplatesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingTemplatesCreate request with any body
	FindingTemplatesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingTemplatesCreate(ctx context.Context, body FindingTemplatesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingTemplatesDestroy request
	FindingTemplatesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingTemplatesRetrieve request
	FindingTemplatesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingTemplatesPartialUpdate request with any body
	FindingTemplatesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingTemplatesPartialUpdate(ctx context.Context, id int, body FindingTemplatesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingTemplatesUpdate request with any body
	FindingTemplatesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingTemplatesUpdate(ctx context.Context, id int, body FindingTemplatesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingTemplatesDeletePreviewList request
	FindingTemplatesDeletePreviewList(ctx context.Context, id int, params *FindingTemplatesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsList request
	FindingsList(ctx context.Context, params *FindingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsCreate request with any body
	FindingsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsCreate(ctx context.Context, body FindingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsAcceptRisksCreate request with any body
	FindingsAcceptRisksCreateWithBody(ctx context.Context, params *FindingsAcceptRisksCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsAcceptRisksCreate(ctx context.Context, params *FindingsAcceptRisksCreateParams, body FindingsAcceptRisksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsGenerateReportCreate request with any body
	FindingsGenerateReportCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsGenerateReportCreate(ctx context.Context, body FindingsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsDestroy request
	FindingsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsRetrieve request
	FindingsRetrieve(ctx context.Context, id int, params *FindingsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsPartialUpdate request with any body
	FindingsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsPartialUpdate(ctx context.Context, id int, body FindingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsUpdate request with any body
	FindingsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsUpdate(ctx context.Context, id int, body FindingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsCloseCreate request with any body
	FindingsCloseCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsCloseCreate(ctx context.Context, id int, body FindingsCloseCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsDeletePreviewList request
	FindingsDeletePreviewList(ctx context.Context, id int, params *FindingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsDuplicateList request
	FindingsDuplicateList(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsDuplicateResetCreate request
	FindingsDuplicateResetCreate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsFilesRetrieve request
	FindingsFilesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsFilesCreate request with any body
	FindingsFilesCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsMetadataDestroy request
	FindingsMetadataDestroy(ctx context.Context, id int, params *FindingsMetadataDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsMetadataList request
	FindingsMetadataList(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsMetadataCreate request with any body
	FindingsMetadataCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsMetadataCreate(ctx context.Context, id int, body FindingsMetadataCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsMetadataUpdate request with any body
	FindingsMetadataUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsMetadataUpdate(ctx context.Context, id int, body FindingsMetadataUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsNotesRetrieve request
	FindingsNotesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsNotesCreate request with any body
	FindingsNotesCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsNotesCreate(ctx context.Context, id int, body FindingsNotesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsOriginalCreate request
	FindingsOriginalCreate(ctx context.Context, id int, newFid int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsRemoveNotePartialUpdate request with any body
	FindingsRemoveNotePartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsRemoveNotePartialUpdate(ctx context.Context, id int, body FindingsRemoveNotePartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsRemoveTagsPartialUpdate request with any body
	FindingsRemoveTagsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsRemoveTagsPartialUpdate(ctx context.Context, id int, body FindingsRemoveTagsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsRemoveTagsUpdate request with any body
	FindingsRemoveTagsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsRemoveTagsUpdate(ctx context.Context, id int, body FindingsRemoveTagsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsRequestResponseRetrieve request
	FindingsRequestResponseRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsRequestResponseCreate request with any body
	FindingsRequestResponseCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsRequestResponseCreate(ctx context.Context, id int, body FindingsRequestResponseCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsTagsRetrieve request
	FindingsTagsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindingsTagsCreate request with any body
	FindingsTagsCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindingsTagsCreate(ctx context.Context, id int, body FindingsTagsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalRolesList request
	GlobalRolesList(ctx context.Context, params *GlobalRolesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalRolesCreate request with any body
	GlobalRolesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GlobalRolesCreate(ctx context.Context, body GlobalRolesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalRolesDestroy request
	GlobalRolesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalRolesRetrieve request
	GlobalRolesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalRolesPartialUpdate request with any body
	GlobalRolesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GlobalRolesPartialUpdate(ctx context.Context, id int, body GlobalRolesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalRolesUpdate request with any body
	GlobalRolesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GlobalRolesUpdate(ctx context.Context, id int, body GlobalRolesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalRolesDeletePreviewList request
	GlobalRolesDeletePreviewList(ctx context.Context, id int, params *GlobalRolesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportLanguagesCreate request with any body
	ImportLanguagesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportScanCreate request with any body
	ImportScanCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraConfigurationsList request
	JiraConfigurationsList(ctx context.Context, params *JiraConfigurationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraConfigurationsCreate request with any body
	JiraConfigurationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraConfigurationsCreate(ctx context.Context, body JiraConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraConfigurationsDestroy request
	JiraConfigurationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraConfigurationsRetrieve request
	JiraConfigurationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraConfigurationsPartialUpdate request with any body
	JiraConfigurationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraConfigurationsPartialUpdate(ctx context.Context, id int, body JiraConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraConfigurationsUpdate request with any body
	JiraConfigurationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraConfigurationsUpdate(ctx context.Context, id int, body JiraConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraConfigurationsDeletePreviewList request
	JiraConfigurationsDeletePreviewList(ctx context.Context, id int, params *JiraConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraFindingMappingsList request
	JiraFindingMappingsList(ctx context.Context, params *JiraFindingMappingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraFindingMappingsCreate request with any body
	JiraFindingMappingsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraFindingMappingsCreate(ctx context.Context, body JiraFindingMappingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraFindingMappingsDestroy request
	JiraFindingMappingsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraFindingMappingsRetrieve request
	JiraFindingMappingsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraFindingMappingsPartialUpdate request with any body
	JiraFindingMappingsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraFindingMappingsPartialUpdate(ctx context.Context, id int, body JiraFindingMappingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraFindingMappingsUpdate request with any body
	JiraFindingMappingsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraFindingMappingsUpdate(ctx context.Context, id int, body JiraFindingMappingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraFindingMappingsDeletePreviewList request
	JiraFindingMappingsDeletePreviewList(ctx context.Context, id int, params *JiraFindingMappingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraInstancesList request
	JiraInstancesList(ctx context.Context, params *JiraInstancesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraInstancesCreate request with any body
	JiraInstancesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraInstancesCreate(ctx context.Context, body JiraInstancesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraInstancesDestroy request
	JiraInstancesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraInstancesRetrieve request
	JiraInstancesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraInstancesPartialUpdate request with any body
	JiraInstancesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraInstancesPartialUpdate(ctx context.Context, id int, body JiraInstancesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraInstancesUpdate request with any body
	JiraInstancesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraInstancesUpdate(ctx context.Context, id int, body JiraInstancesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraInstancesDeletePreviewList request
	JiraInstancesDeletePreviewList(ctx context.Context, id int, params *JiraInstancesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProductConfigurationsList request
	JiraProductConfigurationsList(ctx context.Context, params *JiraProductConfigurationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProductConfigurationsCreate request with any body
	JiraProductConfigurationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraProductConfigurationsCreate(ctx context.Context, body JiraProductConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProductConfigurationsDestroy request
	JiraProductConfigurationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProductConfigurationsRetrieve request
	JiraProductConfigurationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProductConfigurationsPartialUpdate request with any body
	JiraProductConfigurationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraProductConfigurationsPartialUpdate(ctx context.Context, id int, body JiraProductConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProductConfigurationsUpdate request with any body
	JiraProductConfigurationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraProductConfigurationsUpdate(ctx context.Context, id int, body JiraProductConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProductConfigurationsDeletePreviewList request
	JiraProductConfigurationsDeletePreviewList(ctx context.Context, id int, params *JiraProductConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProjectsList request
	JiraProjectsList(ctx context.Context, params *JiraProjectsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProjectsCreate request with any body
	JiraProjectsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraProjectsCreate(ctx context.Context, body JiraProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProjectsDestroy request
	JiraProjectsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProjectsRetrieve request
	JiraProjectsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProjectsPartialUpdate request with any body
	JiraProjectsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraProjectsPartialUpdate(ctx context.Context, id int, body JiraProjectsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProjectsUpdate request with any body
	JiraProjectsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JiraProjectsUpdate(ctx context.Context, id int, body JiraProjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JiraProjectsDeletePreviewList request
	JiraProjectsDeletePreviewList(ctx context.Context, id int, params *JiraProjectsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguageTypesList request
	LanguageTypesList(ctx context.Context, params *LanguageTypesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguageTypesCreate request with any body
	LanguageTypesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LanguageTypesCreate(ctx context.Context, body LanguageTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguageTypesDestroy request
	LanguageTypesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguageTypesRetrieve request
	LanguageTypesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguageTypesPartialUpdate request with any body
	LanguageTypesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LanguageTypesPartialUpdate(ctx context.Context, id int, body LanguageTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguageTypesUpdate request with any body
	LanguageTypesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LanguageTypesUpdate(ctx context.Context, id int, body LanguageTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguageTypesDeletePreviewList request
	LanguageTypesDeletePreviewList(ctx context.Context, id int, params *LanguageTypesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguagesList request
	LanguagesList(ctx context.Context, params *LanguagesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguagesCreate request with any body
	LanguagesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LanguagesCreate(ctx context.Context, body LanguagesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguagesDestroy request
	LanguagesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguagesRetrieve request
	LanguagesRetrieve(ctx context.Context, id int, params *LanguagesRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguagesPartialUpdate request with any body
	LanguagesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LanguagesPartialUpdate(ctx context.Context, id int, body LanguagesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguagesUpdate request with any body
	LanguagesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LanguagesUpdate(ctx context.Context, id int, body LanguagesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LanguagesDeletePreviewList request
	LanguagesDeletePreviewList(ctx context.Context, id int, params *LanguagesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataList request
	MetadataList(ctx context.Context, params *MetadataListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataCreate request with any body
	MetadataCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetadataCreate(ctx context.Context, body MetadataCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataDestroy request
	MetadataDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataRetrieve request
	MetadataRetrieve(ctx context.Context, id int, params *MetadataRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataPartialUpdate request with any body
	MetadataPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetadataPartialUpdate(ctx context.Context, id int, body MetadataPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataUpdate request with any body
	MetadataUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MetadataUpdate(ctx context.Context, id int, body MetadataUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataDeletePreviewList request
	MetadataDeletePreviewList(ctx context.Context, id int, params *MetadataDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworkLocationsList request
	NetworkLocationsList(ctx context.Context, params *NetworkLocationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworkLocationsCreate request with any body
	NetworkLocationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NetworkLocationsCreate(ctx context.Context, body NetworkLocationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworkLocationsDestroy request
	NetworkLocationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworkLocationsRetrieve request
	NetworkLocationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworkLocationsPartialUpdate request with any body
	NetworkLocationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NetworkLocationsPartialUpdate(ctx context.Context, id int, body NetworkLocationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworkLocationsUpdate request with any body
	NetworkLocationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NetworkLocationsUpdate(ctx context.Context, id int, body NetworkLocationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworkLocationsDeletePreviewList request
	NetworkLocationsDeletePreviewList(ctx context.Context, id int, params *NetworkLocationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NoteTypeList request
	NoteTypeList(ctx context.Context, params *NoteTypeListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NoteTypeCreate request with any body
	NoteTypeCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NoteTypeCreate(ctx context.Context, body NoteTypeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NoteTypeDestroy request
	NoteTypeDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NoteTypeRetrieve request
	NoteTypeRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NoteTypePartialUpdate request with any body
	NoteTypePartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NoteTypePartialUpdate(ctx context.Context, id int, body NoteTypePartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NoteTypeUpdate request with any body
	NoteTypeUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NoteTypeUpdate(ctx context.Context, id int, body NoteTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NoteTypeDeletePreviewList request
	NoteTypeDeletePreviewList(ctx context.Context, id int, params *NoteTypeDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotesList request
	NotesList(ctx context.Context, params *NotesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotesRetrieve request
	NotesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotesPartialUpdate request with any body
	NotesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NotesPartialUpdate(ctx context.Context, id int, body NotesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotesUpdate request with any body
	NotesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NotesUpdate(ctx context.Context, id int, body NotesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotificationsList request
	NotificationsList(ctx context.Context, params *NotificationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotificationsCreate request with any body
	NotificationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NotificationsCreate(ctx context.Context, body NotificationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotificationsDestroy request
	NotificationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotificationsRetrieve request
	NotificationsRetrieve(ctx context.Context, id int, params *NotificationsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotificationsPartialUpdate request with any body
	NotificationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NotificationsPartialUpdate(ctx context.Context, id int, body NotificationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotificationsUpdate request with any body
	NotificationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NotificationsUpdate(ctx context.Context, id int, body NotificationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotificationsDeletePreviewList request
	NotificationsDeletePreviewList(ctx context.Context, id int, params *NotificationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oa3SchemaRetrieve request
	Oa3SchemaRetrieve(ctx context.Context, params *Oa3SchemaRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductApiScanConfigurationsList request
	ProductApiScanConfigurationsList(ctx context.Context, params *ProductApiScanConfigurationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductApiScanConfigurationsCreate request with any body
	ProductApiScanConfigurationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductApiScanConfigurationsCreate(ctx context.Context, body ProductApiScanConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductApiScanConfigurationsDestroy request
	ProductApiScanConfigurationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductApiScanConfigurationsRetrieve request
	ProductApiScanConfigurationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductApiScanConfigurationsPartialUpdate request with any body
	ProductApiScanConfigurationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductApiScanConfigurationsPartialUpdate(ctx context.Context, id int, body ProductApiScanConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductApiScanConfigurationsUpdate request with any body
	ProductApiScanConfigurationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductApiScanConfigurationsUpdate(ctx context.Context, id int, body ProductApiScanConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductApiScanConfigurationsDeletePreviewList request
	ProductApiScanConfigurationsDeletePreviewList(ctx context.Context, id int, params *ProductApiScanConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductGroupsList request
	ProductGroupsList(ctx context.Context, params *ProductGroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductGroupsCreate request with any body
	ProductGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductGroupsCreate(ctx context.Context, body ProductGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductGroupsDestroy request
	ProductGroupsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductGroupsRetrieve request
	ProductGroupsRetrieve(ctx context.Context, id int, params *ProductGroupsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductGroupsPartialUpdate request
	ProductGroupsPartialUpdate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductGroupsUpdate request with any body
	ProductGroupsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductGroupsUpdate(ctx context.Context, id int, body ProductGroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductGroupsDeletePreviewList request
	ProductGroupsDeletePreviewList(ctx context.Context, id int, params *ProductGroupsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductMembersList request
	ProductMembersList(ctx context.Context, params *ProductMembersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductMembersCreate request with any body
	ProductMembersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductMembersCreate(ctx context.Context, body ProductMembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductMembersDestroy request
	ProductMembersDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductMembersRetrieve request
	ProductMembersRetrieve(ctx context.Context, id int, params *ProductMembersRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductMembersPartialUpdate request
	ProductMembersPartialUpdate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductMembersUpdate request with any body
	ProductMembersUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductMembersUpdate(ctx context.Context, id int, body ProductMembersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductMembersDeletePreviewList request
	ProductMembersDeletePreviewList(ctx context.Context, id int, params *ProductMembersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeGroupsList request
	ProductTypeGroupsList(ctx context.Context, params *ProductTypeGroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeGroupsCreate request with any body
	ProductTypeGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductTypeGroupsCreate(ctx context.Context, body ProductTypeGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeGroupsDestroy request
	ProductTypeGroupsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeGroupsRetrieve request
	ProductTypeGroupsRetrieve(ctx context.Context, id int, params *ProductTypeGroupsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeGroupsPartialUpdate request
	ProductTypeGroupsPartialUpdate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeGroupsUpdate request with any body
	ProductTypeGroupsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductTypeGroupsUpdate(ctx context.Context, id int, body ProductTypeGroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeGroupsDeletePreviewList request
	ProductTypeGroupsDeletePreviewList(ctx context.Context, id int, params *ProductTypeGroupsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeMembersList request
	ProductTypeMembersList(ctx context.Context, params *ProductTypeMembersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeMembersCreate request with any body
	ProductTypeMembersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductTypeMembersCreate(ctx context.Context, body ProductTypeMembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeMembersDestroy request
	ProductTypeMembersDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeMembersRetrieve request
	ProductTypeMembersRetrieve(ctx context.Context, id int, params *ProductTypeMembersRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeMembersPartialUpdate request
	ProductTypeMembersPartialUpdate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeMembersUpdate request with any body
	ProductTypeMembersUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductTypeMembersUpdate(ctx context.Context, id int, body ProductTypeMembersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypeMembersDeletePreviewList request
	ProductTypeMembersDeletePreviewList(ctx context.Context, id int, params *ProductTypeMembersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypesList request
	ProductTypesList(ctx context.Context, params *ProductTypesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypesCreate request with any body
	ProductTypesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductTypesCreate(ctx context.Context, body ProductTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypesDestroy request
	ProductTypesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypesRetrieve request
	ProductTypesRetrieve(ctx context.Context, id int, params *ProductTypesRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypesPartialUpdate request with any body
	ProductTypesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductTypesPartialUpdate(ctx context.Context, id int, body ProductTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypesUpdate request with any body
	ProductTypesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductTypesUpdate(ctx context.Context, id int, body ProductTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypesDeletePreviewList request
	ProductTypesDeletePreviewList(ctx context.Context, id int, params *ProductTypesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypesGenerateReportCreate request with any body
	ProductTypesGenerateReportCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductTypesGenerateReportCreate(ctx context.Context, id int, body ProductTypesGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsList request
	ProductsList(ctx context.Context, params *ProductsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsCreate request with any body
	ProductsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductsCreate(ctx context.Context, body ProductsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsDestroy request
	ProductsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsRetrieve request
	ProductsRetrieve(ctx context.Context, id int, params *ProductsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsPartialUpdate request with any body
	ProductsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductsPartialUpdate(ctx context.Context, id int, body ProductsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsUpdate request with any body
	ProductsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductsUpdate(ctx context.Context, id int, body ProductsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsDeletePreviewList request
	ProductsDeletePreviewList(ctx context.Context, id int, params *ProductsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsGenerateReportCreate request with any body
	ProductsGenerateReportCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductsGenerateReportCreate(ctx context.Context, id int, body ProductsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegulationsList request
	RegulationsList(ctx context.Context, params *RegulationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegulationsCreate request with any body
	RegulationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegulationsCreate(ctx context.Context, body RegulationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegulationsDestroy request
	RegulationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegulationsRetrieve request
	RegulationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegulationsPartialUpdate request with any body
	RegulationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegulationsPartialUpdate(ctx context.Context, id int, body RegulationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegulationsUpdate request with any body
	RegulationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegulationsUpdate(ctx context.Context, id int, body RegulationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegulationsDeletePreviewList request
	RegulationsDeletePreviewList(ctx context.Context, id int, params *RegulationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReimportScanCreate request with any body
	ReimportScanCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RolesList request
	RolesList(ctx context.Context, params *RolesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RolesRetrieve request
	RolesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaConfigurationsList request
	SlaConfigurationsList(ctx context.Context, params *SlaConfigurationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaConfigurationsCreate request with any body
	SlaConfigurationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlaConfigurationsCreate(ctx context.Context, body SlaConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaConfigurationsDestroy request
	SlaConfigurationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaConfigurationsRetrieve request
	SlaConfigurationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaConfigurationsPartialUpdate request with any body
	SlaConfigurationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlaConfigurationsPartialUpdate(ctx context.Context, id int, body SlaConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlaConfigurationsUpdate request with any body
	SlaConfigurationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlaConfigurationsUpdate(ctx context.Context, id int, body SlaConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeIssuesList request
	SonarqubeIssuesList(ctx context.Context, params *SonarqubeIssuesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeIssuesCreate request with any body
	SonarqubeIssuesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SonarqubeIssuesCreate(ctx context.Context, body SonarqubeIssuesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeIssuesDestroy request
	SonarqubeIssuesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeIssuesRetrieve request
	SonarqubeIssuesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeIssuesPartialUpdate request with any body
	SonarqubeIssuesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SonarqubeIssuesPartialUpdate(ctx context.Context, id int, body SonarqubeIssuesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeIssuesUpdate request with any body
	SonarqubeIssuesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SonarqubeIssuesUpdate(ctx context.Context, id int, body SonarqubeIssuesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeIssuesDeletePreviewList request
	SonarqubeIssuesDeletePreviewList(ctx context.Context, id int, params *SonarqubeIssuesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeTransitionsList request
	SonarqubeTransitionsList(ctx context.Context, params *SonarqubeTransitionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeTransitionsCreate request with any body
	SonarqubeTransitionsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SonarqubeTransitionsCreate(ctx context.Context, body SonarqubeTransitionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeTransitionsDestroy request
	SonarqubeTransitionsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeTransitionsRetrieve request
	SonarqubeTransitionsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeTransitionsPartialUpdate request with any body
	SonarqubeTransitionsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SonarqubeTransitionsPartialUpdate(ctx context.Context, id int, body SonarqubeTransitionsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeTransitionsUpdate request with any body
	SonarqubeTransitionsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SonarqubeTransitionsUpdate(ctx context.Context, id int, body SonarqubeTransitionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SonarqubeTransitionsDeletePreviewList request
	SonarqubeTransitionsDeletePreviewList(ctx context.Context, id int, params *SonarqubeTransitionsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StubFindingsList request
	StubFindingsList(ctx context.Context, params *StubFindingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StubFindingsCreate request with any body
	StubFindingsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StubFindingsCreate(ctx context.Context, body StubFindingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StubFindingsDestroy request
	StubFindingsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StubFindingsRetrieve request
	StubFindingsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StubFindingsPartialUpdate request with any body
	StubFindingsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StubFindingsPartialUpdate(ctx context.Context, id int, body StubFindingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StubFindingsUpdate request with any body
	StubFindingsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StubFindingsUpdate(ctx context.Context, id int, body StubFindingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StubFindingsDeletePreviewList request
	StubFindingsDeletePreviewList(ctx context.Context, id int, params *StubFindingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SystemSettingsList request
	SystemSettingsList(ctx context.Context, params *SystemSettingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SystemSettingsPartialUpdate request with any body
	SystemSettingsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SystemSettingsPartialUpdate(ctx context.Context, id int, body SystemSettingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SystemSettingsUpdate request with any body
	SystemSettingsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SystemSettingsUpdate(ctx context.Context, id int, body SystemSettingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TechnologiesList request
	TechnologiesList(ctx context.Context, params *TechnologiesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TechnologiesCreate request with any body
	TechnologiesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TechnologiesCreate(ctx context.Context, body TechnologiesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TechnologiesDestroy request
	TechnologiesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TechnologiesRetrieve request
	TechnologiesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TechnologiesPartialUpdate request with any body
	TechnologiesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TechnologiesPartialUpdate(ctx context.Context, id int, body TechnologiesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TechnologiesUpdate request with any body
	TechnologiesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TechnologiesUpdate(ctx context.Context, id int, body TechnologiesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TechnologiesDeletePreviewList request
	TechnologiesDeletePreviewList(ctx context.Context, id int, params *TechnologiesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestImportsList request
	TestImportsList(ctx context.Context, params *TestImportsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestImportsCreate request with any body
	TestImportsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestImportsCreate(ctx context.Context, body TestImportsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestImportsDestroy request
	TestImportsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestImportsRetrieve request
	TestImportsRetrieve(ctx context.Context, id int, params *TestImportsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestImportsPartialUpdate request with any body
	TestImportsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestImportsPartialUpdate(ctx context.Context, id int, body TestImportsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestImportsUpdate request with any body
	TestImportsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestImportsUpdate(ctx context.Context, id int, body TestImportsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestImportsDeletePreviewList request
	TestImportsDeletePreviewList(ctx context.Context, id int, params *TestImportsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestTypesList request
	TestTypesList(ctx context.Context, params *TestTypesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestTypesCreate request with any body
	TestTypesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestTypesCreate(ctx context.Context, body TestTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestTypesRetrieve request
	TestTypesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestTypesPartialUpdate request with any body
	TestTypesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestTypesPartialUpdate(ctx context.Context, id int, body TestTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestTypesUpdate request with any body
	TestTypesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestTypesUpdate(ctx context.Context, id int, body TestTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsList request
	TestsList(ctx context.Context, params *TestsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsCreate request with any body
	TestsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestsCreate(ctx context.Context, body TestsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsDestroy request
	TestsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsRetrieve request
	TestsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsPartialUpdate request with any body
	TestsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestsPartialUpdate(ctx context.Context, id int, body TestsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsUpdate request with any body
	TestsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestsUpdate(ctx context.Context, id int, body TestsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsAcceptRisksCreate request with any body
	TestsAcceptRisksCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestsAcceptRisksCreate(ctx context.Context, id int, body TestsAcceptRisksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsDeletePreviewList request
	TestsDeletePreviewList(ctx context.Context, id int, params *TestsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsFilesRetrieve request
	TestsFilesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsFilesCreate request with any body
	TestsFilesCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsGenerateReportCreate request with any body
	TestsGenerateReportCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestsGenerateReportCreate(ctx context.Context, id int, body TestsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsNotesRetrieve request
	TestsNotesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestsNotesCreate request with any body
	TestsNotesCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestsNotesCreate(ctx context.Context, id int, body TestsNotesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolConfigurationsList request
	ToolConfigurationsList(ctx context.Context, params *ToolConfigurationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolConfigurationsCreate request with any body
	ToolConfigurationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToolConfigurationsCreate(ctx context.Context, body ToolConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolConfigurationsDestroy request
	ToolConfigurationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolConfigurationsRetrieve request
	ToolConfigurationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolConfigurationsPartialUpdate request with any body
	ToolConfigurationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToolConfigurationsPartialUpdate(ctx context.Context, id int, body ToolConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolConfigurationsUpdate request with any body
	ToolConfigurationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToolConfigurationsUpdate(ctx context.Context, id int, body ToolConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolConfigurationsDeletePreviewList request
	ToolConfigurationsDeletePreviewList(ctx context.Context, id int, params *ToolConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolProductSettingsList request
	ToolProductSettingsList(ctx context.Context, params *ToolProductSettingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolProductSettingsCreate request with any body
	ToolProductSettingsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToolProductSettingsCreate(ctx context.Context, body ToolProductSettingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolProductSettingsDestroy request
	ToolProductSettingsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolProductSettingsRetrieve request
	ToolProductSettingsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolProductSettingsPartialUpdate request with any body
	ToolProductSettingsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToolProductSettingsPartialUpdate(ctx context.Context, id int, body ToolProductSettingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolProductSettingsUpdate request with any body
	ToolProductSettingsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToolProductSettingsUpdate(ctx context.Context, id int, body ToolProductSettingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolProductSettingsDeletePreviewList request
	ToolProductSettingsDeletePreviewList(ctx context.Context, id int, params *ToolProductSettingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolTypesList request
	ToolTypesList(ctx context.Context, params *ToolTypesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolTypesCreate request with any body
	ToolTypesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToolTypesCreate(ctx context.Context, body ToolTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolTypesDestroy request
	ToolTypesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolTypesRetrieve request
	ToolTypesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolTypesPartialUpdate request with any body
	ToolTypesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToolTypesPartialUpdate(ctx context.Context, id int, body ToolTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolTypesUpdate request with any body
	ToolTypesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ToolTypesUpdate(ctx context.Context, id int, body ToolTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToolTypesDeletePreviewList request
	ToolTypesDeletePreviewList(ctx context.Context, id int, params *ToolTypesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserContactInfosList request
	UserContactInfosList(ctx context.Context, params *UserContactInfosListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserContactInfosCreate request with any body
	UserContactInfosCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserContactInfosCreate(ctx context.Context, body UserContactInfosCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserContactInfosDestroy request
	UserContactInfosDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserContactInfosRetrieve request
	UserContactInfosRetrieve(ctx context.Context, id int, params *UserContactInfosRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserContactInfosPartialUpdate request with any body
	UserContactInfosPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserContactInfosPartialUpdate(ctx context.Context, id int, body UserContactInfosPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserContactInfosUpdate request with any body
	UserContactInfosUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserContactInfosUpdate(ctx context.Context, id int, body UserContactInfosUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserContactInfosDeletePreviewList request
	UserContactInfosDeletePreviewList(ctx context.Context, id int, params *UserContactInfosDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserProfileRetrieve request
	UserProfileRetrieve(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersList request
	UsersList(ctx context.Context, params *UsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersCreate request with any body
	UsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersCreate(ctx context.Context, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersDestroy request
	UsersDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersRetrieve request
	UsersRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersPartialUpdate request with any body
	UsersPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersPartialUpdate(ctx context.Context, id int, body UsersPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersUpdate request with any body
	UsersUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersUpdate(ctx context.Context, id int, body UsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersDeletePreviewList request
	UsersDeletePreviewList(ctx context.Context, id int, params *UsersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ApiTokenAuthCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenAuthCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenAuthCreate(ctx context.Context, body ApiTokenAuthCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenAuthCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigurationPermissionsList(ctx context.Context, params *ConfigurationPermissionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigurationPermissionsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigurationPermissionsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigurationPermissionsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevelopmentEnvironmentsList(ctx context.Context, params *DevelopmentEnvironmentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevelopmentEnvironmentsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevelopmentEnvironmentsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevelopmentEnvironmentsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevelopmentEnvironmentsCreate(ctx context.Context, body DevelopmentEnvironmentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevelopmentEnvironmentsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevelopmentEnvironmentsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevelopmentEnvironmentsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevelopmentEnvironmentsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevelopmentEnvironmentsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevelopmentEnvironmentsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevelopmentEnvironmentsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevelopmentEnvironmentsPartialUpdate(ctx context.Context, id int, body DevelopmentEnvironmentsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevelopmentEnvironmentsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevelopmentEnvironmentsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevelopmentEnvironmentsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevelopmentEnvironmentsUpdate(ctx context.Context, id int, body DevelopmentEnvironmentsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevelopmentEnvironmentsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DevelopmentEnvironmentsDeletePreviewList(ctx context.Context, id int, params *DevelopmentEnvironmentsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDevelopmentEnvironmentsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupMembersList(ctx context.Context, params *DojoGroupMembersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupMembersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupMembersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupMembersCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupMembersCreate(ctx context.Context, body DojoGroupMembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupMembersCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupMembersDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupMembersDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupMembersRetrieve(ctx context.Context, id int, params *DojoGroupMembersRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupMembersRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupMembersPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupMembersPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupMembersPartialUpdate(ctx context.Context, id int, body DojoGroupMembersPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupMembersPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupMembersUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupMembersUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupMembersUpdate(ctx context.Context, id int, body DojoGroupMembersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupMembersUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupMembersDeletePreviewList(ctx context.Context, id int, params *DojoGroupMembersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupMembersDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupsList(ctx context.Context, params *DojoGroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupsCreate(ctx context.Context, body DojoGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupsRetrieve(ctx context.Context, id int, params *DojoGroupsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupsRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupsPartialUpdate(ctx context.Context, id int, body DojoGroupsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupsUpdate(ctx context.Context, id int, body DojoGroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DojoGroupsDeletePreviewList(ctx context.Context, id int, params *DojoGroupsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDojoGroupsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointMetaImportCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointMetaImportCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointStatusList(ctx context.Context, params *EndpointStatusListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointStatusListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointStatusCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointStatusCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointStatusCreate(ctx context.Context, body EndpointStatusCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointStatusCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointStatusDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointStatusDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointStatusRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointStatusRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointStatusPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointStatusPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointStatusPartialUpdate(ctx context.Context, id int, body EndpointStatusPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointStatusPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointStatusUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointStatusUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointStatusUpdate(ctx context.Context, id int, body EndpointStatusUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointStatusUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointStatusDeletePreviewList(ctx context.Context, id int, params *EndpointStatusDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointStatusDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointsList(ctx context.Context, params *EndpointsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointsCreate(ctx context.Context, body EndpointsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointsPartialUpdate(ctx context.Context, id int, body EndpointsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointsUpdate(ctx context.Context, id int, body EndpointsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointsDeletePreviewList(ctx context.Context, id int, params *EndpointsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointsGenerateReportCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointsGenerateReportCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndpointsGenerateReportCreate(ctx context.Context, id int, body EndpointsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndpointsGenerateReportCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementPresetsList(ctx context.Context, params *EngagementPresetsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementPresetsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementPresetsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementPresetsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementPresetsCreate(ctx context.Context, body EngagementPresetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementPresetsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementPresetsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementPresetsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementPresetsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementPresetsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementPresetsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementPresetsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementPresetsPartialUpdate(ctx context.Context, id int, body EngagementPresetsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementPresetsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementPresetsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementPresetsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementPresetsUpdate(ctx context.Context, id int, body EngagementPresetsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementPresetsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementPresetsDeletePreviewList(ctx context.Context, id int, params *EngagementPresetsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementPresetsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsList(ctx context.Context, params *EngagementsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsCreate(ctx context.Context, body EngagementsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsPartialUpdate(ctx context.Context, id int, body EngagementsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsUpdate(ctx context.Context, id int, body EngagementsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsAcceptRisksCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsAcceptRisksCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsAcceptRisksCreate(ctx context.Context, id int, body EngagementsAcceptRisksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsAcceptRisksCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsCloseCreate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsCloseCreateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsDeletePreviewList(ctx context.Context, id int, params *EngagementsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsFilesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsFilesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsFilesCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsFilesCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsGenerateReportCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsGenerateReportCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsGenerateReportCreate(ctx context.Context, id int, body EngagementsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsGenerateReportCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsNotesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsNotesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsNotesCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsNotesCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsNotesCreate(ctx context.Context, id int, body EngagementsNotesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsNotesCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngagementsReopenCreate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngagementsReopenCreateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingTemplatesList(ctx context.Context, params *FindingTemplatesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingTemplatesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingTemplatesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingTemplatesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingTemplatesCreate(ctx context.Context, body FindingTemplatesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingTemplatesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingTemplatesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingTemplatesDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingTemplatesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingTemplatesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingTemplatesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingTemplatesPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingTemplatesPartialUpdate(ctx context.Context, id int, body FindingTemplatesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingTemplatesPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingTemplatesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingTemplatesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingTemplatesUpdate(ctx context.Context, id int, body FindingTemplatesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingTemplatesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingTemplatesDeletePreviewList(ctx context.Context, id int, params *FindingTemplatesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingTemplatesDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsList(ctx context.Context, params *FindingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsCreate(ctx context.Context, body FindingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsAcceptRisksCreateWithBody(ctx context.Context, params *FindingsAcceptRisksCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsAcceptRisksCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsAcceptRisksCreate(ctx context.Context, params *FindingsAcceptRisksCreateParams, body FindingsAcceptRisksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsAcceptRisksCreateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsGenerateReportCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsGenerateReportCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsGenerateReportCreate(ctx context.Context, body FindingsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsGenerateReportCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsRetrieve(ctx context.Context, id int, params *FindingsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsPartialUpdate(ctx context.Context, id int, body FindingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsUpdate(ctx context.Context, id int, body FindingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsCloseCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsCloseCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsCloseCreate(ctx context.Context, id int, body FindingsCloseCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsCloseCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsDeletePreviewList(ctx context.Context, id int, params *FindingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsDuplicateList(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsDuplicateListRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsDuplicateResetCreate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsDuplicateResetCreateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsFilesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsFilesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsFilesCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsFilesCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsMetadataDestroy(ctx context.Context, id int, params *FindingsMetadataDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsMetadataDestroyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsMetadataList(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsMetadataListRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsMetadataCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsMetadataCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsMetadataCreate(ctx context.Context, id int, body FindingsMetadataCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsMetadataCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsMetadataUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsMetadataUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsMetadataUpdate(ctx context.Context, id int, body FindingsMetadataUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsMetadataUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsNotesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsNotesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsNotesCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsNotesCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsNotesCreate(ctx context.Context, id int, body FindingsNotesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsNotesCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsOriginalCreate(ctx context.Context, id int, newFid int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsOriginalCreateRequest(c.Server, id, newFid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsRemoveNotePartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsRemoveNotePartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsRemoveNotePartialUpdate(ctx context.Context, id int, body FindingsRemoveNotePartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsRemoveNotePartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsRemoveTagsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsRemoveTagsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsRemoveTagsPartialUpdate(ctx context.Context, id int, body FindingsRemoveTagsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsRemoveTagsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsRemoveTagsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsRemoveTagsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsRemoveTagsUpdate(ctx context.Context, id int, body FindingsRemoveTagsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsRemoveTagsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsRequestResponseRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsRequestResponseRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsRequestResponseCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsRequestResponseCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsRequestResponseCreate(ctx context.Context, id int, body FindingsRequestResponseCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsRequestResponseCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsTagsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsTagsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsTagsCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsTagsCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindingsTagsCreate(ctx context.Context, id int, body FindingsTagsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindingsTagsCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalRolesList(ctx context.Context, params *GlobalRolesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalRolesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalRolesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalRolesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalRolesCreate(ctx context.Context, body GlobalRolesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalRolesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalRolesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalRolesDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalRolesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalRolesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalRolesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalRolesPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalRolesPartialUpdate(ctx context.Context, id int, body GlobalRolesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalRolesPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalRolesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalRolesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalRolesUpdate(ctx context.Context, id int, body GlobalRolesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalRolesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalRolesDeletePreviewList(ctx context.Context, id int, params *GlobalRolesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalRolesDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportLanguagesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportLanguagesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportScanCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportScanCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraConfigurationsList(ctx context.Context, params *JiraConfigurationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraConfigurationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraConfigurationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraConfigurationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraConfigurationsCreate(ctx context.Context, body JiraConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraConfigurationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraConfigurationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraConfigurationsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraConfigurationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraConfigurationsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraConfigurationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraConfigurationsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraConfigurationsPartialUpdate(ctx context.Context, id int, body JiraConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraConfigurationsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraConfigurationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraConfigurationsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraConfigurationsUpdate(ctx context.Context, id int, body JiraConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraConfigurationsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraConfigurationsDeletePreviewList(ctx context.Context, id int, params *JiraConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraConfigurationsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraFindingMappingsList(ctx context.Context, params *JiraFindingMappingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraFindingMappingsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraFindingMappingsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraFindingMappingsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraFindingMappingsCreate(ctx context.Context, body JiraFindingMappingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraFindingMappingsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraFindingMappingsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraFindingMappingsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraFindingMappingsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraFindingMappingsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraFindingMappingsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraFindingMappingsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraFindingMappingsPartialUpdate(ctx context.Context, id int, body JiraFindingMappingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraFindingMappingsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraFindingMappingsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraFindingMappingsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraFindingMappingsUpdate(ctx context.Context, id int, body JiraFindingMappingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraFindingMappingsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraFindingMappingsDeletePreviewList(ctx context.Context, id int, params *JiraFindingMappingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraFindingMappingsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraInstancesList(ctx context.Context, params *JiraInstancesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraInstancesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraInstancesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraInstancesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraInstancesCreate(ctx context.Context, body JiraInstancesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraInstancesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraInstancesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraInstancesDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraInstancesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraInstancesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraInstancesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraInstancesPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraInstancesPartialUpdate(ctx context.Context, id int, body JiraInstancesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraInstancesPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraInstancesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraInstancesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraInstancesUpdate(ctx context.Context, id int, body JiraInstancesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraInstancesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraInstancesDeletePreviewList(ctx context.Context, id int, params *JiraInstancesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraInstancesDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProductConfigurationsList(ctx context.Context, params *JiraProductConfigurationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProductConfigurationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProductConfigurationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProductConfigurationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProductConfigurationsCreate(ctx context.Context, body JiraProductConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProductConfigurationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProductConfigurationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProductConfigurationsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProductConfigurationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProductConfigurationsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProductConfigurationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProductConfigurationsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProductConfigurationsPartialUpdate(ctx context.Context, id int, body JiraProductConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProductConfigurationsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProductConfigurationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProductConfigurationsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProductConfigurationsUpdate(ctx context.Context, id int, body JiraProductConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProductConfigurationsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProductConfigurationsDeletePreviewList(ctx context.Context, id int, params *JiraProductConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProductConfigurationsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProjectsList(ctx context.Context, params *JiraProjectsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProjectsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProjectsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProjectsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProjectsCreate(ctx context.Context, body JiraProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProjectsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProjectsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProjectsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProjectsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProjectsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProjectsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProjectsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProjectsPartialUpdate(ctx context.Context, id int, body JiraProjectsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProjectsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProjectsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProjectsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProjectsUpdate(ctx context.Context, id int, body JiraProjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProjectsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JiraProjectsDeletePreviewList(ctx context.Context, id int, params *JiraProjectsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJiraProjectsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguageTypesList(ctx context.Context, params *LanguageTypesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguageTypesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguageTypesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguageTypesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguageTypesCreate(ctx context.Context, body LanguageTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguageTypesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguageTypesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguageTypesDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguageTypesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguageTypesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguageTypesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguageTypesPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguageTypesPartialUpdate(ctx context.Context, id int, body LanguageTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguageTypesPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguageTypesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguageTypesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguageTypesUpdate(ctx context.Context, id int, body LanguageTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguageTypesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguageTypesDeletePreviewList(ctx context.Context, id int, params *LanguageTypesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguageTypesDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguagesList(ctx context.Context, params *LanguagesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguagesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguagesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguagesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguagesCreate(ctx context.Context, body LanguagesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguagesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguagesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguagesDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguagesRetrieve(ctx context.Context, id int, params *LanguagesRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguagesRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguagesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguagesPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguagesPartialUpdate(ctx context.Context, id int, body LanguagesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguagesPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguagesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguagesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguagesUpdate(ctx context.Context, id int, body LanguagesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguagesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LanguagesDeletePreviewList(ctx context.Context, id int, params *LanguagesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLanguagesDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataList(ctx context.Context, params *MetadataListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataCreate(ctx context.Context, body MetadataCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataRetrieve(ctx context.Context, id int, params *MetadataRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataPartialUpdate(ctx context.Context, id int, body MetadataPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataUpdate(ctx context.Context, id int, body MetadataUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataDeletePreviewList(ctx context.Context, id int, params *MetadataDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkLocationsList(ctx context.Context, params *NetworkLocationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkLocationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkLocationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkLocationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkLocationsCreate(ctx context.Context, body NetworkLocationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkLocationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkLocationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkLocationsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkLocationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkLocationsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkLocationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkLocationsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkLocationsPartialUpdate(ctx context.Context, id int, body NetworkLocationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkLocationsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkLocationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkLocationsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkLocationsUpdate(ctx context.Context, id int, body NetworkLocationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkLocationsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkLocationsDeletePreviewList(ctx context.Context, id int, params *NetworkLocationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkLocationsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NoteTypeList(ctx context.Context, params *NoteTypeListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNoteTypeListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NoteTypeCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNoteTypeCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NoteTypeCreate(ctx context.Context, body NoteTypeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNoteTypeCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NoteTypeDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNoteTypeDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NoteTypeRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNoteTypeRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NoteTypePartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNoteTypePartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NoteTypePartialUpdate(ctx context.Context, id int, body NoteTypePartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNoteTypePartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NoteTypeUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNoteTypeUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NoteTypeUpdate(ctx context.Context, id int, body NoteTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNoteTypeUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NoteTypeDeletePreviewList(ctx context.Context, id int, params *NoteTypeDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNoteTypeDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotesList(ctx context.Context, params *NotesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotesPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotesPartialUpdate(ctx context.Context, id int, body NotesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotesPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotesUpdate(ctx context.Context, id int, body NotesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsList(ctx context.Context, params *NotificationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsCreate(ctx context.Context, body NotificationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsRetrieve(ctx context.Context, id int, params *NotificationsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsPartialUpdate(ctx context.Context, id int, body NotificationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsUpdate(ctx context.Context, id int, body NotificationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsDeletePreviewList(ctx context.Context, id int, params *NotificationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oa3SchemaRetrieve(ctx context.Context, params *Oa3SchemaRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOa3SchemaRetrieveRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductApiScanConfigurationsList(ctx context.Context, params *ProductApiScanConfigurationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductApiScanConfigurationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductApiScanConfigurationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductApiScanConfigurationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductApiScanConfigurationsCreate(ctx context.Context, body ProductApiScanConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductApiScanConfigurationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductApiScanConfigurationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductApiScanConfigurationsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductApiScanConfigurationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductApiScanConfigurationsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductApiScanConfigurationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductApiScanConfigurationsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductApiScanConfigurationsPartialUpdate(ctx context.Context, id int, body ProductApiScanConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductApiScanConfigurationsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductApiScanConfigurationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductApiScanConfigurationsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductApiScanConfigurationsUpdate(ctx context.Context, id int, body ProductApiScanConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductApiScanConfigurationsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductApiScanConfigurationsDeletePreviewList(ctx context.Context, id int, params *ProductApiScanConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductApiScanConfigurationsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductGroupsList(ctx context.Context, params *ProductGroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductGroupsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductGroupsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductGroupsCreate(ctx context.Context, body ProductGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductGroupsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductGroupsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductGroupsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductGroupsRetrieve(ctx context.Context, id int, params *ProductGroupsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductGroupsRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductGroupsPartialUpdate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductGroupsPartialUpdateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductGroupsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductGroupsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductGroupsUpdate(ctx context.Context, id int, body ProductGroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductGroupsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductGroupsDeletePreviewList(ctx context.Context, id int, params *ProductGroupsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductGroupsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductMembersList(ctx context.Context, params *ProductMembersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductMembersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductMembersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductMembersCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductMembersCreate(ctx context.Context, body ProductMembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductMembersCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductMembersDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductMembersDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductMembersRetrieve(ctx context.Context, id int, params *ProductMembersRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductMembersRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductMembersPartialUpdate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductMembersPartialUpdateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductMembersUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductMembersUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductMembersUpdate(ctx context.Context, id int, body ProductMembersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductMembersUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductMembersDeletePreviewList(ctx context.Context, id int, params *ProductMembersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductMembersDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeGroupsList(ctx context.Context, params *ProductTypeGroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeGroupsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeGroupsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeGroupsCreate(ctx context.Context, body ProductTypeGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeGroupsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeGroupsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeGroupsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeGroupsRetrieve(ctx context.Context, id int, params *ProductTypeGroupsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeGroupsRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeGroupsPartialUpdate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeGroupsPartialUpdateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeGroupsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeGroupsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeGroupsUpdate(ctx context.Context, id int, body ProductTypeGroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeGroupsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeGroupsDeletePreviewList(ctx context.Context, id int, params *ProductTypeGroupsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeGroupsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeMembersList(ctx context.Context, params *ProductTypeMembersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeMembersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeMembersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeMembersCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeMembersCreate(ctx context.Context, body ProductTypeMembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeMembersCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeMembersDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeMembersDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeMembersRetrieve(ctx context.Context, id int, params *ProductTypeMembersRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeMembersRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeMembersPartialUpdate(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeMembersPartialUpdateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeMembersUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeMembersUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeMembersUpdate(ctx context.Context, id int, body ProductTypeMembersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeMembersUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypeMembersDeletePreviewList(ctx context.Context, id int, params *ProductTypeMembersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypeMembersDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypesList(ctx context.Context, params *ProductTypesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypesCreate(ctx context.Context, body ProductTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypesRetrieve(ctx context.Context, id int, params *ProductTypesRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypesPartialUpdate(ctx context.Context, id int, body ProductTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypesUpdate(ctx context.Context, id int, body ProductTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypesDeletePreviewList(ctx context.Context, id int, params *ProductTypesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypesGenerateReportCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesGenerateReportCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypesGenerateReportCreate(ctx context.Context, id int, body ProductTypesGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesGenerateReportCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsList(ctx context.Context, params *ProductsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsCreate(ctx context.Context, body ProductsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsRetrieve(ctx context.Context, id int, params *ProductsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsPartialUpdate(ctx context.Context, id int, body ProductsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsUpdate(ctx context.Context, id int, body ProductsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsDeletePreviewList(ctx context.Context, id int, params *ProductsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsGenerateReportCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsGenerateReportCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsGenerateReportCreate(ctx context.Context, id int, body ProductsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsGenerateReportCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegulationsList(ctx context.Context, params *RegulationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegulationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegulationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegulationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegulationsCreate(ctx context.Context, body RegulationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegulationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegulationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegulationsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegulationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegulationsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegulationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegulationsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegulationsPartialUpdate(ctx context.Context, id int, body RegulationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegulationsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegulationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegulationsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegulationsUpdate(ctx context.Context, id int, body RegulationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegulationsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegulationsDeletePreviewList(ctx context.Context, id int, params *RegulationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegulationsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReimportScanCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReimportScanCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RolesList(ctx context.Context, params *RolesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRolesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RolesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRolesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaConfigurationsList(ctx context.Context, params *SlaConfigurationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaConfigurationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaConfigurationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaConfigurationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaConfigurationsCreate(ctx context.Context, body SlaConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaConfigurationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaConfigurationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaConfigurationsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaConfigurationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaConfigurationsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaConfigurationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaConfigurationsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaConfigurationsPartialUpdate(ctx context.Context, id int, body SlaConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaConfigurationsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaConfigurationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaConfigurationsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlaConfigurationsUpdate(ctx context.Context, id int, body SlaConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlaConfigurationsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeIssuesList(ctx context.Context, params *SonarqubeIssuesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeIssuesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeIssuesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeIssuesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeIssuesCreate(ctx context.Context, body SonarqubeIssuesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeIssuesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeIssuesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeIssuesDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeIssuesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeIssuesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeIssuesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeIssuesPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeIssuesPartialUpdate(ctx context.Context, id int, body SonarqubeIssuesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeIssuesPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeIssuesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeIssuesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeIssuesUpdate(ctx context.Context, id int, body SonarqubeIssuesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeIssuesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeIssuesDeletePreviewList(ctx context.Context, id int, params *SonarqubeIssuesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeIssuesDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeTransitionsList(ctx context.Context, params *SonarqubeTransitionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeTransitionsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeTransitionsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeTransitionsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeTransitionsCreate(ctx context.Context, body SonarqubeTransitionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeTransitionsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeTransitionsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeTransitionsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeTransitionsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeTransitionsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeTransitionsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeTransitionsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeTransitionsPartialUpdate(ctx context.Context, id int, body SonarqubeTransitionsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeTransitionsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeTransitionsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeTransitionsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeTransitionsUpdate(ctx context.Context, id int, body SonarqubeTransitionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeTransitionsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SonarqubeTransitionsDeletePreviewList(ctx context.Context, id int, params *SonarqubeTransitionsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSonarqubeTransitionsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StubFindingsList(ctx context.Context, params *StubFindingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStubFindingsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StubFindingsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStubFindingsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StubFindingsCreate(ctx context.Context, body StubFindingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStubFindingsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StubFindingsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStubFindingsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StubFindingsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStubFindingsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StubFindingsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStubFindingsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StubFindingsPartialUpdate(ctx context.Context, id int, body StubFindingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStubFindingsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StubFindingsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStubFindingsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StubFindingsUpdate(ctx context.Context, id int, body StubFindingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStubFindingsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StubFindingsDeletePreviewList(ctx context.Context, id int, params *StubFindingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStubFindingsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SystemSettingsList(ctx context.Context, params *SystemSettingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSystemSettingsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SystemSettingsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSystemSettingsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SystemSettingsPartialUpdate(ctx context.Context, id int, body SystemSettingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSystemSettingsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SystemSettingsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSystemSettingsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SystemSettingsUpdate(ctx context.Context, id int, body SystemSettingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSystemSettingsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TechnologiesList(ctx context.Context, params *TechnologiesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTechnologiesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TechnologiesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTechnologiesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TechnologiesCreate(ctx context.Context, body TechnologiesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTechnologiesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TechnologiesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTechnologiesDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TechnologiesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTechnologiesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TechnologiesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTechnologiesPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TechnologiesPartialUpdate(ctx context.Context, id int, body TechnologiesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTechnologiesPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TechnologiesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTechnologiesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TechnologiesUpdate(ctx context.Context, id int, body TechnologiesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTechnologiesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TechnologiesDeletePreviewList(ctx context.Context, id int, params *TechnologiesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTechnologiesDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestImportsList(ctx context.Context, params *TestImportsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestImportsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestImportsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestImportsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestImportsCreate(ctx context.Context, body TestImportsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestImportsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestImportsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestImportsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestImportsRetrieve(ctx context.Context, id int, params *TestImportsRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestImportsRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestImportsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestImportsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestImportsPartialUpdate(ctx context.Context, id int, body TestImportsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestImportsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestImportsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestImportsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestImportsUpdate(ctx context.Context, id int, body TestImportsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestImportsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestImportsDeletePreviewList(ctx context.Context, id int, params *TestImportsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestImportsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestTypesList(ctx context.Context, params *TestTypesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestTypesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestTypesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestTypesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestTypesCreate(ctx context.Context, body TestTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestTypesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestTypesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestTypesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestTypesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestTypesPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestTypesPartialUpdate(ctx context.Context, id int, body TestTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestTypesPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestTypesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestTypesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestTypesUpdate(ctx context.Context, id int, body TestTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestTypesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsList(ctx context.Context, params *TestsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsCreate(ctx context.Context, body TestsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsPartialUpdate(ctx context.Context, id int, body TestsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsUpdate(ctx context.Context, id int, body TestsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsAcceptRisksCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsAcceptRisksCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsAcceptRisksCreate(ctx context.Context, id int, body TestsAcceptRisksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsAcceptRisksCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsDeletePreviewList(ctx context.Context, id int, params *TestsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsFilesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsFilesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsFilesCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsFilesCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsGenerateReportCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsGenerateReportCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsGenerateReportCreate(ctx context.Context, id int, body TestsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsGenerateReportCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsNotesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsNotesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsNotesCreateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsNotesCreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestsNotesCreate(ctx context.Context, id int, body TestsNotesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestsNotesCreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolConfigurationsList(ctx context.Context, params *ToolConfigurationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolConfigurationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolConfigurationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolConfigurationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolConfigurationsCreate(ctx context.Context, body ToolConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolConfigurationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolConfigurationsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolConfigurationsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolConfigurationsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolConfigurationsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolConfigurationsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolConfigurationsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolConfigurationsPartialUpdate(ctx context.Context, id int, body ToolConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolConfigurationsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolConfigurationsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolConfigurationsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolConfigurationsUpdate(ctx context.Context, id int, body ToolConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolConfigurationsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolConfigurationsDeletePreviewList(ctx context.Context, id int, params *ToolConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolConfigurationsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolProductSettingsList(ctx context.Context, params *ToolProductSettingsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolProductSettingsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolProductSettingsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolProductSettingsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolProductSettingsCreate(ctx context.Context, body ToolProductSettingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolProductSettingsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolProductSettingsDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolProductSettingsDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolProductSettingsRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolProductSettingsRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolProductSettingsPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolProductSettingsPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolProductSettingsPartialUpdate(ctx context.Context, id int, body ToolProductSettingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolProductSettingsPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolProductSettingsUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolProductSettingsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolProductSettingsUpdate(ctx context.Context, id int, body ToolProductSettingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolProductSettingsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolProductSettingsDeletePreviewList(ctx context.Context, id int, params *ToolProductSettingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolProductSettingsDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolTypesList(ctx context.Context, params *ToolTypesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolTypesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolTypesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolTypesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolTypesCreate(ctx context.Context, body ToolTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolTypesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolTypesDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolTypesDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolTypesRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolTypesRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolTypesPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolTypesPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolTypesPartialUpdate(ctx context.Context, id int, body ToolTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolTypesPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolTypesUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolTypesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolTypesUpdate(ctx context.Context, id int, body ToolTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolTypesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToolTypesDeletePreviewList(ctx context.Context, id int, params *ToolTypesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToolTypesDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserContactInfosList(ctx context.Context, params *UserContactInfosListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserContactInfosListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserContactInfosCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserContactInfosCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserContactInfosCreate(ctx context.Context, body UserContactInfosCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserContactInfosCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserContactInfosDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserContactInfosDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserContactInfosRetrieve(ctx context.Context, id int, params *UserContactInfosRetrieveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserContactInfosRetrieveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserContactInfosPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserContactInfosPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserContactInfosPartialUpdate(ctx context.Context, id int, body UserContactInfosPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserContactInfosPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserContactInfosUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserContactInfosUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserContactInfosUpdate(ctx context.Context, id int, body UserContactInfosUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserContactInfosUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserContactInfosDeletePreviewList(ctx context.Context, id int, params *UserContactInfosDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserContactInfosDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserProfileRetrieve(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserProfileRetrieveRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersList(ctx context.Context, params *UsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersCreate(ctx context.Context, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersDestroy(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersDestroyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersRetrieve(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersRetrieveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersPartialUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersPartialUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersPartialUpdate(ctx context.Context, id int, body UsersPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersPartialUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdateWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdate(ctx context.Context, id int, body UsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersDeletePreviewList(ctx context.Context, id int, params *UsersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersDeletePreviewListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewApiTokenAuthCreateRequest calls the generic ApiTokenAuthCreate builder with application/json body
func NewApiTokenAuthCreateRequest(server string, body ApiTokenAuthCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApiTokenAuthCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewApiTokenAuthCreateRequestWithBody generates requests for ApiTokenAuthCreate with any type of body
func NewApiTokenAuthCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/api-token-auth/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConfigurationPermissionsListRequest generates requests for ConfigurationPermissionsList
func NewConfigurationPermissionsListRequest(server string, params *ConfigurationPermissionsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/configuration_permissions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Codename != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "codename", runtime.ParamLocationQuery, *params.Codename); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigurationPermissionsRetrieveRequest generates requests for ConfigurationPermissionsRetrieve
func NewConfigurationPermissionsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/configuration_permissions/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevelopmentEnvironmentsListRequest generates requests for DevelopmentEnvironmentsList
func NewDevelopmentEnvironmentsListRequest(server string, params *DevelopmentEnvironmentsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/development_environments/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevelopmentEnvironmentsCreateRequest calls the generic DevelopmentEnvironmentsCreate builder with application/json body
func NewDevelopmentEnvironmentsCreateRequest(server string, body DevelopmentEnvironmentsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevelopmentEnvironmentsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDevelopmentEnvironmentsCreateRequestWithBody generates requests for DevelopmentEnvironmentsCreate with any type of body
func NewDevelopmentEnvironmentsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/development_environments/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevelopmentEnvironmentsDestroyRequest generates requests for DevelopmentEnvironmentsDestroy
func NewDevelopmentEnvironmentsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/development_environments/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevelopmentEnvironmentsRetrieveRequest generates requests for DevelopmentEnvironmentsRetrieve
func NewDevelopmentEnvironmentsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/development_environments/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevelopmentEnvironmentsPartialUpdateRequest calls the generic DevelopmentEnvironmentsPartialUpdate builder with application/json body
func NewDevelopmentEnvironmentsPartialUpdateRequest(server string, id int, body DevelopmentEnvironmentsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevelopmentEnvironmentsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDevelopmentEnvironmentsPartialUpdateRequestWithBody generates requests for DevelopmentEnvironmentsPartialUpdate with any type of body
func NewDevelopmentEnvironmentsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/development_environments/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevelopmentEnvironmentsUpdateRequest calls the generic DevelopmentEnvironmentsUpdate builder with application/json body
func NewDevelopmentEnvironmentsUpdateRequest(server string, id int, body DevelopmentEnvironmentsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevelopmentEnvironmentsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDevelopmentEnvironmentsUpdateRequestWithBody generates requests for DevelopmentEnvironmentsUpdate with any type of body
func NewDevelopmentEnvironmentsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/development_environments/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDevelopmentEnvironmentsDeletePreviewListRequest generates requests for DevelopmentEnvironmentsDeletePreviewList
func NewDevelopmentEnvironmentsDeletePreviewListRequest(server string, id int, params *DevelopmentEnvironmentsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/development_environments/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDojoGroupMembersListRequest generates requests for DojoGroupMembersList
func NewDojoGroupMembersListRequest(server string, params *DojoGroupMembersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_group_members/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.GroupId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group_id", runtime.ParamLocationQuery, *params.GroupId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDojoGroupMembersCreateRequest calls the generic DojoGroupMembersCreate builder with application/json body
func NewDojoGroupMembersCreateRequest(server string, body DojoGroupMembersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDojoGroupMembersCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDojoGroupMembersCreateRequestWithBody generates requests for DojoGroupMembersCreate with any type of body
func NewDojoGroupMembersCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_group_members/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDojoGroupMembersDestroyRequest generates requests for DojoGroupMembersDestroy
func NewDojoGroupMembersDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_group_members/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDojoGroupMembersRetrieveRequest generates requests for DojoGroupMembersRetrieve
func NewDojoGroupMembersRetrieveRequest(server string, id int, params *DojoGroupMembersRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_group_members/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDojoGroupMembersPartialUpdateRequest calls the generic DojoGroupMembersPartialUpdate builder with application/json body
func NewDojoGroupMembersPartialUpdateRequest(server string, id int, body DojoGroupMembersPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDojoGroupMembersPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDojoGroupMembersPartialUpdateRequestWithBody generates requests for DojoGroupMembersPartialUpdate with any type of body
func NewDojoGroupMembersPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_group_members/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDojoGroupMembersUpdateRequest calls the generic DojoGroupMembersUpdate builder with application/json body
func NewDojoGroupMembersUpdateRequest(server string, id int, body DojoGroupMembersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDojoGroupMembersUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDojoGroupMembersUpdateRequestWithBody generates requests for DojoGroupMembersUpdate with any type of body
func NewDojoGroupMembersUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_group_members/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDojoGroupMembersDeletePreviewListRequest generates requests for DojoGroupMembersDeletePreviewList
func NewDojoGroupMembersDeletePreviewListRequest(server string, id int, params *DojoGroupMembersDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_group_members/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDojoGroupsListRequest generates requests for DojoGroupsList
func NewDojoGroupsListRequest(server string, params *DojoGroupsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_groups/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SocialProvider != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "social_provider", runtime.ParamLocationQuery, *params.SocialProvider); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDojoGroupsCreateRequest calls the generic DojoGroupsCreate builder with application/json body
func NewDojoGroupsCreateRequest(server string, body DojoGroupsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDojoGroupsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDojoGroupsCreateRequestWithBody generates requests for DojoGroupsCreate with any type of body
func NewDojoGroupsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_groups/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDojoGroupsDestroyRequest generates requests for DojoGroupsDestroy
func NewDojoGroupsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_groups/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDojoGroupsRetrieveRequest generates requests for DojoGroupsRetrieve
func NewDojoGroupsRetrieveRequest(server string, id int, params *DojoGroupsRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_groups/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDojoGroupsPartialUpdateRequest calls the generic DojoGroupsPartialUpdate builder with application/json body
func NewDojoGroupsPartialUpdateRequest(server string, id int, body DojoGroupsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDojoGroupsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDojoGroupsPartialUpdateRequestWithBody generates requests for DojoGroupsPartialUpdate with any type of body
func NewDojoGroupsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_groups/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDojoGroupsUpdateRequest calls the generic DojoGroupsUpdate builder with application/json body
func NewDojoGroupsUpdateRequest(server string, id int, body DojoGroupsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDojoGroupsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDojoGroupsUpdateRequestWithBody generates requests for DojoGroupsUpdate with any type of body
func NewDojoGroupsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_groups/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDojoGroupsDeletePreviewListRequest generates requests for DojoGroupsDeletePreviewList
func NewDojoGroupsDeletePreviewListRequest(server string, id int, params *DojoGroupsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dojo_groups/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndpointMetaImportCreateRequestWithBody generates requests for EndpointMetaImportCreate with any type of body
func NewEndpointMetaImportCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoint_meta_import/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEndpointStatusListRequest generates requests for EndpointStatusList
func NewEndpointStatusListRequest(server string, params *EndpointStatusListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoint_status/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Endpoint != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endpoint", runtime.ParamLocationQuery, *params.Endpoint); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FalsePositive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "false_positive", runtime.ParamLocationQuery, *params.FalsePositive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Finding != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Mitigated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mitigated", runtime.ParamLocationQuery, *params.Mitigated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MitigatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mitigated_by", runtime.ParamLocationQuery, *params.MitigatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutOfScope != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "out_of_scope", runtime.ParamLocationQuery, *params.OutOfScope); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RiskAccepted != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "risk_accepted", runtime.ParamLocationQuery, *params.RiskAccepted); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndpointStatusCreateRequest calls the generic EndpointStatusCreate builder with application/json body
func NewEndpointStatusCreateRequest(server string, body EndpointStatusCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndpointStatusCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewEndpointStatusCreateRequestWithBody generates requests for EndpointStatusCreate with any type of body
func NewEndpointStatusCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoint_status/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEndpointStatusDestroyRequest generates requests for EndpointStatusDestroy
func NewEndpointStatusDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoint_status/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndpointStatusRetrieveRequest generates requests for EndpointStatusRetrieve
func NewEndpointStatusRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoint_status/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndpointStatusPartialUpdateRequest calls the generic EndpointStatusPartialUpdate builder with application/json body
func NewEndpointStatusPartialUpdateRequest(server string, id int, body EndpointStatusPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndpointStatusPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEndpointStatusPartialUpdateRequestWithBody generates requests for EndpointStatusPartialUpdate with any type of body
func NewEndpointStatusPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoint_status/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEndpointStatusUpdateRequest calls the generic EndpointStatusUpdate builder with application/json body
func NewEndpointStatusUpdateRequest(server string, id int, body EndpointStatusUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndpointStatusUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEndpointStatusUpdateRequestWithBody generates requests for EndpointStatusUpdate with any type of body
func NewEndpointStatusUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoint_status/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEndpointStatusDeletePreviewListRequest generates requests for EndpointStatusDeletePreviewList
func NewEndpointStatusDeletePreviewListRequest(server string, id int, params *EndpointStatusDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoint_status/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndpointsListRequest generates requests for EndpointsList
func NewEndpointsListRequest(server string, params *EndpointsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoints/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Fragment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fragment", runtime.ParamLocationQuery, *params.Fragment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Host != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, *params.Host); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_tag", runtime.ParamLocationQuery, *params.NotTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_tags", runtime.ParamLocationQuery, *params.NotTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.O != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "o", runtime.ParamLocationQuery, *params.O); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Path != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Port != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "port", runtime.ParamLocationQuery, *params.Port); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Protocol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "protocol", runtime.ParamLocationQuery, *params.Protocol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Userinfo != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userinfo", runtime.ParamLocationQuery, *params.Userinfo); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndpointsCreateRequest calls the generic EndpointsCreate builder with application/json body
func NewEndpointsCreateRequest(server string, body EndpointsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndpointsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewEndpointsCreateRequestWithBody generates requests for EndpointsCreate with any type of body
func NewEndpointsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoints/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEndpointsDestroyRequest generates requests for EndpointsDestroy
func NewEndpointsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoints/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndpointsRetrieveRequest generates requests for EndpointsRetrieve
func NewEndpointsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoints/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndpointsPartialUpdateRequest calls the generic EndpointsPartialUpdate builder with application/json body
func NewEndpointsPartialUpdateRequest(server string, id int, body EndpointsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndpointsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEndpointsPartialUpdateRequestWithBody generates requests for EndpointsPartialUpdate with any type of body
func NewEndpointsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoints/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEndpointsUpdateRequest calls the generic EndpointsUpdate builder with application/json body
func NewEndpointsUpdateRequest(server string, id int, body EndpointsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndpointsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEndpointsUpdateRequestWithBody generates requests for EndpointsUpdate with any type of body
func NewEndpointsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoints/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEndpointsDeletePreviewListRequest generates requests for EndpointsDeletePreviewList
func NewEndpointsDeletePreviewListRequest(server string, id int, params *EndpointsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoints/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndpointsGenerateReportCreateRequest calls the generic EndpointsGenerateReportCreate builder with application/json body
func NewEndpointsGenerateReportCreateRequest(server string, id int, body EndpointsGenerateReportCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndpointsGenerateReportCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEndpointsGenerateReportCreateRequestWithBody generates requests for EndpointsGenerateReportCreate with any type of body
func NewEndpointsGenerateReportCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/endpoints/%s/generate_report/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementPresetsListRequest generates requests for EngagementPresetsList
func NewEngagementPresetsListRequest(server string, params *EngagementPresetsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagement_presets/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Title != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementPresetsCreateRequest calls the generic EngagementPresetsCreate builder with application/json body
func NewEngagementPresetsCreateRequest(server string, body EngagementPresetsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementPresetsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewEngagementPresetsCreateRequestWithBody generates requests for EngagementPresetsCreate with any type of body
func NewEngagementPresetsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagement_presets/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementPresetsDestroyRequest generates requests for EngagementPresetsDestroy
func NewEngagementPresetsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagement_presets/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementPresetsRetrieveRequest generates requests for EngagementPresetsRetrieve
func NewEngagementPresetsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagement_presets/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementPresetsPartialUpdateRequest calls the generic EngagementPresetsPartialUpdate builder with application/json body
func NewEngagementPresetsPartialUpdateRequest(server string, id int, body EngagementPresetsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementPresetsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEngagementPresetsPartialUpdateRequestWithBody generates requests for EngagementPresetsPartialUpdate with any type of body
func NewEngagementPresetsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagement_presets/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementPresetsUpdateRequest calls the generic EngagementPresetsUpdate builder with application/json body
func NewEngagementPresetsUpdateRequest(server string, id int, body EngagementPresetsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementPresetsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEngagementPresetsUpdateRequestWithBody generates requests for EngagementPresetsUpdate with any type of body
func NewEngagementPresetsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagement_presets/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementPresetsDeletePreviewListRequest generates requests for EngagementPresetsDeletePreviewList
func NewEngagementPresetsDeletePreviewListRequest(server string, id int, params *EngagementPresetsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagement_presets/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementsListRequest generates requests for EngagementsList
func NewEngagementsListRequest(server string, params *EngagementsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Active != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ApiTest != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "api_test", runtime.ParamLocationQuery, *params.ApiTest); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotProductTagsName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_product__tags__name", runtime.ParamLocationQuery, *params.NotProductTagsName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_tag", runtime.ParamLocationQuery, *params.NotTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_tags", runtime.ParamLocationQuery, *params.NotTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.O != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "o", runtime.ParamLocationQuery, *params.O); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PenTest != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pen_test", runtime.ParamLocationQuery, *params.PenTest); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProductProdType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "product__prod_type", runtime.ParamLocationQuery, *params.ProductProdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProductTagsName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "product__tags__name", runtime.ParamLocationQuery, *params.ProductTagsName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ReportType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "report_type", runtime.ParamLocationQuery, *params.ReportType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Requester != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requester", runtime.ParamLocationQuery, *params.Requester); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TargetEnd != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_end", runtime.ParamLocationQuery, *params.TargetEnd); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TargetStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_start", runtime.ParamLocationQuery, *params.TargetStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ThreatModel != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "threat_model", runtime.ParamLocationQuery, *params.ThreatModel); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Updated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated", runtime.ParamLocationQuery, *params.Updated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Version != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementsCreateRequest calls the generic EngagementsCreate builder with application/json body
func NewEngagementsCreateRequest(server string, body EngagementsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewEngagementsCreateRequestWithBody generates requests for EngagementsCreate with any type of body
func NewEngagementsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsDestroyRequest generates requests for EngagementsDestroy
func NewEngagementsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementsRetrieveRequest generates requests for EngagementsRetrieve
func NewEngagementsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementsPartialUpdateRequest calls the generic EngagementsPartialUpdate builder with application/json body
func NewEngagementsPartialUpdateRequest(server string, id int, body EngagementsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEngagementsPartialUpdateRequestWithBody generates requests for EngagementsPartialUpdate with any type of body
func NewEngagementsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsUpdateRequest calls the generic EngagementsUpdate builder with application/json body
func NewEngagementsUpdateRequest(server string, id int, body EngagementsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEngagementsUpdateRequestWithBody generates requests for EngagementsUpdate with any type of body
func NewEngagementsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsAcceptRisksCreateRequest calls the generic EngagementsAcceptRisksCreate builder with application/json body
func NewEngagementsAcceptRisksCreateRequest(server string, id int, body EngagementsAcceptRisksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementsAcceptRisksCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEngagementsAcceptRisksCreateRequestWithBody generates requests for EngagementsAcceptRisksCreate with any type of body
func NewEngagementsAcceptRisksCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/accept_risks/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsCloseCreateRequest generates requests for EngagementsCloseCreate
func NewEngagementsCloseCreateRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/close/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementsDeletePreviewListRequest generates requests for EngagementsDeletePreviewList
func NewEngagementsDeletePreviewListRequest(server string, id int, params *EngagementsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementsFilesRetrieveRequest generates requests for EngagementsFilesRetrieve
func NewEngagementsFilesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/files/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementsFilesCreateRequestWithBody generates requests for EngagementsFilesCreate with any type of body
func NewEngagementsFilesCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/files/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsGenerateReportCreateRequest calls the generic EngagementsGenerateReportCreate builder with application/json body
func NewEngagementsGenerateReportCreateRequest(server string, id int, body EngagementsGenerateReportCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementsGenerateReportCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEngagementsGenerateReportCreateRequestWithBody generates requests for EngagementsGenerateReportCreate with any type of body
func NewEngagementsGenerateReportCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/generate_report/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsNotesRetrieveRequest generates requests for EngagementsNotesRetrieve
func NewEngagementsNotesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/notes/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEngagementsNotesCreateRequest calls the generic EngagementsNotesCreate builder with application/json body
func NewEngagementsNotesCreateRequest(server string, id int, body EngagementsNotesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngagementsNotesCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEngagementsNotesCreateRequestWithBody generates requests for EngagementsNotesCreate with any type of body
func NewEngagementsNotesCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/notes/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngagementsReopenCreateRequest generates requests for EngagementsReopenCreate
func NewEngagementsReopenCreateRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/engagements/%s/reopen/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingTemplatesListRequest generates requests for FindingTemplatesList
func NewFindingTemplatesListRequest(server string, params *FindingTemplatesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/finding_templates/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Cwe != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cwe", runtime.ParamLocationQuery, *params.Cwe); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Description != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Mitigation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mitigation", runtime.ParamLocationQuery, *params.Mitigation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_tag", runtime.ParamLocationQuery, *params.NotTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_tags", runtime.ParamLocationQuery, *params.NotTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.O != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "o", runtime.ParamLocationQuery, *params.O); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Severity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Title != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingTemplatesCreateRequest calls the generic FindingTemplatesCreate builder with application/json body
func NewFindingTemplatesCreateRequest(server string, body FindingTemplatesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingTemplatesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewFindingTemplatesCreateRequestWithBody generates requests for FindingTemplatesCreate with any type of body
func NewFindingTemplatesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/finding_templates/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingTemplatesDestroyRequest generates requests for FindingTemplatesDestroy
func NewFindingTemplatesDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/finding_templates/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingTemplatesRetrieveRequest generates requests for FindingTemplatesRetrieve
func NewFindingTemplatesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/finding_templates/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingTemplatesPartialUpdateRequest calls the generic FindingTemplatesPartialUpdate builder with application/json body
func NewFindingTemplatesPartialUpdateRequest(server string, id int, body FindingTemplatesPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingTemplatesPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingTemplatesPartialUpdateRequestWithBody generates requests for FindingTemplatesPartialUpdate with any type of body
func NewFindingTemplatesPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/finding_templates/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingTemplatesUpdateRequest calls the generic FindingTemplatesUpdate builder with application/json body
func NewFindingTemplatesUpdateRequest(server string, id int, body FindingTemplatesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingTemplatesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingTemplatesUpdateRequestWithBody generates requests for FindingTemplatesUpdate with any type of body
func NewFindingTemplatesUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/finding_templates/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingTemplatesDeletePreviewListRequest generates requests for FindingTemplatesDeletePreviewList
func NewFindingTemplatesDeletePreviewListRequest(server string, id int, params *FindingTemplatesDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/finding_templates/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsListRequest generates requests for FindingsList
func NewFindingsListRequest(server string, params *FindingsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Active != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ComponentName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "component_name", runtime.ParamLocationQuery, *params.ComponentName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ComponentVersion != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "component_version", runtime.ParamLocationQuery, *params.ComponentVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Created != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created", runtime.ParamLocationQuery, *params.Created); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cvssv3 != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cvssv3", runtime.ParamLocationQuery, *params.Cvssv3); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cvssv3Score != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cvssv3_score", runtime.ParamLocationQuery, *params.Cvssv3Score); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cwe != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cwe", runtime.ParamLocationQuery, *params.Cwe); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Date != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DefectReviewRequestedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "defect_review_requested_by", runtime.ParamLocationQuery, *params.DefectReviewRequestedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Description != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duplicate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duplicate", runtime.ParamLocationQuery, *params.Duplicate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DuplicateFinding != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duplicate_finding", runtime.ParamLocationQuery, *params.DuplicateFinding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DynamicFinding != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dynamic_finding", runtime.ParamLocationQuery, *params.DynamicFinding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Endpoints != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "endpoints", runtime.ParamLocationQuery, *params.Endpoints); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FalseP != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "false_p", runtime.ParamLocationQuery, *params.FalseP); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilePath != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_path", runtime.ParamLocationQuery, *params.FilePath); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FindingGroup != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "finding_group", runtime.ParamLocationQuery, *params.FindingGroup); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FoundBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "found_by", runtime.ParamLocationQuery, *params.FoundBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.HasJira != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_jira", runtime.ParamLocationQuery, *params.HasJira); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.HashCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hash_code", runtime.ParamLocationQuery, *params.HashCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Impact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "impact", runtime.ParamLocationQuery, *params.Impact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsMitigated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_mitigated", runtime.ParamLocationQuery, *params.IsMitigated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JiraChange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jira_change", runtime.ParamLocationQuery, *params.JiraChange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JiraCreation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jira_creation", runtime.ParamLocationQuery, *params.JiraCreation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LastReviewed != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_reviewed", runtime.ParamLocationQuery, *params.LastReviewed); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LastReviewedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "last_reviewed_by", runtime.ParamLocationQuery, *params.LastReviewedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LastStatusUpdate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_status_update", runtime.ParamLocationQuery, *params.LastStatusUpdate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Mitigated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mitigated", runtime.ParamLocationQuery, *params.Mitigated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MitigatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mitigated_by", runtime.ParamLocationQuery, *params.MitigatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Mitigation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mitigation", runtime.ParamLocationQuery, *params.Mitigation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NbOccurences != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "nb_occurences", runtime.ParamLocationQuery, *params.NbOccurences); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_tag", runtime.ParamLocationQuery, *params.NotTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_tags", runtime.ParamLocationQuery, *params.NotTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTestEngagementProductTagsName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_test__engagement__product__tags__name", runtime.ParamLocationQuery, *params.NotTestEngagementProductTagsName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTestEngagementTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_test__engagement__tags", runtime.ParamLocationQuery, *params.NotTestEngagementTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTestTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_test__tags", runtime.ParamLocationQuery, *params.NotTestTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NumericalSeverity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "numerical_severity", runtime.ParamLocationQuery, *params.NumericalSeverity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.O != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "o", runtime.ParamLocationQuery, *params.O); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutOfScope != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "out_of_scope", runtime.ParamLocationQuery, *params.OutOfScope); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Param != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "param", runtime.ParamLocationQuery, *params.Param); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Payload != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PlannedRemediationDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "planned_remediation_date", runtime.ParamLocationQuery, *params.PlannedRemediationDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PublishDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publish_date", runtime.ParamLocationQuery, *params.PublishDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.References != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "references", runtime.ParamLocationQuery, *params.References); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RelatedFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "related_fields", runtime.ParamLocationQuery, *params.RelatedFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Reporter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reporter", runtime.ParamLocationQuery, *params.Reporter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ReviewRequestedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "review_requested_by", runtime.ParamLocationQuery, *params.ReviewRequestedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Reviewers != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reviewers", runtime.ParamLocationQuery, *params.Reviewers); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RiskAcceptance != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "risk_acceptance", runtime.ParamLocationQuery, *params.RiskAcceptance); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RiskAccepted != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "risk_accepted", runtime.ParamLocationQuery, *params.RiskAccepted); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SastSinkObject != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sast_sink_object", runtime.ParamLocationQuery, *params.SastSinkObject); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SastSourceFilePath != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sast_source_file_path", runtime.ParamLocationQuery, *params.SastSourceFilePath); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SastSourceLine != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sast_source_line", runtime.ParamLocationQuery, *params.SastSourceLine); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SastSourceObject != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sast_source_object", runtime.ParamLocationQuery, *params.SastSourceObject); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScannerConfidence != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scanner_confidence", runtime.ParamLocationQuery, *params.ScannerConfidence); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Service != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, *params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Severity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SeverityJustification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severity_justification", runtime.ParamLocationQuery, *params.SeverityJustification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SlaStartDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sla_start_date", runtime.ParamLocationQuery, *params.SlaStartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SonarqubeIssue != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sonarqube_issue", runtime.ParamLocationQuery, *params.SonarqubeIssue); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StaticFinding != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static_finding", runtime.ParamLocationQuery, *params.StaticFinding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StepsToReproduce != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "steps_to_reproduce", runtime.ParamLocationQuery, *params.StepsToReproduce); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Test != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestEngagement != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__engagement", runtime.ParamLocationQuery, *params.TestEngagement); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestEngagementProduct != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__engagement__product", runtime.ParamLocationQuery, *params.TestEngagementProduct); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestEngagementProductProdType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__engagement__product__prod_type", runtime.ParamLocationQuery, *params.TestEngagementProductProdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestEngagementProductTagsName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__engagement__product__tags__name", runtime.ParamLocationQuery, *params.TestEngagementProductTagsName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestEngagementTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__engagement__tags", runtime.ParamLocationQuery, *params.TestEngagementTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__tags", runtime.ParamLocationQuery, *params.TestTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestTestType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__test_type", runtime.ParamLocationQuery, *params.TestTestType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Title != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnderDefectReview != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "under_defect_review", runtime.ParamLocationQuery, *params.UnderDefectReview); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnderReview != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "under_review", runtime.ParamLocationQuery, *params.UnderReview); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UniqueIdFromTool != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unique_id_from_tool", runtime.ParamLocationQuery, *params.UniqueIdFromTool); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Verified != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "verified", runtime.ParamLocationQuery, *params.Verified); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VulnIdFromTool != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vuln_id_from_tool", runtime.ParamLocationQuery, *params.VulnIdFromTool); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VulnerabilityId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vulnerability_id", runtime.ParamLocationQuery, *params.VulnerabilityId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsCreateRequest calls the generic FindingsCreate builder with application/json body
func NewFindingsCreateRequest(server string, body FindingsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewFindingsCreateRequestWithBody generates requests for FindingsCreate with any type of body
func NewFindingsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsAcceptRisksCreateRequest calls the generic FindingsAcceptRisksCreate builder with application/json body
func NewFindingsAcceptRisksCreateRequest(server string, params *FindingsAcceptRisksCreateParams, body FindingsAcceptRisksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsAcceptRisksCreateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindingsAcceptRisksCreateRequestWithBody generates requests for FindingsAcceptRisksCreate with any type of body
func NewFindingsAcceptRisksCreateRequestWithBody(server string, params *FindingsAcceptRisksCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/accept_risks/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Active != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ComponentName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "component_name", runtime.ParamLocationQuery, *params.ComponentName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ComponentVersion != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "component_version", runtime.ParamLocationQuery, *params.ComponentVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Created != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created", runtime.ParamLocationQuery, *params.Created); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cvssv3 != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cvssv3", runtime.ParamLocationQuery, *params.Cvssv3); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cvssv3Score != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cvssv3_score", runtime.ParamLocationQuery, *params.Cvssv3Score); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cwe != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cwe", runtime.ParamLocationQuery, *params.Cwe); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Date != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DefectReviewRequestedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "defect_review_requested_by", runtime.ParamLocationQuery, *params.DefectReviewRequestedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Description != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duplicate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duplicate", runtime.ParamLocationQuery, *params.Duplicate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DuplicateFinding != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duplicate_finding", runtime.ParamLocationQuery, *params.DuplicateFinding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DynamicFinding != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dynamic_finding", runtime.ParamLocationQuery, *params.DynamicFinding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Endpoints != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "endpoints", runtime.ParamLocationQuery, *params.Endpoints); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FalseP != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "false_p", runtime.ParamLocationQuery, *params.FalseP); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilePath != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_path", runtime.ParamLocationQuery, *params.FilePath); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FindingGroup != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "finding_group", runtime.ParamLocationQuery, *params.FindingGroup); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FoundBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "found_by", runtime.ParamLocationQuery, *params.FoundBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.HasJira != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_jira", runtime.ParamLocationQuery, *params.HasJira); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.HashCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hash_code", runtime.ParamLocationQuery, *params.HashCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Impact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "impact", runtime.ParamLocationQuery, *params.Impact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsMitigated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_mitigated", runtime.ParamLocationQuery, *params.IsMitigated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JiraChange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jira_change", runtime.ParamLocationQuery, *params.JiraChange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JiraCreation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jira_creation", runtime.ParamLocationQuery, *params.JiraCreation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LastReviewed != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_reviewed", runtime.ParamLocationQuery, *params.LastReviewed); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LastReviewedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "last_reviewed_by", runtime.ParamLocationQuery, *params.LastReviewedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LastStatusUpdate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_status_update", runtime.ParamLocationQuery, *params.LastStatusUpdate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Mitigated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mitigated", runtime.ParamLocationQuery, *params.Mitigated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MitigatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mitigated_by", runtime.ParamLocationQuery, *params.MitigatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Mitigation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mitigation", runtime.ParamLocationQuery, *params.Mitigation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NbOccurences != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "nb_occurences", runtime.ParamLocationQuery, *params.NbOccurences); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_tag", runtime.ParamLocationQuery, *params.NotTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_tags", runtime.ParamLocationQuery, *params.NotTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTestEngagementProductTagsName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_test__engagement__product__tags__name", runtime.ParamLocationQuery, *params.NotTestEngagementProductTagsName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTestEngagementTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_test__engagement__tags", runtime.ParamLocationQuery, *params.NotTestEngagementTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTestTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_test__tags", runtime.ParamLocationQuery, *params.NotTestTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NumericalSeverity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "numerical_severity", runtime.ParamLocationQuery, *params.NumericalSeverity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.O != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "o", runtime.ParamLocationQuery, *params.O); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutOfScope != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "out_of_scope", runtime.ParamLocationQuery, *params.OutOfScope); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Param != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "param", runtime.ParamLocationQuery, *params.Param); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Payload != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PlannedRemediationDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "planned_remediation_date", runtime.ParamLocationQuery, *params.PlannedRemediationDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PublishDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publish_date", runtime.ParamLocationQuery, *params.PublishDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.References != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "references", runtime.ParamLocationQuery, *params.References); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Reporter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reporter", runtime.ParamLocationQuery, *params.Reporter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ReviewRequestedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "review_requested_by", runtime.ParamLocationQuery, *params.ReviewRequestedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Reviewers != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reviewers", runtime.ParamLocationQuery, *params.Reviewers); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RiskAcceptance != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "risk_acceptance", runtime.ParamLocationQuery, *params.RiskAcceptance); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RiskAccepted != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "risk_accepted", runtime.ParamLocationQuery, *params.RiskAccepted); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SastSinkObject != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sast_sink_object", runtime.ParamLocationQuery, *params.SastSinkObject); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SastSourceFilePath != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sast_source_file_path", runtime.ParamLocationQuery, *params.SastSourceFilePath); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SastSourceLine != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sast_source_line", runtime.ParamLocationQuery, *params.SastSourceLine); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SastSourceObject != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sast_source_object", runtime.ParamLocationQuery, *params.SastSourceObject); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScannerConfidence != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scanner_confidence", runtime.ParamLocationQuery, *params.ScannerConfidence); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Service != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, *params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Severity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SeverityJustification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severity_justification", runtime.ParamLocationQuery, *params.SeverityJustification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SlaStartDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sla_start_date", runtime.ParamLocationQuery, *params.SlaStartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SonarqubeIssue != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sonarqube_issue", runtime.ParamLocationQuery, *params.SonarqubeIssue); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StaticFinding != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static_finding", runtime.ParamLocationQuery, *params.StaticFinding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StepsToReproduce != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "steps_to_reproduce", runtime.ParamLocationQuery, *params.StepsToReproduce); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Test != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestEngagement != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__engagement", runtime.ParamLocationQuery, *params.TestEngagement); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestEngagementProduct != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__engagement__product", runtime.ParamLocationQuery, *params.TestEngagementProduct); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestEngagementProductProdType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__engagement__product__prod_type", runtime.ParamLocationQuery, *params.TestEngagementProductProdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestEngagementProductTagsName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__engagement__product__tags__name", runtime.ParamLocationQuery, *params.TestEngagementProductTagsName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestEngagementTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__engagement__tags", runtime.ParamLocationQuery, *params.TestEngagementTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__tags", runtime.ParamLocationQuery, *params.TestTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestTestType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "test__test_type", runtime.ParamLocationQuery, *params.TestTestType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Title != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnderDefectReview != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "under_defect_review", runtime.ParamLocationQuery, *params.UnderDefectReview); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnderReview != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "under_review", runtime.ParamLocationQuery, *params.UnderReview); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UniqueIdFromTool != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unique_id_from_tool", runtime.ParamLocationQuery, *params.UniqueIdFromTool); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Verified != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "verified", runtime.ParamLocationQuery, *params.Verified); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VulnIdFromTool != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vuln_id_from_tool", runtime.ParamLocationQuery, *params.VulnIdFromTool); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VulnerabilityId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vulnerability_id", runtime.ParamLocationQuery, *params.VulnerabilityId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsGenerateReportCreateRequest calls the generic FindingsGenerateReportCreate builder with application/json body
func NewFindingsGenerateReportCreateRequest(server string, body FindingsGenerateReportCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsGenerateReportCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewFindingsGenerateReportCreateRequestWithBody generates requests for FindingsGenerateReportCreate with any type of body
func NewFindingsGenerateReportCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/generate_report/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsDestroyRequest generates requests for FindingsDestroy
func NewFindingsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsRetrieveRequest generates requests for FindingsRetrieve
func NewFindingsRetrieveRequest(server string, id int, params *FindingsRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RelatedFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "related_fields", runtime.ParamLocationQuery, *params.RelatedFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsPartialUpdateRequest calls the generic FindingsPartialUpdate builder with application/json body
func NewFindingsPartialUpdateRequest(server string, id int, body FindingsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingsPartialUpdateRequestWithBody generates requests for FindingsPartialUpdate with any type of body
func NewFindingsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsUpdateRequest calls the generic FindingsUpdate builder with application/json body
func NewFindingsUpdateRequest(server string, id int, body FindingsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingsUpdateRequestWithBody generates requests for FindingsUpdate with any type of body
func NewFindingsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsCloseCreateRequest calls the generic FindingsCloseCreate builder with application/json body
func NewFindingsCloseCreateRequest(server string, id int, body FindingsCloseCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsCloseCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingsCloseCreateRequestWithBody generates requests for FindingsCloseCreate with any type of body
func NewFindingsCloseCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/close/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsDeletePreviewListRequest generates requests for FindingsDeletePreviewList
func NewFindingsDeletePreviewListRequest(server string, id int, params *FindingsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsDuplicateListRequest generates requests for FindingsDuplicateList
func NewFindingsDuplicateListRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/duplicate/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsDuplicateResetCreateRequest generates requests for FindingsDuplicateResetCreate
func NewFindingsDuplicateResetCreateRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/duplicate/reset/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsFilesRetrieveRequest generates requests for FindingsFilesRetrieve
func NewFindingsFilesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/files/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsFilesCreateRequestWithBody generates requests for FindingsFilesCreate with any type of body
func NewFindingsFilesCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/files/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsMetadataDestroyRequest generates requests for FindingsMetadataDestroy
func NewFindingsMetadataDestroyRequest(server string, id int, params *FindingsMetadataDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/metadata/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsMetadataListRequest generates requests for FindingsMetadataList
func NewFindingsMetadataListRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/metadata/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsMetadataCreateRequest calls the generic FindingsMetadataCreate builder with application/json body
func NewFindingsMetadataCreateRequest(server string, id int, body FindingsMetadataCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsMetadataCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingsMetadataCreateRequestWithBody generates requests for FindingsMetadataCreate with any type of body
func NewFindingsMetadataCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/metadata/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsMetadataUpdateRequest calls the generic FindingsMetadataUpdate builder with application/json body
func NewFindingsMetadataUpdateRequest(server string, id int, body FindingsMetadataUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsMetadataUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingsMetadataUpdateRequestWithBody generates requests for FindingsMetadataUpdate with any type of body
func NewFindingsMetadataUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/metadata/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsNotesRetrieveRequest generates requests for FindingsNotesRetrieve
func NewFindingsNotesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/notes/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsNotesCreateRequest calls the generic FindingsNotesCreate builder with application/json body
func NewFindingsNotesCreateRequest(server string, id int, body FindingsNotesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsNotesCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingsNotesCreateRequestWithBody generates requests for FindingsNotesCreate with any type of body
func NewFindingsNotesCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/notes/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsOriginalCreateRequest generates requests for FindingsOriginalCreate
func NewFindingsOriginalCreateRequest(server string, id int, newFid int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "new_fid", runtime.ParamLocationPath, newFid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/original/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsRemoveNotePartialUpdateRequest calls the generic FindingsRemoveNotePartialUpdate builder with application/json body
func NewFindingsRemoveNotePartialUpdateRequest(server string, id int, body FindingsRemoveNotePartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsRemoveNotePartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingsRemoveNotePartialUpdateRequestWithBody generates requests for FindingsRemoveNotePartialUpdate with any type of body
func NewFindingsRemoveNotePartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/remove_note/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsRemoveTagsPartialUpdateRequest calls the generic FindingsRemoveTagsPartialUpdate builder with application/json body
func NewFindingsRemoveTagsPartialUpdateRequest(server string, id int, body FindingsRemoveTagsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsRemoveTagsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingsRemoveTagsPartialUpdateRequestWithBody generates requests for FindingsRemoveTagsPartialUpdate with any type of body
func NewFindingsRemoveTagsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/remove_tags/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsRemoveTagsUpdateRequest calls the generic FindingsRemoveTagsUpdate builder with application/json body
func NewFindingsRemoveTagsUpdateRequest(server string, id int, body FindingsRemoveTagsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsRemoveTagsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingsRemoveTagsUpdateRequestWithBody generates requests for FindingsRemoveTagsUpdate with any type of body
func NewFindingsRemoveTagsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/remove_tags/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsRequestResponseRetrieveRequest generates requests for FindingsRequestResponseRetrieve
func NewFindingsRequestResponseRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/request_response/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsRequestResponseCreateRequest calls the generic FindingsRequestResponseCreate builder with application/json body
func NewFindingsRequestResponseCreateRequest(server string, id int, body FindingsRequestResponseCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsRequestResponseCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingsRequestResponseCreateRequestWithBody generates requests for FindingsRequestResponseCreate with any type of body
func NewFindingsRequestResponseCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/request_response/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindingsTagsRetrieveRequest generates requests for FindingsTagsRetrieve
func NewFindingsTagsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/tags/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindingsTagsCreateRequest calls the generic FindingsTagsCreate builder with application/json body
func NewFindingsTagsCreateRequest(server string, id int, body FindingsTagsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindingsTagsCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewFindingsTagsCreateRequestWithBody generates requests for FindingsTagsCreate with any type of body
func NewFindingsTagsCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/findings/%s/tags/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGlobalRolesListRequest generates requests for GlobalRolesList
func NewGlobalRolesListRequest(server string, params *GlobalRolesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/global_roles/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Group != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Role != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.User != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlobalRolesCreateRequest calls the generic GlobalRolesCreate builder with application/json body
func NewGlobalRolesCreateRequest(server string, body GlobalRolesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGlobalRolesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewGlobalRolesCreateRequestWithBody generates requests for GlobalRolesCreate with any type of body
func NewGlobalRolesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/global_roles/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGlobalRolesDestroyRequest generates requests for GlobalRolesDestroy
func NewGlobalRolesDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/global_roles/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlobalRolesRetrieveRequest generates requests for GlobalRolesRetrieve
func NewGlobalRolesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/global_roles/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlobalRolesPartialUpdateRequest calls the generic GlobalRolesPartialUpdate builder with application/json body
func NewGlobalRolesPartialUpdateRequest(server string, id int, body GlobalRolesPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGlobalRolesPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewGlobalRolesPartialUpdateRequestWithBody generates requests for GlobalRolesPartialUpdate with any type of body
func NewGlobalRolesPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/global_roles/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGlobalRolesUpdateRequest calls the generic GlobalRolesUpdate builder with application/json body
func NewGlobalRolesUpdateRequest(server string, id int, body GlobalRolesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGlobalRolesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewGlobalRolesUpdateRequestWithBody generates requests for GlobalRolesUpdate with any type of body
func NewGlobalRolesUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/global_roles/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGlobalRolesDeletePreviewListRequest generates requests for GlobalRolesDeletePreviewList
func NewGlobalRolesDeletePreviewListRequest(server string, id int, params *GlobalRolesDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/global_roles/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportLanguagesCreateRequestWithBody generates requests for ImportLanguagesCreate with any type of body
func NewImportLanguagesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/import-languages/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewImportScanCreateRequestWithBody generates requests for ImportScanCreate with any type of body
func NewImportScanCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/import-scan/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraConfigurationsListRequest generates requests for JiraConfigurationsList
func NewJiraConfigurationsListRequest(server string, params *JiraConfigurationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_configurations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Url != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, *params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraConfigurationsCreateRequest calls the generic JiraConfigurationsCreate builder with application/json body
func NewJiraConfigurationsCreateRequest(server string, body JiraConfigurationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraConfigurationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewJiraConfigurationsCreateRequestWithBody generates requests for JiraConfigurationsCreate with any type of body
func NewJiraConfigurationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_configurations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraConfigurationsDestroyRequest generates requests for JiraConfigurationsDestroy
func NewJiraConfigurationsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraConfigurationsRetrieveRequest generates requests for JiraConfigurationsRetrieve
func NewJiraConfigurationsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraConfigurationsPartialUpdateRequest calls the generic JiraConfigurationsPartialUpdate builder with application/json body
func NewJiraConfigurationsPartialUpdateRequest(server string, id int, body JiraConfigurationsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraConfigurationsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewJiraConfigurationsPartialUpdateRequestWithBody generates requests for JiraConfigurationsPartialUpdate with any type of body
func NewJiraConfigurationsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraConfigurationsUpdateRequest calls the generic JiraConfigurationsUpdate builder with application/json body
func NewJiraConfigurationsUpdateRequest(server string, id int, body JiraConfigurationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraConfigurationsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewJiraConfigurationsUpdateRequestWithBody generates requests for JiraConfigurationsUpdate with any type of body
func NewJiraConfigurationsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraConfigurationsDeletePreviewListRequest generates requests for JiraConfigurationsDeletePreviewList
func NewJiraConfigurationsDeletePreviewListRequest(server string, id int, params *JiraConfigurationsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_configurations/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraFindingMappingsListRequest generates requests for JiraFindingMappingsList
func NewJiraFindingMappingsListRequest(server string, params *JiraFindingMappingsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_finding_mappings/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Engagement != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "engagement", runtime.ParamLocationQuery, *params.Engagement); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Finding != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FindingGroup != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding_group", runtime.ParamLocationQuery, *params.FindingGroup); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JiraId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jira_id", runtime.ParamLocationQuery, *params.JiraId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JiraKey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jira_key", runtime.ParamLocationQuery, *params.JiraKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraFindingMappingsCreateRequest calls the generic JiraFindingMappingsCreate builder with application/json body
func NewJiraFindingMappingsCreateRequest(server string, body JiraFindingMappingsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraFindingMappingsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewJiraFindingMappingsCreateRequestWithBody generates requests for JiraFindingMappingsCreate with any type of body
func NewJiraFindingMappingsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_finding_mappings/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraFindingMappingsDestroyRequest generates requests for JiraFindingMappingsDestroy
func NewJiraFindingMappingsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_finding_mappings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraFindingMappingsRetrieveRequest generates requests for JiraFindingMappingsRetrieve
func NewJiraFindingMappingsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_finding_mappings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraFindingMappingsPartialUpdateRequest calls the generic JiraFindingMappingsPartialUpdate builder with application/json body
func NewJiraFindingMappingsPartialUpdateRequest(server string, id int, body JiraFindingMappingsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraFindingMappingsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewJiraFindingMappingsPartialUpdateRequestWithBody generates requests for JiraFindingMappingsPartialUpdate with any type of body
func NewJiraFindingMappingsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_finding_mappings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraFindingMappingsUpdateRequest calls the generic JiraFindingMappingsUpdate builder with application/json body
func NewJiraFindingMappingsUpdateRequest(server string, id int, body JiraFindingMappingsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraFindingMappingsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewJiraFindingMappingsUpdateRequestWithBody generates requests for JiraFindingMappingsUpdate with any type of body
func NewJiraFindingMappingsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_finding_mappings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraFindingMappingsDeletePreviewListRequest generates requests for JiraFindingMappingsDeletePreviewList
func NewJiraFindingMappingsDeletePreviewListRequest(server string, id int, params *JiraFindingMappingsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_finding_mappings/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraInstancesListRequest generates requests for JiraInstancesList
func NewJiraInstancesListRequest(server string, params *JiraInstancesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_instances/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Url != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, *params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraInstancesCreateRequest calls the generic JiraInstancesCreate builder with application/json body
func NewJiraInstancesCreateRequest(server string, body JiraInstancesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraInstancesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewJiraInstancesCreateRequestWithBody generates requests for JiraInstancesCreate with any type of body
func NewJiraInstancesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_instances/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraInstancesDestroyRequest generates requests for JiraInstancesDestroy
func NewJiraInstancesDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_instances/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraInstancesRetrieveRequest generates requests for JiraInstancesRetrieve
func NewJiraInstancesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_instances/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraInstancesPartialUpdateRequest calls the generic JiraInstancesPartialUpdate builder with application/json body
func NewJiraInstancesPartialUpdateRequest(server string, id int, body JiraInstancesPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraInstancesPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewJiraInstancesPartialUpdateRequestWithBody generates requests for JiraInstancesPartialUpdate with any type of body
func NewJiraInstancesPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_instances/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraInstancesUpdateRequest calls the generic JiraInstancesUpdate builder with application/json body
func NewJiraInstancesUpdateRequest(server string, id int, body JiraInstancesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraInstancesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewJiraInstancesUpdateRequestWithBody generates requests for JiraInstancesUpdate with any type of body
func NewJiraInstancesUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_instances/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraInstancesDeletePreviewListRequest generates requests for JiraInstancesDeletePreviewList
func NewJiraInstancesDeletePreviewListRequest(server string, id int, params *JiraInstancesDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_instances/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraProductConfigurationsListRequest generates requests for JiraProductConfigurationsList
func NewJiraProductConfigurationsListRequest(server string, params *JiraProductConfigurationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_product_configurations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Component != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "component", runtime.ParamLocationQuery, *params.Component); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EnableEngagementEpicMapping != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enable_engagement_epic_mapping", runtime.ParamLocationQuery, *params.EnableEngagementEpicMapping); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Engagement != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "engagement", runtime.ParamLocationQuery, *params.Engagement); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JiraInstance != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jira_instance", runtime.ParamLocationQuery, *params.JiraInstance); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProjectKey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_key", runtime.ParamLocationQuery, *params.ProjectKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PushAllIssues != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "push_all_issues", runtime.ParamLocationQuery, *params.PushAllIssues); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PushNotes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "push_notes", runtime.ParamLocationQuery, *params.PushNotes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraProductConfigurationsCreateRequest calls the generic JiraProductConfigurationsCreate builder with application/json body
func NewJiraProductConfigurationsCreateRequest(server string, body JiraProductConfigurationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraProductConfigurationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewJiraProductConfigurationsCreateRequestWithBody generates requests for JiraProductConfigurationsCreate with any type of body
func NewJiraProductConfigurationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_product_configurations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraProductConfigurationsDestroyRequest generates requests for JiraProductConfigurationsDestroy
func NewJiraProductConfigurationsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_product_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraProductConfigurationsRetrieveRequest generates requests for JiraProductConfigurationsRetrieve
func NewJiraProductConfigurationsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_product_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraProductConfigurationsPartialUpdateRequest calls the generic JiraProductConfigurationsPartialUpdate builder with application/json body
func NewJiraProductConfigurationsPartialUpdateRequest(server string, id int, body JiraProductConfigurationsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraProductConfigurationsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewJiraProductConfigurationsPartialUpdateRequestWithBody generates requests for JiraProductConfigurationsPartialUpdate with any type of body
func NewJiraProductConfigurationsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_product_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraProductConfigurationsUpdateRequest calls the generic JiraProductConfigurationsUpdate builder with application/json body
func NewJiraProductConfigurationsUpdateRequest(server string, id int, body JiraProductConfigurationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraProductConfigurationsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewJiraProductConfigurationsUpdateRequestWithBody generates requests for JiraProductConfigurationsUpdate with any type of body
func NewJiraProductConfigurationsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_product_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraProductConfigurationsDeletePreviewListRequest generates requests for JiraProductConfigurationsDeletePreviewList
func NewJiraProductConfigurationsDeletePreviewListRequest(server string, id int, params *JiraProductConfigurationsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_product_configurations/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraProjectsListRequest generates requests for JiraProjectsList
func NewJiraProjectsListRequest(server string, params *JiraProjectsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_projects/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Component != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "component", runtime.ParamLocationQuery, *params.Component); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EnableEngagementEpicMapping != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enable_engagement_epic_mapping", runtime.ParamLocationQuery, *params.EnableEngagementEpicMapping); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Engagement != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "engagement", runtime.ParamLocationQuery, *params.Engagement); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JiraInstance != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jira_instance", runtime.ParamLocationQuery, *params.JiraInstance); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProjectKey != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_key", runtime.ParamLocationQuery, *params.ProjectKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PushAllIssues != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "push_all_issues", runtime.ParamLocationQuery, *params.PushAllIssues); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PushNotes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "push_notes", runtime.ParamLocationQuery, *params.PushNotes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraProjectsCreateRequest calls the generic JiraProjectsCreate builder with application/json body
func NewJiraProjectsCreateRequest(server string, body JiraProjectsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraProjectsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewJiraProjectsCreateRequestWithBody generates requests for JiraProjectsCreate with any type of body
func NewJiraProjectsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_projects/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraProjectsDestroyRequest generates requests for JiraProjectsDestroy
func NewJiraProjectsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_projects/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraProjectsRetrieveRequest generates requests for JiraProjectsRetrieve
func NewJiraProjectsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_projects/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJiraProjectsPartialUpdateRequest calls the generic JiraProjectsPartialUpdate builder with application/json body
func NewJiraProjectsPartialUpdateRequest(server string, id int, body JiraProjectsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraProjectsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewJiraProjectsPartialUpdateRequestWithBody generates requests for JiraProjectsPartialUpdate with any type of body
func NewJiraProjectsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_projects/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraProjectsUpdateRequest calls the generic JiraProjectsUpdate builder with application/json body
func NewJiraProjectsUpdateRequest(server string, id int, body JiraProjectsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJiraProjectsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewJiraProjectsUpdateRequestWithBody generates requests for JiraProjectsUpdate with any type of body
func NewJiraProjectsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_projects/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJiraProjectsDeletePreviewListRequest generates requests for JiraProjectsDeletePreviewList
func NewJiraProjectsDeletePreviewListRequest(server string, id int, params *JiraProjectsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jira_projects/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLanguageTypesListRequest generates requests for LanguageTypesList
func NewLanguageTypesListRequest(server string, params *LanguageTypesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/language_types/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Color != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "color", runtime.ParamLocationQuery, *params.Color); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Language != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLanguageTypesCreateRequest calls the generic LanguageTypesCreate builder with application/json body
func NewLanguageTypesCreateRequest(server string, body LanguageTypesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLanguageTypesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewLanguageTypesCreateRequestWithBody generates requests for LanguageTypesCreate with any type of body
func NewLanguageTypesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/language_types/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLanguageTypesDestroyRequest generates requests for LanguageTypesDestroy
func NewLanguageTypesDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/language_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLanguageTypesRetrieveRequest generates requests for LanguageTypesRetrieve
func NewLanguageTypesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/language_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLanguageTypesPartialUpdateRequest calls the generic LanguageTypesPartialUpdate builder with application/json body
func NewLanguageTypesPartialUpdateRequest(server string, id int, body LanguageTypesPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLanguageTypesPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLanguageTypesPartialUpdateRequestWithBody generates requests for LanguageTypesPartialUpdate with any type of body
func NewLanguageTypesPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/language_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLanguageTypesUpdateRequest calls the generic LanguageTypesUpdate builder with application/json body
func NewLanguageTypesUpdateRequest(server string, id int, body LanguageTypesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLanguageTypesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLanguageTypesUpdateRequestWithBody generates requests for LanguageTypesUpdate with any type of body
func NewLanguageTypesUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/language_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLanguageTypesDeletePreviewListRequest generates requests for LanguageTypesDeletePreviewList
func NewLanguageTypesDeletePreviewListRequest(server string, id int, params *LanguageTypesDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/language_types/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLanguagesListRequest generates requests for LanguagesList
func NewLanguagesListRequest(server string, params *LanguagesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/languages/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Language != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLanguagesCreateRequest calls the generic LanguagesCreate builder with application/json body
func NewLanguagesCreateRequest(server string, body LanguagesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLanguagesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewLanguagesCreateRequestWithBody generates requests for LanguagesCreate with any type of body
func NewLanguagesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/languages/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLanguagesDestroyRequest generates requests for LanguagesDestroy
func NewLanguagesDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/languages/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLanguagesRetrieveRequest generates requests for LanguagesRetrieve
func NewLanguagesRetrieveRequest(server string, id int, params *LanguagesRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/languages/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLanguagesPartialUpdateRequest calls the generic LanguagesPartialUpdate builder with application/json body
func NewLanguagesPartialUpdateRequest(server string, id int, body LanguagesPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLanguagesPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLanguagesPartialUpdateRequestWithBody generates requests for LanguagesPartialUpdate with any type of body
func NewLanguagesPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/languages/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLanguagesUpdateRequest calls the generic LanguagesUpdate builder with application/json body
func NewLanguagesUpdateRequest(server string, id int, body LanguagesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLanguagesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLanguagesUpdateRequestWithBody generates requests for LanguagesUpdate with any type of body
func NewLanguagesUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/languages/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLanguagesDeletePreviewListRequest generates requests for LanguagesDeletePreviewList
func NewLanguagesDeletePreviewListRequest(server string, id int, params *LanguagesDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/languages/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataListRequest generates requests for MetadataList
func NewMetadataListRequest(server string, params *MetadataListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/metadata/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Endpoint != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endpoint", runtime.ParamLocationQuery, *params.Endpoint); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Finding != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Value != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, *params.Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataCreateRequest calls the generic MetadataCreate builder with application/json body
func NewMetadataCreateRequest(server string, body MetadataCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetadataCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewMetadataCreateRequestWithBody generates requests for MetadataCreate with any type of body
func NewMetadataCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/metadata/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetadataDestroyRequest generates requests for MetadataDestroy
func NewMetadataDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/metadata/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataRetrieveRequest generates requests for MetadataRetrieve
func NewMetadataRetrieveRequest(server string, id int, params *MetadataRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/metadata/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataPartialUpdateRequest calls the generic MetadataPartialUpdate builder with application/json body
func NewMetadataPartialUpdateRequest(server string, id int, body MetadataPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetadataPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewMetadataPartialUpdateRequestWithBody generates requests for MetadataPartialUpdate with any type of body
func NewMetadataPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/metadata/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetadataUpdateRequest calls the generic MetadataUpdate builder with application/json body
func NewMetadataUpdateRequest(server string, id int, body MetadataUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMetadataUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewMetadataUpdateRequestWithBody generates requests for MetadataUpdate with any type of body
func NewMetadataUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/metadata/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetadataDeletePreviewListRequest generates requests for MetadataDeletePreviewList
func NewMetadataDeletePreviewListRequest(server string, id int, params *MetadataDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/metadata/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNetworkLocationsListRequest generates requests for NetworkLocationsList
func NewNetworkLocationsListRequest(server string, params *NetworkLocationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/network_locations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Location != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location", runtime.ParamLocationQuery, *params.Location); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNetworkLocationsCreateRequest calls the generic NetworkLocationsCreate builder with application/json body
func NewNetworkLocationsCreateRequest(server string, body NetworkLocationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNetworkLocationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewNetworkLocationsCreateRequestWithBody generates requests for NetworkLocationsCreate with any type of body
func NewNetworkLocationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/network_locations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNetworkLocationsDestroyRequest generates requests for NetworkLocationsDestroy
func NewNetworkLocationsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/network_locations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNetworkLocationsRetrieveRequest generates requests for NetworkLocationsRetrieve
func NewNetworkLocationsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/network_locations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNetworkLocationsPartialUpdateRequest calls the generic NetworkLocationsPartialUpdate builder with application/json body
func NewNetworkLocationsPartialUpdateRequest(server string, id int, body NetworkLocationsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNetworkLocationsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewNetworkLocationsPartialUpdateRequestWithBody generates requests for NetworkLocationsPartialUpdate with any type of body
func NewNetworkLocationsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/network_locations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNetworkLocationsUpdateRequest calls the generic NetworkLocationsUpdate builder with application/json body
func NewNetworkLocationsUpdateRequest(server string, id int, body NetworkLocationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNetworkLocationsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewNetworkLocationsUpdateRequestWithBody generates requests for NetworkLocationsUpdate with any type of body
func NewNetworkLocationsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/network_locations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNetworkLocationsDeletePreviewListRequest generates requests for NetworkLocationsDeletePreviewList
func NewNetworkLocationsDeletePreviewListRequest(server string, id int, params *NetworkLocationsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/network_locations/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNoteTypeListRequest generates requests for NoteTypeList
func NewNoteTypeListRequest(server string, params *NoteTypeListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/note_type/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Description != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsActive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_active", runtime.ParamLocationQuery, *params.IsActive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsMandatory != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_mandatory", runtime.ParamLocationQuery, *params.IsMandatory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsSingle != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_single", runtime.ParamLocationQuery, *params.IsSingle); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNoteTypeCreateRequest calls the generic NoteTypeCreate builder with application/json body
func NewNoteTypeCreateRequest(server string, body NoteTypeCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNoteTypeCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewNoteTypeCreateRequestWithBody generates requests for NoteTypeCreate with any type of body
func NewNoteTypeCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/note_type/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNoteTypeDestroyRequest generates requests for NoteTypeDestroy
func NewNoteTypeDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/note_type/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNoteTypeRetrieveRequest generates requests for NoteTypeRetrieve
func NewNoteTypeRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/note_type/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNoteTypePartialUpdateRequest calls the generic NoteTypePartialUpdate builder with application/json body
func NewNoteTypePartialUpdateRequest(server string, id int, body NoteTypePartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNoteTypePartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewNoteTypePartialUpdateRequestWithBody generates requests for NoteTypePartialUpdate with any type of body
func NewNoteTypePartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/note_type/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNoteTypeUpdateRequest calls the generic NoteTypeUpdate builder with application/json body
func NewNoteTypeUpdateRequest(server string, id int, body NoteTypeUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNoteTypeUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewNoteTypeUpdateRequestWithBody generates requests for NoteTypeUpdate with any type of body
func NewNoteTypeUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/note_type/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNoteTypeDeletePreviewListRequest generates requests for NoteTypeDeletePreviewList
func NewNoteTypeDeletePreviewListRequest(server string, id int, params *NoteTypeDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/note_type/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNotesListRequest generates requests for NotesList
func NewNotesListRequest(server string, params *NotesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/notes/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Author != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "author", runtime.ParamLocationQuery, *params.Author); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Date != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EditTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "edit_time", runtime.ParamLocationQuery, *params.EditTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Edited != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "edited", runtime.ParamLocationQuery, *params.Edited); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Editor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "editor", runtime.ParamLocationQuery, *params.Editor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Entry != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entry", runtime.ParamLocationQuery, *params.Entry); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Private != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "private", runtime.ParamLocationQuery, *params.Private); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNotesRetrieveRequest generates requests for NotesRetrieve
func NewNotesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/notes/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNotesPartialUpdateRequest calls the generic NotesPartialUpdate builder with application/json body
func NewNotesPartialUpdateRequest(server string, id int, body NotesPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNotesPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewNotesPartialUpdateRequestWithBody generates requests for NotesPartialUpdate with any type of body
func NewNotesPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/notes/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNotesUpdateRequest calls the generic NotesUpdate builder with application/json body
func NewNotesUpdateRequest(server string, id int, body NotesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNotesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewNotesUpdateRequestWithBody generates requests for NotesUpdate with any type of body
func NewNotesUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/notes/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNotificationsListRequest generates requests for NotificationsList
func NewNotificationsListRequest(server string, params *NotificationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/notifications/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Template != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "template", runtime.ParamLocationQuery, *params.Template); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.User != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNotificationsCreateRequest calls the generic NotificationsCreate builder with application/json body
func NewNotificationsCreateRequest(server string, body NotificationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNotificationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewNotificationsCreateRequestWithBody generates requests for NotificationsCreate with any type of body
func NewNotificationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/notifications/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNotificationsDestroyRequest generates requests for NotificationsDestroy
func NewNotificationsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/notifications/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNotificationsRetrieveRequest generates requests for NotificationsRetrieve
func NewNotificationsRetrieveRequest(server string, id int, params *NotificationsRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/notifications/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNotificationsPartialUpdateRequest calls the generic NotificationsPartialUpdate builder with application/json body
func NewNotificationsPartialUpdateRequest(server string, id int, body NotificationsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNotificationsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewNotificationsPartialUpdateRequestWithBody generates requests for NotificationsPartialUpdate with any type of body
func NewNotificationsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/notifications/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNotificationsUpdateRequest calls the generic NotificationsUpdate builder with application/json body
func NewNotificationsUpdateRequest(server string, id int, body NotificationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNotificationsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewNotificationsUpdateRequestWithBody generates requests for NotificationsUpdate with any type of body
func NewNotificationsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/notifications/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNotificationsDeletePreviewListRequest generates requests for NotificationsDeletePreviewList
func NewNotificationsDeletePreviewListRequest(server string, id int, params *NotificationsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/notifications/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOa3SchemaRetrieveRequest generates requests for Oa3SchemaRetrieve
func NewOa3SchemaRetrieveRequest(server string, params *Oa3SchemaRetrieveParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/oa3/schema/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Lang != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductApiScanConfigurationsListRequest generates requests for ProductApiScanConfigurationsList
func NewProductApiScanConfigurationsListRequest(server string, params *ProductApiScanConfigurationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_api_scan_configurations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ServiceKey1 != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service_key_1", runtime.ParamLocationQuery, *params.ServiceKey1); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ServiceKey2 != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service_key_2", runtime.ParamLocationQuery, *params.ServiceKey2); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ServiceKey3 != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service_key_3", runtime.ParamLocationQuery, *params.ServiceKey3); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToolConfiguration != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tool_configuration", runtime.ParamLocationQuery, *params.ToolConfiguration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductApiScanConfigurationsCreateRequest calls the generic ProductApiScanConfigurationsCreate builder with application/json body
func NewProductApiScanConfigurationsCreateRequest(server string, body ProductApiScanConfigurationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductApiScanConfigurationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewProductApiScanConfigurationsCreateRequestWithBody generates requests for ProductApiScanConfigurationsCreate with any type of body
func NewProductApiScanConfigurationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_api_scan_configurations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductApiScanConfigurationsDestroyRequest generates requests for ProductApiScanConfigurationsDestroy
func NewProductApiScanConfigurationsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_api_scan_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductApiScanConfigurationsRetrieveRequest generates requests for ProductApiScanConfigurationsRetrieve
func NewProductApiScanConfigurationsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_api_scan_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductApiScanConfigurationsPartialUpdateRequest calls the generic ProductApiScanConfigurationsPartialUpdate builder with application/json body
func NewProductApiScanConfigurationsPartialUpdateRequest(server string, id int, body ProductApiScanConfigurationsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductApiScanConfigurationsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProductApiScanConfigurationsPartialUpdateRequestWithBody generates requests for ProductApiScanConfigurationsPartialUpdate with any type of body
func NewProductApiScanConfigurationsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_api_scan_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductApiScanConfigurationsUpdateRequest calls the generic ProductApiScanConfigurationsUpdate builder with application/json body
func NewProductApiScanConfigurationsUpdateRequest(server string, id int, body ProductApiScanConfigurationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductApiScanConfigurationsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProductApiScanConfigurationsUpdateRequestWithBody generates requests for ProductApiScanConfigurationsUpdate with any type of body
func NewProductApiScanConfigurationsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_api_scan_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductApiScanConfigurationsDeletePreviewListRequest generates requests for ProductApiScanConfigurationsDeletePreviewList
func NewProductApiScanConfigurationsDeletePreviewListRequest(server string, id int, params *ProductApiScanConfigurationsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_api_scan_configurations/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductGroupsListRequest generates requests for ProductGroupsList
func NewProductGroupsListRequest(server string, params *ProductGroupsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_groups/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.GroupId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group_id", runtime.ParamLocationQuery, *params.GroupId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProductId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_id", runtime.ParamLocationQuery, *params.ProductId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductGroupsCreateRequest calls the generic ProductGroupsCreate builder with application/json body
func NewProductGroupsCreateRequest(server string, body ProductGroupsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductGroupsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewProductGroupsCreateRequestWithBody generates requests for ProductGroupsCreate with any type of body
func NewProductGroupsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_groups/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductGroupsDestroyRequest generates requests for ProductGroupsDestroy
func NewProductGroupsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_groups/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductGroupsRetrieveRequest generates requests for ProductGroupsRetrieve
func NewProductGroupsRetrieveRequest(server string, id int, params *ProductGroupsRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_groups/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductGroupsPartialUpdateRequest generates requests for ProductGroupsPartialUpdate
func NewProductGroupsPartialUpdateRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_groups/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductGroupsUpdateRequest calls the generic ProductGroupsUpdate builder with application/json body
func NewProductGroupsUpdateRequest(server string, id int, body ProductGroupsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductGroupsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProductGroupsUpdateRequestWithBody generates requests for ProductGroupsUpdate with any type of body
func NewProductGroupsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_groups/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductGroupsDeletePreviewListRequest generates requests for ProductGroupsDeletePreviewList
func NewProductGroupsDeletePreviewListRequest(server string, id int, params *ProductGroupsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_groups/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductMembersListRequest generates requests for ProductMembersList
func NewProductMembersListRequest(server string, params *ProductMembersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_members/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProductId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_id", runtime.ParamLocationQuery, *params.ProductId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductMembersCreateRequest calls the generic ProductMembersCreate builder with application/json body
func NewProductMembersCreateRequest(server string, body ProductMembersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductMembersCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewProductMembersCreateRequestWithBody generates requests for ProductMembersCreate with any type of body
func NewProductMembersCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_members/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductMembersDestroyRequest generates requests for ProductMembersDestroy
func NewProductMembersDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_members/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductMembersRetrieveRequest generates requests for ProductMembersRetrieve
func NewProductMembersRetrieveRequest(server string, id int, params *ProductMembersRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_members/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductMembersPartialUpdateRequest generates requests for ProductMembersPartialUpdate
func NewProductMembersPartialUpdateRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_members/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductMembersUpdateRequest calls the generic ProductMembersUpdate builder with application/json body
func NewProductMembersUpdateRequest(server string, id int, body ProductMembersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductMembersUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProductMembersUpdateRequestWithBody generates requests for ProductMembersUpdate with any type of body
func NewProductMembersUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_members/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductMembersDeletePreviewListRequest generates requests for ProductMembersDeletePreviewList
func NewProductMembersDeletePreviewListRequest(server string, id int, params *ProductMembersDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_members/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypeGroupsListRequest generates requests for ProductTypeGroupsList
func NewProductTypeGroupsListRequest(server string, params *ProductTypeGroupsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_groups/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.GroupId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group_id", runtime.ParamLocationQuery, *params.GroupId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProductTypeId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_type_id", runtime.ParamLocationQuery, *params.ProductTypeId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypeGroupsCreateRequest calls the generic ProductTypeGroupsCreate builder with application/json body
func NewProductTypeGroupsCreateRequest(server string, body ProductTypeGroupsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductTypeGroupsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewProductTypeGroupsCreateRequestWithBody generates requests for ProductTypeGroupsCreate with any type of body
func NewProductTypeGroupsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_groups/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductTypeGroupsDestroyRequest generates requests for ProductTypeGroupsDestroy
func NewProductTypeGroupsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_groups/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypeGroupsRetrieveRequest generates requests for ProductTypeGroupsRetrieve
func NewProductTypeGroupsRetrieveRequest(server string, id int, params *ProductTypeGroupsRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_groups/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypeGroupsPartialUpdateRequest generates requests for ProductTypeGroupsPartialUpdate
func NewProductTypeGroupsPartialUpdateRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_groups/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypeGroupsUpdateRequest calls the generic ProductTypeGroupsUpdate builder with application/json body
func NewProductTypeGroupsUpdateRequest(server string, id int, body ProductTypeGroupsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductTypeGroupsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProductTypeGroupsUpdateRequestWithBody generates requests for ProductTypeGroupsUpdate with any type of body
func NewProductTypeGroupsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_groups/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductTypeGroupsDeletePreviewListRequest generates requests for ProductTypeGroupsDeletePreviewList
func NewProductTypeGroupsDeletePreviewListRequest(server string, id int, params *ProductTypeGroupsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_groups/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypeMembersListRequest generates requests for ProductTypeMembersList
func NewProductTypeMembersListRequest(server string, params *ProductTypeMembersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_members/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProductTypeId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product_type_id", runtime.ParamLocationQuery, *params.ProductTypeId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypeMembersCreateRequest calls the generic ProductTypeMembersCreate builder with application/json body
func NewProductTypeMembersCreateRequest(server string, body ProductTypeMembersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductTypeMembersCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewProductTypeMembersCreateRequestWithBody generates requests for ProductTypeMembersCreate with any type of body
func NewProductTypeMembersCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_members/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductTypeMembersDestroyRequest generates requests for ProductTypeMembersDestroy
func NewProductTypeMembersDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_members/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypeMembersRetrieveRequest generates requests for ProductTypeMembersRetrieve
func NewProductTypeMembersRetrieveRequest(server string, id int, params *ProductTypeMembersRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_members/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypeMembersPartialUpdateRequest generates requests for ProductTypeMembersPartialUpdate
func NewProductTypeMembersPartialUpdateRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_members/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypeMembersUpdateRequest calls the generic ProductTypeMembersUpdate builder with application/json body
func NewProductTypeMembersUpdateRequest(server string, id int, body ProductTypeMembersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductTypeMembersUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProductTypeMembersUpdateRequestWithBody generates requests for ProductTypeMembersUpdate with any type of body
func NewProductTypeMembersUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_members/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductTypeMembersDeletePreviewListRequest generates requests for ProductTypeMembersDeletePreviewList
func NewProductTypeMembersDeletePreviewListRequest(server string, id int, params *ProductTypeMembersDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_type_members/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypesListRequest generates requests for ProductTypesList
func NewProductTypesListRequest(server string, params *ProductTypesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_types/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Created != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created", runtime.ParamLocationQuery, *params.Created); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CriticalProduct != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "critical_product", runtime.ParamLocationQuery, *params.CriticalProduct); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.KeyProduct != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key_product", runtime.ParamLocationQuery, *params.KeyProduct); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Updated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated", runtime.ParamLocationQuery, *params.Updated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypesCreateRequest calls the generic ProductTypesCreate builder with application/json body
func NewProductTypesCreateRequest(server string, body ProductTypesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductTypesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewProductTypesCreateRequestWithBody generates requests for ProductTypesCreate with any type of body
func NewProductTypesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_types/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductTypesDestroyRequest generates requests for ProductTypesDestroy
func NewProductTypesDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypesRetrieveRequest generates requests for ProductTypesRetrieve
func NewProductTypesRetrieveRequest(server string, id int, params *ProductTypesRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypesPartialUpdateRequest calls the generic ProductTypesPartialUpdate builder with application/json body
func NewProductTypesPartialUpdateRequest(server string, id int, body ProductTypesPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductTypesPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProductTypesPartialUpdateRequestWithBody generates requests for ProductTypesPartialUpdate with any type of body
func NewProductTypesPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductTypesUpdateRequest calls the generic ProductTypesUpdate builder with application/json body
func NewProductTypesUpdateRequest(server string, id int, body ProductTypesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductTypesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProductTypesUpdateRequestWithBody generates requests for ProductTypesUpdate with any type of body
func NewProductTypesUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductTypesDeletePreviewListRequest generates requests for ProductTypesDeletePreviewList
func NewProductTypesDeletePreviewListRequest(server string, id int, params *ProductTypesDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_types/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypesGenerateReportCreateRequest calls the generic ProductTypesGenerateReportCreate builder with application/json body
func NewProductTypesGenerateReportCreateRequest(server string, id int, body ProductTypesGenerateReportCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductTypesGenerateReportCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProductTypesGenerateReportCreateRequestWithBody generates requests for ProductTypesGenerateReportCreate with any type of body
func NewProductTypesGenerateReportCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/product_types/%s/generate_report/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductsListRequest generates requests for ProductsList
func NewProductsListRequest(server string, params *ProductsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/products/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BusinessCriticality != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "business_criticality", runtime.ParamLocationQuery, *params.BusinessCriticality); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Created != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created", runtime.ParamLocationQuery, *params.Created); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Description != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExternalAudience != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "external_audience", runtime.ParamLocationQuery, *params.ExternalAudience); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InternetAccessible != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "internet_accessible", runtime.ParamLocationQuery, *params.InternetAccessible); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Lifecycle != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lifecycle", runtime.ParamLocationQuery, *params.Lifecycle); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_tag", runtime.ParamLocationQuery, *params.NotTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_tags", runtime.ParamLocationQuery, *params.NotTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.O != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "o", runtime.ParamLocationQuery, *params.O); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Origin != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "origin", runtime.ParamLocationQuery, *params.Origin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Platform != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platform", runtime.ParamLocationQuery, *params.Platform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProdNumericGrade != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "prod_numeric_grade", runtime.ParamLocationQuery, *params.ProdNumericGrade); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProdType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "prod_type", runtime.ParamLocationQuery, *params.ProdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProductManager != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "product_manager", runtime.ParamLocationQuery, *params.ProductManager); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Regulations != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "regulations", runtime.ParamLocationQuery, *params.Regulations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Revenue != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "revenue", runtime.ParamLocationQuery, *params.Revenue); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TeamManager != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "team_manager", runtime.ParamLocationQuery, *params.TeamManager); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TechnicalContact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "technical_contact", runtime.ParamLocationQuery, *params.TechnicalContact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tid", runtime.ParamLocationQuery, *params.Tid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Updated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated", runtime.ParamLocationQuery, *params.Updated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UserRecords != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user_records", runtime.ParamLocationQuery, *params.UserRecords); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductsCreateRequest calls the generic ProductsCreate builder with application/json body
func NewProductsCreateRequest(server string, body ProductsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewProductsCreateRequestWithBody generates requests for ProductsCreate with any type of body
func NewProductsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/products/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductsDestroyRequest generates requests for ProductsDestroy
func NewProductsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/products/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductsRetrieveRequest generates requests for ProductsRetrieve
func NewProductsRetrieveRequest(server string, id int, params *ProductsRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/products/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductsPartialUpdateRequest calls the generic ProductsPartialUpdate builder with application/json body
func NewProductsPartialUpdateRequest(server string, id int, body ProductsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProductsPartialUpdateRequestWithBody generates requests for ProductsPartialUpdate with any type of body
func NewProductsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/products/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductsUpdateRequest calls the generic ProductsUpdate builder with application/json body
func NewProductsUpdateRequest(server string, id int, body ProductsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProductsUpdateRequestWithBody generates requests for ProductsUpdate with any type of body
func NewProductsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/products/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProductsDeletePreviewListRequest generates requests for ProductsDeletePreviewList
func NewProductsDeletePreviewListRequest(server string, id int, params *ProductsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/products/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductsGenerateReportCreateRequest calls the generic ProductsGenerateReportCreate builder with application/json body
func NewProductsGenerateReportCreateRequest(server string, id int, body ProductsGenerateReportCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductsGenerateReportCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewProductsGenerateReportCreateRequestWithBody generates requests for ProductsGenerateReportCreate with any type of body
func NewProductsGenerateReportCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/products/%s/generate_report/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegulationsListRequest generates requests for RegulationsList
func NewRegulationsListRequest(server string, params *RegulationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/regulations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Description != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegulationsCreateRequest calls the generic RegulationsCreate builder with application/json body
func NewRegulationsCreateRequest(server string, body RegulationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegulationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewRegulationsCreateRequestWithBody generates requests for RegulationsCreate with any type of body
func NewRegulationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/regulations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegulationsDestroyRequest generates requests for RegulationsDestroy
func NewRegulationsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/regulations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegulationsRetrieveRequest generates requests for RegulationsRetrieve
func NewRegulationsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/regulations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegulationsPartialUpdateRequest calls the generic RegulationsPartialUpdate builder with application/json body
func NewRegulationsPartialUpdateRequest(server string, id int, body RegulationsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegulationsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRegulationsPartialUpdateRequestWithBody generates requests for RegulationsPartialUpdate with any type of body
func NewRegulationsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/regulations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegulationsUpdateRequest calls the generic RegulationsUpdate builder with application/json body
func NewRegulationsUpdateRequest(server string, id int, body RegulationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegulationsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRegulationsUpdateRequestWithBody generates requests for RegulationsUpdate with any type of body
func NewRegulationsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/regulations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegulationsDeletePreviewListRequest generates requests for RegulationsDeletePreviewList
func NewRegulationsDeletePreviewListRequest(server string, id int, params *RegulationsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/regulations/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReimportScanCreateRequestWithBody generates requests for ReimportScanCreate with any type of body
func NewReimportScanCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/reimport-scan/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRolesListRequest generates requests for RolesList
func NewRolesListRequest(server string, params *RolesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/roles/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRolesRetrieveRequest generates requests for RolesRetrieve
func NewRolesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/roles/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlaConfigurationsListRequest generates requests for SlaConfigurationsList
func NewSlaConfigurationsListRequest(server string, params *SlaConfigurationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sla_configurations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlaConfigurationsCreateRequest calls the generic SlaConfigurationsCreate builder with application/json body
func NewSlaConfigurationsCreateRequest(server string, body SlaConfigurationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlaConfigurationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSlaConfigurationsCreateRequestWithBody generates requests for SlaConfigurationsCreate with any type of body
func NewSlaConfigurationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sla_configurations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlaConfigurationsDestroyRequest generates requests for SlaConfigurationsDestroy
func NewSlaConfigurationsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sla_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlaConfigurationsRetrieveRequest generates requests for SlaConfigurationsRetrieve
func NewSlaConfigurationsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sla_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlaConfigurationsPartialUpdateRequest calls the generic SlaConfigurationsPartialUpdate builder with application/json body
func NewSlaConfigurationsPartialUpdateRequest(server string, id int, body SlaConfigurationsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlaConfigurationsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSlaConfigurationsPartialUpdateRequestWithBody generates requests for SlaConfigurationsPartialUpdate with any type of body
func NewSlaConfigurationsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sla_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlaConfigurationsUpdateRequest calls the generic SlaConfigurationsUpdate builder with application/json body
func NewSlaConfigurationsUpdateRequest(server string, id int, body SlaConfigurationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlaConfigurationsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSlaConfigurationsUpdateRequestWithBody generates requests for SlaConfigurationsUpdate with any type of body
func NewSlaConfigurationsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sla_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSonarqubeIssuesListRequest generates requests for SonarqubeIssuesList
func NewSonarqubeIssuesListRequest(server string, params *SonarqubeIssuesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_issues/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Key != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSonarqubeIssuesCreateRequest calls the generic SonarqubeIssuesCreate builder with application/json body
func NewSonarqubeIssuesCreateRequest(server string, body SonarqubeIssuesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSonarqubeIssuesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSonarqubeIssuesCreateRequestWithBody generates requests for SonarqubeIssuesCreate with any type of body
func NewSonarqubeIssuesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_issues/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSonarqubeIssuesDestroyRequest generates requests for SonarqubeIssuesDestroy
func NewSonarqubeIssuesDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_issues/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSonarqubeIssuesRetrieveRequest generates requests for SonarqubeIssuesRetrieve
func NewSonarqubeIssuesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_issues/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSonarqubeIssuesPartialUpdateRequest calls the generic SonarqubeIssuesPartialUpdate builder with application/json body
func NewSonarqubeIssuesPartialUpdateRequest(server string, id int, body SonarqubeIssuesPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSonarqubeIssuesPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSonarqubeIssuesPartialUpdateRequestWithBody generates requests for SonarqubeIssuesPartialUpdate with any type of body
func NewSonarqubeIssuesPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_issues/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSonarqubeIssuesUpdateRequest calls the generic SonarqubeIssuesUpdate builder with application/json body
func NewSonarqubeIssuesUpdateRequest(server string, id int, body SonarqubeIssuesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSonarqubeIssuesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSonarqubeIssuesUpdateRequestWithBody generates requests for SonarqubeIssuesUpdate with any type of body
func NewSonarqubeIssuesUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_issues/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSonarqubeIssuesDeletePreviewListRequest generates requests for SonarqubeIssuesDeletePreviewList
func NewSonarqubeIssuesDeletePreviewListRequest(server string, id int, params *SonarqubeIssuesDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_issues/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSonarqubeTransitionsListRequest generates requests for SonarqubeTransitionsList
func NewSonarqubeTransitionsListRequest(server string, params *SonarqubeTransitionsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_transitions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.FindingStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding_status", runtime.ParamLocationQuery, *params.FindingStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SonarqubeIssue != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sonarqube_issue", runtime.ParamLocationQuery, *params.SonarqubeIssue); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SonarqubeStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sonarqube_status", runtime.ParamLocationQuery, *params.SonarqubeStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Transitions != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transitions", runtime.ParamLocationQuery, *params.Transitions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSonarqubeTransitionsCreateRequest calls the generic SonarqubeTransitionsCreate builder with application/json body
func NewSonarqubeTransitionsCreateRequest(server string, body SonarqubeTransitionsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSonarqubeTransitionsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSonarqubeTransitionsCreateRequestWithBody generates requests for SonarqubeTransitionsCreate with any type of body
func NewSonarqubeTransitionsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_transitions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSonarqubeTransitionsDestroyRequest generates requests for SonarqubeTransitionsDestroy
func NewSonarqubeTransitionsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_transitions/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSonarqubeTransitionsRetrieveRequest generates requests for SonarqubeTransitionsRetrieve
func NewSonarqubeTransitionsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_transitions/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSonarqubeTransitionsPartialUpdateRequest calls the generic SonarqubeTransitionsPartialUpdate builder with application/json body
func NewSonarqubeTransitionsPartialUpdateRequest(server string, id int, body SonarqubeTransitionsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSonarqubeTransitionsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSonarqubeTransitionsPartialUpdateRequestWithBody generates requests for SonarqubeTransitionsPartialUpdate with any type of body
func NewSonarqubeTransitionsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_transitions/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSonarqubeTransitionsUpdateRequest calls the generic SonarqubeTransitionsUpdate builder with application/json body
func NewSonarqubeTransitionsUpdateRequest(server string, id int, body SonarqubeTransitionsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSonarqubeTransitionsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSonarqubeTransitionsUpdateRequestWithBody generates requests for SonarqubeTransitionsUpdate with any type of body
func NewSonarqubeTransitionsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_transitions/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSonarqubeTransitionsDeletePreviewListRequest generates requests for SonarqubeTransitionsDeletePreviewList
func NewSonarqubeTransitionsDeletePreviewListRequest(server string, id int, params *SonarqubeTransitionsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/sonarqube_transitions/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStubFindingsListRequest generates requests for StubFindingsList
func NewStubFindingsListRequest(server string, params *StubFindingsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/stub_findings/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Date != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Description != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Severity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Title != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStubFindingsCreateRequest calls the generic StubFindingsCreate builder with application/json body
func NewStubFindingsCreateRequest(server string, body StubFindingsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStubFindingsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewStubFindingsCreateRequestWithBody generates requests for StubFindingsCreate with any type of body
func NewStubFindingsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/stub_findings/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStubFindingsDestroyRequest generates requests for StubFindingsDestroy
func NewStubFindingsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/stub_findings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStubFindingsRetrieveRequest generates requests for StubFindingsRetrieve
func NewStubFindingsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/stub_findings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStubFindingsPartialUpdateRequest calls the generic StubFindingsPartialUpdate builder with application/json body
func NewStubFindingsPartialUpdateRequest(server string, id int, body StubFindingsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStubFindingsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewStubFindingsPartialUpdateRequestWithBody generates requests for StubFindingsPartialUpdate with any type of body
func NewStubFindingsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/stub_findings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStubFindingsUpdateRequest calls the generic StubFindingsUpdate builder with application/json body
func NewStubFindingsUpdateRequest(server string, id int, body StubFindingsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStubFindingsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewStubFindingsUpdateRequestWithBody generates requests for StubFindingsUpdate with any type of body
func NewStubFindingsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/stub_findings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStubFindingsDeletePreviewListRequest generates requests for StubFindingsDeletePreviewList
func NewStubFindingsDeletePreviewListRequest(server string, id int, params *StubFindingsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/stub_findings/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSystemSettingsListRequest generates requests for SystemSettingsList
func NewSystemSettingsListRequest(server string, params *SystemSettingsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/system_settings/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSystemSettingsPartialUpdateRequest calls the generic SystemSettingsPartialUpdate builder with application/json body
func NewSystemSettingsPartialUpdateRequest(server string, id int, body SystemSettingsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSystemSettingsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSystemSettingsPartialUpdateRequestWithBody generates requests for SystemSettingsPartialUpdate with any type of body
func NewSystemSettingsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/system_settings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSystemSettingsUpdateRequest calls the generic SystemSettingsUpdate builder with application/json body
func NewSystemSettingsUpdateRequest(server string, id int, body SystemSettingsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSystemSettingsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSystemSettingsUpdateRequestWithBody generates requests for SystemSettingsUpdate with any type of body
func NewSystemSettingsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/system_settings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTechnologiesListRequest generates requests for TechnologiesList
func NewTechnologiesListRequest(server string, params *TechnologiesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/technologies/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_tag", runtime.ParamLocationQuery, *params.NotTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_tags", runtime.ParamLocationQuery, *params.NotTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.User != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Version != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTechnologiesCreateRequest calls the generic TechnologiesCreate builder with application/json body
func NewTechnologiesCreateRequest(server string, body TechnologiesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTechnologiesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTechnologiesCreateRequestWithBody generates requests for TechnologiesCreate with any type of body
func NewTechnologiesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/technologies/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTechnologiesDestroyRequest generates requests for TechnologiesDestroy
func NewTechnologiesDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/technologies/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTechnologiesRetrieveRequest generates requests for TechnologiesRetrieve
func NewTechnologiesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/technologies/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTechnologiesPartialUpdateRequest calls the generic TechnologiesPartialUpdate builder with application/json body
func NewTechnologiesPartialUpdateRequest(server string, id int, body TechnologiesPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTechnologiesPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTechnologiesPartialUpdateRequestWithBody generates requests for TechnologiesPartialUpdate with any type of body
func NewTechnologiesPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/technologies/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTechnologiesUpdateRequest calls the generic TechnologiesUpdate builder with application/json body
func NewTechnologiesUpdateRequest(server string, id int, body TechnologiesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTechnologiesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTechnologiesUpdateRequestWithBody generates requests for TechnologiesUpdate with any type of body
func NewTechnologiesUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/technologies/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTechnologiesDeletePreviewListRequest generates requests for TechnologiesDeletePreviewList
func NewTechnologiesDeletePreviewListRequest(server string, id int, params *TechnologiesDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/technologies/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestImportsListRequest generates requests for TestImportsList
func NewTestImportsListRequest(server string, params *TestImportsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/test_imports/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BranchTag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branch_tag", runtime.ParamLocationQuery, *params.BranchTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BuildId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "build_id", runtime.ParamLocationQuery, *params.BuildId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CommitHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commit_hash", runtime.ParamLocationQuery, *params.CommitHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FindingsAffected != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "findings_affected", runtime.ParamLocationQuery, *params.FindingsAffected); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Test != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestImportFindingActionAction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test_import_finding_action__action", runtime.ParamLocationQuery, *params.TestImportFindingActionAction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestImportFindingActionCreated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test_import_finding_action__created", runtime.ParamLocationQuery, *params.TestImportFindingActionCreated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestImportFindingActionFinding != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test_import_finding_action__finding", runtime.ParamLocationQuery, *params.TestImportFindingActionFinding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Version != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestImportsCreateRequest calls the generic TestImportsCreate builder with application/json body
func NewTestImportsCreateRequest(server string, body TestImportsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestImportsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTestImportsCreateRequestWithBody generates requests for TestImportsCreate with any type of body
func NewTestImportsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/test_imports/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestImportsDestroyRequest generates requests for TestImportsDestroy
func NewTestImportsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/test_imports/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestImportsRetrieveRequest generates requests for TestImportsRetrieve
func NewTestImportsRetrieveRequest(server string, id int, params *TestImportsRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/test_imports/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestImportsPartialUpdateRequest calls the generic TestImportsPartialUpdate builder with application/json body
func NewTestImportsPartialUpdateRequest(server string, id int, body TestImportsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestImportsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTestImportsPartialUpdateRequestWithBody generates requests for TestImportsPartialUpdate with any type of body
func NewTestImportsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/test_imports/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestImportsUpdateRequest calls the generic TestImportsUpdate builder with application/json body
func NewTestImportsUpdateRequest(server string, id int, body TestImportsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestImportsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTestImportsUpdateRequestWithBody generates requests for TestImportsUpdate with any type of body
func NewTestImportsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/test_imports/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestImportsDeletePreviewListRequest generates requests for TestImportsDeletePreviewList
func NewTestImportsDeletePreviewListRequest(server string, id int, params *TestImportsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/test_imports/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestTypesListRequest generates requests for TestTypesList
func NewTestTypesListRequest(server string, params *TestTypesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/test_types/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestTypesCreateRequest calls the generic TestTypesCreate builder with application/json body
func NewTestTypesCreateRequest(server string, body TestTypesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestTypesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTestTypesCreateRequestWithBody generates requests for TestTypesCreate with any type of body
func NewTestTypesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/test_types/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestTypesRetrieveRequest generates requests for TestTypesRetrieve
func NewTestTypesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/test_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestTypesPartialUpdateRequest calls the generic TestTypesPartialUpdate builder with application/json body
func NewTestTypesPartialUpdateRequest(server string, id int, body TestTypesPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestTypesPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTestTypesPartialUpdateRequestWithBody generates requests for TestTypesPartialUpdate with any type of body
func NewTestTypesPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/test_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestTypesUpdateRequest calls the generic TestTypesUpdate builder with application/json body
func NewTestTypesUpdateRequest(server string, id int, body TestTypesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestTypesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTestTypesUpdateRequestWithBody generates requests for TestTypesUpdate with any type of body
func NewTestTypesUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/test_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestsListRequest generates requests for TestsList
func NewTestsListRequest(server string, params *TestsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ActualTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actual_time", runtime.ParamLocationQuery, *params.ActualTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ApiScanConfiguration != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "api_scan_configuration", runtime.ParamLocationQuery, *params.ApiScanConfiguration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BranchTag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branch_tag", runtime.ParamLocationQuery, *params.BranchTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BuildId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "build_id", runtime.ParamLocationQuery, *params.BuildId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CommitHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commit_hash", runtime.ParamLocationQuery, *params.CommitHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Engagement != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "engagement", runtime.ParamLocationQuery, *params.Engagement); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EngagementProductTagsName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "engagement__product__tags__name", runtime.ParamLocationQuery, *params.EngagementProductTagsName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EngagementTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "engagement__tags", runtime.ParamLocationQuery, *params.EngagementTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotEngagementProductTagsName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_engagement__product__tags__name", runtime.ParamLocationQuery, *params.NotEngagementProductTagsName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotEngagementTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_engagement__tags", runtime.ParamLocationQuery, *params.NotEngagementTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_tag", runtime.ParamLocationQuery, *params.NotTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NotTags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "not_tags", runtime.ParamLocationQuery, *params.NotTags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notes", runtime.ParamLocationQuery, *params.Notes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.O != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "o", runtime.ParamLocationQuery, *params.O); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PercentComplete != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percent_complete", runtime.ParamLocationQuery, *params.PercentComplete); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tag != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TargetEnd != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_end", runtime.ParamLocationQuery, *params.TargetEnd); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TargetStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_start", runtime.ParamLocationQuery, *params.TargetStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TestType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test_type", runtime.ParamLocationQuery, *params.TestType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Title != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Version != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestsCreateRequest calls the generic TestsCreate builder with application/json body
func NewTestsCreateRequest(server string, body TestsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTestsCreateRequestWithBody generates requests for TestsCreate with any type of body
func NewTestsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestsDestroyRequest generates requests for TestsDestroy
func NewTestsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestsRetrieveRequest generates requests for TestsRetrieve
func NewTestsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestsPartialUpdateRequest calls the generic TestsPartialUpdate builder with application/json body
func NewTestsPartialUpdateRequest(server string, id int, body TestsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTestsPartialUpdateRequestWithBody generates requests for TestsPartialUpdate with any type of body
func NewTestsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestsUpdateRequest calls the generic TestsUpdate builder with application/json body
func NewTestsUpdateRequest(server string, id int, body TestsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTestsUpdateRequestWithBody generates requests for TestsUpdate with any type of body
func NewTestsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestsAcceptRisksCreateRequest calls the generic TestsAcceptRisksCreate builder with application/json body
func NewTestsAcceptRisksCreateRequest(server string, id int, body TestsAcceptRisksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestsAcceptRisksCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTestsAcceptRisksCreateRequestWithBody generates requests for TestsAcceptRisksCreate with any type of body
func NewTestsAcceptRisksCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/%s/accept_risks/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestsDeletePreviewListRequest generates requests for TestsDeletePreviewList
func NewTestsDeletePreviewListRequest(server string, id int, params *TestsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestsFilesRetrieveRequest generates requests for TestsFilesRetrieve
func NewTestsFilesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/%s/files/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestsFilesCreateRequestWithBody generates requests for TestsFilesCreate with any type of body
func NewTestsFilesCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/%s/files/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestsGenerateReportCreateRequest calls the generic TestsGenerateReportCreate builder with application/json body
func NewTestsGenerateReportCreateRequest(server string, id int, body TestsGenerateReportCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestsGenerateReportCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTestsGenerateReportCreateRequestWithBody generates requests for TestsGenerateReportCreate with any type of body
func NewTestsGenerateReportCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/%s/generate_report/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestsNotesRetrieveRequest generates requests for TestsNotesRetrieve
func NewTestsNotesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/%s/notes/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestsNotesCreateRequest calls the generic TestsNotesCreate builder with application/json body
func NewTestsNotesCreateRequest(server string, id int, body TestsNotesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestsNotesCreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTestsNotesCreateRequestWithBody generates requests for TestsNotesCreate with any type of body
func NewTestsNotesCreateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tests/%s/notes/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewToolConfigurationsListRequest generates requests for ToolConfigurationsList
func NewToolConfigurationsListRequest(server string, params *ToolConfigurationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_configurations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AuthenticationType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authentication_type", runtime.ParamLocationQuery, *params.AuthenticationType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToolType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tool_type", runtime.ParamLocationQuery, *params.ToolType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Url != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, *params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToolConfigurationsCreateRequest calls the generic ToolConfigurationsCreate builder with application/json body
func NewToolConfigurationsCreateRequest(server string, body ToolConfigurationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToolConfigurationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewToolConfigurationsCreateRequestWithBody generates requests for ToolConfigurationsCreate with any type of body
func NewToolConfigurationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_configurations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewToolConfigurationsDestroyRequest generates requests for ToolConfigurationsDestroy
func NewToolConfigurationsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToolConfigurationsRetrieveRequest generates requests for ToolConfigurationsRetrieve
func NewToolConfigurationsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToolConfigurationsPartialUpdateRequest calls the generic ToolConfigurationsPartialUpdate builder with application/json body
func NewToolConfigurationsPartialUpdateRequest(server string, id int, body ToolConfigurationsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToolConfigurationsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewToolConfigurationsPartialUpdateRequestWithBody generates requests for ToolConfigurationsPartialUpdate with any type of body
func NewToolConfigurationsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewToolConfigurationsUpdateRequest calls the generic ToolConfigurationsUpdate builder with application/json body
func NewToolConfigurationsUpdateRequest(server string, id int, body ToolConfigurationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToolConfigurationsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewToolConfigurationsUpdateRequestWithBody generates requests for ToolConfigurationsUpdate with any type of body
func NewToolConfigurationsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_configurations/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewToolConfigurationsDeletePreviewListRequest generates requests for ToolConfigurationsDeletePreviewList
func NewToolConfigurationsDeletePreviewListRequest(server string, id int, params *ToolConfigurationsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_configurations/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToolProductSettingsListRequest generates requests for ToolProductSettingsList
func NewToolProductSettingsListRequest(server string, params *ToolProductSettingsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_product_settings/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToolConfiguration != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tool_configuration", runtime.ParamLocationQuery, *params.ToolConfiguration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToolProjectId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tool_project_id", runtime.ParamLocationQuery, *params.ToolProjectId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Url != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, *params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToolProductSettingsCreateRequest calls the generic ToolProductSettingsCreate builder with application/json body
func NewToolProductSettingsCreateRequest(server string, body ToolProductSettingsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToolProductSettingsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewToolProductSettingsCreateRequestWithBody generates requests for ToolProductSettingsCreate with any type of body
func NewToolProductSettingsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_product_settings/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewToolProductSettingsDestroyRequest generates requests for ToolProductSettingsDestroy
func NewToolProductSettingsDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_product_settings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToolProductSettingsRetrieveRequest generates requests for ToolProductSettingsRetrieve
func NewToolProductSettingsRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_product_settings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToolProductSettingsPartialUpdateRequest calls the generic ToolProductSettingsPartialUpdate builder with application/json body
func NewToolProductSettingsPartialUpdateRequest(server string, id int, body ToolProductSettingsPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToolProductSettingsPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewToolProductSettingsPartialUpdateRequestWithBody generates requests for ToolProductSettingsPartialUpdate with any type of body
func NewToolProductSettingsPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_product_settings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewToolProductSettingsUpdateRequest calls the generic ToolProductSettingsUpdate builder with application/json body
func NewToolProductSettingsUpdateRequest(server string, id int, body ToolProductSettingsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToolProductSettingsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewToolProductSettingsUpdateRequestWithBody generates requests for ToolProductSettingsUpdate with any type of body
func NewToolProductSettingsUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_product_settings/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewToolProductSettingsDeletePreviewListRequest generates requests for ToolProductSettingsDeletePreviewList
func NewToolProductSettingsDeletePreviewListRequest(server string, id int, params *ToolProductSettingsDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_product_settings/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToolTypesListRequest generates requests for ToolTypesList
func NewToolTypesListRequest(server string, params *ToolTypesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_types/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Description != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToolTypesCreateRequest calls the generic ToolTypesCreate builder with application/json body
func NewToolTypesCreateRequest(server string, body ToolTypesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToolTypesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewToolTypesCreateRequestWithBody generates requests for ToolTypesCreate with any type of body
func NewToolTypesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_types/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewToolTypesDestroyRequest generates requests for ToolTypesDestroy
func NewToolTypesDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToolTypesRetrieveRequest generates requests for ToolTypesRetrieve
func NewToolTypesRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToolTypesPartialUpdateRequest calls the generic ToolTypesPartialUpdate builder with application/json body
func NewToolTypesPartialUpdateRequest(server string, id int, body ToolTypesPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToolTypesPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewToolTypesPartialUpdateRequestWithBody generates requests for ToolTypesPartialUpdate with any type of body
func NewToolTypesPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewToolTypesUpdateRequest calls the generic ToolTypesUpdate builder with application/json body
func NewToolTypesUpdateRequest(server string, id int, body ToolTypesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewToolTypesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewToolTypesUpdateRequestWithBody generates requests for ToolTypesUpdate with any type of body
func NewToolTypesUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_types/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewToolTypesDeletePreviewListRequest generates requests for ToolTypesDeletePreviewList
func NewToolTypesDeletePreviewListRequest(server string, id int, params *ToolTypesDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tool_types/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserContactInfosListRequest generates requests for UserContactInfosList
func NewUserContactInfosListRequest(server string, params *UserContactInfosListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/user_contact_infos/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BlockExecution != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "block_execution", runtime.ParamLocationQuery, *params.BlockExecution); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CellNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cell_number", runtime.ParamLocationQuery, *params.CellNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ForcePasswordReset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_password_reset", runtime.ParamLocationQuery, *params.ForcePasswordReset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GithubUsername != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "github_username", runtime.ParamLocationQuery, *params.GithubUsername); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PhoneNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phone_number", runtime.ParamLocationQuery, *params.PhoneNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SlackUserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slack_user_id", runtime.ParamLocationQuery, *params.SlackUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SlackUsername != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slack_username", runtime.ParamLocationQuery, *params.SlackUsername); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Title != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TwitterUsername != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "twitter_username", runtime.ParamLocationQuery, *params.TwitterUsername); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.User != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserContactInfosCreateRequest calls the generic UserContactInfosCreate builder with application/json body
func NewUserContactInfosCreateRequest(server string, body UserContactInfosCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserContactInfosCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewUserContactInfosCreateRequestWithBody generates requests for UserContactInfosCreate with any type of body
func NewUserContactInfosCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/user_contact_infos/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserContactInfosDestroyRequest generates requests for UserContactInfosDestroy
func NewUserContactInfosDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/user_contact_infos/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserContactInfosRetrieveRequest generates requests for UserContactInfosRetrieve
func NewUserContactInfosRetrieveRequest(server string, id int, params *UserContactInfosRetrieveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/user_contact_infos/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Prefetch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefetch", runtime.ParamLocationQuery, *params.Prefetch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserContactInfosPartialUpdateRequest calls the generic UserContactInfosPartialUpdate builder with application/json body
func NewUserContactInfosPartialUpdateRequest(server string, id int, body UserContactInfosPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserContactInfosPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUserContactInfosPartialUpdateRequestWithBody generates requests for UserContactInfosPartialUpdate with any type of body
func NewUserContactInfosPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/user_contact_infos/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserContactInfosUpdateRequest calls the generic UserContactInfosUpdate builder with application/json body
func NewUserContactInfosUpdateRequest(server string, id int, body UserContactInfosUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserContactInfosUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUserContactInfosUpdateRequestWithBody generates requests for UserContactInfosUpdate with any type of body
func NewUserContactInfosUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/user_contact_infos/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserContactInfosDeletePreviewListRequest generates requests for UserContactInfosDeletePreviewList
func NewUserContactInfosDeletePreviewListRequest(server string, id int, params *UserContactInfosDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/user_contact_infos/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserProfileRetrieveRequest generates requests for UserProfileRetrieve
func NewUserProfileRetrieveRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/user_profile/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersListRequest generates requests for UsersList
func NewUsersListRequest(server string, params *UsersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Email != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FirstName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_name", runtime.ParamLocationQuery, *params.FirstName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsActive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_active", runtime.ParamLocationQuery, *params.IsActive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsSuperuser != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_superuser", runtime.ParamLocationQuery, *params.IsSuperuser); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LastName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_name", runtime.ParamLocationQuery, *params.LastName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Username != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersCreateRequest calls the generic UsersCreate builder with application/json body
func NewUsersCreateRequest(server string, body UsersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewUsersCreateRequestWithBody generates requests for UsersCreate with any type of body
func NewUsersCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersDestroyRequest generates requests for UsersDestroy
func NewUsersDestroyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersRetrieveRequest generates requests for UsersRetrieve
func NewUsersRetrieveRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersPartialUpdateRequest calls the generic UsersPartialUpdate builder with application/json body
func NewUsersPartialUpdateRequest(server string, id int, body UsersPartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersPartialUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUsersPartialUpdateRequestWithBody generates requests for UsersPartialUpdate with any type of body
func NewUsersPartialUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersUpdateRequest calls the generic UsersUpdate builder with application/json body
func NewUsersUpdateRequest(server string, id int, body UsersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUsersUpdateRequestWithBody generates requests for UsersUpdate with any type of body
func NewUsersUpdateRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersDeletePreviewListRequest generates requests for UsersDeletePreviewList
func NewUsersDeletePreviewListRequest(server string, id int, params *UsersDeletePreviewListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/delete_preview/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ApiTokenAuthCreate request with any body
	ApiTokenAuthCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiTokenAuthCreateResponse, error)

	ApiTokenAuthCreateWithResponse(ctx context.Context, body ApiTokenAuthCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiTokenAuthCreateResponse, error)

	// ConfigurationPermissionsList request
	ConfigurationPermissionsListWithResponse(ctx context.Context, params *ConfigurationPermissionsListParams, reqEditors ...RequestEditorFn) (*ConfigurationPermissionsListResponse, error)

	// ConfigurationPermissionsRetrieve request
	ConfigurationPermissionsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ConfigurationPermissionsRetrieveResponse, error)

	// DevelopmentEnvironmentsList request
	DevelopmentEnvironmentsListWithResponse(ctx context.Context, params *DevelopmentEnvironmentsListParams, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsListResponse, error)

	// DevelopmentEnvironmentsCreate request with any body
	DevelopmentEnvironmentsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsCreateResponse, error)

	DevelopmentEnvironmentsCreateWithResponse(ctx context.Context, body DevelopmentEnvironmentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsCreateResponse, error)

	// DevelopmentEnvironmentsDestroy request
	DevelopmentEnvironmentsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsDestroyResponse, error)

	// DevelopmentEnvironmentsRetrieve request
	DevelopmentEnvironmentsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsRetrieveResponse, error)

	// DevelopmentEnvironmentsPartialUpdate request with any body
	DevelopmentEnvironmentsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsPartialUpdateResponse, error)

	DevelopmentEnvironmentsPartialUpdateWithResponse(ctx context.Context, id int, body DevelopmentEnvironmentsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsPartialUpdateResponse, error)

	// DevelopmentEnvironmentsUpdate request with any body
	DevelopmentEnvironmentsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsUpdateResponse, error)

	DevelopmentEnvironmentsUpdateWithResponse(ctx context.Context, id int, body DevelopmentEnvironmentsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsUpdateResponse, error)

	// DevelopmentEnvironmentsDeletePreviewList request
	DevelopmentEnvironmentsDeletePreviewListWithResponse(ctx context.Context, id int, params *DevelopmentEnvironmentsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsDeletePreviewListResponse, error)

	// DojoGroupMembersList request
	DojoGroupMembersListWithResponse(ctx context.Context, params *DojoGroupMembersListParams, reqEditors ...RequestEditorFn) (*DojoGroupMembersListResponse, error)

	// DojoGroupMembersCreate request with any body
	DojoGroupMembersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DojoGroupMembersCreateResponse, error)

	DojoGroupMembersCreateWithResponse(ctx context.Context, body DojoGroupMembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DojoGroupMembersCreateResponse, error)

	// DojoGroupMembersDestroy request
	DojoGroupMembersDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DojoGroupMembersDestroyResponse, error)

	// DojoGroupMembersRetrieve request
	DojoGroupMembersRetrieveWithResponse(ctx context.Context, id int, params *DojoGroupMembersRetrieveParams, reqEditors ...RequestEditorFn) (*DojoGroupMembersRetrieveResponse, error)

	// DojoGroupMembersPartialUpdate request with any body
	DojoGroupMembersPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DojoGroupMembersPartialUpdateResponse, error)

	DojoGroupMembersPartialUpdateWithResponse(ctx context.Context, id int, body DojoGroupMembersPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DojoGroupMembersPartialUpdateResponse, error)

	// DojoGroupMembersUpdate request with any body
	DojoGroupMembersUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DojoGroupMembersUpdateResponse, error)

	DojoGroupMembersUpdateWithResponse(ctx context.Context, id int, body DojoGroupMembersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DojoGroupMembersUpdateResponse, error)

	// DojoGroupMembersDeletePreviewList request
	DojoGroupMembersDeletePreviewListWithResponse(ctx context.Context, id int, params *DojoGroupMembersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*DojoGroupMembersDeletePreviewListResponse, error)

	// DojoGroupsList request
	DojoGroupsListWithResponse(ctx context.Context, params *DojoGroupsListParams, reqEditors ...RequestEditorFn) (*DojoGroupsListResponse, error)

	// DojoGroupsCreate request with any body
	DojoGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DojoGroupsCreateResponse, error)

	DojoGroupsCreateWithResponse(ctx context.Context, body DojoGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DojoGroupsCreateResponse, error)

	// DojoGroupsDestroy request
	DojoGroupsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DojoGroupsDestroyResponse, error)

	// DojoGroupsRetrieve request
	DojoGroupsRetrieveWithResponse(ctx context.Context, id int, params *DojoGroupsRetrieveParams, reqEditors ...RequestEditorFn) (*DojoGroupsRetrieveResponse, error)

	// DojoGroupsPartialUpdate request with any body
	DojoGroupsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DojoGroupsPartialUpdateResponse, error)

	DojoGroupsPartialUpdateWithResponse(ctx context.Context, id int, body DojoGroupsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DojoGroupsPartialUpdateResponse, error)

	// DojoGroupsUpdate request with any body
	DojoGroupsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DojoGroupsUpdateResponse, error)

	DojoGroupsUpdateWithResponse(ctx context.Context, id int, body DojoGroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DojoGroupsUpdateResponse, error)

	// DojoGroupsDeletePreviewList request
	DojoGroupsDeletePreviewListWithResponse(ctx context.Context, id int, params *DojoGroupsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*DojoGroupsDeletePreviewListResponse, error)

	// EndpointMetaImportCreate request with any body
	EndpointMetaImportCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointMetaImportCreateResponse, error)

	// EndpointStatusList request
	EndpointStatusListWithResponse(ctx context.Context, params *EndpointStatusListParams, reqEditors ...RequestEditorFn) (*EndpointStatusListResponse, error)

	// EndpointStatusCreate request with any body
	EndpointStatusCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointStatusCreateResponse, error)

	EndpointStatusCreateWithResponse(ctx context.Context, body EndpointStatusCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointStatusCreateResponse, error)

	// EndpointStatusDestroy request
	EndpointStatusDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EndpointStatusDestroyResponse, error)

	// EndpointStatusRetrieve request
	EndpointStatusRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EndpointStatusRetrieveResponse, error)

	// EndpointStatusPartialUpdate request with any body
	EndpointStatusPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointStatusPartialUpdateResponse, error)

	EndpointStatusPartialUpdateWithResponse(ctx context.Context, id int, body EndpointStatusPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointStatusPartialUpdateResponse, error)

	// EndpointStatusUpdate request with any body
	EndpointStatusUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointStatusUpdateResponse, error)

	EndpointStatusUpdateWithResponse(ctx context.Context, id int, body EndpointStatusUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointStatusUpdateResponse, error)

	// EndpointStatusDeletePreviewList request
	EndpointStatusDeletePreviewListWithResponse(ctx context.Context, id int, params *EndpointStatusDeletePreviewListParams, reqEditors ...RequestEditorFn) (*EndpointStatusDeletePreviewListResponse, error)

	// EndpointsList request
	EndpointsListWithResponse(ctx context.Context, params *EndpointsListParams, reqEditors ...RequestEditorFn) (*EndpointsListResponse, error)

	// EndpointsCreate request with any body
	EndpointsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointsCreateResponse, error)

	EndpointsCreateWithResponse(ctx context.Context, body EndpointsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointsCreateResponse, error)

	// EndpointsDestroy request
	EndpointsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EndpointsDestroyResponse, error)

	// EndpointsRetrieve request
	EndpointsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EndpointsRetrieveResponse, error)

	// EndpointsPartialUpdate request with any body
	EndpointsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointsPartialUpdateResponse, error)

	EndpointsPartialUpdateWithResponse(ctx context.Context, id int, body EndpointsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointsPartialUpdateResponse, error)

	// EndpointsUpdate request with any body
	EndpointsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointsUpdateResponse, error)

	EndpointsUpdateWithResponse(ctx context.Context, id int, body EndpointsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointsUpdateResponse, error)

	// EndpointsDeletePreviewList request
	EndpointsDeletePreviewListWithResponse(ctx context.Context, id int, params *EndpointsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*EndpointsDeletePreviewListResponse, error)

	// EndpointsGenerateReportCreate request with any body
	EndpointsGenerateReportCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointsGenerateReportCreateResponse, error)

	EndpointsGenerateReportCreateWithResponse(ctx context.Context, id int, body EndpointsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointsGenerateReportCreateResponse, error)

	// EngagementPresetsList request
	EngagementPresetsListWithResponse(ctx context.Context, params *EngagementPresetsListParams, reqEditors ...RequestEditorFn) (*EngagementPresetsListResponse, error)

	// EngagementPresetsCreate request with any body
	EngagementPresetsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementPresetsCreateResponse, error)

	EngagementPresetsCreateWithResponse(ctx context.Context, body EngagementPresetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementPresetsCreateResponse, error)

	// EngagementPresetsDestroy request
	EngagementPresetsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementPresetsDestroyResponse, error)

	// EngagementPresetsRetrieve request
	EngagementPresetsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementPresetsRetrieveResponse, error)

	// EngagementPresetsPartialUpdate request with any body
	EngagementPresetsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementPresetsPartialUpdateResponse, error)

	EngagementPresetsPartialUpdateWithResponse(ctx context.Context, id int, body EngagementPresetsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementPresetsPartialUpdateResponse, error)

	// EngagementPresetsUpdate request with any body
	EngagementPresetsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementPresetsUpdateResponse, error)

	EngagementPresetsUpdateWithResponse(ctx context.Context, id int, body EngagementPresetsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementPresetsUpdateResponse, error)

	// EngagementPresetsDeletePreviewList request
	EngagementPresetsDeletePreviewListWithResponse(ctx context.Context, id int, params *EngagementPresetsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*EngagementPresetsDeletePreviewListResponse, error)

	// EngagementsList request
	EngagementsListWithResponse(ctx context.Context, params *EngagementsListParams, reqEditors ...RequestEditorFn) (*EngagementsListResponse, error)

	// EngagementsCreate request with any body
	EngagementsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsCreateResponse, error)

	EngagementsCreateWithResponse(ctx context.Context, body EngagementsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsCreateResponse, error)

	// EngagementsDestroy request
	EngagementsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementsDestroyResponse, error)

	// EngagementsRetrieve request
	EngagementsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementsRetrieveResponse, error)

	// EngagementsPartialUpdate request with any body
	EngagementsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsPartialUpdateResponse, error)

	EngagementsPartialUpdateWithResponse(ctx context.Context, id int, body EngagementsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsPartialUpdateResponse, error)

	// EngagementsUpdate request with any body
	EngagementsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsUpdateResponse, error)

	EngagementsUpdateWithResponse(ctx context.Context, id int, body EngagementsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsUpdateResponse, error)

	// EngagementsAcceptRisksCreate request with any body
	EngagementsAcceptRisksCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsAcceptRisksCreateResponse, error)

	EngagementsAcceptRisksCreateWithResponse(ctx context.Context, id int, body EngagementsAcceptRisksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsAcceptRisksCreateResponse, error)

	// EngagementsCloseCreate request
	EngagementsCloseCreateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementsCloseCreateResponse, error)

	// EngagementsDeletePreviewList request
	EngagementsDeletePreviewListWithResponse(ctx context.Context, id int, params *EngagementsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*EngagementsDeletePreviewListResponse, error)

	// EngagementsFilesRetrieve request
	EngagementsFilesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementsFilesRetrieveResponse, error)

	// EngagementsFilesCreate request with any body
	EngagementsFilesCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsFilesCreateResponse, error)

	// EngagementsGenerateReportCreate request with any body
	EngagementsGenerateReportCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsGenerateReportCreateResponse, error)

	EngagementsGenerateReportCreateWithResponse(ctx context.Context, id int, body EngagementsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsGenerateReportCreateResponse, error)

	// EngagementsNotesRetrieve request
	EngagementsNotesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementsNotesRetrieveResponse, error)

	// EngagementsNotesCreate request with any body
	EngagementsNotesCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsNotesCreateResponse, error)

	EngagementsNotesCreateWithResponse(ctx context.Context, id int, body EngagementsNotesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsNotesCreateResponse, error)

	// EngagementsReopenCreate request
	EngagementsReopenCreateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementsReopenCreateResponse, error)

	// FindingTemplatesList request
	FindingTemplatesListWithResponse(ctx context.Context, params *FindingTemplatesListParams, reqEditors ...RequestEditorFn) (*FindingTemplatesListResponse, error)

	// FindingTemplatesCreate request with any body
	FindingTemplatesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingTemplatesCreateResponse, error)

	FindingTemplatesCreateWithResponse(ctx context.Context, body FindingTemplatesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingTemplatesCreateResponse, error)

	// FindingTemplatesDestroy request
	FindingTemplatesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingTemplatesDestroyResponse, error)

	// FindingTemplatesRetrieve request
	FindingTemplatesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingTemplatesRetrieveResponse, error)

	// FindingTemplatesPartialUpdate request with any body
	FindingTemplatesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingTemplatesPartialUpdateResponse, error)

	FindingTemplatesPartialUpdateWithResponse(ctx context.Context, id int, body FindingTemplatesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingTemplatesPartialUpdateResponse, error)

	// FindingTemplatesUpdate request with any body
	FindingTemplatesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingTemplatesUpdateResponse, error)

	FindingTemplatesUpdateWithResponse(ctx context.Context, id int, body FindingTemplatesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingTemplatesUpdateResponse, error)

	// FindingTemplatesDeletePreviewList request
	FindingTemplatesDeletePreviewListWithResponse(ctx context.Context, id int, params *FindingTemplatesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*FindingTemplatesDeletePreviewListResponse, error)

	// FindingsList request
	FindingsListWithResponse(ctx context.Context, params *FindingsListParams, reqEditors ...RequestEditorFn) (*FindingsListResponse, error)

	// FindingsCreate request with any body
	FindingsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsCreateResponse, error)

	FindingsCreateWithResponse(ctx context.Context, body FindingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsCreateResponse, error)

	// FindingsAcceptRisksCreate request with any body
	FindingsAcceptRisksCreateWithBodyWithResponse(ctx context.Context, params *FindingsAcceptRisksCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsAcceptRisksCreateResponse, error)

	FindingsAcceptRisksCreateWithResponse(ctx context.Context, params *FindingsAcceptRisksCreateParams, body FindingsAcceptRisksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsAcceptRisksCreateResponse, error)

	// FindingsGenerateReportCreate request with any body
	FindingsGenerateReportCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsGenerateReportCreateResponse, error)

	FindingsGenerateReportCreateWithResponse(ctx context.Context, body FindingsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsGenerateReportCreateResponse, error)

	// FindingsDestroy request
	FindingsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsDestroyResponse, error)

	// FindingsRetrieve request
	FindingsRetrieveWithResponse(ctx context.Context, id int, params *FindingsRetrieveParams, reqEditors ...RequestEditorFn) (*FindingsRetrieveResponse, error)

	// FindingsPartialUpdate request with any body
	FindingsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsPartialUpdateResponse, error)

	FindingsPartialUpdateWithResponse(ctx context.Context, id int, body FindingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsPartialUpdateResponse, error)

	// FindingsUpdate request with any body
	FindingsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsUpdateResponse, error)

	FindingsUpdateWithResponse(ctx context.Context, id int, body FindingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsUpdateResponse, error)

	// FindingsCloseCreate request with any body
	FindingsCloseCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsCloseCreateResponse, error)

	FindingsCloseCreateWithResponse(ctx context.Context, id int, body FindingsCloseCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsCloseCreateResponse, error)

	// FindingsDeletePreviewList request
	FindingsDeletePreviewListWithResponse(ctx context.Context, id int, params *FindingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*FindingsDeletePreviewListResponse, error)

	// FindingsDuplicateList request
	FindingsDuplicateListWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsDuplicateListResponse, error)

	// FindingsDuplicateResetCreate request
	FindingsDuplicateResetCreateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsDuplicateResetCreateResponse, error)

	// FindingsFilesRetrieve request
	FindingsFilesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsFilesRetrieveResponse, error)

	// FindingsFilesCreate request with any body
	FindingsFilesCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsFilesCreateResponse, error)

	// FindingsMetadataDestroy request
	FindingsMetadataDestroyWithResponse(ctx context.Context, id int, params *FindingsMetadataDestroyParams, reqEditors ...RequestEditorFn) (*FindingsMetadataDestroyResponse, error)

	// FindingsMetadataList request
	FindingsMetadataListWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsMetadataListResponse, error)

	// FindingsMetadataCreate request with any body
	FindingsMetadataCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsMetadataCreateResponse, error)

	FindingsMetadataCreateWithResponse(ctx context.Context, id int, body FindingsMetadataCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsMetadataCreateResponse, error)

	// FindingsMetadataUpdate request with any body
	FindingsMetadataUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsMetadataUpdateResponse, error)

	FindingsMetadataUpdateWithResponse(ctx context.Context, id int, body FindingsMetadataUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsMetadataUpdateResponse, error)

	// FindingsNotesRetrieve request
	FindingsNotesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsNotesRetrieveResponse, error)

	// FindingsNotesCreate request with any body
	FindingsNotesCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsNotesCreateResponse, error)

	FindingsNotesCreateWithResponse(ctx context.Context, id int, body FindingsNotesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsNotesCreateResponse, error)

	// FindingsOriginalCreate request
	FindingsOriginalCreateWithResponse(ctx context.Context, id int, newFid int, reqEditors ...RequestEditorFn) (*FindingsOriginalCreateResponse, error)

	// FindingsRemoveNotePartialUpdate request with any body
	FindingsRemoveNotePartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsRemoveNotePartialUpdateResponse, error)

	FindingsRemoveNotePartialUpdateWithResponse(ctx context.Context, id int, body FindingsRemoveNotePartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsRemoveNotePartialUpdateResponse, error)

	// FindingsRemoveTagsPartialUpdate request with any body
	FindingsRemoveTagsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsRemoveTagsPartialUpdateResponse, error)

	FindingsRemoveTagsPartialUpdateWithResponse(ctx context.Context, id int, body FindingsRemoveTagsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsRemoveTagsPartialUpdateResponse, error)

	// FindingsRemoveTagsUpdate request with any body
	FindingsRemoveTagsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsRemoveTagsUpdateResponse, error)

	FindingsRemoveTagsUpdateWithResponse(ctx context.Context, id int, body FindingsRemoveTagsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsRemoveTagsUpdateResponse, error)

	// FindingsRequestResponseRetrieve request
	FindingsRequestResponseRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsRequestResponseRetrieveResponse, error)

	// FindingsRequestResponseCreate request with any body
	FindingsRequestResponseCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsRequestResponseCreateResponse, error)

	FindingsRequestResponseCreateWithResponse(ctx context.Context, id int, body FindingsRequestResponseCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsRequestResponseCreateResponse, error)

	// FindingsTagsRetrieve request
	FindingsTagsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsTagsRetrieveResponse, error)

	// FindingsTagsCreate request with any body
	FindingsTagsCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsTagsCreateResponse, error)

	FindingsTagsCreateWithResponse(ctx context.Context, id int, body FindingsTagsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsTagsCreateResponse, error)

	// GlobalRolesList request
	GlobalRolesListWithResponse(ctx context.Context, params *GlobalRolesListParams, reqEditors ...RequestEditorFn) (*GlobalRolesListResponse, error)

	// GlobalRolesCreate request with any body
	GlobalRolesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalRolesCreateResponse, error)

	GlobalRolesCreateWithResponse(ctx context.Context, body GlobalRolesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalRolesCreateResponse, error)

	// GlobalRolesDestroy request
	GlobalRolesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GlobalRolesDestroyResponse, error)

	// GlobalRolesRetrieve request
	GlobalRolesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GlobalRolesRetrieveResponse, error)

	// GlobalRolesPartialUpdate request with any body
	GlobalRolesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalRolesPartialUpdateResponse, error)

	GlobalRolesPartialUpdateWithResponse(ctx context.Context, id int, body GlobalRolesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalRolesPartialUpdateResponse, error)

	// GlobalRolesUpdate request with any body
	GlobalRolesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalRolesUpdateResponse, error)

	GlobalRolesUpdateWithResponse(ctx context.Context, id int, body GlobalRolesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalRolesUpdateResponse, error)

	// GlobalRolesDeletePreviewList request
	GlobalRolesDeletePreviewListWithResponse(ctx context.Context, id int, params *GlobalRolesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*GlobalRolesDeletePreviewListResponse, error)

	// ImportLanguagesCreate request with any body
	ImportLanguagesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportLanguagesCreateResponse, error)

	// ImportScanCreate request with any body
	ImportScanCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportScanCreateResponse, error)

	// JiraConfigurationsList request
	JiraConfigurationsListWithResponse(ctx context.Context, params *JiraConfigurationsListParams, reqEditors ...RequestEditorFn) (*JiraConfigurationsListResponse, error)

	// JiraConfigurationsCreate request with any body
	JiraConfigurationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraConfigurationsCreateResponse, error)

	JiraConfigurationsCreateWithResponse(ctx context.Context, body JiraConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraConfigurationsCreateResponse, error)

	// JiraConfigurationsDestroy request
	JiraConfigurationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraConfigurationsDestroyResponse, error)

	// JiraConfigurationsRetrieve request
	JiraConfigurationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraConfigurationsRetrieveResponse, error)

	// JiraConfigurationsPartialUpdate request with any body
	JiraConfigurationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraConfigurationsPartialUpdateResponse, error)

	JiraConfigurationsPartialUpdateWithResponse(ctx context.Context, id int, body JiraConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraConfigurationsPartialUpdateResponse, error)

	// JiraConfigurationsUpdate request with any body
	JiraConfigurationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraConfigurationsUpdateResponse, error)

	JiraConfigurationsUpdateWithResponse(ctx context.Context, id int, body JiraConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraConfigurationsUpdateResponse, error)

	// JiraConfigurationsDeletePreviewList request
	JiraConfigurationsDeletePreviewListWithResponse(ctx context.Context, id int, params *JiraConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*JiraConfigurationsDeletePreviewListResponse, error)

	// JiraFindingMappingsList request
	JiraFindingMappingsListWithResponse(ctx context.Context, params *JiraFindingMappingsListParams, reqEditors ...RequestEditorFn) (*JiraFindingMappingsListResponse, error)

	// JiraFindingMappingsCreate request with any body
	JiraFindingMappingsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraFindingMappingsCreateResponse, error)

	JiraFindingMappingsCreateWithResponse(ctx context.Context, body JiraFindingMappingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraFindingMappingsCreateResponse, error)

	// JiraFindingMappingsDestroy request
	JiraFindingMappingsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraFindingMappingsDestroyResponse, error)

	// JiraFindingMappingsRetrieve request
	JiraFindingMappingsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraFindingMappingsRetrieveResponse, error)

	// JiraFindingMappingsPartialUpdate request with any body
	JiraFindingMappingsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraFindingMappingsPartialUpdateResponse, error)

	JiraFindingMappingsPartialUpdateWithResponse(ctx context.Context, id int, body JiraFindingMappingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraFindingMappingsPartialUpdateResponse, error)

	// JiraFindingMappingsUpdate request with any body
	JiraFindingMappingsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraFindingMappingsUpdateResponse, error)

	JiraFindingMappingsUpdateWithResponse(ctx context.Context, id int, body JiraFindingMappingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraFindingMappingsUpdateResponse, error)

	// JiraFindingMappingsDeletePreviewList request
	JiraFindingMappingsDeletePreviewListWithResponse(ctx context.Context, id int, params *JiraFindingMappingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*JiraFindingMappingsDeletePreviewListResponse, error)

	// JiraInstancesList request
	JiraInstancesListWithResponse(ctx context.Context, params *JiraInstancesListParams, reqEditors ...RequestEditorFn) (*JiraInstancesListResponse, error)

	// JiraInstancesCreate request with any body
	JiraInstancesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraInstancesCreateResponse, error)

	JiraInstancesCreateWithResponse(ctx context.Context, body JiraInstancesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraInstancesCreateResponse, error)

	// JiraInstancesDestroy request
	JiraInstancesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraInstancesDestroyResponse, error)

	// JiraInstancesRetrieve request
	JiraInstancesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraInstancesRetrieveResponse, error)

	// JiraInstancesPartialUpdate request with any body
	JiraInstancesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraInstancesPartialUpdateResponse, error)

	JiraInstancesPartialUpdateWithResponse(ctx context.Context, id int, body JiraInstancesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraInstancesPartialUpdateResponse, error)

	// JiraInstancesUpdate request with any body
	JiraInstancesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraInstancesUpdateResponse, error)

	JiraInstancesUpdateWithResponse(ctx context.Context, id int, body JiraInstancesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraInstancesUpdateResponse, error)

	// JiraInstancesDeletePreviewList request
	JiraInstancesDeletePreviewListWithResponse(ctx context.Context, id int, params *JiraInstancesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*JiraInstancesDeletePreviewListResponse, error)

	// JiraProductConfigurationsList request
	JiraProductConfigurationsListWithResponse(ctx context.Context, params *JiraProductConfigurationsListParams, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsListResponse, error)

	// JiraProductConfigurationsCreate request with any body
	JiraProductConfigurationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsCreateResponse, error)

	JiraProductConfigurationsCreateWithResponse(ctx context.Context, body JiraProductConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsCreateResponse, error)

	// JiraProductConfigurationsDestroy request
	JiraProductConfigurationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsDestroyResponse, error)

	// JiraProductConfigurationsRetrieve request
	JiraProductConfigurationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsRetrieveResponse, error)

	// JiraProductConfigurationsPartialUpdate request with any body
	JiraProductConfigurationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsPartialUpdateResponse, error)

	JiraProductConfigurationsPartialUpdateWithResponse(ctx context.Context, id int, body JiraProductConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsPartialUpdateResponse, error)

	// JiraProductConfigurationsUpdate request with any body
	JiraProductConfigurationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsUpdateResponse, error)

	JiraProductConfigurationsUpdateWithResponse(ctx context.Context, id int, body JiraProductConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsUpdateResponse, error)

	// JiraProductConfigurationsDeletePreviewList request
	JiraProductConfigurationsDeletePreviewListWithResponse(ctx context.Context, id int, params *JiraProductConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsDeletePreviewListResponse, error)

	// JiraProjectsList request
	JiraProjectsListWithResponse(ctx context.Context, params *JiraProjectsListParams, reqEditors ...RequestEditorFn) (*JiraProjectsListResponse, error)

	// JiraProjectsCreate request with any body
	JiraProjectsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraProjectsCreateResponse, error)

	JiraProjectsCreateWithResponse(ctx context.Context, body JiraProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraProjectsCreateResponse, error)

	// JiraProjectsDestroy request
	JiraProjectsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraProjectsDestroyResponse, error)

	// JiraProjectsRetrieve request
	JiraProjectsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraProjectsRetrieveResponse, error)

	// JiraProjectsPartialUpdate request with any body
	JiraProjectsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraProjectsPartialUpdateResponse, error)

	JiraProjectsPartialUpdateWithResponse(ctx context.Context, id int, body JiraProjectsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraProjectsPartialUpdateResponse, error)

	// JiraProjectsUpdate request with any body
	JiraProjectsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraProjectsUpdateResponse, error)

	JiraProjectsUpdateWithResponse(ctx context.Context, id int, body JiraProjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraProjectsUpdateResponse, error)

	// JiraProjectsDeletePreviewList request
	JiraProjectsDeletePreviewListWithResponse(ctx context.Context, id int, params *JiraProjectsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*JiraProjectsDeletePreviewListResponse, error)

	// LanguageTypesList request
	LanguageTypesListWithResponse(ctx context.Context, params *LanguageTypesListParams, reqEditors ...RequestEditorFn) (*LanguageTypesListResponse, error)

	// LanguageTypesCreate request with any body
	LanguageTypesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LanguageTypesCreateResponse, error)

	LanguageTypesCreateWithResponse(ctx context.Context, body LanguageTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*LanguageTypesCreateResponse, error)

	// LanguageTypesDestroy request
	LanguageTypesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*LanguageTypesDestroyResponse, error)

	// LanguageTypesRetrieve request
	LanguageTypesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*LanguageTypesRetrieveResponse, error)

	// LanguageTypesPartialUpdate request with any body
	LanguageTypesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LanguageTypesPartialUpdateResponse, error)

	LanguageTypesPartialUpdateWithResponse(ctx context.Context, id int, body LanguageTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LanguageTypesPartialUpdateResponse, error)

	// LanguageTypesUpdate request with any body
	LanguageTypesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LanguageTypesUpdateResponse, error)

	LanguageTypesUpdateWithResponse(ctx context.Context, id int, body LanguageTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LanguageTypesUpdateResponse, error)

	// LanguageTypesDeletePreviewList request
	LanguageTypesDeletePreviewListWithResponse(ctx context.Context, id int, params *LanguageTypesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*LanguageTypesDeletePreviewListResponse, error)

	// LanguagesList request
	LanguagesListWithResponse(ctx context.Context, params *LanguagesListParams, reqEditors ...RequestEditorFn) (*LanguagesListResponse, error)

	// LanguagesCreate request with any body
	LanguagesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LanguagesCreateResponse, error)

	LanguagesCreateWithResponse(ctx context.Context, body LanguagesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*LanguagesCreateResponse, error)

	// LanguagesDestroy request
	LanguagesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*LanguagesDestroyResponse, error)

	// LanguagesRetrieve request
	LanguagesRetrieveWithResponse(ctx context.Context, id int, params *LanguagesRetrieveParams, reqEditors ...RequestEditorFn) (*LanguagesRetrieveResponse, error)

	// LanguagesPartialUpdate request with any body
	LanguagesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LanguagesPartialUpdateResponse, error)

	LanguagesPartialUpdateWithResponse(ctx context.Context, id int, body LanguagesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LanguagesPartialUpdateResponse, error)

	// LanguagesUpdate request with any body
	LanguagesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LanguagesUpdateResponse, error)

	LanguagesUpdateWithResponse(ctx context.Context, id int, body LanguagesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LanguagesUpdateResponse, error)

	// LanguagesDeletePreviewList request
	LanguagesDeletePreviewListWithResponse(ctx context.Context, id int, params *LanguagesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*LanguagesDeletePreviewListResponse, error)

	// MetadataList request
	MetadataListWithResponse(ctx context.Context, params *MetadataListParams, reqEditors ...RequestEditorFn) (*MetadataListResponse, error)

	// MetadataCreate request with any body
	MetadataCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetadataCreateResponse, error)

	MetadataCreateWithResponse(ctx context.Context, body MetadataCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetadataCreateResponse, error)

	// MetadataDestroy request
	MetadataDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*MetadataDestroyResponse, error)

	// MetadataRetrieve request
	MetadataRetrieveWithResponse(ctx context.Context, id int, params *MetadataRetrieveParams, reqEditors ...RequestEditorFn) (*MetadataRetrieveResponse, error)

	// MetadataPartialUpdate request with any body
	MetadataPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetadataPartialUpdateResponse, error)

	MetadataPartialUpdateWithResponse(ctx context.Context, id int, body MetadataPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetadataPartialUpdateResponse, error)

	// MetadataUpdate request with any body
	MetadataUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetadataUpdateResponse, error)

	MetadataUpdateWithResponse(ctx context.Context, id int, body MetadataUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetadataUpdateResponse, error)

	// MetadataDeletePreviewList request
	MetadataDeletePreviewListWithResponse(ctx context.Context, id int, params *MetadataDeletePreviewListParams, reqEditors ...RequestEditorFn) (*MetadataDeletePreviewListResponse, error)

	// NetworkLocationsList request
	NetworkLocationsListWithResponse(ctx context.Context, params *NetworkLocationsListParams, reqEditors ...RequestEditorFn) (*NetworkLocationsListResponse, error)

	// NetworkLocationsCreate request with any body
	NetworkLocationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NetworkLocationsCreateResponse, error)

	NetworkLocationsCreateWithResponse(ctx context.Context, body NetworkLocationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*NetworkLocationsCreateResponse, error)

	// NetworkLocationsDestroy request
	NetworkLocationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*NetworkLocationsDestroyResponse, error)

	// NetworkLocationsRetrieve request
	NetworkLocationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*NetworkLocationsRetrieveResponse, error)

	// NetworkLocationsPartialUpdate request with any body
	NetworkLocationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NetworkLocationsPartialUpdateResponse, error)

	NetworkLocationsPartialUpdateWithResponse(ctx context.Context, id int, body NetworkLocationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NetworkLocationsPartialUpdateResponse, error)

	// NetworkLocationsUpdate request with any body
	NetworkLocationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NetworkLocationsUpdateResponse, error)

	NetworkLocationsUpdateWithResponse(ctx context.Context, id int, body NetworkLocationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NetworkLocationsUpdateResponse, error)

	// NetworkLocationsDeletePreviewList request
	NetworkLocationsDeletePreviewListWithResponse(ctx context.Context, id int, params *NetworkLocationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*NetworkLocationsDeletePreviewListResponse, error)

	// NoteTypeList request
	NoteTypeListWithResponse(ctx context.Context, params *NoteTypeListParams, reqEditors ...RequestEditorFn) (*NoteTypeListResponse, error)

	// NoteTypeCreate request with any body
	NoteTypeCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NoteTypeCreateResponse, error)

	NoteTypeCreateWithResponse(ctx context.Context, body NoteTypeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*NoteTypeCreateResponse, error)

	// NoteTypeDestroy request
	NoteTypeDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*NoteTypeDestroyResponse, error)

	// NoteTypeRetrieve request
	NoteTypeRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*NoteTypeRetrieveResponse, error)

	// NoteTypePartialUpdate request with any body
	NoteTypePartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NoteTypePartialUpdateResponse, error)

	NoteTypePartialUpdateWithResponse(ctx context.Context, id int, body NoteTypePartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NoteTypePartialUpdateResponse, error)

	// NoteTypeUpdate request with any body
	NoteTypeUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NoteTypeUpdateResponse, error)

	NoteTypeUpdateWithResponse(ctx context.Context, id int, body NoteTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NoteTypeUpdateResponse, error)

	// NoteTypeDeletePreviewList request
	NoteTypeDeletePreviewListWithResponse(ctx context.Context, id int, params *NoteTypeDeletePreviewListParams, reqEditors ...RequestEditorFn) (*NoteTypeDeletePreviewListResponse, error)

	// NotesList request
	NotesListWithResponse(ctx context.Context, params *NotesListParams, reqEditors ...RequestEditorFn) (*NotesListResponse, error)

	// NotesRetrieve request
	NotesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*NotesRetrieveResponse, error)

	// NotesPartialUpdate request with any body
	NotesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotesPartialUpdateResponse, error)

	NotesPartialUpdateWithResponse(ctx context.Context, id int, body NotesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NotesPartialUpdateResponse, error)

	// NotesUpdate request with any body
	NotesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotesUpdateResponse, error)

	NotesUpdateWithResponse(ctx context.Context, id int, body NotesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NotesUpdateResponse, error)

	// NotificationsList request
	NotificationsListWithResponse(ctx context.Context, params *NotificationsListParams, reqEditors ...RequestEditorFn) (*NotificationsListResponse, error)

	// NotificationsCreate request with any body
	NotificationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotificationsCreateResponse, error)

	NotificationsCreateWithResponse(ctx context.Context, body NotificationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*NotificationsCreateResponse, error)

	// NotificationsDestroy request
	NotificationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*NotificationsDestroyResponse, error)

	// NotificationsRetrieve request
	NotificationsRetrieveWithResponse(ctx context.Context, id int, params *NotificationsRetrieveParams, reqEditors ...RequestEditorFn) (*NotificationsRetrieveResponse, error)

	// NotificationsPartialUpdate request with any body
	NotificationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotificationsPartialUpdateResponse, error)

	NotificationsPartialUpdateWithResponse(ctx context.Context, id int, body NotificationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NotificationsPartialUpdateResponse, error)

	// NotificationsUpdate request with any body
	NotificationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotificationsUpdateResponse, error)

	NotificationsUpdateWithResponse(ctx context.Context, id int, body NotificationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NotificationsUpdateResponse, error)

	// NotificationsDeletePreviewList request
	NotificationsDeletePreviewListWithResponse(ctx context.Context, id int, params *NotificationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*NotificationsDeletePreviewListResponse, error)

	// Oa3SchemaRetrieve request
	Oa3SchemaRetrieveWithResponse(ctx context.Context, params *Oa3SchemaRetrieveParams, reqEditors ...RequestEditorFn) (*Oa3SchemaRetrieveResponse, error)

	// ProductApiScanConfigurationsList request
	ProductApiScanConfigurationsListWithResponse(ctx context.Context, params *ProductApiScanConfigurationsListParams, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsListResponse, error)

	// ProductApiScanConfigurationsCreate request with any body
	ProductApiScanConfigurationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsCreateResponse, error)

	ProductApiScanConfigurationsCreateWithResponse(ctx context.Context, body ProductApiScanConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsCreateResponse, error)

	// ProductApiScanConfigurationsDestroy request
	ProductApiScanConfigurationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsDestroyResponse, error)

	// ProductApiScanConfigurationsRetrieve request
	ProductApiScanConfigurationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsRetrieveResponse, error)

	// ProductApiScanConfigurationsPartialUpdate request with any body
	ProductApiScanConfigurationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsPartialUpdateResponse, error)

	ProductApiScanConfigurationsPartialUpdateWithResponse(ctx context.Context, id int, body ProductApiScanConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsPartialUpdateResponse, error)

	// ProductApiScanConfigurationsUpdate request with any body
	ProductApiScanConfigurationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsUpdateResponse, error)

	ProductApiScanConfigurationsUpdateWithResponse(ctx context.Context, id int, body ProductApiScanConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsUpdateResponse, error)

	// ProductApiScanConfigurationsDeletePreviewList request
	ProductApiScanConfigurationsDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductApiScanConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsDeletePreviewListResponse, error)

	// ProductGroupsList request
	ProductGroupsListWithResponse(ctx context.Context, params *ProductGroupsListParams, reqEditors ...RequestEditorFn) (*ProductGroupsListResponse, error)

	// ProductGroupsCreate request with any body
	ProductGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductGroupsCreateResponse, error)

	ProductGroupsCreateWithResponse(ctx context.Context, body ProductGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductGroupsCreateResponse, error)

	// ProductGroupsDestroy request
	ProductGroupsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductGroupsDestroyResponse, error)

	// ProductGroupsRetrieve request
	ProductGroupsRetrieveWithResponse(ctx context.Context, id int, params *ProductGroupsRetrieveParams, reqEditors ...RequestEditorFn) (*ProductGroupsRetrieveResponse, error)

	// ProductGroupsPartialUpdate request
	ProductGroupsPartialUpdateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductGroupsPartialUpdateResponse, error)

	// ProductGroupsUpdate request with any body
	ProductGroupsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductGroupsUpdateResponse, error)

	ProductGroupsUpdateWithResponse(ctx context.Context, id int, body ProductGroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductGroupsUpdateResponse, error)

	// ProductGroupsDeletePreviewList request
	ProductGroupsDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductGroupsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductGroupsDeletePreviewListResponse, error)

	// ProductMembersList request
	ProductMembersListWithResponse(ctx context.Context, params *ProductMembersListParams, reqEditors ...RequestEditorFn) (*ProductMembersListResponse, error)

	// ProductMembersCreate request with any body
	ProductMembersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductMembersCreateResponse, error)

	ProductMembersCreateWithResponse(ctx context.Context, body ProductMembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductMembersCreateResponse, error)

	// ProductMembersDestroy request
	ProductMembersDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductMembersDestroyResponse, error)

	// ProductMembersRetrieve request
	ProductMembersRetrieveWithResponse(ctx context.Context, id int, params *ProductMembersRetrieveParams, reqEditors ...RequestEditorFn) (*ProductMembersRetrieveResponse, error)

	// ProductMembersPartialUpdate request
	ProductMembersPartialUpdateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductMembersPartialUpdateResponse, error)

	// ProductMembersUpdate request with any body
	ProductMembersUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductMembersUpdateResponse, error)

	ProductMembersUpdateWithResponse(ctx context.Context, id int, body ProductMembersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductMembersUpdateResponse, error)

	// ProductMembersDeletePreviewList request
	ProductMembersDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductMembersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductMembersDeletePreviewListResponse, error)

	// ProductTypeGroupsList request
	ProductTypeGroupsListWithResponse(ctx context.Context, params *ProductTypeGroupsListParams, reqEditors ...RequestEditorFn) (*ProductTypeGroupsListResponse, error)

	// ProductTypeGroupsCreate request with any body
	ProductTypeGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypeGroupsCreateResponse, error)

	ProductTypeGroupsCreateWithResponse(ctx context.Context, body ProductTypeGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypeGroupsCreateResponse, error)

	// ProductTypeGroupsDestroy request
	ProductTypeGroupsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductTypeGroupsDestroyResponse, error)

	// ProductTypeGroupsRetrieve request
	ProductTypeGroupsRetrieveWithResponse(ctx context.Context, id int, params *ProductTypeGroupsRetrieveParams, reqEditors ...RequestEditorFn) (*ProductTypeGroupsRetrieveResponse, error)

	// ProductTypeGroupsPartialUpdate request
	ProductTypeGroupsPartialUpdateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductTypeGroupsPartialUpdateResponse, error)

	// ProductTypeGroupsUpdate request with any body
	ProductTypeGroupsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypeGroupsUpdateResponse, error)

	ProductTypeGroupsUpdateWithResponse(ctx context.Context, id int, body ProductTypeGroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypeGroupsUpdateResponse, error)

	// ProductTypeGroupsDeletePreviewList request
	ProductTypeGroupsDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductTypeGroupsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductTypeGroupsDeletePreviewListResponse, error)

	// ProductTypeMembersList request
	ProductTypeMembersListWithResponse(ctx context.Context, params *ProductTypeMembersListParams, reqEditors ...RequestEditorFn) (*ProductTypeMembersListResponse, error)

	// ProductTypeMembersCreate request with any body
	ProductTypeMembersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypeMembersCreateResponse, error)

	ProductTypeMembersCreateWithResponse(ctx context.Context, body ProductTypeMembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypeMembersCreateResponse, error)

	// ProductTypeMembersDestroy request
	ProductTypeMembersDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductTypeMembersDestroyResponse, error)

	// ProductTypeMembersRetrieve request
	ProductTypeMembersRetrieveWithResponse(ctx context.Context, id int, params *ProductTypeMembersRetrieveParams, reqEditors ...RequestEditorFn) (*ProductTypeMembersRetrieveResponse, error)

	// ProductTypeMembersPartialUpdate request
	ProductTypeMembersPartialUpdateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductTypeMembersPartialUpdateResponse, error)

	// ProductTypeMembersUpdate request with any body
	ProductTypeMembersUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypeMembersUpdateResponse, error)

	ProductTypeMembersUpdateWithResponse(ctx context.Context, id int, body ProductTypeMembersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypeMembersUpdateResponse, error)

	// ProductTypeMembersDeletePreviewList request
	ProductTypeMembersDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductTypeMembersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductTypeMembersDeletePreviewListResponse, error)

	// ProductTypesList request
	ProductTypesListWithResponse(ctx context.Context, params *ProductTypesListParams, reqEditors ...RequestEditorFn) (*ProductTypesListResponse, error)

	// ProductTypesCreate request with any body
	ProductTypesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypesCreateResponse, error)

	ProductTypesCreateWithResponse(ctx context.Context, body ProductTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypesCreateResponse, error)

	// ProductTypesDestroy request
	ProductTypesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductTypesDestroyResponse, error)

	// ProductTypesRetrieve request
	ProductTypesRetrieveWithResponse(ctx context.Context, id int, params *ProductTypesRetrieveParams, reqEditors ...RequestEditorFn) (*ProductTypesRetrieveResponse, error)

	// ProductTypesPartialUpdate request with any body
	ProductTypesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypesPartialUpdateResponse, error)

	ProductTypesPartialUpdateWithResponse(ctx context.Context, id int, body ProductTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypesPartialUpdateResponse, error)

	// ProductTypesUpdate request with any body
	ProductTypesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypesUpdateResponse, error)

	ProductTypesUpdateWithResponse(ctx context.Context, id int, body ProductTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypesUpdateResponse, error)

	// ProductTypesDeletePreviewList request
	ProductTypesDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductTypesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductTypesDeletePreviewListResponse, error)

	// ProductTypesGenerateReportCreate request with any body
	ProductTypesGenerateReportCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypesGenerateReportCreateResponse, error)

	ProductTypesGenerateReportCreateWithResponse(ctx context.Context, id int, body ProductTypesGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypesGenerateReportCreateResponse, error)

	// ProductsList request
	ProductsListWithResponse(ctx context.Context, params *ProductsListParams, reqEditors ...RequestEditorFn) (*ProductsListResponse, error)

	// ProductsCreate request with any body
	ProductsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductsCreateResponse, error)

	ProductsCreateWithResponse(ctx context.Context, body ProductsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductsCreateResponse, error)

	// ProductsDestroy request
	ProductsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductsDestroyResponse, error)

	// ProductsRetrieve request
	ProductsRetrieveWithResponse(ctx context.Context, id int, params *ProductsRetrieveParams, reqEditors ...RequestEditorFn) (*ProductsRetrieveResponse, error)

	// ProductsPartialUpdate request with any body
	ProductsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductsPartialUpdateResponse, error)

	ProductsPartialUpdateWithResponse(ctx context.Context, id int, body ProductsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductsPartialUpdateResponse, error)

	// ProductsUpdate request with any body
	ProductsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductsUpdateResponse, error)

	ProductsUpdateWithResponse(ctx context.Context, id int, body ProductsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductsUpdateResponse, error)

	// ProductsDeletePreviewList request
	ProductsDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductsDeletePreviewListResponse, error)

	// ProductsGenerateReportCreate request with any body
	ProductsGenerateReportCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductsGenerateReportCreateResponse, error)

	ProductsGenerateReportCreateWithResponse(ctx context.Context, id int, body ProductsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductsGenerateReportCreateResponse, error)

	// RegulationsList request
	RegulationsListWithResponse(ctx context.Context, params *RegulationsListParams, reqEditors ...RequestEditorFn) (*RegulationsListResponse, error)

	// RegulationsCreate request with any body
	RegulationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegulationsCreateResponse, error)

	RegulationsCreateWithResponse(ctx context.Context, body RegulationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RegulationsCreateResponse, error)

	// RegulationsDestroy request
	RegulationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RegulationsDestroyResponse, error)

	// RegulationsRetrieve request
	RegulationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RegulationsRetrieveResponse, error)

	// RegulationsPartialUpdate request with any body
	RegulationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegulationsPartialUpdateResponse, error)

	RegulationsPartialUpdateWithResponse(ctx context.Context, id int, body RegulationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RegulationsPartialUpdateResponse, error)

	// RegulationsUpdate request with any body
	RegulationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegulationsUpdateResponse, error)

	RegulationsUpdateWithResponse(ctx context.Context, id int, body RegulationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RegulationsUpdateResponse, error)

	// RegulationsDeletePreviewList request
	RegulationsDeletePreviewListWithResponse(ctx context.Context, id int, params *RegulationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*RegulationsDeletePreviewListResponse, error)

	// ReimportScanCreate request with any body
	ReimportScanCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReimportScanCreateResponse, error)

	// RolesList request
	RolesListWithResponse(ctx context.Context, params *RolesListParams, reqEditors ...RequestEditorFn) (*RolesListResponse, error)

	// RolesRetrieve request
	RolesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RolesRetrieveResponse, error)

	// SlaConfigurationsList request
	SlaConfigurationsListWithResponse(ctx context.Context, params *SlaConfigurationsListParams, reqEditors ...RequestEditorFn) (*SlaConfigurationsListResponse, error)

	// SlaConfigurationsCreate request with any body
	SlaConfigurationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaConfigurationsCreateResponse, error)

	SlaConfigurationsCreateWithResponse(ctx context.Context, body SlaConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaConfigurationsCreateResponse, error)

	// SlaConfigurationsDestroy request
	SlaConfigurationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*SlaConfigurationsDestroyResponse, error)

	// SlaConfigurationsRetrieve request
	SlaConfigurationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*SlaConfigurationsRetrieveResponse, error)

	// SlaConfigurationsPartialUpdate request with any body
	SlaConfigurationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaConfigurationsPartialUpdateResponse, error)

	SlaConfigurationsPartialUpdateWithResponse(ctx context.Context, id int, body SlaConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaConfigurationsPartialUpdateResponse, error)

	// SlaConfigurationsUpdate request with any body
	SlaConfigurationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaConfigurationsUpdateResponse, error)

	SlaConfigurationsUpdateWithResponse(ctx context.Context, id int, body SlaConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaConfigurationsUpdateResponse, error)

	// SonarqubeIssuesList request
	SonarqubeIssuesListWithResponse(ctx context.Context, params *SonarqubeIssuesListParams, reqEditors ...RequestEditorFn) (*SonarqubeIssuesListResponse, error)

	// SonarqubeIssuesCreate request with any body
	SonarqubeIssuesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SonarqubeIssuesCreateResponse, error)

	SonarqubeIssuesCreateWithResponse(ctx context.Context, body SonarqubeIssuesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SonarqubeIssuesCreateResponse, error)

	// SonarqubeIssuesDestroy request
	SonarqubeIssuesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*SonarqubeIssuesDestroyResponse, error)

	// SonarqubeIssuesRetrieve request
	SonarqubeIssuesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*SonarqubeIssuesRetrieveResponse, error)

	// SonarqubeIssuesPartialUpdate request with any body
	SonarqubeIssuesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SonarqubeIssuesPartialUpdateResponse, error)

	SonarqubeIssuesPartialUpdateWithResponse(ctx context.Context, id int, body SonarqubeIssuesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SonarqubeIssuesPartialUpdateResponse, error)

	// SonarqubeIssuesUpdate request with any body
	SonarqubeIssuesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SonarqubeIssuesUpdateResponse, error)

	SonarqubeIssuesUpdateWithResponse(ctx context.Context, id int, body SonarqubeIssuesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SonarqubeIssuesUpdateResponse, error)

	// SonarqubeIssuesDeletePreviewList request
	SonarqubeIssuesDeletePreviewListWithResponse(ctx context.Context, id int, params *SonarqubeIssuesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*SonarqubeIssuesDeletePreviewListResponse, error)

	// SonarqubeTransitionsList request
	SonarqubeTransitionsListWithResponse(ctx context.Context, params *SonarqubeTransitionsListParams, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsListResponse, error)

	// SonarqubeTransitionsCreate request with any body
	SonarqubeTransitionsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsCreateResponse, error)

	SonarqubeTransitionsCreateWithResponse(ctx context.Context, body SonarqubeTransitionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsCreateResponse, error)

	// SonarqubeTransitionsDestroy request
	SonarqubeTransitionsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsDestroyResponse, error)

	// SonarqubeTransitionsRetrieve request
	SonarqubeTransitionsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsRetrieveResponse, error)

	// SonarqubeTransitionsPartialUpdate request with any body
	SonarqubeTransitionsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsPartialUpdateResponse, error)

	SonarqubeTransitionsPartialUpdateWithResponse(ctx context.Context, id int, body SonarqubeTransitionsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsPartialUpdateResponse, error)

	// SonarqubeTransitionsUpdate request with any body
	SonarqubeTransitionsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsUpdateResponse, error)

	SonarqubeTransitionsUpdateWithResponse(ctx context.Context, id int, body SonarqubeTransitionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsUpdateResponse, error)

	// SonarqubeTransitionsDeletePreviewList request
	SonarqubeTransitionsDeletePreviewListWithResponse(ctx context.Context, id int, params *SonarqubeTransitionsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsDeletePreviewListResponse, error)

	// StubFindingsList request
	StubFindingsListWithResponse(ctx context.Context, params *StubFindingsListParams, reqEditors ...RequestEditorFn) (*StubFindingsListResponse, error)

	// StubFindingsCreate request with any body
	StubFindingsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StubFindingsCreateResponse, error)

	StubFindingsCreateWithResponse(ctx context.Context, body StubFindingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*StubFindingsCreateResponse, error)

	// StubFindingsDestroy request
	StubFindingsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*StubFindingsDestroyResponse, error)

	// StubFindingsRetrieve request
	StubFindingsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*StubFindingsRetrieveResponse, error)

	// StubFindingsPartialUpdate request with any body
	StubFindingsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StubFindingsPartialUpdateResponse, error)

	StubFindingsPartialUpdateWithResponse(ctx context.Context, id int, body StubFindingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*StubFindingsPartialUpdateResponse, error)

	// StubFindingsUpdate request with any body
	StubFindingsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StubFindingsUpdateResponse, error)

	StubFindingsUpdateWithResponse(ctx context.Context, id int, body StubFindingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*StubFindingsUpdateResponse, error)

	// StubFindingsDeletePreviewList request
	StubFindingsDeletePreviewListWithResponse(ctx context.Context, id int, params *StubFindingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*StubFindingsDeletePreviewListResponse, error)

	// SystemSettingsList request
	SystemSettingsListWithResponse(ctx context.Context, params *SystemSettingsListParams, reqEditors ...RequestEditorFn) (*SystemSettingsListResponse, error)

	// SystemSettingsPartialUpdate request with any body
	SystemSettingsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SystemSettingsPartialUpdateResponse, error)

	SystemSettingsPartialUpdateWithResponse(ctx context.Context, id int, body SystemSettingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SystemSettingsPartialUpdateResponse, error)

	// SystemSettingsUpdate request with any body
	SystemSettingsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SystemSettingsUpdateResponse, error)

	SystemSettingsUpdateWithResponse(ctx context.Context, id int, body SystemSettingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SystemSettingsUpdateResponse, error)

	// TechnologiesList request
	TechnologiesListWithResponse(ctx context.Context, params *TechnologiesListParams, reqEditors ...RequestEditorFn) (*TechnologiesListResponse, error)

	// TechnologiesCreate request with any body
	TechnologiesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TechnologiesCreateResponse, error)

	TechnologiesCreateWithResponse(ctx context.Context, body TechnologiesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TechnologiesCreateResponse, error)

	// TechnologiesDestroy request
	TechnologiesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TechnologiesDestroyResponse, error)

	// TechnologiesRetrieve request
	TechnologiesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TechnologiesRetrieveResponse, error)

	// TechnologiesPartialUpdate request with any body
	TechnologiesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TechnologiesPartialUpdateResponse, error)

	TechnologiesPartialUpdateWithResponse(ctx context.Context, id int, body TechnologiesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TechnologiesPartialUpdateResponse, error)

	// TechnologiesUpdate request with any body
	TechnologiesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TechnologiesUpdateResponse, error)

	TechnologiesUpdateWithResponse(ctx context.Context, id int, body TechnologiesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TechnologiesUpdateResponse, error)

	// TechnologiesDeletePreviewList request
	TechnologiesDeletePreviewListWithResponse(ctx context.Context, id int, params *TechnologiesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*TechnologiesDeletePreviewListResponse, error)

	// TestImportsList request
	TestImportsListWithResponse(ctx context.Context, params *TestImportsListParams, reqEditors ...RequestEditorFn) (*TestImportsListResponse, error)

	// TestImportsCreate request with any body
	TestImportsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestImportsCreateResponse, error)

	TestImportsCreateWithResponse(ctx context.Context, body TestImportsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestImportsCreateResponse, error)

	// TestImportsDestroy request
	TestImportsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TestImportsDestroyResponse, error)

	// TestImportsRetrieve request
	TestImportsRetrieveWithResponse(ctx context.Context, id int, params *TestImportsRetrieveParams, reqEditors ...RequestEditorFn) (*TestImportsRetrieveResponse, error)

	// TestImportsPartialUpdate request with any body
	TestImportsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestImportsPartialUpdateResponse, error)

	TestImportsPartialUpdateWithResponse(ctx context.Context, id int, body TestImportsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestImportsPartialUpdateResponse, error)

	// TestImportsUpdate request with any body
	TestImportsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestImportsUpdateResponse, error)

	TestImportsUpdateWithResponse(ctx context.Context, id int, body TestImportsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestImportsUpdateResponse, error)

	// TestImportsDeletePreviewList request
	TestImportsDeletePreviewListWithResponse(ctx context.Context, id int, params *TestImportsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*TestImportsDeletePreviewListResponse, error)

	// TestTypesList request
	TestTypesListWithResponse(ctx context.Context, params *TestTypesListParams, reqEditors ...RequestEditorFn) (*TestTypesListResponse, error)

	// TestTypesCreate request with any body
	TestTypesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestTypesCreateResponse, error)

	TestTypesCreateWithResponse(ctx context.Context, body TestTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestTypesCreateResponse, error)

	// TestTypesRetrieve request
	TestTypesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TestTypesRetrieveResponse, error)

	// TestTypesPartialUpdate request with any body
	TestTypesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestTypesPartialUpdateResponse, error)

	TestTypesPartialUpdateWithResponse(ctx context.Context, id int, body TestTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestTypesPartialUpdateResponse, error)

	// TestTypesUpdate request with any body
	TestTypesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestTypesUpdateResponse, error)

	TestTypesUpdateWithResponse(ctx context.Context, id int, body TestTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestTypesUpdateResponse, error)

	// TestsList request
	TestsListWithResponse(ctx context.Context, params *TestsListParams, reqEditors ...RequestEditorFn) (*TestsListResponse, error)

	// TestsCreate request with any body
	TestsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsCreateResponse, error)

	TestsCreateWithResponse(ctx context.Context, body TestsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestsCreateResponse, error)

	// TestsDestroy request
	TestsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TestsDestroyResponse, error)

	// TestsRetrieve request
	TestsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TestsRetrieveResponse, error)

	// TestsPartialUpdate request with any body
	TestsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsPartialUpdateResponse, error)

	TestsPartialUpdateWithResponse(ctx context.Context, id int, body TestsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestsPartialUpdateResponse, error)

	// TestsUpdate request with any body
	TestsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsUpdateResponse, error)

	TestsUpdateWithResponse(ctx context.Context, id int, body TestsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestsUpdateResponse, error)

	// TestsAcceptRisksCreate request with any body
	TestsAcceptRisksCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsAcceptRisksCreateResponse, error)

	TestsAcceptRisksCreateWithResponse(ctx context.Context, id int, body TestsAcceptRisksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestsAcceptRisksCreateResponse, error)

	// TestsDeletePreviewList request
	TestsDeletePreviewListWithResponse(ctx context.Context, id int, params *TestsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*TestsDeletePreviewListResponse, error)

	// TestsFilesRetrieve request
	TestsFilesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TestsFilesRetrieveResponse, error)

	// TestsFilesCreate request with any body
	TestsFilesCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsFilesCreateResponse, error)

	// TestsGenerateReportCreate request with any body
	TestsGenerateReportCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsGenerateReportCreateResponse, error)

	TestsGenerateReportCreateWithResponse(ctx context.Context, id int, body TestsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestsGenerateReportCreateResponse, error)

	// TestsNotesRetrieve request
	TestsNotesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TestsNotesRetrieveResponse, error)

	// TestsNotesCreate request with any body
	TestsNotesCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsNotesCreateResponse, error)

	TestsNotesCreateWithResponse(ctx context.Context, id int, body TestsNotesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestsNotesCreateResponse, error)

	// ToolConfigurationsList request
	ToolConfigurationsListWithResponse(ctx context.Context, params *ToolConfigurationsListParams, reqEditors ...RequestEditorFn) (*ToolConfigurationsListResponse, error)

	// ToolConfigurationsCreate request with any body
	ToolConfigurationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolConfigurationsCreateResponse, error)

	ToolConfigurationsCreateWithResponse(ctx context.Context, body ToolConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolConfigurationsCreateResponse, error)

	// ToolConfigurationsDestroy request
	ToolConfigurationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ToolConfigurationsDestroyResponse, error)

	// ToolConfigurationsRetrieve request
	ToolConfigurationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ToolConfigurationsRetrieveResponse, error)

	// ToolConfigurationsPartialUpdate request with any body
	ToolConfigurationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolConfigurationsPartialUpdateResponse, error)

	ToolConfigurationsPartialUpdateWithResponse(ctx context.Context, id int, body ToolConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolConfigurationsPartialUpdateResponse, error)

	// ToolConfigurationsUpdate request with any body
	ToolConfigurationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolConfigurationsUpdateResponse, error)

	ToolConfigurationsUpdateWithResponse(ctx context.Context, id int, body ToolConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolConfigurationsUpdateResponse, error)

	// ToolConfigurationsDeletePreviewList request
	ToolConfigurationsDeletePreviewListWithResponse(ctx context.Context, id int, params *ToolConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ToolConfigurationsDeletePreviewListResponse, error)

	// ToolProductSettingsList request
	ToolProductSettingsListWithResponse(ctx context.Context, params *ToolProductSettingsListParams, reqEditors ...RequestEditorFn) (*ToolProductSettingsListResponse, error)

	// ToolProductSettingsCreate request with any body
	ToolProductSettingsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolProductSettingsCreateResponse, error)

	ToolProductSettingsCreateWithResponse(ctx context.Context, body ToolProductSettingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolProductSettingsCreateResponse, error)

	// ToolProductSettingsDestroy request
	ToolProductSettingsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ToolProductSettingsDestroyResponse, error)

	// ToolProductSettingsRetrieve request
	ToolProductSettingsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ToolProductSettingsRetrieveResponse, error)

	// ToolProductSettingsPartialUpdate request with any body
	ToolProductSettingsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolProductSettingsPartialUpdateResponse, error)

	ToolProductSettingsPartialUpdateWithResponse(ctx context.Context, id int, body ToolProductSettingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolProductSettingsPartialUpdateResponse, error)

	// ToolProductSettingsUpdate request with any body
	ToolProductSettingsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolProductSettingsUpdateResponse, error)

	ToolProductSettingsUpdateWithResponse(ctx context.Context, id int, body ToolProductSettingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolProductSettingsUpdateResponse, error)

	// ToolProductSettingsDeletePreviewList request
	ToolProductSettingsDeletePreviewListWithResponse(ctx context.Context, id int, params *ToolProductSettingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ToolProductSettingsDeletePreviewListResponse, error)

	// ToolTypesList request
	ToolTypesListWithResponse(ctx context.Context, params *ToolTypesListParams, reqEditors ...RequestEditorFn) (*ToolTypesListResponse, error)

	// ToolTypesCreate request with any body
	ToolTypesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolTypesCreateResponse, error)

	ToolTypesCreateWithResponse(ctx context.Context, body ToolTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolTypesCreateResponse, error)

	// ToolTypesDestroy request
	ToolTypesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ToolTypesDestroyResponse, error)

	// ToolTypesRetrieve request
	ToolTypesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ToolTypesRetrieveResponse, error)

	// ToolTypesPartialUpdate request with any body
	ToolTypesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolTypesPartialUpdateResponse, error)

	ToolTypesPartialUpdateWithResponse(ctx context.Context, id int, body ToolTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolTypesPartialUpdateResponse, error)

	// ToolTypesUpdate request with any body
	ToolTypesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolTypesUpdateResponse, error)

	ToolTypesUpdateWithResponse(ctx context.Context, id int, body ToolTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolTypesUpdateResponse, error)

	// ToolTypesDeletePreviewList request
	ToolTypesDeletePreviewListWithResponse(ctx context.Context, id int, params *ToolTypesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ToolTypesDeletePreviewListResponse, error)

	// UserContactInfosList request
	UserContactInfosListWithResponse(ctx context.Context, params *UserContactInfosListParams, reqEditors ...RequestEditorFn) (*UserContactInfosListResponse, error)

	// UserContactInfosCreate request with any body
	UserContactInfosCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserContactInfosCreateResponse, error)

	UserContactInfosCreateWithResponse(ctx context.Context, body UserContactInfosCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserContactInfosCreateResponse, error)

	// UserContactInfosDestroy request
	UserContactInfosDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*UserContactInfosDestroyResponse, error)

	// UserContactInfosRetrieve request
	UserContactInfosRetrieveWithResponse(ctx context.Context, id int, params *UserContactInfosRetrieveParams, reqEditors ...RequestEditorFn) (*UserContactInfosRetrieveResponse, error)

	// UserContactInfosPartialUpdate request with any body
	UserContactInfosPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserContactInfosPartialUpdateResponse, error)

	UserContactInfosPartialUpdateWithResponse(ctx context.Context, id int, body UserContactInfosPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserContactInfosPartialUpdateResponse, error)

	// UserContactInfosUpdate request with any body
	UserContactInfosUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserContactInfosUpdateResponse, error)

	UserContactInfosUpdateWithResponse(ctx context.Context, id int, body UserContactInfosUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserContactInfosUpdateResponse, error)

	// UserContactInfosDeletePreviewList request
	UserContactInfosDeletePreviewListWithResponse(ctx context.Context, id int, params *UserContactInfosDeletePreviewListParams, reqEditors ...RequestEditorFn) (*UserContactInfosDeletePreviewListResponse, error)

	// UserProfileRetrieve request
	UserProfileRetrieveWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserProfileRetrieveResponse, error)

	// UsersList request
	UsersListWithResponse(ctx context.Context, params *UsersListParams, reqEditors ...RequestEditorFn) (*UsersListResponse, error)

	// UsersCreate request with any body
	UsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error)

	UsersCreateWithResponse(ctx context.Context, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error)

	// UsersDestroy request
	UsersDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*UsersDestroyResponse, error)

	// UsersRetrieve request
	UsersRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*UsersRetrieveResponse, error)

	// UsersPartialUpdate request with any body
	UsersPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersPartialUpdateResponse, error)

	UsersPartialUpdateWithResponse(ctx context.Context, id int, body UsersPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersPartialUpdateResponse, error)

	// UsersUpdate request with any body
	UsersUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdateResponse, error)

	UsersUpdateWithResponse(ctx context.Context, id int, body UsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdateResponse, error)

	// UsersDeletePreviewList request
	UsersDeletePreviewListWithResponse(ctx context.Context, id int, params *UsersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*UsersDeletePreviewListResponse, error)
}

type ApiTokenAuthCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthToken
}

// Status returns HTTPResponse.Status
func (r ApiTokenAuthCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiTokenAuthCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigurationPermissionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedConfigurationPermissionList
}

// Status returns HTTPResponse.Status
func (r ConfigurationPermissionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigurationPermissionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigurationPermissionsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigurationPermission
}

// Status returns HTTPResponse.Status
func (r ConfigurationPermissionsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigurationPermissionsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevelopmentEnvironmentsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDevelopmentEnvironmentList
}

// Status returns HTTPResponse.Status
func (r DevelopmentEnvironmentsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevelopmentEnvironmentsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevelopmentEnvironmentsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DevelopmentEnvironment
}

// Status returns HTTPResponse.Status
func (r DevelopmentEnvironmentsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevelopmentEnvironmentsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevelopmentEnvironmentsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DevelopmentEnvironmentsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevelopmentEnvironmentsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevelopmentEnvironmentsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevelopmentEnvironment
}

// Status returns HTTPResponse.Status
func (r DevelopmentEnvironmentsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevelopmentEnvironmentsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevelopmentEnvironmentsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevelopmentEnvironment
}

// Status returns HTTPResponse.Status
func (r DevelopmentEnvironmentsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevelopmentEnvironmentsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevelopmentEnvironmentsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevelopmentEnvironment
}

// Status returns HTTPResponse.Status
func (r DevelopmentEnvironmentsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevelopmentEnvironmentsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevelopmentEnvironmentsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r DevelopmentEnvironmentsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevelopmentEnvironmentsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupMembersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDojoGroupMemberList
}

// Status returns HTTPResponse.Status
func (r DojoGroupMembersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupMembersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupMembersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DojoGroupMember
}

// Status returns HTTPResponse.Status
func (r DojoGroupMembersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupMembersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupMembersDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DojoGroupMembersDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupMembersDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupMembersRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DojoGroupMember
}

// Status returns HTTPResponse.Status
func (r DojoGroupMembersRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupMembersRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupMembersPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DojoGroupMember
}

// Status returns HTTPResponse.Status
func (r DojoGroupMembersPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupMembersPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupMembersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DojoGroupMember
}

// Status returns HTTPResponse.Status
func (r DojoGroupMembersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupMembersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupMembersDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r DojoGroupMembersDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupMembersDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDojoGroupList
}

// Status returns HTTPResponse.Status
func (r DojoGroupsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DojoGroup
}

// Status returns HTTPResponse.Status
func (r DojoGroupsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DojoGroupsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DojoGroup
}

// Status returns HTTPResponse.Status
func (r DojoGroupsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DojoGroup
}

// Status returns HTTPResponse.Status
func (r DojoGroupsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DojoGroup
}

// Status returns HTTPResponse.Status
func (r DojoGroupsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DojoGroupsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r DojoGroupsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DojoGroupsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointMetaImportCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EndpointMetaImporter
}

// Status returns HTTPResponse.Status
func (r EndpointMetaImportCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointMetaImportCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointStatusListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedEndpointStatusList
}

// Status returns HTTPResponse.Status
func (r EndpointStatusListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointStatusListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointStatusCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EndpointStatus
}

// Status returns HTTPResponse.Status
func (r EndpointStatusCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointStatusCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointStatusDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EndpointStatusDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointStatusDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointStatusRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointStatus
}

// Status returns HTTPResponse.Status
func (r EndpointStatusRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointStatusRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointStatusPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointStatus
}

// Status returns HTTPResponse.Status
func (r EndpointStatusPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointStatusPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointStatusUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointStatus
}

// Status returns HTTPResponse.Status
func (r EndpointStatusUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointStatusUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointStatusDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r EndpointStatusDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointStatusDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedEndpointList
}

// Status returns HTTPResponse.Status
func (r EndpointsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Endpoint
}

// Status returns HTTPResponse.Status
func (r EndpointsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EndpointsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoint
}

// Status returns HTTPResponse.Status
func (r EndpointsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoint
}

// Status returns HTTPResponse.Status
func (r EndpointsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoint
}

// Status returns HTTPResponse.Status
func (r EndpointsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r EndpointsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndpointsGenerateReportCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportGenerate
}

// Status returns HTTPResponse.Status
func (r EndpointsGenerateReportCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndpointsGenerateReportCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementPresetsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedEngagementPresetsList
}

// Status returns HTTPResponse.Status
func (r EngagementPresetsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementPresetsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementPresetsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EngagementPresets
}

// Status returns HTTPResponse.Status
func (r EngagementPresetsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementPresetsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementPresetsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EngagementPresetsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementPresetsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementPresetsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementPresets
}

// Status returns HTTPResponse.Status
func (r EngagementPresetsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementPresetsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementPresetsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementPresets
}

// Status returns HTTPResponse.Status
func (r EngagementPresetsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementPresetsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementPresetsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementPresets
}

// Status returns HTTPResponse.Status
func (r EngagementPresetsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementPresetsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementPresetsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r EngagementPresetsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementPresetsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedEngagementList
}

// Status returns HTTPResponse.Status
func (r EngagementsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Engagement
}

// Status returns HTTPResponse.Status
func (r EngagementsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EngagementsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Engagement
}

// Status returns HTTPResponse.Status
func (r EngagementsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Engagement
}

// Status returns HTTPResponse.Status
func (r EngagementsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Engagement
}

// Status returns HTTPResponse.Status
func (r EngagementsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsAcceptRisksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]RiskAcceptance
}

// Status returns HTTPResponse.Status
func (r EngagementsAcceptRisksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsAcceptRisksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsCloseCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EngagementsCloseCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsCloseCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r EngagementsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsFilesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementToFiles
}

// Status returns HTTPResponse.Status
func (r EngagementsFilesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsFilesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsFilesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *File
}

// Status returns HTTPResponse.Status
func (r EngagementsFilesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsFilesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsGenerateReportCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportGenerate
}

// Status returns HTTPResponse.Status
func (r EngagementsGenerateReportCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsGenerateReportCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsNotesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EngagementToNotes
}

// Status returns HTTPResponse.Status
func (r EngagementsNotesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsNotesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsNotesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Note
}

// Status returns HTTPResponse.Status
func (r EngagementsNotesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsNotesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngagementsReopenCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EngagementsReopenCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngagementsReopenCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingTemplatesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedFindingTemplateList
}

// Status returns HTTPResponse.Status
func (r FindingTemplatesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingTemplatesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingTemplatesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FindingTemplate
}

// Status returns HTTPResponse.Status
func (r FindingTemplatesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingTemplatesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingTemplatesDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindingTemplatesDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingTemplatesDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingTemplatesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindingTemplate
}

// Status returns HTTPResponse.Status
func (r FindingTemplatesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingTemplatesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingTemplatesPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindingTemplate
}

// Status returns HTTPResponse.Status
func (r FindingTemplatesPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingTemplatesPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingTemplatesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindingTemplate
}

// Status returns HTTPResponse.Status
func (r FindingTemplatesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingTemplatesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingTemplatesDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r FindingTemplatesDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingTemplatesDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedFindingList
}

// Status returns HTTPResponse.Status
func (r FindingsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FindingCreate
}

// Status returns HTTPResponse.Status
func (r FindingsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsAcceptRisksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PaginatedRiskAcceptanceList
}

// Status returns HTTPResponse.Status
func (r FindingsAcceptRisksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsAcceptRisksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsGenerateReportCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportGenerate
}

// Status returns HTTPResponse.Status
func (r FindingsGenerateReportCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsGenerateReportCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindingsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Finding
}

// Status returns HTTPResponse.Status
func (r FindingsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Finding
}

// Status returns HTTPResponse.Status
func (r FindingsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Finding
}

// Status returns HTTPResponse.Status
func (r FindingsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsCloseCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindingClose
}

// Status returns HTTPResponse.Status
func (r FindingsCloseCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsCloseCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r FindingsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsDuplicateListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Finding
}

// Status returns HTTPResponse.Status
func (r FindingsDuplicateListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsDuplicateListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsDuplicateResetCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindingsDuplicateResetCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsDuplicateResetCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsFilesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindingToFiles
}

// Status returns HTTPResponse.Status
func (r FindingsFilesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsFilesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsFilesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *File
}

// Status returns HTTPResponse.Status
func (r FindingsFilesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsFilesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsMetadataDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindingsMetadataDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsMetadataDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsMetadataListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FindingMeta
}

// Status returns HTTPResponse.Status
func (r FindingsMetadataListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsMetadataListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsMetadataCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindingMeta
}

// Status returns HTTPResponse.Status
func (r FindingsMetadataCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsMetadataCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsMetadataUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindingMeta
}

// Status returns HTTPResponse.Status
func (r FindingsMetadataUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsMetadataUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsNotesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindingToNotes
}

// Status returns HTTPResponse.Status
func (r FindingsNotesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsNotesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsNotesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Note
}

// Status returns HTTPResponse.Status
func (r FindingsNotesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsNotesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsOriginalCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindingsOriginalCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsOriginalCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsRemoveNotePartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindingsRemoveNotePartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsRemoveNotePartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsRemoveTagsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindingsRemoveTagsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsRemoveTagsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsRemoveTagsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindingsRemoveTagsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsRemoveTagsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsRequestResponseRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BurpRawRequestResponse
}

// Status returns HTTPResponse.Status
func (r FindingsRequestResponseRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsRequestResponseRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsRequestResponseCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BurpRawRequestResponse
}

// Status returns HTTPResponse.Status
func (r FindingsRequestResponseCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsRequestResponseCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsTagsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tag
}

// Status returns HTTPResponse.Status
func (r FindingsTagsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsTagsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindingsTagsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Tag
}

// Status returns HTTPResponse.Status
func (r FindingsTagsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindingsTagsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalRolesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedGlobalRoleList
}

// Status returns HTTPResponse.Status
func (r GlobalRolesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalRolesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalRolesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GlobalRole
}

// Status returns HTTPResponse.Status
func (r GlobalRolesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalRolesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalRolesDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GlobalRolesDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalRolesDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalRolesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalRole
}

// Status returns HTTPResponse.Status
func (r GlobalRolesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalRolesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalRolesPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalRole
}

// Status returns HTTPResponse.Status
func (r GlobalRolesPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalRolesPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalRolesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalRole
}

// Status returns HTTPResponse.Status
func (r GlobalRolesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalRolesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalRolesDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r GlobalRolesDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalRolesDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportLanguagesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ImportLanguages
}

// Status returns HTTPResponse.Status
func (r ImportLanguagesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportLanguagesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportScanCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ImportScan
}

// Status returns HTTPResponse.Status
func (r ImportScanCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportScanCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraConfigurationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedJIRAInstanceList
}

// Status returns HTTPResponse.Status
func (r JiraConfigurationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraConfigurationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraConfigurationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *JIRAInstance
}

// Status returns HTTPResponse.Status
func (r JiraConfigurationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraConfigurationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraConfigurationsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r JiraConfigurationsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraConfigurationsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraConfigurationsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAInstance
}

// Status returns HTTPResponse.Status
func (r JiraConfigurationsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraConfigurationsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraConfigurationsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAInstance
}

// Status returns HTTPResponse.Status
func (r JiraConfigurationsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraConfigurationsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraConfigurationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAInstance
}

// Status returns HTTPResponse.Status
func (r JiraConfigurationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraConfigurationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraConfigurationsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r JiraConfigurationsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraConfigurationsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraFindingMappingsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedJIRAIssueList
}

// Status returns HTTPResponse.Status
func (r JiraFindingMappingsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraFindingMappingsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraFindingMappingsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *JIRAIssue
}

// Status returns HTTPResponse.Status
func (r JiraFindingMappingsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraFindingMappingsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraFindingMappingsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r JiraFindingMappingsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraFindingMappingsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraFindingMappingsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAIssue
}

// Status returns HTTPResponse.Status
func (r JiraFindingMappingsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraFindingMappingsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraFindingMappingsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAIssue
}

// Status returns HTTPResponse.Status
func (r JiraFindingMappingsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraFindingMappingsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraFindingMappingsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAIssue
}

// Status returns HTTPResponse.Status
func (r JiraFindingMappingsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraFindingMappingsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraFindingMappingsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r JiraFindingMappingsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraFindingMappingsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraInstancesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedJIRAInstanceList
}

// Status returns HTTPResponse.Status
func (r JiraInstancesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraInstancesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraInstancesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *JIRAInstance
}

// Status returns HTTPResponse.Status
func (r JiraInstancesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraInstancesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraInstancesDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r JiraInstancesDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraInstancesDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraInstancesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAInstance
}

// Status returns HTTPResponse.Status
func (r JiraInstancesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraInstancesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraInstancesPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAInstance
}

// Status returns HTTPResponse.Status
func (r JiraInstancesPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraInstancesPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraInstancesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAInstance
}

// Status returns HTTPResponse.Status
func (r JiraInstancesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraInstancesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraInstancesDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r JiraInstancesDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraInstancesDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProductConfigurationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedJIRAProjectList
}

// Status returns HTTPResponse.Status
func (r JiraProductConfigurationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProductConfigurationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProductConfigurationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *JIRAProject
}

// Status returns HTTPResponse.Status
func (r JiraProductConfigurationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProductConfigurationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProductConfigurationsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r JiraProductConfigurationsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProductConfigurationsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProductConfigurationsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAProject
}

// Status returns HTTPResponse.Status
func (r JiraProductConfigurationsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProductConfigurationsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProductConfigurationsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAProject
}

// Status returns HTTPResponse.Status
func (r JiraProductConfigurationsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProductConfigurationsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProductConfigurationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAProject
}

// Status returns HTTPResponse.Status
func (r JiraProductConfigurationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProductConfigurationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProductConfigurationsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r JiraProductConfigurationsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProductConfigurationsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProjectsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedJIRAProjectList
}

// Status returns HTTPResponse.Status
func (r JiraProjectsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProjectsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProjectsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *JIRAProject
}

// Status returns HTTPResponse.Status
func (r JiraProjectsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProjectsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProjectsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r JiraProjectsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProjectsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProjectsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAProject
}

// Status returns HTTPResponse.Status
func (r JiraProjectsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProjectsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProjectsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAProject
}

// Status returns HTTPResponse.Status
func (r JiraProjectsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProjectsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProjectsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JIRAProject
}

// Status returns HTTPResponse.Status
func (r JiraProjectsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProjectsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JiraProjectsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r JiraProjectsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JiraProjectsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguageTypesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedLanguageTypeList
}

// Status returns HTTPResponse.Status
func (r LanguageTypesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguageTypesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguageTypesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LanguageType
}

// Status returns HTTPResponse.Status
func (r LanguageTypesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguageTypesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguageTypesDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LanguageTypesDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguageTypesDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguageTypesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LanguageType
}

// Status returns HTTPResponse.Status
func (r LanguageTypesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguageTypesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguageTypesPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LanguageType
}

// Status returns HTTPResponse.Status
func (r LanguageTypesPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguageTypesPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguageTypesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LanguageType
}

// Status returns HTTPResponse.Status
func (r LanguageTypesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguageTypesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguageTypesDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r LanguageTypesDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguageTypesDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguagesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedLanguageList
}

// Status returns HTTPResponse.Status
func (r LanguagesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguagesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguagesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Language
}

// Status returns HTTPResponse.Status
func (r LanguagesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguagesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguagesDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LanguagesDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguagesDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguagesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Language
}

// Status returns HTTPResponse.Status
func (r LanguagesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguagesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguagesPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Language
}

// Status returns HTTPResponse.Status
func (r LanguagesPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguagesPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguagesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Language
}

// Status returns HTTPResponse.Status
func (r LanguagesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguagesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LanguagesDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r LanguagesDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LanguagesDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedMetaList
}

// Status returns HTTPResponse.Status
func (r MetadataListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Meta
}

// Status returns HTTPResponse.Status
func (r MetadataCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MetadataDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Meta
}

// Status returns HTTPResponse.Status
func (r MetadataRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Meta
}

// Status returns HTTPResponse.Status
func (r MetadataPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Meta
}

// Status returns HTTPResponse.Status
func (r MetadataUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r MetadataDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworkLocationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedNetworkLocationsList
}

// Status returns HTTPResponse.Status
func (r NetworkLocationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworkLocationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworkLocationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NetworkLocations
}

// Status returns HTTPResponse.Status
func (r NetworkLocationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworkLocationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworkLocationsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NetworkLocationsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworkLocationsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworkLocationsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkLocations
}

// Status returns HTTPResponse.Status
func (r NetworkLocationsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworkLocationsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworkLocationsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkLocations
}

// Status returns HTTPResponse.Status
func (r NetworkLocationsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworkLocationsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworkLocationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkLocations
}

// Status returns HTTPResponse.Status
func (r NetworkLocationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworkLocationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworkLocationsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r NetworkLocationsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworkLocationsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NoteTypeListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedNoteTypeList
}

// Status returns HTTPResponse.Status
func (r NoteTypeListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NoteTypeListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NoteTypeCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NoteType
}

// Status returns HTTPResponse.Status
func (r NoteTypeCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NoteTypeCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NoteTypeDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NoteTypeDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NoteTypeDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NoteTypeRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NoteType
}

// Status returns HTTPResponse.Status
func (r NoteTypeRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NoteTypeRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NoteTypePartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NoteType
}

// Status returns HTTPResponse.Status
func (r NoteTypePartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NoteTypePartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NoteTypeUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NoteType
}

// Status returns HTTPResponse.Status
func (r NoteTypeUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NoteTypeUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NoteTypeDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r NoteTypeDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NoteTypeDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedNoteList
}

// Status returns HTTPResponse.Status
func (r NotesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Note
}

// Status returns HTTPResponse.Status
func (r NotesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotesPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Note
}

// Status returns HTTPResponse.Status
func (r NotesPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotesPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Note
}

// Status returns HTTPResponse.Status
func (r NotesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotificationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedNotificationsList
}

// Status returns HTTPResponse.Status
func (r NotificationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotificationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotificationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Notifications
}

// Status returns HTTPResponse.Status
func (r NotificationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotificationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotificationsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NotificationsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotificationsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotificationsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notifications
}

// Status returns HTTPResponse.Status
func (r NotificationsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotificationsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotificationsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notifications
}

// Status returns HTTPResponse.Status
func (r NotificationsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotificationsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotificationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notifications
}

// Status returns HTTPResponse.Status
func (r NotificationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotificationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotificationsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r NotificationsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotificationsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oa3SchemaRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]interface{} `json:"-"`
	}
	YAML200 *struct {
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r Oa3SchemaRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oa3SchemaRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductApiScanConfigurationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedProductAPIScanConfigurationList
}

// Status returns HTTPResponse.Status
func (r ProductApiScanConfigurationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductApiScanConfigurationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductApiScanConfigurationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProductAPIScanConfiguration
}

// Status returns HTTPResponse.Status
func (r ProductApiScanConfigurationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductApiScanConfigurationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductApiScanConfigurationsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProductApiScanConfigurationsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductApiScanConfigurationsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductApiScanConfigurationsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductAPIScanConfiguration
}

// Status returns HTTPResponse.Status
func (r ProductApiScanConfigurationsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductApiScanConfigurationsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductApiScanConfigurationsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductAPIScanConfiguration
}

// Status returns HTTPResponse.Status
func (r ProductApiScanConfigurationsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductApiScanConfigurationsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductApiScanConfigurationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductAPIScanConfiguration
}

// Status returns HTTPResponse.Status
func (r ProductApiScanConfigurationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductApiScanConfigurationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductApiScanConfigurationsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r ProductApiScanConfigurationsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductApiScanConfigurationsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductGroupsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedProductGroupList
}

// Status returns HTTPResponse.Status
func (r ProductGroupsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductGroupsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductGroupsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProductGroup
}

// Status returns HTTPResponse.Status
func (r ProductGroupsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductGroupsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductGroupsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProductGroupsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductGroupsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductGroupsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductGroup
}

// Status returns HTTPResponse.Status
func (r ProductGroupsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductGroupsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductGroupsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProductGroupsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductGroupsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductGroupsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductGroup
}

// Status returns HTTPResponse.Status
func (r ProductGroupsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductGroupsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductGroupsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r ProductGroupsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductGroupsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductMembersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedProductMemberList
}

// Status returns HTTPResponse.Status
func (r ProductMembersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductMembersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductMembersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProductMember
}

// Status returns HTTPResponse.Status
func (r ProductMembersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductMembersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductMembersDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProductMembersDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductMembersDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductMembersRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductMember
}

// Status returns HTTPResponse.Status
func (r ProductMembersRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductMembersRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductMembersPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProductMembersPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductMembersPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductMembersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductMember
}

// Status returns HTTPResponse.Status
func (r ProductMembersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductMembersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductMembersDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r ProductMembersDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductMembersDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeGroupsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedProductTypeGroupList
}

// Status returns HTTPResponse.Status
func (r ProductTypeGroupsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeGroupsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeGroupsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProductTypeGroup
}

// Status returns HTTPResponse.Status
func (r ProductTypeGroupsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeGroupsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeGroupsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProductTypeGroupsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeGroupsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeGroupsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductTypeGroup
}

// Status returns HTTPResponse.Status
func (r ProductTypeGroupsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeGroupsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeGroupsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProductTypeGroupsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeGroupsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeGroupsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductTypeGroup
}

// Status returns HTTPResponse.Status
func (r ProductTypeGroupsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeGroupsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeGroupsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r ProductTypeGroupsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeGroupsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeMembersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedProductTypeMemberList
}

// Status returns HTTPResponse.Status
func (r ProductTypeMembersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeMembersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeMembersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProductTypeMember
}

// Status returns HTTPResponse.Status
func (r ProductTypeMembersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeMembersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeMembersDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProductTypeMembersDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeMembersDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeMembersRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductTypeMember
}

// Status returns HTTPResponse.Status
func (r ProductTypeMembersRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeMembersRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeMembersPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProductTypeMembersPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeMembersPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeMembersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductTypeMember
}

// Status returns HTTPResponse.Status
func (r ProductTypeMembersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeMembersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypeMembersDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r ProductTypeMembersDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypeMembersDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedProductTypeList
}

// Status returns HTTPResponse.Status
func (r ProductTypesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProductType
}

// Status returns HTTPResponse.Status
func (r ProductTypesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypesDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProductTypesDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypesDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductType
}

// Status returns HTTPResponse.Status
func (r ProductTypesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypesPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductType
}

// Status returns HTTPResponse.Status
func (r ProductTypesPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypesPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductType
}

// Status returns HTTPResponse.Status
func (r ProductTypesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypesDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r ProductTypesDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypesDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypesGenerateReportCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportGenerate
}

// Status returns HTTPResponse.Status
func (r ProductTypesGenerateReportCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypesGenerateReportCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedProductList
}

// Status returns HTTPResponse.Status
func (r ProductsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Product
}

// Status returns HTTPResponse.Status
func (r ProductsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProductsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Product
}

// Status returns HTTPResponse.Status
func (r ProductsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Product
}

// Status returns HTTPResponse.Status
func (r ProductsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Product
}

// Status returns HTTPResponse.Status
func (r ProductsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r ProductsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsGenerateReportCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportGenerate
}

// Status returns HTTPResponse.Status
func (r ProductsGenerateReportCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsGenerateReportCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegulationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedRegulationList
}

// Status returns HTTPResponse.Status
func (r RegulationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegulationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegulationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Regulation
}

// Status returns HTTPResponse.Status
func (r RegulationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegulationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegulationsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RegulationsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegulationsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegulationsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Regulation
}

// Status returns HTTPResponse.Status
func (r RegulationsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegulationsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegulationsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Regulation
}

// Status returns HTTPResponse.Status
func (r RegulationsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegulationsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegulationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Regulation
}

// Status returns HTTPResponse.Status
func (r RegulationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegulationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegulationsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r RegulationsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegulationsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReimportScanCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ReImportScan
}

// Status returns HTTPResponse.Status
func (r ReimportScanCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReimportScanCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RolesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedRoleList
}

// Status returns HTTPResponse.Status
func (r RolesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RolesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RolesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
}

// Status returns HTTPResponse.Status
func (r RolesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RolesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaConfigurationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedSLAConfigurationList
}

// Status returns HTTPResponse.Status
func (r SlaConfigurationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaConfigurationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaConfigurationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SLAConfiguration
}

// Status returns HTTPResponse.Status
func (r SlaConfigurationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaConfigurationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaConfigurationsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SlaConfigurationsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaConfigurationsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaConfigurationsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SLAConfiguration
}

// Status returns HTTPResponse.Status
func (r SlaConfigurationsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaConfigurationsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaConfigurationsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SLAConfiguration
}

// Status returns HTTPResponse.Status
func (r SlaConfigurationsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaConfigurationsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlaConfigurationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SLAConfiguration
}

// Status returns HTTPResponse.Status
func (r SlaConfigurationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlaConfigurationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeIssuesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedSonarqubeIssueList
}

// Status returns HTTPResponse.Status
func (r SonarqubeIssuesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeIssuesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeIssuesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SonarqubeIssue
}

// Status returns HTTPResponse.Status
func (r SonarqubeIssuesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeIssuesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeIssuesDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SonarqubeIssuesDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeIssuesDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeIssuesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SonarqubeIssue
}

// Status returns HTTPResponse.Status
func (r SonarqubeIssuesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeIssuesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeIssuesPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SonarqubeIssue
}

// Status returns HTTPResponse.Status
func (r SonarqubeIssuesPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeIssuesPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeIssuesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SonarqubeIssue
}

// Status returns HTTPResponse.Status
func (r SonarqubeIssuesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeIssuesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeIssuesDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r SonarqubeIssuesDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeIssuesDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeTransitionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedSonarqubeIssueTransitionList
}

// Status returns HTTPResponse.Status
func (r SonarqubeTransitionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeTransitionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeTransitionsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SonarqubeIssueTransition
}

// Status returns HTTPResponse.Status
func (r SonarqubeTransitionsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeTransitionsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeTransitionsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SonarqubeTransitionsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeTransitionsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeTransitionsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SonarqubeIssueTransition
}

// Status returns HTTPResponse.Status
func (r SonarqubeTransitionsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeTransitionsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeTransitionsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SonarqubeIssueTransition
}

// Status returns HTTPResponse.Status
func (r SonarqubeTransitionsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeTransitionsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeTransitionsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SonarqubeIssueTransition
}

// Status returns HTTPResponse.Status
func (r SonarqubeTransitionsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeTransitionsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SonarqubeTransitionsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r SonarqubeTransitionsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SonarqubeTransitionsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StubFindingsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedStubFindingList
}

// Status returns HTTPResponse.Status
func (r StubFindingsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StubFindingsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StubFindingsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StubFindingCreate
}

// Status returns HTTPResponse.Status
func (r StubFindingsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StubFindingsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StubFindingsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StubFindingsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StubFindingsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StubFindingsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StubFinding
}

// Status returns HTTPResponse.Status
func (r StubFindingsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StubFindingsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StubFindingsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StubFinding
}

// Status returns HTTPResponse.Status
func (r StubFindingsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StubFindingsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StubFindingsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StubFinding
}

// Status returns HTTPResponse.Status
func (r StubFindingsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StubFindingsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StubFindingsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r StubFindingsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StubFindingsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SystemSettingsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedSystemSettingsList
}

// Status returns HTTPResponse.Status
func (r SystemSettingsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SystemSettingsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SystemSettingsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SystemSettings
}

// Status returns HTTPResponse.Status
func (r SystemSettingsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SystemSettingsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SystemSettingsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SystemSettings
}

// Status returns HTTPResponse.Status
func (r SystemSettingsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SystemSettingsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TechnologiesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedAppAnalysisList
}

// Status returns HTTPResponse.Status
func (r TechnologiesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TechnologiesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TechnologiesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppAnalysis
}

// Status returns HTTPResponse.Status
func (r TechnologiesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TechnologiesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TechnologiesDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TechnologiesDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TechnologiesDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TechnologiesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppAnalysis
}

// Status returns HTTPResponse.Status
func (r TechnologiesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TechnologiesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TechnologiesPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppAnalysis
}

// Status returns HTTPResponse.Status
func (r TechnologiesPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TechnologiesPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TechnologiesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppAnalysis
}

// Status returns HTTPResponse.Status
func (r TechnologiesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TechnologiesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TechnologiesDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r TechnologiesDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TechnologiesDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestImportsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedTestImportList
}

// Status returns HTTPResponse.Status
func (r TestImportsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestImportsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestImportsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TestImport
}

// Status returns HTTPResponse.Status
func (r TestImportsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestImportsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestImportsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestImportsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestImportsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestImportsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestImport
}

// Status returns HTTPResponse.Status
func (r TestImportsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestImportsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestImportsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestImport
}

// Status returns HTTPResponse.Status
func (r TestImportsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestImportsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestImportsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestImport
}

// Status returns HTTPResponse.Status
func (r TestImportsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestImportsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestImportsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r TestImportsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestImportsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestTypesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedTestTypeList
}

// Status returns HTTPResponse.Status
func (r TestTypesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestTypesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestTypesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TestType
}

// Status returns HTTPResponse.Status
func (r TestTypesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestTypesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestTypesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestType
}

// Status returns HTTPResponse.Status
func (r TestTypesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestTypesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestTypesPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestType
}

// Status returns HTTPResponse.Status
func (r TestTypesPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestTypesPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestTypesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestType
}

// Status returns HTTPResponse.Status
func (r TestTypesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestTypesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedTestList
}

// Status returns HTTPResponse.Status
func (r TestsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TestCreate
}

// Status returns HTTPResponse.Status
func (r TestsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TestsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Test
}

// Status returns HTTPResponse.Status
func (r TestsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Test
}

// Status returns HTTPResponse.Status
func (r TestsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Test
}

// Status returns HTTPResponse.Status
func (r TestsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsAcceptRisksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]RiskAcceptance
}

// Status returns HTTPResponse.Status
func (r TestsAcceptRisksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsAcceptRisksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r TestsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsFilesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestToFiles
}

// Status returns HTTPResponse.Status
func (r TestsFilesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsFilesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsFilesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *File
}

// Status returns HTTPResponse.Status
func (r TestsFilesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsFilesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsGenerateReportCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportGenerate
}

// Status returns HTTPResponse.Status
func (r TestsGenerateReportCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsGenerateReportCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsNotesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestToNotes
}

// Status returns HTTPResponse.Status
func (r TestsNotesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsNotesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestsNotesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Note
}

// Status returns HTTPResponse.Status
func (r TestsNotesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestsNotesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolConfigurationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedToolConfigurationList
}

// Status returns HTTPResponse.Status
func (r ToolConfigurationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolConfigurationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolConfigurationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ToolConfiguration
}

// Status returns HTTPResponse.Status
func (r ToolConfigurationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolConfigurationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolConfigurationsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ToolConfigurationsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolConfigurationsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolConfigurationsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ToolConfiguration
}

// Status returns HTTPResponse.Status
func (r ToolConfigurationsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolConfigurationsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolConfigurationsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ToolConfiguration
}

// Status returns HTTPResponse.Status
func (r ToolConfigurationsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolConfigurationsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolConfigurationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ToolConfiguration
}

// Status returns HTTPResponse.Status
func (r ToolConfigurationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolConfigurationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolConfigurationsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r ToolConfigurationsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolConfigurationsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolProductSettingsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedToolProductSettingsList
}

// Status returns HTTPResponse.Status
func (r ToolProductSettingsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolProductSettingsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolProductSettingsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ToolProductSettings
}

// Status returns HTTPResponse.Status
func (r ToolProductSettingsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolProductSettingsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolProductSettingsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ToolProductSettingsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolProductSettingsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolProductSettingsRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ToolProductSettings
}

// Status returns HTTPResponse.Status
func (r ToolProductSettingsRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolProductSettingsRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolProductSettingsPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ToolProductSettings
}

// Status returns HTTPResponse.Status
func (r ToolProductSettingsPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolProductSettingsPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolProductSettingsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ToolProductSettings
}

// Status returns HTTPResponse.Status
func (r ToolProductSettingsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolProductSettingsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolProductSettingsDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r ToolProductSettingsDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolProductSettingsDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolTypesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedToolTypeList
}

// Status returns HTTPResponse.Status
func (r ToolTypesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolTypesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolTypesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ToolType
}

// Status returns HTTPResponse.Status
func (r ToolTypesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolTypesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolTypesDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ToolTypesDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolTypesDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolTypesRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ToolType
}

// Status returns HTTPResponse.Status
func (r ToolTypesRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolTypesRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolTypesPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ToolType
}

// Status returns HTTPResponse.Status
func (r ToolTypesPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolTypesPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolTypesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ToolType
}

// Status returns HTTPResponse.Status
func (r ToolTypesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolTypesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToolTypesDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r ToolTypesDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToolTypesDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserContactInfosListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedUserContactInfoList
}

// Status returns HTTPResponse.Status
func (r UserContactInfosListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserContactInfosListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserContactInfosCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *UserContactInfo
}

// Status returns HTTPResponse.Status
func (r UserContactInfosCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserContactInfosCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserContactInfosDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserContactInfosDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserContactInfosDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserContactInfosRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserContactInfo
}

// Status returns HTTPResponse.Status
func (r UserContactInfosRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserContactInfosRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserContactInfosPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserContactInfo
}

// Status returns HTTPResponse.Status
func (r UserContactInfosPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserContactInfosPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserContactInfosUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserContactInfo
}

// Status returns HTTPResponse.Status
func (r UserContactInfosUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserContactInfosUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserContactInfosDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r UserContactInfosDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserContactInfosDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserProfileRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserProfile
}

// Status returns HTTPResponse.Status
func (r UserProfileRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserProfileRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedUserList
}

// Status returns HTTPResponse.Status
func (r UsersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
}

// Status returns HTTPResponse.Status
func (r UsersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UsersDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r UsersRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersPartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r UsersPartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersPartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r UsersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersDeletePreviewListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDeletePreviewList
}

// Status returns HTTPResponse.Status
func (r UsersDeletePreviewListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersDeletePreviewListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ApiTokenAuthCreateWithBodyWithResponse request with arbitrary body returning *ApiTokenAuthCreateResponse
func (c *ClientWithResponses) ApiTokenAuthCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiTokenAuthCreateResponse, error) {
	rsp, err := c.ApiTokenAuthCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenAuthCreateResponse(rsp)
}

func (c *ClientWithResponses) ApiTokenAuthCreateWithResponse(ctx context.Context, body ApiTokenAuthCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiTokenAuthCreateResponse, error) {
	rsp, err := c.ApiTokenAuthCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenAuthCreateResponse(rsp)
}

// ConfigurationPermissionsListWithResponse request returning *ConfigurationPermissionsListResponse
func (c *ClientWithResponses) ConfigurationPermissionsListWithResponse(ctx context.Context, params *ConfigurationPermissionsListParams, reqEditors ...RequestEditorFn) (*ConfigurationPermissionsListResponse, error) {
	rsp, err := c.ConfigurationPermissionsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigurationPermissionsListResponse(rsp)
}

// ConfigurationPermissionsRetrieveWithResponse request returning *ConfigurationPermissionsRetrieveResponse
func (c *ClientWithResponses) ConfigurationPermissionsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ConfigurationPermissionsRetrieveResponse, error) {
	rsp, err := c.ConfigurationPermissionsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigurationPermissionsRetrieveResponse(rsp)
}

// DevelopmentEnvironmentsListWithResponse request returning *DevelopmentEnvironmentsListResponse
func (c *ClientWithResponses) DevelopmentEnvironmentsListWithResponse(ctx context.Context, params *DevelopmentEnvironmentsListParams, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsListResponse, error) {
	rsp, err := c.DevelopmentEnvironmentsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevelopmentEnvironmentsListResponse(rsp)
}

// DevelopmentEnvironmentsCreateWithBodyWithResponse request with arbitrary body returning *DevelopmentEnvironmentsCreateResponse
func (c *ClientWithResponses) DevelopmentEnvironmentsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsCreateResponse, error) {
	rsp, err := c.DevelopmentEnvironmentsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevelopmentEnvironmentsCreateResponse(rsp)
}

func (c *ClientWithResponses) DevelopmentEnvironmentsCreateWithResponse(ctx context.Context, body DevelopmentEnvironmentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsCreateResponse, error) {
	rsp, err := c.DevelopmentEnvironmentsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevelopmentEnvironmentsCreateResponse(rsp)
}

// DevelopmentEnvironmentsDestroyWithResponse request returning *DevelopmentEnvironmentsDestroyResponse
func (c *ClientWithResponses) DevelopmentEnvironmentsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsDestroyResponse, error) {
	rsp, err := c.DevelopmentEnvironmentsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevelopmentEnvironmentsDestroyResponse(rsp)
}

// DevelopmentEnvironmentsRetrieveWithResponse request returning *DevelopmentEnvironmentsRetrieveResponse
func (c *ClientWithResponses) DevelopmentEnvironmentsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsRetrieveResponse, error) {
	rsp, err := c.DevelopmentEnvironmentsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevelopmentEnvironmentsRetrieveResponse(rsp)
}

// DevelopmentEnvironmentsPartialUpdateWithBodyWithResponse request with arbitrary body returning *DevelopmentEnvironmentsPartialUpdateResponse
func (c *ClientWithResponses) DevelopmentEnvironmentsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsPartialUpdateResponse, error) {
	rsp, err := c.DevelopmentEnvironmentsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevelopmentEnvironmentsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) DevelopmentEnvironmentsPartialUpdateWithResponse(ctx context.Context, id int, body DevelopmentEnvironmentsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsPartialUpdateResponse, error) {
	rsp, err := c.DevelopmentEnvironmentsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevelopmentEnvironmentsPartialUpdateResponse(rsp)
}

// DevelopmentEnvironmentsUpdateWithBodyWithResponse request with arbitrary body returning *DevelopmentEnvironmentsUpdateResponse
func (c *ClientWithResponses) DevelopmentEnvironmentsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsUpdateResponse, error) {
	rsp, err := c.DevelopmentEnvironmentsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevelopmentEnvironmentsUpdateResponse(rsp)
}

func (c *ClientWithResponses) DevelopmentEnvironmentsUpdateWithResponse(ctx context.Context, id int, body DevelopmentEnvironmentsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsUpdateResponse, error) {
	rsp, err := c.DevelopmentEnvironmentsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevelopmentEnvironmentsUpdateResponse(rsp)
}

// DevelopmentEnvironmentsDeletePreviewListWithResponse request returning *DevelopmentEnvironmentsDeletePreviewListResponse
func (c *ClientWithResponses) DevelopmentEnvironmentsDeletePreviewListWithResponse(ctx context.Context, id int, params *DevelopmentEnvironmentsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*DevelopmentEnvironmentsDeletePreviewListResponse, error) {
	rsp, err := c.DevelopmentEnvironmentsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDevelopmentEnvironmentsDeletePreviewListResponse(rsp)
}

// DojoGroupMembersListWithResponse request returning *DojoGroupMembersListResponse
func (c *ClientWithResponses) DojoGroupMembersListWithResponse(ctx context.Context, params *DojoGroupMembersListParams, reqEditors ...RequestEditorFn) (*DojoGroupMembersListResponse, error) {
	rsp, err := c.DojoGroupMembersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupMembersListResponse(rsp)
}

// DojoGroupMembersCreateWithBodyWithResponse request with arbitrary body returning *DojoGroupMembersCreateResponse
func (c *ClientWithResponses) DojoGroupMembersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DojoGroupMembersCreateResponse, error) {
	rsp, err := c.DojoGroupMembersCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupMembersCreateResponse(rsp)
}

func (c *ClientWithResponses) DojoGroupMembersCreateWithResponse(ctx context.Context, body DojoGroupMembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DojoGroupMembersCreateResponse, error) {
	rsp, err := c.DojoGroupMembersCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupMembersCreateResponse(rsp)
}

// DojoGroupMembersDestroyWithResponse request returning *DojoGroupMembersDestroyResponse
func (c *ClientWithResponses) DojoGroupMembersDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DojoGroupMembersDestroyResponse, error) {
	rsp, err := c.DojoGroupMembersDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupMembersDestroyResponse(rsp)
}

// DojoGroupMembersRetrieveWithResponse request returning *DojoGroupMembersRetrieveResponse
func (c *ClientWithResponses) DojoGroupMembersRetrieveWithResponse(ctx context.Context, id int, params *DojoGroupMembersRetrieveParams, reqEditors ...RequestEditorFn) (*DojoGroupMembersRetrieveResponse, error) {
	rsp, err := c.DojoGroupMembersRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupMembersRetrieveResponse(rsp)
}

// DojoGroupMembersPartialUpdateWithBodyWithResponse request with arbitrary body returning *DojoGroupMembersPartialUpdateResponse
func (c *ClientWithResponses) DojoGroupMembersPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DojoGroupMembersPartialUpdateResponse, error) {
	rsp, err := c.DojoGroupMembersPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupMembersPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) DojoGroupMembersPartialUpdateWithResponse(ctx context.Context, id int, body DojoGroupMembersPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DojoGroupMembersPartialUpdateResponse, error) {
	rsp, err := c.DojoGroupMembersPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupMembersPartialUpdateResponse(rsp)
}

// DojoGroupMembersUpdateWithBodyWithResponse request with arbitrary body returning *DojoGroupMembersUpdateResponse
func (c *ClientWithResponses) DojoGroupMembersUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DojoGroupMembersUpdateResponse, error) {
	rsp, err := c.DojoGroupMembersUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupMembersUpdateResponse(rsp)
}

func (c *ClientWithResponses) DojoGroupMembersUpdateWithResponse(ctx context.Context, id int, body DojoGroupMembersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DojoGroupMembersUpdateResponse, error) {
	rsp, err := c.DojoGroupMembersUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupMembersUpdateResponse(rsp)
}

// DojoGroupMembersDeletePreviewListWithResponse request returning *DojoGroupMembersDeletePreviewListResponse
func (c *ClientWithResponses) DojoGroupMembersDeletePreviewListWithResponse(ctx context.Context, id int, params *DojoGroupMembersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*DojoGroupMembersDeletePreviewListResponse, error) {
	rsp, err := c.DojoGroupMembersDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupMembersDeletePreviewListResponse(rsp)
}

// DojoGroupsListWithResponse request returning *DojoGroupsListResponse
func (c *ClientWithResponses) DojoGroupsListWithResponse(ctx context.Context, params *DojoGroupsListParams, reqEditors ...RequestEditorFn) (*DojoGroupsListResponse, error) {
	rsp, err := c.DojoGroupsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupsListResponse(rsp)
}

// DojoGroupsCreateWithBodyWithResponse request with arbitrary body returning *DojoGroupsCreateResponse
func (c *ClientWithResponses) DojoGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DojoGroupsCreateResponse, error) {
	rsp, err := c.DojoGroupsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupsCreateResponse(rsp)
}

func (c *ClientWithResponses) DojoGroupsCreateWithResponse(ctx context.Context, body DojoGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DojoGroupsCreateResponse, error) {
	rsp, err := c.DojoGroupsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupsCreateResponse(rsp)
}

// DojoGroupsDestroyWithResponse request returning *DojoGroupsDestroyResponse
func (c *ClientWithResponses) DojoGroupsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DojoGroupsDestroyResponse, error) {
	rsp, err := c.DojoGroupsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupsDestroyResponse(rsp)
}

// DojoGroupsRetrieveWithResponse request returning *DojoGroupsRetrieveResponse
func (c *ClientWithResponses) DojoGroupsRetrieveWithResponse(ctx context.Context, id int, params *DojoGroupsRetrieveParams, reqEditors ...RequestEditorFn) (*DojoGroupsRetrieveResponse, error) {
	rsp, err := c.DojoGroupsRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupsRetrieveResponse(rsp)
}

// DojoGroupsPartialUpdateWithBodyWithResponse request with arbitrary body returning *DojoGroupsPartialUpdateResponse
func (c *ClientWithResponses) DojoGroupsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DojoGroupsPartialUpdateResponse, error) {
	rsp, err := c.DojoGroupsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) DojoGroupsPartialUpdateWithResponse(ctx context.Context, id int, body DojoGroupsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DojoGroupsPartialUpdateResponse, error) {
	rsp, err := c.DojoGroupsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupsPartialUpdateResponse(rsp)
}

// DojoGroupsUpdateWithBodyWithResponse request with arbitrary body returning *DojoGroupsUpdateResponse
func (c *ClientWithResponses) DojoGroupsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DojoGroupsUpdateResponse, error) {
	rsp, err := c.DojoGroupsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupsUpdateResponse(rsp)
}

func (c *ClientWithResponses) DojoGroupsUpdateWithResponse(ctx context.Context, id int, body DojoGroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*DojoGroupsUpdateResponse, error) {
	rsp, err := c.DojoGroupsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupsUpdateResponse(rsp)
}

// DojoGroupsDeletePreviewListWithResponse request returning *DojoGroupsDeletePreviewListResponse
func (c *ClientWithResponses) DojoGroupsDeletePreviewListWithResponse(ctx context.Context, id int, params *DojoGroupsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*DojoGroupsDeletePreviewListResponse, error) {
	rsp, err := c.DojoGroupsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDojoGroupsDeletePreviewListResponse(rsp)
}

// EndpointMetaImportCreateWithBodyWithResponse request with arbitrary body returning *EndpointMetaImportCreateResponse
func (c *ClientWithResponses) EndpointMetaImportCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointMetaImportCreateResponse, error) {
	rsp, err := c.EndpointMetaImportCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointMetaImportCreateResponse(rsp)
}

// EndpointStatusListWithResponse request returning *EndpointStatusListResponse
func (c *ClientWithResponses) EndpointStatusListWithResponse(ctx context.Context, params *EndpointStatusListParams, reqEditors ...RequestEditorFn) (*EndpointStatusListResponse, error) {
	rsp, err := c.EndpointStatusList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointStatusListResponse(rsp)
}

// EndpointStatusCreateWithBodyWithResponse request with arbitrary body returning *EndpointStatusCreateResponse
func (c *ClientWithResponses) EndpointStatusCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointStatusCreateResponse, error) {
	rsp, err := c.EndpointStatusCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointStatusCreateResponse(rsp)
}

func (c *ClientWithResponses) EndpointStatusCreateWithResponse(ctx context.Context, body EndpointStatusCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointStatusCreateResponse, error) {
	rsp, err := c.EndpointStatusCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointStatusCreateResponse(rsp)
}

// EndpointStatusDestroyWithResponse request returning *EndpointStatusDestroyResponse
func (c *ClientWithResponses) EndpointStatusDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EndpointStatusDestroyResponse, error) {
	rsp, err := c.EndpointStatusDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointStatusDestroyResponse(rsp)
}

// EndpointStatusRetrieveWithResponse request returning *EndpointStatusRetrieveResponse
func (c *ClientWithResponses) EndpointStatusRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EndpointStatusRetrieveResponse, error) {
	rsp, err := c.EndpointStatusRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointStatusRetrieveResponse(rsp)
}

// EndpointStatusPartialUpdateWithBodyWithResponse request with arbitrary body returning *EndpointStatusPartialUpdateResponse
func (c *ClientWithResponses) EndpointStatusPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointStatusPartialUpdateResponse, error) {
	rsp, err := c.EndpointStatusPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointStatusPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) EndpointStatusPartialUpdateWithResponse(ctx context.Context, id int, body EndpointStatusPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointStatusPartialUpdateResponse, error) {
	rsp, err := c.EndpointStatusPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointStatusPartialUpdateResponse(rsp)
}

// EndpointStatusUpdateWithBodyWithResponse request with arbitrary body returning *EndpointStatusUpdateResponse
func (c *ClientWithResponses) EndpointStatusUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointStatusUpdateResponse, error) {
	rsp, err := c.EndpointStatusUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointStatusUpdateResponse(rsp)
}

func (c *ClientWithResponses) EndpointStatusUpdateWithResponse(ctx context.Context, id int, body EndpointStatusUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointStatusUpdateResponse, error) {
	rsp, err := c.EndpointStatusUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointStatusUpdateResponse(rsp)
}

// EndpointStatusDeletePreviewListWithResponse request returning *EndpointStatusDeletePreviewListResponse
func (c *ClientWithResponses) EndpointStatusDeletePreviewListWithResponse(ctx context.Context, id int, params *EndpointStatusDeletePreviewListParams, reqEditors ...RequestEditorFn) (*EndpointStatusDeletePreviewListResponse, error) {
	rsp, err := c.EndpointStatusDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointStatusDeletePreviewListResponse(rsp)
}

// EndpointsListWithResponse request returning *EndpointsListResponse
func (c *ClientWithResponses) EndpointsListWithResponse(ctx context.Context, params *EndpointsListParams, reqEditors ...RequestEditorFn) (*EndpointsListResponse, error) {
	rsp, err := c.EndpointsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointsListResponse(rsp)
}

// EndpointsCreateWithBodyWithResponse request with arbitrary body returning *EndpointsCreateResponse
func (c *ClientWithResponses) EndpointsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointsCreateResponse, error) {
	rsp, err := c.EndpointsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointsCreateResponse(rsp)
}

func (c *ClientWithResponses) EndpointsCreateWithResponse(ctx context.Context, body EndpointsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointsCreateResponse, error) {
	rsp, err := c.EndpointsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointsCreateResponse(rsp)
}

// EndpointsDestroyWithResponse request returning *EndpointsDestroyResponse
func (c *ClientWithResponses) EndpointsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EndpointsDestroyResponse, error) {
	rsp, err := c.EndpointsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointsDestroyResponse(rsp)
}

// EndpointsRetrieveWithResponse request returning *EndpointsRetrieveResponse
func (c *ClientWithResponses) EndpointsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EndpointsRetrieveResponse, error) {
	rsp, err := c.EndpointsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointsRetrieveResponse(rsp)
}

// EndpointsPartialUpdateWithBodyWithResponse request with arbitrary body returning *EndpointsPartialUpdateResponse
func (c *ClientWithResponses) EndpointsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointsPartialUpdateResponse, error) {
	rsp, err := c.EndpointsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) EndpointsPartialUpdateWithResponse(ctx context.Context, id int, body EndpointsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointsPartialUpdateResponse, error) {
	rsp, err := c.EndpointsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointsPartialUpdateResponse(rsp)
}

// EndpointsUpdateWithBodyWithResponse request with arbitrary body returning *EndpointsUpdateResponse
func (c *ClientWithResponses) EndpointsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointsUpdateResponse, error) {
	rsp, err := c.EndpointsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointsUpdateResponse(rsp)
}

func (c *ClientWithResponses) EndpointsUpdateWithResponse(ctx context.Context, id int, body EndpointsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointsUpdateResponse, error) {
	rsp, err := c.EndpointsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointsUpdateResponse(rsp)
}

// EndpointsDeletePreviewListWithResponse request returning *EndpointsDeletePreviewListResponse
func (c *ClientWithResponses) EndpointsDeletePreviewListWithResponse(ctx context.Context, id int, params *EndpointsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*EndpointsDeletePreviewListResponse, error) {
	rsp, err := c.EndpointsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointsDeletePreviewListResponse(rsp)
}

// EndpointsGenerateReportCreateWithBodyWithResponse request with arbitrary body returning *EndpointsGenerateReportCreateResponse
func (c *ClientWithResponses) EndpointsGenerateReportCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndpointsGenerateReportCreateResponse, error) {
	rsp, err := c.EndpointsGenerateReportCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointsGenerateReportCreateResponse(rsp)
}

func (c *ClientWithResponses) EndpointsGenerateReportCreateWithResponse(ctx context.Context, id int, body EndpointsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EndpointsGenerateReportCreateResponse, error) {
	rsp, err := c.EndpointsGenerateReportCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndpointsGenerateReportCreateResponse(rsp)
}

// EngagementPresetsListWithResponse request returning *EngagementPresetsListResponse
func (c *ClientWithResponses) EngagementPresetsListWithResponse(ctx context.Context, params *EngagementPresetsListParams, reqEditors ...RequestEditorFn) (*EngagementPresetsListResponse, error) {
	rsp, err := c.EngagementPresetsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementPresetsListResponse(rsp)
}

// EngagementPresetsCreateWithBodyWithResponse request with arbitrary body returning *EngagementPresetsCreateResponse
func (c *ClientWithResponses) EngagementPresetsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementPresetsCreateResponse, error) {
	rsp, err := c.EngagementPresetsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementPresetsCreateResponse(rsp)
}

func (c *ClientWithResponses) EngagementPresetsCreateWithResponse(ctx context.Context, body EngagementPresetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementPresetsCreateResponse, error) {
	rsp, err := c.EngagementPresetsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementPresetsCreateResponse(rsp)
}

// EngagementPresetsDestroyWithResponse request returning *EngagementPresetsDestroyResponse
func (c *ClientWithResponses) EngagementPresetsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementPresetsDestroyResponse, error) {
	rsp, err := c.EngagementPresetsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementPresetsDestroyResponse(rsp)
}

// EngagementPresetsRetrieveWithResponse request returning *EngagementPresetsRetrieveResponse
func (c *ClientWithResponses) EngagementPresetsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementPresetsRetrieveResponse, error) {
	rsp, err := c.EngagementPresetsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementPresetsRetrieveResponse(rsp)
}

// EngagementPresetsPartialUpdateWithBodyWithResponse request with arbitrary body returning *EngagementPresetsPartialUpdateResponse
func (c *ClientWithResponses) EngagementPresetsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementPresetsPartialUpdateResponse, error) {
	rsp, err := c.EngagementPresetsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementPresetsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) EngagementPresetsPartialUpdateWithResponse(ctx context.Context, id int, body EngagementPresetsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementPresetsPartialUpdateResponse, error) {
	rsp, err := c.EngagementPresetsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementPresetsPartialUpdateResponse(rsp)
}

// EngagementPresetsUpdateWithBodyWithResponse request with arbitrary body returning *EngagementPresetsUpdateResponse
func (c *ClientWithResponses) EngagementPresetsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementPresetsUpdateResponse, error) {
	rsp, err := c.EngagementPresetsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementPresetsUpdateResponse(rsp)
}

func (c *ClientWithResponses) EngagementPresetsUpdateWithResponse(ctx context.Context, id int, body EngagementPresetsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementPresetsUpdateResponse, error) {
	rsp, err := c.EngagementPresetsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementPresetsUpdateResponse(rsp)
}

// EngagementPresetsDeletePreviewListWithResponse request returning *EngagementPresetsDeletePreviewListResponse
func (c *ClientWithResponses) EngagementPresetsDeletePreviewListWithResponse(ctx context.Context, id int, params *EngagementPresetsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*EngagementPresetsDeletePreviewListResponse, error) {
	rsp, err := c.EngagementPresetsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementPresetsDeletePreviewListResponse(rsp)
}

// EngagementsListWithResponse request returning *EngagementsListResponse
func (c *ClientWithResponses) EngagementsListWithResponse(ctx context.Context, params *EngagementsListParams, reqEditors ...RequestEditorFn) (*EngagementsListResponse, error) {
	rsp, err := c.EngagementsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsListResponse(rsp)
}

// EngagementsCreateWithBodyWithResponse request with arbitrary body returning *EngagementsCreateResponse
func (c *ClientWithResponses) EngagementsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsCreateResponse, error) {
	rsp, err := c.EngagementsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsCreateResponse(rsp)
}

func (c *ClientWithResponses) EngagementsCreateWithResponse(ctx context.Context, body EngagementsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsCreateResponse, error) {
	rsp, err := c.EngagementsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsCreateResponse(rsp)
}

// EngagementsDestroyWithResponse request returning *EngagementsDestroyResponse
func (c *ClientWithResponses) EngagementsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementsDestroyResponse, error) {
	rsp, err := c.EngagementsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsDestroyResponse(rsp)
}

// EngagementsRetrieveWithResponse request returning *EngagementsRetrieveResponse
func (c *ClientWithResponses) EngagementsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementsRetrieveResponse, error) {
	rsp, err := c.EngagementsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsRetrieveResponse(rsp)
}

// EngagementsPartialUpdateWithBodyWithResponse request with arbitrary body returning *EngagementsPartialUpdateResponse
func (c *ClientWithResponses) EngagementsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsPartialUpdateResponse, error) {
	rsp, err := c.EngagementsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) EngagementsPartialUpdateWithResponse(ctx context.Context, id int, body EngagementsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsPartialUpdateResponse, error) {
	rsp, err := c.EngagementsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsPartialUpdateResponse(rsp)
}

// EngagementsUpdateWithBodyWithResponse request with arbitrary body returning *EngagementsUpdateResponse
func (c *ClientWithResponses) EngagementsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsUpdateResponse, error) {
	rsp, err := c.EngagementsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsUpdateResponse(rsp)
}

func (c *ClientWithResponses) EngagementsUpdateWithResponse(ctx context.Context, id int, body EngagementsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsUpdateResponse, error) {
	rsp, err := c.EngagementsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsUpdateResponse(rsp)
}

// EngagementsAcceptRisksCreateWithBodyWithResponse request with arbitrary body returning *EngagementsAcceptRisksCreateResponse
func (c *ClientWithResponses) EngagementsAcceptRisksCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsAcceptRisksCreateResponse, error) {
	rsp, err := c.EngagementsAcceptRisksCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsAcceptRisksCreateResponse(rsp)
}

func (c *ClientWithResponses) EngagementsAcceptRisksCreateWithResponse(ctx context.Context, id int, body EngagementsAcceptRisksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsAcceptRisksCreateResponse, error) {
	rsp, err := c.EngagementsAcceptRisksCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsAcceptRisksCreateResponse(rsp)
}

// EngagementsCloseCreateWithResponse request returning *EngagementsCloseCreateResponse
func (c *ClientWithResponses) EngagementsCloseCreateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementsCloseCreateResponse, error) {
	rsp, err := c.EngagementsCloseCreate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsCloseCreateResponse(rsp)
}

// EngagementsDeletePreviewListWithResponse request returning *EngagementsDeletePreviewListResponse
func (c *ClientWithResponses) EngagementsDeletePreviewListWithResponse(ctx context.Context, id int, params *EngagementsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*EngagementsDeletePreviewListResponse, error) {
	rsp, err := c.EngagementsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsDeletePreviewListResponse(rsp)
}

// EngagementsFilesRetrieveWithResponse request returning *EngagementsFilesRetrieveResponse
func (c *ClientWithResponses) EngagementsFilesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementsFilesRetrieveResponse, error) {
	rsp, err := c.EngagementsFilesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsFilesRetrieveResponse(rsp)
}

// EngagementsFilesCreateWithBodyWithResponse request with arbitrary body returning *EngagementsFilesCreateResponse
func (c *ClientWithResponses) EngagementsFilesCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsFilesCreateResponse, error) {
	rsp, err := c.EngagementsFilesCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsFilesCreateResponse(rsp)
}

// EngagementsGenerateReportCreateWithBodyWithResponse request with arbitrary body returning *EngagementsGenerateReportCreateResponse
func (c *ClientWithResponses) EngagementsGenerateReportCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsGenerateReportCreateResponse, error) {
	rsp, err := c.EngagementsGenerateReportCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsGenerateReportCreateResponse(rsp)
}

func (c *ClientWithResponses) EngagementsGenerateReportCreateWithResponse(ctx context.Context, id int, body EngagementsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsGenerateReportCreateResponse, error) {
	rsp, err := c.EngagementsGenerateReportCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsGenerateReportCreateResponse(rsp)
}

// EngagementsNotesRetrieveWithResponse request returning *EngagementsNotesRetrieveResponse
func (c *ClientWithResponses) EngagementsNotesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementsNotesRetrieveResponse, error) {
	rsp, err := c.EngagementsNotesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsNotesRetrieveResponse(rsp)
}

// EngagementsNotesCreateWithBodyWithResponse request with arbitrary body returning *EngagementsNotesCreateResponse
func (c *ClientWithResponses) EngagementsNotesCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngagementsNotesCreateResponse, error) {
	rsp, err := c.EngagementsNotesCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsNotesCreateResponse(rsp)
}

func (c *ClientWithResponses) EngagementsNotesCreateWithResponse(ctx context.Context, id int, body EngagementsNotesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EngagementsNotesCreateResponse, error) {
	rsp, err := c.EngagementsNotesCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsNotesCreateResponse(rsp)
}

// EngagementsReopenCreateWithResponse request returning *EngagementsReopenCreateResponse
func (c *ClientWithResponses) EngagementsReopenCreateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*EngagementsReopenCreateResponse, error) {
	rsp, err := c.EngagementsReopenCreate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngagementsReopenCreateResponse(rsp)
}

// FindingTemplatesListWithResponse request returning *FindingTemplatesListResponse
func (c *ClientWithResponses) FindingTemplatesListWithResponse(ctx context.Context, params *FindingTemplatesListParams, reqEditors ...RequestEditorFn) (*FindingTemplatesListResponse, error) {
	rsp, err := c.FindingTemplatesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingTemplatesListResponse(rsp)
}

// FindingTemplatesCreateWithBodyWithResponse request with arbitrary body returning *FindingTemplatesCreateResponse
func (c *ClientWithResponses) FindingTemplatesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingTemplatesCreateResponse, error) {
	rsp, err := c.FindingTemplatesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingTemplatesCreateResponse(rsp)
}

func (c *ClientWithResponses) FindingTemplatesCreateWithResponse(ctx context.Context, body FindingTemplatesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingTemplatesCreateResponse, error) {
	rsp, err := c.FindingTemplatesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingTemplatesCreateResponse(rsp)
}

// FindingTemplatesDestroyWithResponse request returning *FindingTemplatesDestroyResponse
func (c *ClientWithResponses) FindingTemplatesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingTemplatesDestroyResponse, error) {
	rsp, err := c.FindingTemplatesDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingTemplatesDestroyResponse(rsp)
}

// FindingTemplatesRetrieveWithResponse request returning *FindingTemplatesRetrieveResponse
func (c *ClientWithResponses) FindingTemplatesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingTemplatesRetrieveResponse, error) {
	rsp, err := c.FindingTemplatesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingTemplatesRetrieveResponse(rsp)
}

// FindingTemplatesPartialUpdateWithBodyWithResponse request with arbitrary body returning *FindingTemplatesPartialUpdateResponse
func (c *ClientWithResponses) FindingTemplatesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingTemplatesPartialUpdateResponse, error) {
	rsp, err := c.FindingTemplatesPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingTemplatesPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) FindingTemplatesPartialUpdateWithResponse(ctx context.Context, id int, body FindingTemplatesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingTemplatesPartialUpdateResponse, error) {
	rsp, err := c.FindingTemplatesPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingTemplatesPartialUpdateResponse(rsp)
}

// FindingTemplatesUpdateWithBodyWithResponse request with arbitrary body returning *FindingTemplatesUpdateResponse
func (c *ClientWithResponses) FindingTemplatesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingTemplatesUpdateResponse, error) {
	rsp, err := c.FindingTemplatesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingTemplatesUpdateResponse(rsp)
}

func (c *ClientWithResponses) FindingTemplatesUpdateWithResponse(ctx context.Context, id int, body FindingTemplatesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingTemplatesUpdateResponse, error) {
	rsp, err := c.FindingTemplatesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingTemplatesUpdateResponse(rsp)
}

// FindingTemplatesDeletePreviewListWithResponse request returning *FindingTemplatesDeletePreviewListResponse
func (c *ClientWithResponses) FindingTemplatesDeletePreviewListWithResponse(ctx context.Context, id int, params *FindingTemplatesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*FindingTemplatesDeletePreviewListResponse, error) {
	rsp, err := c.FindingTemplatesDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingTemplatesDeletePreviewListResponse(rsp)
}

// FindingsListWithResponse request returning *FindingsListResponse
func (c *ClientWithResponses) FindingsListWithResponse(ctx context.Context, params *FindingsListParams, reqEditors ...RequestEditorFn) (*FindingsListResponse, error) {
	rsp, err := c.FindingsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsListResponse(rsp)
}

// FindingsCreateWithBodyWithResponse request with arbitrary body returning *FindingsCreateResponse
func (c *ClientWithResponses) FindingsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsCreateResponse, error) {
	rsp, err := c.FindingsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsCreateResponse(rsp)
}

func (c *ClientWithResponses) FindingsCreateWithResponse(ctx context.Context, body FindingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsCreateResponse, error) {
	rsp, err := c.FindingsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsCreateResponse(rsp)
}

// FindingsAcceptRisksCreateWithBodyWithResponse request with arbitrary body returning *FindingsAcceptRisksCreateResponse
func (c *ClientWithResponses) FindingsAcceptRisksCreateWithBodyWithResponse(ctx context.Context, params *FindingsAcceptRisksCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsAcceptRisksCreateResponse, error) {
	rsp, err := c.FindingsAcceptRisksCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsAcceptRisksCreateResponse(rsp)
}

func (c *ClientWithResponses) FindingsAcceptRisksCreateWithResponse(ctx context.Context, params *FindingsAcceptRisksCreateParams, body FindingsAcceptRisksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsAcceptRisksCreateResponse, error) {
	rsp, err := c.FindingsAcceptRisksCreate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsAcceptRisksCreateResponse(rsp)
}

// FindingsGenerateReportCreateWithBodyWithResponse request with arbitrary body returning *FindingsGenerateReportCreateResponse
func (c *ClientWithResponses) FindingsGenerateReportCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsGenerateReportCreateResponse, error) {
	rsp, err := c.FindingsGenerateReportCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsGenerateReportCreateResponse(rsp)
}

func (c *ClientWithResponses) FindingsGenerateReportCreateWithResponse(ctx context.Context, body FindingsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsGenerateReportCreateResponse, error) {
	rsp, err := c.FindingsGenerateReportCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsGenerateReportCreateResponse(rsp)
}

// FindingsDestroyWithResponse request returning *FindingsDestroyResponse
func (c *ClientWithResponses) FindingsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsDestroyResponse, error) {
	rsp, err := c.FindingsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsDestroyResponse(rsp)
}

// FindingsRetrieveWithResponse request returning *FindingsRetrieveResponse
func (c *ClientWithResponses) FindingsRetrieveWithResponse(ctx context.Context, id int, params *FindingsRetrieveParams, reqEditors ...RequestEditorFn) (*FindingsRetrieveResponse, error) {
	rsp, err := c.FindingsRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsRetrieveResponse(rsp)
}

// FindingsPartialUpdateWithBodyWithResponse request with arbitrary body returning *FindingsPartialUpdateResponse
func (c *ClientWithResponses) FindingsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsPartialUpdateResponse, error) {
	rsp, err := c.FindingsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) FindingsPartialUpdateWithResponse(ctx context.Context, id int, body FindingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsPartialUpdateResponse, error) {
	rsp, err := c.FindingsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsPartialUpdateResponse(rsp)
}

// FindingsUpdateWithBodyWithResponse request with arbitrary body returning *FindingsUpdateResponse
func (c *ClientWithResponses) FindingsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsUpdateResponse, error) {
	rsp, err := c.FindingsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsUpdateResponse(rsp)
}

func (c *ClientWithResponses) FindingsUpdateWithResponse(ctx context.Context, id int, body FindingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsUpdateResponse, error) {
	rsp, err := c.FindingsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsUpdateResponse(rsp)
}

// FindingsCloseCreateWithBodyWithResponse request with arbitrary body returning *FindingsCloseCreateResponse
func (c *ClientWithResponses) FindingsCloseCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsCloseCreateResponse, error) {
	rsp, err := c.FindingsCloseCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsCloseCreateResponse(rsp)
}

func (c *ClientWithResponses) FindingsCloseCreateWithResponse(ctx context.Context, id int, body FindingsCloseCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsCloseCreateResponse, error) {
	rsp, err := c.FindingsCloseCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsCloseCreateResponse(rsp)
}

// FindingsDeletePreviewListWithResponse request returning *FindingsDeletePreviewListResponse
func (c *ClientWithResponses) FindingsDeletePreviewListWithResponse(ctx context.Context, id int, params *FindingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*FindingsDeletePreviewListResponse, error) {
	rsp, err := c.FindingsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsDeletePreviewListResponse(rsp)
}

// FindingsDuplicateListWithResponse request returning *FindingsDuplicateListResponse
func (c *ClientWithResponses) FindingsDuplicateListWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsDuplicateListResponse, error) {
	rsp, err := c.FindingsDuplicateList(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsDuplicateListResponse(rsp)
}

// FindingsDuplicateResetCreateWithResponse request returning *FindingsDuplicateResetCreateResponse
func (c *ClientWithResponses) FindingsDuplicateResetCreateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsDuplicateResetCreateResponse, error) {
	rsp, err := c.FindingsDuplicateResetCreate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsDuplicateResetCreateResponse(rsp)
}

// FindingsFilesRetrieveWithResponse request returning *FindingsFilesRetrieveResponse
func (c *ClientWithResponses) FindingsFilesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsFilesRetrieveResponse, error) {
	rsp, err := c.FindingsFilesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsFilesRetrieveResponse(rsp)
}

// FindingsFilesCreateWithBodyWithResponse request with arbitrary body returning *FindingsFilesCreateResponse
func (c *ClientWithResponses) FindingsFilesCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsFilesCreateResponse, error) {
	rsp, err := c.FindingsFilesCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsFilesCreateResponse(rsp)
}

// FindingsMetadataDestroyWithResponse request returning *FindingsMetadataDestroyResponse
func (c *ClientWithResponses) FindingsMetadataDestroyWithResponse(ctx context.Context, id int, params *FindingsMetadataDestroyParams, reqEditors ...RequestEditorFn) (*FindingsMetadataDestroyResponse, error) {
	rsp, err := c.FindingsMetadataDestroy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsMetadataDestroyResponse(rsp)
}

// FindingsMetadataListWithResponse request returning *FindingsMetadataListResponse
func (c *ClientWithResponses) FindingsMetadataListWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsMetadataListResponse, error) {
	rsp, err := c.FindingsMetadataList(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsMetadataListResponse(rsp)
}

// FindingsMetadataCreateWithBodyWithResponse request with arbitrary body returning *FindingsMetadataCreateResponse
func (c *ClientWithResponses) FindingsMetadataCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsMetadataCreateResponse, error) {
	rsp, err := c.FindingsMetadataCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsMetadataCreateResponse(rsp)
}

func (c *ClientWithResponses) FindingsMetadataCreateWithResponse(ctx context.Context, id int, body FindingsMetadataCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsMetadataCreateResponse, error) {
	rsp, err := c.FindingsMetadataCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsMetadataCreateResponse(rsp)
}

// FindingsMetadataUpdateWithBodyWithResponse request with arbitrary body returning *FindingsMetadataUpdateResponse
func (c *ClientWithResponses) FindingsMetadataUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsMetadataUpdateResponse, error) {
	rsp, err := c.FindingsMetadataUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsMetadataUpdateResponse(rsp)
}

func (c *ClientWithResponses) FindingsMetadataUpdateWithResponse(ctx context.Context, id int, body FindingsMetadataUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsMetadataUpdateResponse, error) {
	rsp, err := c.FindingsMetadataUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsMetadataUpdateResponse(rsp)
}

// FindingsNotesRetrieveWithResponse request returning *FindingsNotesRetrieveResponse
func (c *ClientWithResponses) FindingsNotesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsNotesRetrieveResponse, error) {
	rsp, err := c.FindingsNotesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsNotesRetrieveResponse(rsp)
}

// FindingsNotesCreateWithBodyWithResponse request with arbitrary body returning *FindingsNotesCreateResponse
func (c *ClientWithResponses) FindingsNotesCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsNotesCreateResponse, error) {
	rsp, err := c.FindingsNotesCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsNotesCreateResponse(rsp)
}

func (c *ClientWithResponses) FindingsNotesCreateWithResponse(ctx context.Context, id int, body FindingsNotesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsNotesCreateResponse, error) {
	rsp, err := c.FindingsNotesCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsNotesCreateResponse(rsp)
}

// FindingsOriginalCreateWithResponse request returning *FindingsOriginalCreateResponse
func (c *ClientWithResponses) FindingsOriginalCreateWithResponse(ctx context.Context, id int, newFid int, reqEditors ...RequestEditorFn) (*FindingsOriginalCreateResponse, error) {
	rsp, err := c.FindingsOriginalCreate(ctx, id, newFid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsOriginalCreateResponse(rsp)
}

// FindingsRemoveNotePartialUpdateWithBodyWithResponse request with arbitrary body returning *FindingsRemoveNotePartialUpdateResponse
func (c *ClientWithResponses) FindingsRemoveNotePartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsRemoveNotePartialUpdateResponse, error) {
	rsp, err := c.FindingsRemoveNotePartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsRemoveNotePartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) FindingsRemoveNotePartialUpdateWithResponse(ctx context.Context, id int, body FindingsRemoveNotePartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsRemoveNotePartialUpdateResponse, error) {
	rsp, err := c.FindingsRemoveNotePartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsRemoveNotePartialUpdateResponse(rsp)
}

// FindingsRemoveTagsPartialUpdateWithBodyWithResponse request with arbitrary body returning *FindingsRemoveTagsPartialUpdateResponse
func (c *ClientWithResponses) FindingsRemoveTagsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsRemoveTagsPartialUpdateResponse, error) {
	rsp, err := c.FindingsRemoveTagsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsRemoveTagsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) FindingsRemoveTagsPartialUpdateWithResponse(ctx context.Context, id int, body FindingsRemoveTagsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsRemoveTagsPartialUpdateResponse, error) {
	rsp, err := c.FindingsRemoveTagsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsRemoveTagsPartialUpdateResponse(rsp)
}

// FindingsRemoveTagsUpdateWithBodyWithResponse request with arbitrary body returning *FindingsRemoveTagsUpdateResponse
func (c *ClientWithResponses) FindingsRemoveTagsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsRemoveTagsUpdateResponse, error) {
	rsp, err := c.FindingsRemoveTagsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsRemoveTagsUpdateResponse(rsp)
}

func (c *ClientWithResponses) FindingsRemoveTagsUpdateWithResponse(ctx context.Context, id int, body FindingsRemoveTagsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsRemoveTagsUpdateResponse, error) {
	rsp, err := c.FindingsRemoveTagsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsRemoveTagsUpdateResponse(rsp)
}

// FindingsRequestResponseRetrieveWithResponse request returning *FindingsRequestResponseRetrieveResponse
func (c *ClientWithResponses) FindingsRequestResponseRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsRequestResponseRetrieveResponse, error) {
	rsp, err := c.FindingsRequestResponseRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsRequestResponseRetrieveResponse(rsp)
}

// FindingsRequestResponseCreateWithBodyWithResponse request with arbitrary body returning *FindingsRequestResponseCreateResponse
func (c *ClientWithResponses) FindingsRequestResponseCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsRequestResponseCreateResponse, error) {
	rsp, err := c.FindingsRequestResponseCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsRequestResponseCreateResponse(rsp)
}

func (c *ClientWithResponses) FindingsRequestResponseCreateWithResponse(ctx context.Context, id int, body FindingsRequestResponseCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsRequestResponseCreateResponse, error) {
	rsp, err := c.FindingsRequestResponseCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsRequestResponseCreateResponse(rsp)
}

// FindingsTagsRetrieveWithResponse request returning *FindingsTagsRetrieveResponse
func (c *ClientWithResponses) FindingsTagsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*FindingsTagsRetrieveResponse, error) {
	rsp, err := c.FindingsTagsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsTagsRetrieveResponse(rsp)
}

// FindingsTagsCreateWithBodyWithResponse request with arbitrary body returning *FindingsTagsCreateResponse
func (c *ClientWithResponses) FindingsTagsCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindingsTagsCreateResponse, error) {
	rsp, err := c.FindingsTagsCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsTagsCreateResponse(rsp)
}

func (c *ClientWithResponses) FindingsTagsCreateWithResponse(ctx context.Context, id int, body FindingsTagsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FindingsTagsCreateResponse, error) {
	rsp, err := c.FindingsTagsCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindingsTagsCreateResponse(rsp)
}

// GlobalRolesListWithResponse request returning *GlobalRolesListResponse
func (c *ClientWithResponses) GlobalRolesListWithResponse(ctx context.Context, params *GlobalRolesListParams, reqEditors ...RequestEditorFn) (*GlobalRolesListResponse, error) {
	rsp, err := c.GlobalRolesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalRolesListResponse(rsp)
}

// GlobalRolesCreateWithBodyWithResponse request with arbitrary body returning *GlobalRolesCreateResponse
func (c *ClientWithResponses) GlobalRolesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalRolesCreateResponse, error) {
	rsp, err := c.GlobalRolesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalRolesCreateResponse(rsp)
}

func (c *ClientWithResponses) GlobalRolesCreateWithResponse(ctx context.Context, body GlobalRolesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalRolesCreateResponse, error) {
	rsp, err := c.GlobalRolesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalRolesCreateResponse(rsp)
}

// GlobalRolesDestroyWithResponse request returning *GlobalRolesDestroyResponse
func (c *ClientWithResponses) GlobalRolesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GlobalRolesDestroyResponse, error) {
	rsp, err := c.GlobalRolesDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalRolesDestroyResponse(rsp)
}

// GlobalRolesRetrieveWithResponse request returning *GlobalRolesRetrieveResponse
func (c *ClientWithResponses) GlobalRolesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GlobalRolesRetrieveResponse, error) {
	rsp, err := c.GlobalRolesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalRolesRetrieveResponse(rsp)
}

// GlobalRolesPartialUpdateWithBodyWithResponse request with arbitrary body returning *GlobalRolesPartialUpdateResponse
func (c *ClientWithResponses) GlobalRolesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalRolesPartialUpdateResponse, error) {
	rsp, err := c.GlobalRolesPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalRolesPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) GlobalRolesPartialUpdateWithResponse(ctx context.Context, id int, body GlobalRolesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalRolesPartialUpdateResponse, error) {
	rsp, err := c.GlobalRolesPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalRolesPartialUpdateResponse(rsp)
}

// GlobalRolesUpdateWithBodyWithResponse request with arbitrary body returning *GlobalRolesUpdateResponse
func (c *ClientWithResponses) GlobalRolesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalRolesUpdateResponse, error) {
	rsp, err := c.GlobalRolesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalRolesUpdateResponse(rsp)
}

func (c *ClientWithResponses) GlobalRolesUpdateWithResponse(ctx context.Context, id int, body GlobalRolesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalRolesUpdateResponse, error) {
	rsp, err := c.GlobalRolesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalRolesUpdateResponse(rsp)
}

// GlobalRolesDeletePreviewListWithResponse request returning *GlobalRolesDeletePreviewListResponse
func (c *ClientWithResponses) GlobalRolesDeletePreviewListWithResponse(ctx context.Context, id int, params *GlobalRolesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*GlobalRolesDeletePreviewListResponse, error) {
	rsp, err := c.GlobalRolesDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalRolesDeletePreviewListResponse(rsp)
}

// ImportLanguagesCreateWithBodyWithResponse request with arbitrary body returning *ImportLanguagesCreateResponse
func (c *ClientWithResponses) ImportLanguagesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportLanguagesCreateResponse, error) {
	rsp, err := c.ImportLanguagesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportLanguagesCreateResponse(rsp)
}

// ImportScanCreateWithBodyWithResponse request with arbitrary body returning *ImportScanCreateResponse
func (c *ClientWithResponses) ImportScanCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportScanCreateResponse, error) {
	rsp, err := c.ImportScanCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportScanCreateResponse(rsp)
}

// JiraConfigurationsListWithResponse request returning *JiraConfigurationsListResponse
func (c *ClientWithResponses) JiraConfigurationsListWithResponse(ctx context.Context, params *JiraConfigurationsListParams, reqEditors ...RequestEditorFn) (*JiraConfigurationsListResponse, error) {
	rsp, err := c.JiraConfigurationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraConfigurationsListResponse(rsp)
}

// JiraConfigurationsCreateWithBodyWithResponse request with arbitrary body returning *JiraConfigurationsCreateResponse
func (c *ClientWithResponses) JiraConfigurationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraConfigurationsCreateResponse, error) {
	rsp, err := c.JiraConfigurationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraConfigurationsCreateResponse(rsp)
}

func (c *ClientWithResponses) JiraConfigurationsCreateWithResponse(ctx context.Context, body JiraConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraConfigurationsCreateResponse, error) {
	rsp, err := c.JiraConfigurationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraConfigurationsCreateResponse(rsp)
}

// JiraConfigurationsDestroyWithResponse request returning *JiraConfigurationsDestroyResponse
func (c *ClientWithResponses) JiraConfigurationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraConfigurationsDestroyResponse, error) {
	rsp, err := c.JiraConfigurationsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraConfigurationsDestroyResponse(rsp)
}

// JiraConfigurationsRetrieveWithResponse request returning *JiraConfigurationsRetrieveResponse
func (c *ClientWithResponses) JiraConfigurationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraConfigurationsRetrieveResponse, error) {
	rsp, err := c.JiraConfigurationsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraConfigurationsRetrieveResponse(rsp)
}

// JiraConfigurationsPartialUpdateWithBodyWithResponse request with arbitrary body returning *JiraConfigurationsPartialUpdateResponse
func (c *ClientWithResponses) JiraConfigurationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraConfigurationsPartialUpdateResponse, error) {
	rsp, err := c.JiraConfigurationsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraConfigurationsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) JiraConfigurationsPartialUpdateWithResponse(ctx context.Context, id int, body JiraConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraConfigurationsPartialUpdateResponse, error) {
	rsp, err := c.JiraConfigurationsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraConfigurationsPartialUpdateResponse(rsp)
}

// JiraConfigurationsUpdateWithBodyWithResponse request with arbitrary body returning *JiraConfigurationsUpdateResponse
func (c *ClientWithResponses) JiraConfigurationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraConfigurationsUpdateResponse, error) {
	rsp, err := c.JiraConfigurationsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraConfigurationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) JiraConfigurationsUpdateWithResponse(ctx context.Context, id int, body JiraConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraConfigurationsUpdateResponse, error) {
	rsp, err := c.JiraConfigurationsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraConfigurationsUpdateResponse(rsp)
}

// JiraConfigurationsDeletePreviewListWithResponse request returning *JiraConfigurationsDeletePreviewListResponse
func (c *ClientWithResponses) JiraConfigurationsDeletePreviewListWithResponse(ctx context.Context, id int, params *JiraConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*JiraConfigurationsDeletePreviewListResponse, error) {
	rsp, err := c.JiraConfigurationsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraConfigurationsDeletePreviewListResponse(rsp)
}

// JiraFindingMappingsListWithResponse request returning *JiraFindingMappingsListResponse
func (c *ClientWithResponses) JiraFindingMappingsListWithResponse(ctx context.Context, params *JiraFindingMappingsListParams, reqEditors ...RequestEditorFn) (*JiraFindingMappingsListResponse, error) {
	rsp, err := c.JiraFindingMappingsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraFindingMappingsListResponse(rsp)
}

// JiraFindingMappingsCreateWithBodyWithResponse request with arbitrary body returning *JiraFindingMappingsCreateResponse
func (c *ClientWithResponses) JiraFindingMappingsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraFindingMappingsCreateResponse, error) {
	rsp, err := c.JiraFindingMappingsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraFindingMappingsCreateResponse(rsp)
}

func (c *ClientWithResponses) JiraFindingMappingsCreateWithResponse(ctx context.Context, body JiraFindingMappingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraFindingMappingsCreateResponse, error) {
	rsp, err := c.JiraFindingMappingsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraFindingMappingsCreateResponse(rsp)
}

// JiraFindingMappingsDestroyWithResponse request returning *JiraFindingMappingsDestroyResponse
func (c *ClientWithResponses) JiraFindingMappingsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraFindingMappingsDestroyResponse, error) {
	rsp, err := c.JiraFindingMappingsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraFindingMappingsDestroyResponse(rsp)
}

// JiraFindingMappingsRetrieveWithResponse request returning *JiraFindingMappingsRetrieveResponse
func (c *ClientWithResponses) JiraFindingMappingsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraFindingMappingsRetrieveResponse, error) {
	rsp, err := c.JiraFindingMappingsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraFindingMappingsRetrieveResponse(rsp)
}

// JiraFindingMappingsPartialUpdateWithBodyWithResponse request with arbitrary body returning *JiraFindingMappingsPartialUpdateResponse
func (c *ClientWithResponses) JiraFindingMappingsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraFindingMappingsPartialUpdateResponse, error) {
	rsp, err := c.JiraFindingMappingsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraFindingMappingsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) JiraFindingMappingsPartialUpdateWithResponse(ctx context.Context, id int, body JiraFindingMappingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraFindingMappingsPartialUpdateResponse, error) {
	rsp, err := c.JiraFindingMappingsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraFindingMappingsPartialUpdateResponse(rsp)
}

// JiraFindingMappingsUpdateWithBodyWithResponse request with arbitrary body returning *JiraFindingMappingsUpdateResponse
func (c *ClientWithResponses) JiraFindingMappingsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraFindingMappingsUpdateResponse, error) {
	rsp, err := c.JiraFindingMappingsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraFindingMappingsUpdateResponse(rsp)
}

func (c *ClientWithResponses) JiraFindingMappingsUpdateWithResponse(ctx context.Context, id int, body JiraFindingMappingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraFindingMappingsUpdateResponse, error) {
	rsp, err := c.JiraFindingMappingsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraFindingMappingsUpdateResponse(rsp)
}

// JiraFindingMappingsDeletePreviewListWithResponse request returning *JiraFindingMappingsDeletePreviewListResponse
func (c *ClientWithResponses) JiraFindingMappingsDeletePreviewListWithResponse(ctx context.Context, id int, params *JiraFindingMappingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*JiraFindingMappingsDeletePreviewListResponse, error) {
	rsp, err := c.JiraFindingMappingsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraFindingMappingsDeletePreviewListResponse(rsp)
}

// JiraInstancesListWithResponse request returning *JiraInstancesListResponse
func (c *ClientWithResponses) JiraInstancesListWithResponse(ctx context.Context, params *JiraInstancesListParams, reqEditors ...RequestEditorFn) (*JiraInstancesListResponse, error) {
	rsp, err := c.JiraInstancesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraInstancesListResponse(rsp)
}

// JiraInstancesCreateWithBodyWithResponse request with arbitrary body returning *JiraInstancesCreateResponse
func (c *ClientWithResponses) JiraInstancesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraInstancesCreateResponse, error) {
	rsp, err := c.JiraInstancesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraInstancesCreateResponse(rsp)
}

func (c *ClientWithResponses) JiraInstancesCreateWithResponse(ctx context.Context, body JiraInstancesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraInstancesCreateResponse, error) {
	rsp, err := c.JiraInstancesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraInstancesCreateResponse(rsp)
}

// JiraInstancesDestroyWithResponse request returning *JiraInstancesDestroyResponse
func (c *ClientWithResponses) JiraInstancesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraInstancesDestroyResponse, error) {
	rsp, err := c.JiraInstancesDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraInstancesDestroyResponse(rsp)
}

// JiraInstancesRetrieveWithResponse request returning *JiraInstancesRetrieveResponse
func (c *ClientWithResponses) JiraInstancesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraInstancesRetrieveResponse, error) {
	rsp, err := c.JiraInstancesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraInstancesRetrieveResponse(rsp)
}

// JiraInstancesPartialUpdateWithBodyWithResponse request with arbitrary body returning *JiraInstancesPartialUpdateResponse
func (c *ClientWithResponses) JiraInstancesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraInstancesPartialUpdateResponse, error) {
	rsp, err := c.JiraInstancesPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraInstancesPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) JiraInstancesPartialUpdateWithResponse(ctx context.Context, id int, body JiraInstancesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraInstancesPartialUpdateResponse, error) {
	rsp, err := c.JiraInstancesPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraInstancesPartialUpdateResponse(rsp)
}

// JiraInstancesUpdateWithBodyWithResponse request with arbitrary body returning *JiraInstancesUpdateResponse
func (c *ClientWithResponses) JiraInstancesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraInstancesUpdateResponse, error) {
	rsp, err := c.JiraInstancesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraInstancesUpdateResponse(rsp)
}

func (c *ClientWithResponses) JiraInstancesUpdateWithResponse(ctx context.Context, id int, body JiraInstancesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraInstancesUpdateResponse, error) {
	rsp, err := c.JiraInstancesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraInstancesUpdateResponse(rsp)
}

// JiraInstancesDeletePreviewListWithResponse request returning *JiraInstancesDeletePreviewListResponse
func (c *ClientWithResponses) JiraInstancesDeletePreviewListWithResponse(ctx context.Context, id int, params *JiraInstancesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*JiraInstancesDeletePreviewListResponse, error) {
	rsp, err := c.JiraInstancesDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraInstancesDeletePreviewListResponse(rsp)
}

// JiraProductConfigurationsListWithResponse request returning *JiraProductConfigurationsListResponse
func (c *ClientWithResponses) JiraProductConfigurationsListWithResponse(ctx context.Context, params *JiraProductConfigurationsListParams, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsListResponse, error) {
	rsp, err := c.JiraProductConfigurationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProductConfigurationsListResponse(rsp)
}

// JiraProductConfigurationsCreateWithBodyWithResponse request with arbitrary body returning *JiraProductConfigurationsCreateResponse
func (c *ClientWithResponses) JiraProductConfigurationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsCreateResponse, error) {
	rsp, err := c.JiraProductConfigurationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProductConfigurationsCreateResponse(rsp)
}

func (c *ClientWithResponses) JiraProductConfigurationsCreateWithResponse(ctx context.Context, body JiraProductConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsCreateResponse, error) {
	rsp, err := c.JiraProductConfigurationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProductConfigurationsCreateResponse(rsp)
}

// JiraProductConfigurationsDestroyWithResponse request returning *JiraProductConfigurationsDestroyResponse
func (c *ClientWithResponses) JiraProductConfigurationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsDestroyResponse, error) {
	rsp, err := c.JiraProductConfigurationsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProductConfigurationsDestroyResponse(rsp)
}

// JiraProductConfigurationsRetrieveWithResponse request returning *JiraProductConfigurationsRetrieveResponse
func (c *ClientWithResponses) JiraProductConfigurationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsRetrieveResponse, error) {
	rsp, err := c.JiraProductConfigurationsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProductConfigurationsRetrieveResponse(rsp)
}

// JiraProductConfigurationsPartialUpdateWithBodyWithResponse request with arbitrary body returning *JiraProductConfigurationsPartialUpdateResponse
func (c *ClientWithResponses) JiraProductConfigurationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsPartialUpdateResponse, error) {
	rsp, err := c.JiraProductConfigurationsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProductConfigurationsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) JiraProductConfigurationsPartialUpdateWithResponse(ctx context.Context, id int, body JiraProductConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsPartialUpdateResponse, error) {
	rsp, err := c.JiraProductConfigurationsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProductConfigurationsPartialUpdateResponse(rsp)
}

// JiraProductConfigurationsUpdateWithBodyWithResponse request with arbitrary body returning *JiraProductConfigurationsUpdateResponse
func (c *ClientWithResponses) JiraProductConfigurationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsUpdateResponse, error) {
	rsp, err := c.JiraProductConfigurationsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProductConfigurationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) JiraProductConfigurationsUpdateWithResponse(ctx context.Context, id int, body JiraProductConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsUpdateResponse, error) {
	rsp, err := c.JiraProductConfigurationsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProductConfigurationsUpdateResponse(rsp)
}

// JiraProductConfigurationsDeletePreviewListWithResponse request returning *JiraProductConfigurationsDeletePreviewListResponse
func (c *ClientWithResponses) JiraProductConfigurationsDeletePreviewListWithResponse(ctx context.Context, id int, params *JiraProductConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*JiraProductConfigurationsDeletePreviewListResponse, error) {
	rsp, err := c.JiraProductConfigurationsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProductConfigurationsDeletePreviewListResponse(rsp)
}

// JiraProjectsListWithResponse request returning *JiraProjectsListResponse
func (c *ClientWithResponses) JiraProjectsListWithResponse(ctx context.Context, params *JiraProjectsListParams, reqEditors ...RequestEditorFn) (*JiraProjectsListResponse, error) {
	rsp, err := c.JiraProjectsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProjectsListResponse(rsp)
}

// JiraProjectsCreateWithBodyWithResponse request with arbitrary body returning *JiraProjectsCreateResponse
func (c *ClientWithResponses) JiraProjectsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraProjectsCreateResponse, error) {
	rsp, err := c.JiraProjectsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProjectsCreateResponse(rsp)
}

func (c *ClientWithResponses) JiraProjectsCreateWithResponse(ctx context.Context, body JiraProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraProjectsCreateResponse, error) {
	rsp, err := c.JiraProjectsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProjectsCreateResponse(rsp)
}

// JiraProjectsDestroyWithResponse request returning *JiraProjectsDestroyResponse
func (c *ClientWithResponses) JiraProjectsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraProjectsDestroyResponse, error) {
	rsp, err := c.JiraProjectsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProjectsDestroyResponse(rsp)
}

// JiraProjectsRetrieveWithResponse request returning *JiraProjectsRetrieveResponse
func (c *ClientWithResponses) JiraProjectsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*JiraProjectsRetrieveResponse, error) {
	rsp, err := c.JiraProjectsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProjectsRetrieveResponse(rsp)
}

// JiraProjectsPartialUpdateWithBodyWithResponse request with arbitrary body returning *JiraProjectsPartialUpdateResponse
func (c *ClientWithResponses) JiraProjectsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraProjectsPartialUpdateResponse, error) {
	rsp, err := c.JiraProjectsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProjectsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) JiraProjectsPartialUpdateWithResponse(ctx context.Context, id int, body JiraProjectsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraProjectsPartialUpdateResponse, error) {
	rsp, err := c.JiraProjectsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProjectsPartialUpdateResponse(rsp)
}

// JiraProjectsUpdateWithBodyWithResponse request with arbitrary body returning *JiraProjectsUpdateResponse
func (c *ClientWithResponses) JiraProjectsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JiraProjectsUpdateResponse, error) {
	rsp, err := c.JiraProjectsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProjectsUpdateResponse(rsp)
}

func (c *ClientWithResponses) JiraProjectsUpdateWithResponse(ctx context.Context, id int, body JiraProjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*JiraProjectsUpdateResponse, error) {
	rsp, err := c.JiraProjectsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProjectsUpdateResponse(rsp)
}

// JiraProjectsDeletePreviewListWithResponse request returning *JiraProjectsDeletePreviewListResponse
func (c *ClientWithResponses) JiraProjectsDeletePreviewListWithResponse(ctx context.Context, id int, params *JiraProjectsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*JiraProjectsDeletePreviewListResponse, error) {
	rsp, err := c.JiraProjectsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJiraProjectsDeletePreviewListResponse(rsp)
}

// LanguageTypesListWithResponse request returning *LanguageTypesListResponse
func (c *ClientWithResponses) LanguageTypesListWithResponse(ctx context.Context, params *LanguageTypesListParams, reqEditors ...RequestEditorFn) (*LanguageTypesListResponse, error) {
	rsp, err := c.LanguageTypesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguageTypesListResponse(rsp)
}

// LanguageTypesCreateWithBodyWithResponse request with arbitrary body returning *LanguageTypesCreateResponse
func (c *ClientWithResponses) LanguageTypesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LanguageTypesCreateResponse, error) {
	rsp, err := c.LanguageTypesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguageTypesCreateResponse(rsp)
}

func (c *ClientWithResponses) LanguageTypesCreateWithResponse(ctx context.Context, body LanguageTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*LanguageTypesCreateResponse, error) {
	rsp, err := c.LanguageTypesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguageTypesCreateResponse(rsp)
}

// LanguageTypesDestroyWithResponse request returning *LanguageTypesDestroyResponse
func (c *ClientWithResponses) LanguageTypesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*LanguageTypesDestroyResponse, error) {
	rsp, err := c.LanguageTypesDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguageTypesDestroyResponse(rsp)
}

// LanguageTypesRetrieveWithResponse request returning *LanguageTypesRetrieveResponse
func (c *ClientWithResponses) LanguageTypesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*LanguageTypesRetrieveResponse, error) {
	rsp, err := c.LanguageTypesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguageTypesRetrieveResponse(rsp)
}

// LanguageTypesPartialUpdateWithBodyWithResponse request with arbitrary body returning *LanguageTypesPartialUpdateResponse
func (c *ClientWithResponses) LanguageTypesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LanguageTypesPartialUpdateResponse, error) {
	rsp, err := c.LanguageTypesPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguageTypesPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) LanguageTypesPartialUpdateWithResponse(ctx context.Context, id int, body LanguageTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LanguageTypesPartialUpdateResponse, error) {
	rsp, err := c.LanguageTypesPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguageTypesPartialUpdateResponse(rsp)
}

// LanguageTypesUpdateWithBodyWithResponse request with arbitrary body returning *LanguageTypesUpdateResponse
func (c *ClientWithResponses) LanguageTypesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LanguageTypesUpdateResponse, error) {
	rsp, err := c.LanguageTypesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguageTypesUpdateResponse(rsp)
}

func (c *ClientWithResponses) LanguageTypesUpdateWithResponse(ctx context.Context, id int, body LanguageTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LanguageTypesUpdateResponse, error) {
	rsp, err := c.LanguageTypesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguageTypesUpdateResponse(rsp)
}

// LanguageTypesDeletePreviewListWithResponse request returning *LanguageTypesDeletePreviewListResponse
func (c *ClientWithResponses) LanguageTypesDeletePreviewListWithResponse(ctx context.Context, id int, params *LanguageTypesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*LanguageTypesDeletePreviewListResponse, error) {
	rsp, err := c.LanguageTypesDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguageTypesDeletePreviewListResponse(rsp)
}

// LanguagesListWithResponse request returning *LanguagesListResponse
func (c *ClientWithResponses) LanguagesListWithResponse(ctx context.Context, params *LanguagesListParams, reqEditors ...RequestEditorFn) (*LanguagesListResponse, error) {
	rsp, err := c.LanguagesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguagesListResponse(rsp)
}

// LanguagesCreateWithBodyWithResponse request with arbitrary body returning *LanguagesCreateResponse
func (c *ClientWithResponses) LanguagesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LanguagesCreateResponse, error) {
	rsp, err := c.LanguagesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguagesCreateResponse(rsp)
}

func (c *ClientWithResponses) LanguagesCreateWithResponse(ctx context.Context, body LanguagesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*LanguagesCreateResponse, error) {
	rsp, err := c.LanguagesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguagesCreateResponse(rsp)
}

// LanguagesDestroyWithResponse request returning *LanguagesDestroyResponse
func (c *ClientWithResponses) LanguagesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*LanguagesDestroyResponse, error) {
	rsp, err := c.LanguagesDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguagesDestroyResponse(rsp)
}

// LanguagesRetrieveWithResponse request returning *LanguagesRetrieveResponse
func (c *ClientWithResponses) LanguagesRetrieveWithResponse(ctx context.Context, id int, params *LanguagesRetrieveParams, reqEditors ...RequestEditorFn) (*LanguagesRetrieveResponse, error) {
	rsp, err := c.LanguagesRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguagesRetrieveResponse(rsp)
}

// LanguagesPartialUpdateWithBodyWithResponse request with arbitrary body returning *LanguagesPartialUpdateResponse
func (c *ClientWithResponses) LanguagesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LanguagesPartialUpdateResponse, error) {
	rsp, err := c.LanguagesPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguagesPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) LanguagesPartialUpdateWithResponse(ctx context.Context, id int, body LanguagesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LanguagesPartialUpdateResponse, error) {
	rsp, err := c.LanguagesPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguagesPartialUpdateResponse(rsp)
}

// LanguagesUpdateWithBodyWithResponse request with arbitrary body returning *LanguagesUpdateResponse
func (c *ClientWithResponses) LanguagesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LanguagesUpdateResponse, error) {
	rsp, err := c.LanguagesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguagesUpdateResponse(rsp)
}

func (c *ClientWithResponses) LanguagesUpdateWithResponse(ctx context.Context, id int, body LanguagesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LanguagesUpdateResponse, error) {
	rsp, err := c.LanguagesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguagesUpdateResponse(rsp)
}

// LanguagesDeletePreviewListWithResponse request returning *LanguagesDeletePreviewListResponse
func (c *ClientWithResponses) LanguagesDeletePreviewListWithResponse(ctx context.Context, id int, params *LanguagesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*LanguagesDeletePreviewListResponse, error) {
	rsp, err := c.LanguagesDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLanguagesDeletePreviewListResponse(rsp)
}

// MetadataListWithResponse request returning *MetadataListResponse
func (c *ClientWithResponses) MetadataListWithResponse(ctx context.Context, params *MetadataListParams, reqEditors ...RequestEditorFn) (*MetadataListResponse, error) {
	rsp, err := c.MetadataList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataListResponse(rsp)
}

// MetadataCreateWithBodyWithResponse request with arbitrary body returning *MetadataCreateResponse
func (c *ClientWithResponses) MetadataCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetadataCreateResponse, error) {
	rsp, err := c.MetadataCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataCreateResponse(rsp)
}

func (c *ClientWithResponses) MetadataCreateWithResponse(ctx context.Context, body MetadataCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetadataCreateResponse, error) {
	rsp, err := c.MetadataCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataCreateResponse(rsp)
}

// MetadataDestroyWithResponse request returning *MetadataDestroyResponse
func (c *ClientWithResponses) MetadataDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*MetadataDestroyResponse, error) {
	rsp, err := c.MetadataDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataDestroyResponse(rsp)
}

// MetadataRetrieveWithResponse request returning *MetadataRetrieveResponse
func (c *ClientWithResponses) MetadataRetrieveWithResponse(ctx context.Context, id int, params *MetadataRetrieveParams, reqEditors ...RequestEditorFn) (*MetadataRetrieveResponse, error) {
	rsp, err := c.MetadataRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataRetrieveResponse(rsp)
}

// MetadataPartialUpdateWithBodyWithResponse request with arbitrary body returning *MetadataPartialUpdateResponse
func (c *ClientWithResponses) MetadataPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetadataPartialUpdateResponse, error) {
	rsp, err := c.MetadataPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) MetadataPartialUpdateWithResponse(ctx context.Context, id int, body MetadataPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetadataPartialUpdateResponse, error) {
	rsp, err := c.MetadataPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataPartialUpdateResponse(rsp)
}

// MetadataUpdateWithBodyWithResponse request with arbitrary body returning *MetadataUpdateResponse
func (c *ClientWithResponses) MetadataUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MetadataUpdateResponse, error) {
	rsp, err := c.MetadataUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataUpdateResponse(rsp)
}

func (c *ClientWithResponses) MetadataUpdateWithResponse(ctx context.Context, id int, body MetadataUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MetadataUpdateResponse, error) {
	rsp, err := c.MetadataUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataUpdateResponse(rsp)
}

// MetadataDeletePreviewListWithResponse request returning *MetadataDeletePreviewListResponse
func (c *ClientWithResponses) MetadataDeletePreviewListWithResponse(ctx context.Context, id int, params *MetadataDeletePreviewListParams, reqEditors ...RequestEditorFn) (*MetadataDeletePreviewListResponse, error) {
	rsp, err := c.MetadataDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataDeletePreviewListResponse(rsp)
}

// NetworkLocationsListWithResponse request returning *NetworkLocationsListResponse
func (c *ClientWithResponses) NetworkLocationsListWithResponse(ctx context.Context, params *NetworkLocationsListParams, reqEditors ...RequestEditorFn) (*NetworkLocationsListResponse, error) {
	rsp, err := c.NetworkLocationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkLocationsListResponse(rsp)
}

// NetworkLocationsCreateWithBodyWithResponse request with arbitrary body returning *NetworkLocationsCreateResponse
func (c *ClientWithResponses) NetworkLocationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NetworkLocationsCreateResponse, error) {
	rsp, err := c.NetworkLocationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkLocationsCreateResponse(rsp)
}

func (c *ClientWithResponses) NetworkLocationsCreateWithResponse(ctx context.Context, body NetworkLocationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*NetworkLocationsCreateResponse, error) {
	rsp, err := c.NetworkLocationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkLocationsCreateResponse(rsp)
}

// NetworkLocationsDestroyWithResponse request returning *NetworkLocationsDestroyResponse
func (c *ClientWithResponses) NetworkLocationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*NetworkLocationsDestroyResponse, error) {
	rsp, err := c.NetworkLocationsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkLocationsDestroyResponse(rsp)
}

// NetworkLocationsRetrieveWithResponse request returning *NetworkLocationsRetrieveResponse
func (c *ClientWithResponses) NetworkLocationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*NetworkLocationsRetrieveResponse, error) {
	rsp, err := c.NetworkLocationsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkLocationsRetrieveResponse(rsp)
}

// NetworkLocationsPartialUpdateWithBodyWithResponse request with arbitrary body returning *NetworkLocationsPartialUpdateResponse
func (c *ClientWithResponses) NetworkLocationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NetworkLocationsPartialUpdateResponse, error) {
	rsp, err := c.NetworkLocationsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkLocationsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) NetworkLocationsPartialUpdateWithResponse(ctx context.Context, id int, body NetworkLocationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NetworkLocationsPartialUpdateResponse, error) {
	rsp, err := c.NetworkLocationsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkLocationsPartialUpdateResponse(rsp)
}

// NetworkLocationsUpdateWithBodyWithResponse request with arbitrary body returning *NetworkLocationsUpdateResponse
func (c *ClientWithResponses) NetworkLocationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NetworkLocationsUpdateResponse, error) {
	rsp, err := c.NetworkLocationsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkLocationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) NetworkLocationsUpdateWithResponse(ctx context.Context, id int, body NetworkLocationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NetworkLocationsUpdateResponse, error) {
	rsp, err := c.NetworkLocationsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkLocationsUpdateResponse(rsp)
}

// NetworkLocationsDeletePreviewListWithResponse request returning *NetworkLocationsDeletePreviewListResponse
func (c *ClientWithResponses) NetworkLocationsDeletePreviewListWithResponse(ctx context.Context, id int, params *NetworkLocationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*NetworkLocationsDeletePreviewListResponse, error) {
	rsp, err := c.NetworkLocationsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkLocationsDeletePreviewListResponse(rsp)
}

// NoteTypeListWithResponse request returning *NoteTypeListResponse
func (c *ClientWithResponses) NoteTypeListWithResponse(ctx context.Context, params *NoteTypeListParams, reqEditors ...RequestEditorFn) (*NoteTypeListResponse, error) {
	rsp, err := c.NoteTypeList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNoteTypeListResponse(rsp)
}

// NoteTypeCreateWithBodyWithResponse request with arbitrary body returning *NoteTypeCreateResponse
func (c *ClientWithResponses) NoteTypeCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NoteTypeCreateResponse, error) {
	rsp, err := c.NoteTypeCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNoteTypeCreateResponse(rsp)
}

func (c *ClientWithResponses) NoteTypeCreateWithResponse(ctx context.Context, body NoteTypeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*NoteTypeCreateResponse, error) {
	rsp, err := c.NoteTypeCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNoteTypeCreateResponse(rsp)
}

// NoteTypeDestroyWithResponse request returning *NoteTypeDestroyResponse
func (c *ClientWithResponses) NoteTypeDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*NoteTypeDestroyResponse, error) {
	rsp, err := c.NoteTypeDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNoteTypeDestroyResponse(rsp)
}

// NoteTypeRetrieveWithResponse request returning *NoteTypeRetrieveResponse
func (c *ClientWithResponses) NoteTypeRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*NoteTypeRetrieveResponse, error) {
	rsp, err := c.NoteTypeRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNoteTypeRetrieveResponse(rsp)
}

// NoteTypePartialUpdateWithBodyWithResponse request with arbitrary body returning *NoteTypePartialUpdateResponse
func (c *ClientWithResponses) NoteTypePartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NoteTypePartialUpdateResponse, error) {
	rsp, err := c.NoteTypePartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNoteTypePartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) NoteTypePartialUpdateWithResponse(ctx context.Context, id int, body NoteTypePartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NoteTypePartialUpdateResponse, error) {
	rsp, err := c.NoteTypePartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNoteTypePartialUpdateResponse(rsp)
}

// NoteTypeUpdateWithBodyWithResponse request with arbitrary body returning *NoteTypeUpdateResponse
func (c *ClientWithResponses) NoteTypeUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NoteTypeUpdateResponse, error) {
	rsp, err := c.NoteTypeUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNoteTypeUpdateResponse(rsp)
}

func (c *ClientWithResponses) NoteTypeUpdateWithResponse(ctx context.Context, id int, body NoteTypeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NoteTypeUpdateResponse, error) {
	rsp, err := c.NoteTypeUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNoteTypeUpdateResponse(rsp)
}

// NoteTypeDeletePreviewListWithResponse request returning *NoteTypeDeletePreviewListResponse
func (c *ClientWithResponses) NoteTypeDeletePreviewListWithResponse(ctx context.Context, id int, params *NoteTypeDeletePreviewListParams, reqEditors ...RequestEditorFn) (*NoteTypeDeletePreviewListResponse, error) {
	rsp, err := c.NoteTypeDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNoteTypeDeletePreviewListResponse(rsp)
}

// NotesListWithResponse request returning *NotesListResponse
func (c *ClientWithResponses) NotesListWithResponse(ctx context.Context, params *NotesListParams, reqEditors ...RequestEditorFn) (*NotesListResponse, error) {
	rsp, err := c.NotesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotesListResponse(rsp)
}

// NotesRetrieveWithResponse request returning *NotesRetrieveResponse
func (c *ClientWithResponses) NotesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*NotesRetrieveResponse, error) {
	rsp, err := c.NotesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotesRetrieveResponse(rsp)
}

// NotesPartialUpdateWithBodyWithResponse request with arbitrary body returning *NotesPartialUpdateResponse
func (c *ClientWithResponses) NotesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotesPartialUpdateResponse, error) {
	rsp, err := c.NotesPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotesPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) NotesPartialUpdateWithResponse(ctx context.Context, id int, body NotesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NotesPartialUpdateResponse, error) {
	rsp, err := c.NotesPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotesPartialUpdateResponse(rsp)
}

// NotesUpdateWithBodyWithResponse request with arbitrary body returning *NotesUpdateResponse
func (c *ClientWithResponses) NotesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotesUpdateResponse, error) {
	rsp, err := c.NotesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotesUpdateResponse(rsp)
}

func (c *ClientWithResponses) NotesUpdateWithResponse(ctx context.Context, id int, body NotesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NotesUpdateResponse, error) {
	rsp, err := c.NotesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotesUpdateResponse(rsp)
}

// NotificationsListWithResponse request returning *NotificationsListResponse
func (c *ClientWithResponses) NotificationsListWithResponse(ctx context.Context, params *NotificationsListParams, reqEditors ...RequestEditorFn) (*NotificationsListResponse, error) {
	rsp, err := c.NotificationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsListResponse(rsp)
}

// NotificationsCreateWithBodyWithResponse request with arbitrary body returning *NotificationsCreateResponse
func (c *ClientWithResponses) NotificationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotificationsCreateResponse, error) {
	rsp, err := c.NotificationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsCreateResponse(rsp)
}

func (c *ClientWithResponses) NotificationsCreateWithResponse(ctx context.Context, body NotificationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*NotificationsCreateResponse, error) {
	rsp, err := c.NotificationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsCreateResponse(rsp)
}

// NotificationsDestroyWithResponse request returning *NotificationsDestroyResponse
func (c *ClientWithResponses) NotificationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*NotificationsDestroyResponse, error) {
	rsp, err := c.NotificationsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsDestroyResponse(rsp)
}

// NotificationsRetrieveWithResponse request returning *NotificationsRetrieveResponse
func (c *ClientWithResponses) NotificationsRetrieveWithResponse(ctx context.Context, id int, params *NotificationsRetrieveParams, reqEditors ...RequestEditorFn) (*NotificationsRetrieveResponse, error) {
	rsp, err := c.NotificationsRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsRetrieveResponse(rsp)
}

// NotificationsPartialUpdateWithBodyWithResponse request with arbitrary body returning *NotificationsPartialUpdateResponse
func (c *ClientWithResponses) NotificationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotificationsPartialUpdateResponse, error) {
	rsp, err := c.NotificationsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) NotificationsPartialUpdateWithResponse(ctx context.Context, id int, body NotificationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NotificationsPartialUpdateResponse, error) {
	rsp, err := c.NotificationsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsPartialUpdateResponse(rsp)
}

// NotificationsUpdateWithBodyWithResponse request with arbitrary body returning *NotificationsUpdateResponse
func (c *ClientWithResponses) NotificationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotificationsUpdateResponse, error) {
	rsp, err := c.NotificationsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) NotificationsUpdateWithResponse(ctx context.Context, id int, body NotificationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NotificationsUpdateResponse, error) {
	rsp, err := c.NotificationsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsUpdateResponse(rsp)
}

// NotificationsDeletePreviewListWithResponse request returning *NotificationsDeletePreviewListResponse
func (c *ClientWithResponses) NotificationsDeletePreviewListWithResponse(ctx context.Context, id int, params *NotificationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*NotificationsDeletePreviewListResponse, error) {
	rsp, err := c.NotificationsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsDeletePreviewListResponse(rsp)
}

// Oa3SchemaRetrieveWithResponse request returning *Oa3SchemaRetrieveResponse
func (c *ClientWithResponses) Oa3SchemaRetrieveWithResponse(ctx context.Context, params *Oa3SchemaRetrieveParams, reqEditors ...RequestEditorFn) (*Oa3SchemaRetrieveResponse, error) {
	rsp, err := c.Oa3SchemaRetrieve(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOa3SchemaRetrieveResponse(rsp)
}

// ProductApiScanConfigurationsListWithResponse request returning *ProductApiScanConfigurationsListResponse
func (c *ClientWithResponses) ProductApiScanConfigurationsListWithResponse(ctx context.Context, params *ProductApiScanConfigurationsListParams, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsListResponse, error) {
	rsp, err := c.ProductApiScanConfigurationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductApiScanConfigurationsListResponse(rsp)
}

// ProductApiScanConfigurationsCreateWithBodyWithResponse request with arbitrary body returning *ProductApiScanConfigurationsCreateResponse
func (c *ClientWithResponses) ProductApiScanConfigurationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsCreateResponse, error) {
	rsp, err := c.ProductApiScanConfigurationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductApiScanConfigurationsCreateResponse(rsp)
}

func (c *ClientWithResponses) ProductApiScanConfigurationsCreateWithResponse(ctx context.Context, body ProductApiScanConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsCreateResponse, error) {
	rsp, err := c.ProductApiScanConfigurationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductApiScanConfigurationsCreateResponse(rsp)
}

// ProductApiScanConfigurationsDestroyWithResponse request returning *ProductApiScanConfigurationsDestroyResponse
func (c *ClientWithResponses) ProductApiScanConfigurationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsDestroyResponse, error) {
	rsp, err := c.ProductApiScanConfigurationsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductApiScanConfigurationsDestroyResponse(rsp)
}

// ProductApiScanConfigurationsRetrieveWithResponse request returning *ProductApiScanConfigurationsRetrieveResponse
func (c *ClientWithResponses) ProductApiScanConfigurationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsRetrieveResponse, error) {
	rsp, err := c.ProductApiScanConfigurationsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductApiScanConfigurationsRetrieveResponse(rsp)
}

// ProductApiScanConfigurationsPartialUpdateWithBodyWithResponse request with arbitrary body returning *ProductApiScanConfigurationsPartialUpdateResponse
func (c *ClientWithResponses) ProductApiScanConfigurationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsPartialUpdateResponse, error) {
	rsp, err := c.ProductApiScanConfigurationsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductApiScanConfigurationsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProductApiScanConfigurationsPartialUpdateWithResponse(ctx context.Context, id int, body ProductApiScanConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsPartialUpdateResponse, error) {
	rsp, err := c.ProductApiScanConfigurationsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductApiScanConfigurationsPartialUpdateResponse(rsp)
}

// ProductApiScanConfigurationsUpdateWithBodyWithResponse request with arbitrary body returning *ProductApiScanConfigurationsUpdateResponse
func (c *ClientWithResponses) ProductApiScanConfigurationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsUpdateResponse, error) {
	rsp, err := c.ProductApiScanConfigurationsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductApiScanConfigurationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProductApiScanConfigurationsUpdateWithResponse(ctx context.Context, id int, body ProductApiScanConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsUpdateResponse, error) {
	rsp, err := c.ProductApiScanConfigurationsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductApiScanConfigurationsUpdateResponse(rsp)
}

// ProductApiScanConfigurationsDeletePreviewListWithResponse request returning *ProductApiScanConfigurationsDeletePreviewListResponse
func (c *ClientWithResponses) ProductApiScanConfigurationsDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductApiScanConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductApiScanConfigurationsDeletePreviewListResponse, error) {
	rsp, err := c.ProductApiScanConfigurationsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductApiScanConfigurationsDeletePreviewListResponse(rsp)
}

// ProductGroupsListWithResponse request returning *ProductGroupsListResponse
func (c *ClientWithResponses) ProductGroupsListWithResponse(ctx context.Context, params *ProductGroupsListParams, reqEditors ...RequestEditorFn) (*ProductGroupsListResponse, error) {
	rsp, err := c.ProductGroupsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductGroupsListResponse(rsp)
}

// ProductGroupsCreateWithBodyWithResponse request with arbitrary body returning *ProductGroupsCreateResponse
func (c *ClientWithResponses) ProductGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductGroupsCreateResponse, error) {
	rsp, err := c.ProductGroupsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductGroupsCreateResponse(rsp)
}

func (c *ClientWithResponses) ProductGroupsCreateWithResponse(ctx context.Context, body ProductGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductGroupsCreateResponse, error) {
	rsp, err := c.ProductGroupsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductGroupsCreateResponse(rsp)
}

// ProductGroupsDestroyWithResponse request returning *ProductGroupsDestroyResponse
func (c *ClientWithResponses) ProductGroupsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductGroupsDestroyResponse, error) {
	rsp, err := c.ProductGroupsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductGroupsDestroyResponse(rsp)
}

// ProductGroupsRetrieveWithResponse request returning *ProductGroupsRetrieveResponse
func (c *ClientWithResponses) ProductGroupsRetrieveWithResponse(ctx context.Context, id int, params *ProductGroupsRetrieveParams, reqEditors ...RequestEditorFn) (*ProductGroupsRetrieveResponse, error) {
	rsp, err := c.ProductGroupsRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductGroupsRetrieveResponse(rsp)
}

// ProductGroupsPartialUpdateWithResponse request returning *ProductGroupsPartialUpdateResponse
func (c *ClientWithResponses) ProductGroupsPartialUpdateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductGroupsPartialUpdateResponse, error) {
	rsp, err := c.ProductGroupsPartialUpdate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductGroupsPartialUpdateResponse(rsp)
}

// ProductGroupsUpdateWithBodyWithResponse request with arbitrary body returning *ProductGroupsUpdateResponse
func (c *ClientWithResponses) ProductGroupsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductGroupsUpdateResponse, error) {
	rsp, err := c.ProductGroupsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductGroupsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProductGroupsUpdateWithResponse(ctx context.Context, id int, body ProductGroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductGroupsUpdateResponse, error) {
	rsp, err := c.ProductGroupsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductGroupsUpdateResponse(rsp)
}

// ProductGroupsDeletePreviewListWithResponse request returning *ProductGroupsDeletePreviewListResponse
func (c *ClientWithResponses) ProductGroupsDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductGroupsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductGroupsDeletePreviewListResponse, error) {
	rsp, err := c.ProductGroupsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductGroupsDeletePreviewListResponse(rsp)
}

// ProductMembersListWithResponse request returning *ProductMembersListResponse
func (c *ClientWithResponses) ProductMembersListWithResponse(ctx context.Context, params *ProductMembersListParams, reqEditors ...RequestEditorFn) (*ProductMembersListResponse, error) {
	rsp, err := c.ProductMembersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductMembersListResponse(rsp)
}

// ProductMembersCreateWithBodyWithResponse request with arbitrary body returning *ProductMembersCreateResponse
func (c *ClientWithResponses) ProductMembersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductMembersCreateResponse, error) {
	rsp, err := c.ProductMembersCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductMembersCreateResponse(rsp)
}

func (c *ClientWithResponses) ProductMembersCreateWithResponse(ctx context.Context, body ProductMembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductMembersCreateResponse, error) {
	rsp, err := c.ProductMembersCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductMembersCreateResponse(rsp)
}

// ProductMembersDestroyWithResponse request returning *ProductMembersDestroyResponse
func (c *ClientWithResponses) ProductMembersDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductMembersDestroyResponse, error) {
	rsp, err := c.ProductMembersDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductMembersDestroyResponse(rsp)
}

// ProductMembersRetrieveWithResponse request returning *ProductMembersRetrieveResponse
func (c *ClientWithResponses) ProductMembersRetrieveWithResponse(ctx context.Context, id int, params *ProductMembersRetrieveParams, reqEditors ...RequestEditorFn) (*ProductMembersRetrieveResponse, error) {
	rsp, err := c.ProductMembersRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductMembersRetrieveResponse(rsp)
}

// ProductMembersPartialUpdateWithResponse request returning *ProductMembersPartialUpdateResponse
func (c *ClientWithResponses) ProductMembersPartialUpdateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductMembersPartialUpdateResponse, error) {
	rsp, err := c.ProductMembersPartialUpdate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductMembersPartialUpdateResponse(rsp)
}

// ProductMembersUpdateWithBodyWithResponse request with arbitrary body returning *ProductMembersUpdateResponse
func (c *ClientWithResponses) ProductMembersUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductMembersUpdateResponse, error) {
	rsp, err := c.ProductMembersUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductMembersUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProductMembersUpdateWithResponse(ctx context.Context, id int, body ProductMembersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductMembersUpdateResponse, error) {
	rsp, err := c.ProductMembersUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductMembersUpdateResponse(rsp)
}

// ProductMembersDeletePreviewListWithResponse request returning *ProductMembersDeletePreviewListResponse
func (c *ClientWithResponses) ProductMembersDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductMembersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductMembersDeletePreviewListResponse, error) {
	rsp, err := c.ProductMembersDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductMembersDeletePreviewListResponse(rsp)
}

// ProductTypeGroupsListWithResponse request returning *ProductTypeGroupsListResponse
func (c *ClientWithResponses) ProductTypeGroupsListWithResponse(ctx context.Context, params *ProductTypeGroupsListParams, reqEditors ...RequestEditorFn) (*ProductTypeGroupsListResponse, error) {
	rsp, err := c.ProductTypeGroupsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeGroupsListResponse(rsp)
}

// ProductTypeGroupsCreateWithBodyWithResponse request with arbitrary body returning *ProductTypeGroupsCreateResponse
func (c *ClientWithResponses) ProductTypeGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypeGroupsCreateResponse, error) {
	rsp, err := c.ProductTypeGroupsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeGroupsCreateResponse(rsp)
}

func (c *ClientWithResponses) ProductTypeGroupsCreateWithResponse(ctx context.Context, body ProductTypeGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypeGroupsCreateResponse, error) {
	rsp, err := c.ProductTypeGroupsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeGroupsCreateResponse(rsp)
}

// ProductTypeGroupsDestroyWithResponse request returning *ProductTypeGroupsDestroyResponse
func (c *ClientWithResponses) ProductTypeGroupsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductTypeGroupsDestroyResponse, error) {
	rsp, err := c.ProductTypeGroupsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeGroupsDestroyResponse(rsp)
}

// ProductTypeGroupsRetrieveWithResponse request returning *ProductTypeGroupsRetrieveResponse
func (c *ClientWithResponses) ProductTypeGroupsRetrieveWithResponse(ctx context.Context, id int, params *ProductTypeGroupsRetrieveParams, reqEditors ...RequestEditorFn) (*ProductTypeGroupsRetrieveResponse, error) {
	rsp, err := c.ProductTypeGroupsRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeGroupsRetrieveResponse(rsp)
}

// ProductTypeGroupsPartialUpdateWithResponse request returning *ProductTypeGroupsPartialUpdateResponse
func (c *ClientWithResponses) ProductTypeGroupsPartialUpdateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductTypeGroupsPartialUpdateResponse, error) {
	rsp, err := c.ProductTypeGroupsPartialUpdate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeGroupsPartialUpdateResponse(rsp)
}

// ProductTypeGroupsUpdateWithBodyWithResponse request with arbitrary body returning *ProductTypeGroupsUpdateResponse
func (c *ClientWithResponses) ProductTypeGroupsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypeGroupsUpdateResponse, error) {
	rsp, err := c.ProductTypeGroupsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeGroupsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProductTypeGroupsUpdateWithResponse(ctx context.Context, id int, body ProductTypeGroupsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypeGroupsUpdateResponse, error) {
	rsp, err := c.ProductTypeGroupsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeGroupsUpdateResponse(rsp)
}

// ProductTypeGroupsDeletePreviewListWithResponse request returning *ProductTypeGroupsDeletePreviewListResponse
func (c *ClientWithResponses) ProductTypeGroupsDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductTypeGroupsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductTypeGroupsDeletePreviewListResponse, error) {
	rsp, err := c.ProductTypeGroupsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeGroupsDeletePreviewListResponse(rsp)
}

// ProductTypeMembersListWithResponse request returning *ProductTypeMembersListResponse
func (c *ClientWithResponses) ProductTypeMembersListWithResponse(ctx context.Context, params *ProductTypeMembersListParams, reqEditors ...RequestEditorFn) (*ProductTypeMembersListResponse, error) {
	rsp, err := c.ProductTypeMembersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeMembersListResponse(rsp)
}

// ProductTypeMembersCreateWithBodyWithResponse request with arbitrary body returning *ProductTypeMembersCreateResponse
func (c *ClientWithResponses) ProductTypeMembersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypeMembersCreateResponse, error) {
	rsp, err := c.ProductTypeMembersCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeMembersCreateResponse(rsp)
}

func (c *ClientWithResponses) ProductTypeMembersCreateWithResponse(ctx context.Context, body ProductTypeMembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypeMembersCreateResponse, error) {
	rsp, err := c.ProductTypeMembersCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeMembersCreateResponse(rsp)
}

// ProductTypeMembersDestroyWithResponse request returning *ProductTypeMembersDestroyResponse
func (c *ClientWithResponses) ProductTypeMembersDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductTypeMembersDestroyResponse, error) {
	rsp, err := c.ProductTypeMembersDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeMembersDestroyResponse(rsp)
}

// ProductTypeMembersRetrieveWithResponse request returning *ProductTypeMembersRetrieveResponse
func (c *ClientWithResponses) ProductTypeMembersRetrieveWithResponse(ctx context.Context, id int, params *ProductTypeMembersRetrieveParams, reqEditors ...RequestEditorFn) (*ProductTypeMembersRetrieveResponse, error) {
	rsp, err := c.ProductTypeMembersRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeMembersRetrieveResponse(rsp)
}

// ProductTypeMembersPartialUpdateWithResponse request returning *ProductTypeMembersPartialUpdateResponse
func (c *ClientWithResponses) ProductTypeMembersPartialUpdateWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductTypeMembersPartialUpdateResponse, error) {
	rsp, err := c.ProductTypeMembersPartialUpdate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeMembersPartialUpdateResponse(rsp)
}

// ProductTypeMembersUpdateWithBodyWithResponse request with arbitrary body returning *ProductTypeMembersUpdateResponse
func (c *ClientWithResponses) ProductTypeMembersUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypeMembersUpdateResponse, error) {
	rsp, err := c.ProductTypeMembersUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeMembersUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProductTypeMembersUpdateWithResponse(ctx context.Context, id int, body ProductTypeMembersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypeMembersUpdateResponse, error) {
	rsp, err := c.ProductTypeMembersUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeMembersUpdateResponse(rsp)
}

// ProductTypeMembersDeletePreviewListWithResponse request returning *ProductTypeMembersDeletePreviewListResponse
func (c *ClientWithResponses) ProductTypeMembersDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductTypeMembersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductTypeMembersDeletePreviewListResponse, error) {
	rsp, err := c.ProductTypeMembersDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypeMembersDeletePreviewListResponse(rsp)
}

// ProductTypesListWithResponse request returning *ProductTypesListResponse
func (c *ClientWithResponses) ProductTypesListWithResponse(ctx context.Context, params *ProductTypesListParams, reqEditors ...RequestEditorFn) (*ProductTypesListResponse, error) {
	rsp, err := c.ProductTypesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesListResponse(rsp)
}

// ProductTypesCreateWithBodyWithResponse request with arbitrary body returning *ProductTypesCreateResponse
func (c *ClientWithResponses) ProductTypesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypesCreateResponse, error) {
	rsp, err := c.ProductTypesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesCreateResponse(rsp)
}

func (c *ClientWithResponses) ProductTypesCreateWithResponse(ctx context.Context, body ProductTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypesCreateResponse, error) {
	rsp, err := c.ProductTypesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesCreateResponse(rsp)
}

// ProductTypesDestroyWithResponse request returning *ProductTypesDestroyResponse
func (c *ClientWithResponses) ProductTypesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductTypesDestroyResponse, error) {
	rsp, err := c.ProductTypesDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesDestroyResponse(rsp)
}

// ProductTypesRetrieveWithResponse request returning *ProductTypesRetrieveResponse
func (c *ClientWithResponses) ProductTypesRetrieveWithResponse(ctx context.Context, id int, params *ProductTypesRetrieveParams, reqEditors ...RequestEditorFn) (*ProductTypesRetrieveResponse, error) {
	rsp, err := c.ProductTypesRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesRetrieveResponse(rsp)
}

// ProductTypesPartialUpdateWithBodyWithResponse request with arbitrary body returning *ProductTypesPartialUpdateResponse
func (c *ClientWithResponses) ProductTypesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypesPartialUpdateResponse, error) {
	rsp, err := c.ProductTypesPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProductTypesPartialUpdateWithResponse(ctx context.Context, id int, body ProductTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypesPartialUpdateResponse, error) {
	rsp, err := c.ProductTypesPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesPartialUpdateResponse(rsp)
}

// ProductTypesUpdateWithBodyWithResponse request with arbitrary body returning *ProductTypesUpdateResponse
func (c *ClientWithResponses) ProductTypesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypesUpdateResponse, error) {
	rsp, err := c.ProductTypesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProductTypesUpdateWithResponse(ctx context.Context, id int, body ProductTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypesUpdateResponse, error) {
	rsp, err := c.ProductTypesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesUpdateResponse(rsp)
}

// ProductTypesDeletePreviewListWithResponse request returning *ProductTypesDeletePreviewListResponse
func (c *ClientWithResponses) ProductTypesDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductTypesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductTypesDeletePreviewListResponse, error) {
	rsp, err := c.ProductTypesDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesDeletePreviewListResponse(rsp)
}

// ProductTypesGenerateReportCreateWithBodyWithResponse request with arbitrary body returning *ProductTypesGenerateReportCreateResponse
func (c *ClientWithResponses) ProductTypesGenerateReportCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductTypesGenerateReportCreateResponse, error) {
	rsp, err := c.ProductTypesGenerateReportCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesGenerateReportCreateResponse(rsp)
}

func (c *ClientWithResponses) ProductTypesGenerateReportCreateWithResponse(ctx context.Context, id int, body ProductTypesGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductTypesGenerateReportCreateResponse, error) {
	rsp, err := c.ProductTypesGenerateReportCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesGenerateReportCreateResponse(rsp)
}

// ProductsListWithResponse request returning *ProductsListResponse
func (c *ClientWithResponses) ProductsListWithResponse(ctx context.Context, params *ProductsListParams, reqEditors ...RequestEditorFn) (*ProductsListResponse, error) {
	rsp, err := c.ProductsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsListResponse(rsp)
}

// ProductsCreateWithBodyWithResponse request with arbitrary body returning *ProductsCreateResponse
func (c *ClientWithResponses) ProductsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductsCreateResponse, error) {
	rsp, err := c.ProductsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsCreateResponse(rsp)
}

func (c *ClientWithResponses) ProductsCreateWithResponse(ctx context.Context, body ProductsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductsCreateResponse, error) {
	rsp, err := c.ProductsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsCreateResponse(rsp)
}

// ProductsDestroyWithResponse request returning *ProductsDestroyResponse
func (c *ClientWithResponses) ProductsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ProductsDestroyResponse, error) {
	rsp, err := c.ProductsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsDestroyResponse(rsp)
}

// ProductsRetrieveWithResponse request returning *ProductsRetrieveResponse
func (c *ClientWithResponses) ProductsRetrieveWithResponse(ctx context.Context, id int, params *ProductsRetrieveParams, reqEditors ...RequestEditorFn) (*ProductsRetrieveResponse, error) {
	rsp, err := c.ProductsRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsRetrieveResponse(rsp)
}

// ProductsPartialUpdateWithBodyWithResponse request with arbitrary body returning *ProductsPartialUpdateResponse
func (c *ClientWithResponses) ProductsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductsPartialUpdateResponse, error) {
	rsp, err := c.ProductsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProductsPartialUpdateWithResponse(ctx context.Context, id int, body ProductsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductsPartialUpdateResponse, error) {
	rsp, err := c.ProductsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsPartialUpdateResponse(rsp)
}

// ProductsUpdateWithBodyWithResponse request with arbitrary body returning *ProductsUpdateResponse
func (c *ClientWithResponses) ProductsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductsUpdateResponse, error) {
	rsp, err := c.ProductsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProductsUpdateWithResponse(ctx context.Context, id int, body ProductsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductsUpdateResponse, error) {
	rsp, err := c.ProductsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsUpdateResponse(rsp)
}

// ProductsDeletePreviewListWithResponse request returning *ProductsDeletePreviewListResponse
func (c *ClientWithResponses) ProductsDeletePreviewListWithResponse(ctx context.Context, id int, params *ProductsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ProductsDeletePreviewListResponse, error) {
	rsp, err := c.ProductsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsDeletePreviewListResponse(rsp)
}

// ProductsGenerateReportCreateWithBodyWithResponse request with arbitrary body returning *ProductsGenerateReportCreateResponse
func (c *ClientWithResponses) ProductsGenerateReportCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductsGenerateReportCreateResponse, error) {
	rsp, err := c.ProductsGenerateReportCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsGenerateReportCreateResponse(rsp)
}

func (c *ClientWithResponses) ProductsGenerateReportCreateWithResponse(ctx context.Context, id int, body ProductsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductsGenerateReportCreateResponse, error) {
	rsp, err := c.ProductsGenerateReportCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsGenerateReportCreateResponse(rsp)
}

// RegulationsListWithResponse request returning *RegulationsListResponse
func (c *ClientWithResponses) RegulationsListWithResponse(ctx context.Context, params *RegulationsListParams, reqEditors ...RequestEditorFn) (*RegulationsListResponse, error) {
	rsp, err := c.RegulationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegulationsListResponse(rsp)
}

// RegulationsCreateWithBodyWithResponse request with arbitrary body returning *RegulationsCreateResponse
func (c *ClientWithResponses) RegulationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegulationsCreateResponse, error) {
	rsp, err := c.RegulationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegulationsCreateResponse(rsp)
}

func (c *ClientWithResponses) RegulationsCreateWithResponse(ctx context.Context, body RegulationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RegulationsCreateResponse, error) {
	rsp, err := c.RegulationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegulationsCreateResponse(rsp)
}

// RegulationsDestroyWithResponse request returning *RegulationsDestroyResponse
func (c *ClientWithResponses) RegulationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RegulationsDestroyResponse, error) {
	rsp, err := c.RegulationsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegulationsDestroyResponse(rsp)
}

// RegulationsRetrieveWithResponse request returning *RegulationsRetrieveResponse
func (c *ClientWithResponses) RegulationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RegulationsRetrieveResponse, error) {
	rsp, err := c.RegulationsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegulationsRetrieveResponse(rsp)
}

// RegulationsPartialUpdateWithBodyWithResponse request with arbitrary body returning *RegulationsPartialUpdateResponse
func (c *ClientWithResponses) RegulationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegulationsPartialUpdateResponse, error) {
	rsp, err := c.RegulationsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegulationsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) RegulationsPartialUpdateWithResponse(ctx context.Context, id int, body RegulationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RegulationsPartialUpdateResponse, error) {
	rsp, err := c.RegulationsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegulationsPartialUpdateResponse(rsp)
}

// RegulationsUpdateWithBodyWithResponse request with arbitrary body returning *RegulationsUpdateResponse
func (c *ClientWithResponses) RegulationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegulationsUpdateResponse, error) {
	rsp, err := c.RegulationsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegulationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) RegulationsUpdateWithResponse(ctx context.Context, id int, body RegulationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RegulationsUpdateResponse, error) {
	rsp, err := c.RegulationsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegulationsUpdateResponse(rsp)
}

// RegulationsDeletePreviewListWithResponse request returning *RegulationsDeletePreviewListResponse
func (c *ClientWithResponses) RegulationsDeletePreviewListWithResponse(ctx context.Context, id int, params *RegulationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*RegulationsDeletePreviewListResponse, error) {
	rsp, err := c.RegulationsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegulationsDeletePreviewListResponse(rsp)
}

// ReimportScanCreateWithBodyWithResponse request with arbitrary body returning *ReimportScanCreateResponse
func (c *ClientWithResponses) ReimportScanCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReimportScanCreateResponse, error) {
	rsp, err := c.ReimportScanCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReimportScanCreateResponse(rsp)
}

// RolesListWithResponse request returning *RolesListResponse
func (c *ClientWithResponses) RolesListWithResponse(ctx context.Context, params *RolesListParams, reqEditors ...RequestEditorFn) (*RolesListResponse, error) {
	rsp, err := c.RolesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRolesListResponse(rsp)
}

// RolesRetrieveWithResponse request returning *RolesRetrieveResponse
func (c *ClientWithResponses) RolesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RolesRetrieveResponse, error) {
	rsp, err := c.RolesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRolesRetrieveResponse(rsp)
}

// SlaConfigurationsListWithResponse request returning *SlaConfigurationsListResponse
func (c *ClientWithResponses) SlaConfigurationsListWithResponse(ctx context.Context, params *SlaConfigurationsListParams, reqEditors ...RequestEditorFn) (*SlaConfigurationsListResponse, error) {
	rsp, err := c.SlaConfigurationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaConfigurationsListResponse(rsp)
}

// SlaConfigurationsCreateWithBodyWithResponse request with arbitrary body returning *SlaConfigurationsCreateResponse
func (c *ClientWithResponses) SlaConfigurationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaConfigurationsCreateResponse, error) {
	rsp, err := c.SlaConfigurationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaConfigurationsCreateResponse(rsp)
}

func (c *ClientWithResponses) SlaConfigurationsCreateWithResponse(ctx context.Context, body SlaConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaConfigurationsCreateResponse, error) {
	rsp, err := c.SlaConfigurationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaConfigurationsCreateResponse(rsp)
}

// SlaConfigurationsDestroyWithResponse request returning *SlaConfigurationsDestroyResponse
func (c *ClientWithResponses) SlaConfigurationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*SlaConfigurationsDestroyResponse, error) {
	rsp, err := c.SlaConfigurationsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaConfigurationsDestroyResponse(rsp)
}

// SlaConfigurationsRetrieveWithResponse request returning *SlaConfigurationsRetrieveResponse
func (c *ClientWithResponses) SlaConfigurationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*SlaConfigurationsRetrieveResponse, error) {
	rsp, err := c.SlaConfigurationsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaConfigurationsRetrieveResponse(rsp)
}

// SlaConfigurationsPartialUpdateWithBodyWithResponse request with arbitrary body returning *SlaConfigurationsPartialUpdateResponse
func (c *ClientWithResponses) SlaConfigurationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaConfigurationsPartialUpdateResponse, error) {
	rsp, err := c.SlaConfigurationsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaConfigurationsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) SlaConfigurationsPartialUpdateWithResponse(ctx context.Context, id int, body SlaConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaConfigurationsPartialUpdateResponse, error) {
	rsp, err := c.SlaConfigurationsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaConfigurationsPartialUpdateResponse(rsp)
}

// SlaConfigurationsUpdateWithBodyWithResponse request with arbitrary body returning *SlaConfigurationsUpdateResponse
func (c *ClientWithResponses) SlaConfigurationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlaConfigurationsUpdateResponse, error) {
	rsp, err := c.SlaConfigurationsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaConfigurationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) SlaConfigurationsUpdateWithResponse(ctx context.Context, id int, body SlaConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlaConfigurationsUpdateResponse, error) {
	rsp, err := c.SlaConfigurationsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlaConfigurationsUpdateResponse(rsp)
}

// SonarqubeIssuesListWithResponse request returning *SonarqubeIssuesListResponse
func (c *ClientWithResponses) SonarqubeIssuesListWithResponse(ctx context.Context, params *SonarqubeIssuesListParams, reqEditors ...RequestEditorFn) (*SonarqubeIssuesListResponse, error) {
	rsp, err := c.SonarqubeIssuesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeIssuesListResponse(rsp)
}

// SonarqubeIssuesCreateWithBodyWithResponse request with arbitrary body returning *SonarqubeIssuesCreateResponse
func (c *ClientWithResponses) SonarqubeIssuesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SonarqubeIssuesCreateResponse, error) {
	rsp, err := c.SonarqubeIssuesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeIssuesCreateResponse(rsp)
}

func (c *ClientWithResponses) SonarqubeIssuesCreateWithResponse(ctx context.Context, body SonarqubeIssuesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SonarqubeIssuesCreateResponse, error) {
	rsp, err := c.SonarqubeIssuesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeIssuesCreateResponse(rsp)
}

// SonarqubeIssuesDestroyWithResponse request returning *SonarqubeIssuesDestroyResponse
func (c *ClientWithResponses) SonarqubeIssuesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*SonarqubeIssuesDestroyResponse, error) {
	rsp, err := c.SonarqubeIssuesDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeIssuesDestroyResponse(rsp)
}

// SonarqubeIssuesRetrieveWithResponse request returning *SonarqubeIssuesRetrieveResponse
func (c *ClientWithResponses) SonarqubeIssuesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*SonarqubeIssuesRetrieveResponse, error) {
	rsp, err := c.SonarqubeIssuesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeIssuesRetrieveResponse(rsp)
}

// SonarqubeIssuesPartialUpdateWithBodyWithResponse request with arbitrary body returning *SonarqubeIssuesPartialUpdateResponse
func (c *ClientWithResponses) SonarqubeIssuesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SonarqubeIssuesPartialUpdateResponse, error) {
	rsp, err := c.SonarqubeIssuesPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeIssuesPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) SonarqubeIssuesPartialUpdateWithResponse(ctx context.Context, id int, body SonarqubeIssuesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SonarqubeIssuesPartialUpdateResponse, error) {
	rsp, err := c.SonarqubeIssuesPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeIssuesPartialUpdateResponse(rsp)
}

// SonarqubeIssuesUpdateWithBodyWithResponse request with arbitrary body returning *SonarqubeIssuesUpdateResponse
func (c *ClientWithResponses) SonarqubeIssuesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SonarqubeIssuesUpdateResponse, error) {
	rsp, err := c.SonarqubeIssuesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeIssuesUpdateResponse(rsp)
}

func (c *ClientWithResponses) SonarqubeIssuesUpdateWithResponse(ctx context.Context, id int, body SonarqubeIssuesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SonarqubeIssuesUpdateResponse, error) {
	rsp, err := c.SonarqubeIssuesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeIssuesUpdateResponse(rsp)
}

// SonarqubeIssuesDeletePreviewListWithResponse request returning *SonarqubeIssuesDeletePreviewListResponse
func (c *ClientWithResponses) SonarqubeIssuesDeletePreviewListWithResponse(ctx context.Context, id int, params *SonarqubeIssuesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*SonarqubeIssuesDeletePreviewListResponse, error) {
	rsp, err := c.SonarqubeIssuesDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeIssuesDeletePreviewListResponse(rsp)
}

// SonarqubeTransitionsListWithResponse request returning *SonarqubeTransitionsListResponse
func (c *ClientWithResponses) SonarqubeTransitionsListWithResponse(ctx context.Context, params *SonarqubeTransitionsListParams, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsListResponse, error) {
	rsp, err := c.SonarqubeTransitionsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeTransitionsListResponse(rsp)
}

// SonarqubeTransitionsCreateWithBodyWithResponse request with arbitrary body returning *SonarqubeTransitionsCreateResponse
func (c *ClientWithResponses) SonarqubeTransitionsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsCreateResponse, error) {
	rsp, err := c.SonarqubeTransitionsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeTransitionsCreateResponse(rsp)
}

func (c *ClientWithResponses) SonarqubeTransitionsCreateWithResponse(ctx context.Context, body SonarqubeTransitionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsCreateResponse, error) {
	rsp, err := c.SonarqubeTransitionsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeTransitionsCreateResponse(rsp)
}

// SonarqubeTransitionsDestroyWithResponse request returning *SonarqubeTransitionsDestroyResponse
func (c *ClientWithResponses) SonarqubeTransitionsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsDestroyResponse, error) {
	rsp, err := c.SonarqubeTransitionsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeTransitionsDestroyResponse(rsp)
}

// SonarqubeTransitionsRetrieveWithResponse request returning *SonarqubeTransitionsRetrieveResponse
func (c *ClientWithResponses) SonarqubeTransitionsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsRetrieveResponse, error) {
	rsp, err := c.SonarqubeTransitionsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeTransitionsRetrieveResponse(rsp)
}

// SonarqubeTransitionsPartialUpdateWithBodyWithResponse request with arbitrary body returning *SonarqubeTransitionsPartialUpdateResponse
func (c *ClientWithResponses) SonarqubeTransitionsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsPartialUpdateResponse, error) {
	rsp, err := c.SonarqubeTransitionsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeTransitionsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) SonarqubeTransitionsPartialUpdateWithResponse(ctx context.Context, id int, body SonarqubeTransitionsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsPartialUpdateResponse, error) {
	rsp, err := c.SonarqubeTransitionsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeTransitionsPartialUpdateResponse(rsp)
}

// SonarqubeTransitionsUpdateWithBodyWithResponse request with arbitrary body returning *SonarqubeTransitionsUpdateResponse
func (c *ClientWithResponses) SonarqubeTransitionsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsUpdateResponse, error) {
	rsp, err := c.SonarqubeTransitionsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeTransitionsUpdateResponse(rsp)
}

func (c *ClientWithResponses) SonarqubeTransitionsUpdateWithResponse(ctx context.Context, id int, body SonarqubeTransitionsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsUpdateResponse, error) {
	rsp, err := c.SonarqubeTransitionsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeTransitionsUpdateResponse(rsp)
}

// SonarqubeTransitionsDeletePreviewListWithResponse request returning *SonarqubeTransitionsDeletePreviewListResponse
func (c *ClientWithResponses) SonarqubeTransitionsDeletePreviewListWithResponse(ctx context.Context, id int, params *SonarqubeTransitionsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*SonarqubeTransitionsDeletePreviewListResponse, error) {
	rsp, err := c.SonarqubeTransitionsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSonarqubeTransitionsDeletePreviewListResponse(rsp)
}

// StubFindingsListWithResponse request returning *StubFindingsListResponse
func (c *ClientWithResponses) StubFindingsListWithResponse(ctx context.Context, params *StubFindingsListParams, reqEditors ...RequestEditorFn) (*StubFindingsListResponse, error) {
	rsp, err := c.StubFindingsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStubFindingsListResponse(rsp)
}

// StubFindingsCreateWithBodyWithResponse request with arbitrary body returning *StubFindingsCreateResponse
func (c *ClientWithResponses) StubFindingsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StubFindingsCreateResponse, error) {
	rsp, err := c.StubFindingsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStubFindingsCreateResponse(rsp)
}

func (c *ClientWithResponses) StubFindingsCreateWithResponse(ctx context.Context, body StubFindingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*StubFindingsCreateResponse, error) {
	rsp, err := c.StubFindingsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStubFindingsCreateResponse(rsp)
}

// StubFindingsDestroyWithResponse request returning *StubFindingsDestroyResponse
func (c *ClientWithResponses) StubFindingsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*StubFindingsDestroyResponse, error) {
	rsp, err := c.StubFindingsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStubFindingsDestroyResponse(rsp)
}

// StubFindingsRetrieveWithResponse request returning *StubFindingsRetrieveResponse
func (c *ClientWithResponses) StubFindingsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*StubFindingsRetrieveResponse, error) {
	rsp, err := c.StubFindingsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStubFindingsRetrieveResponse(rsp)
}

// StubFindingsPartialUpdateWithBodyWithResponse request with arbitrary body returning *StubFindingsPartialUpdateResponse
func (c *ClientWithResponses) StubFindingsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StubFindingsPartialUpdateResponse, error) {
	rsp, err := c.StubFindingsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStubFindingsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) StubFindingsPartialUpdateWithResponse(ctx context.Context, id int, body StubFindingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*StubFindingsPartialUpdateResponse, error) {
	rsp, err := c.StubFindingsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStubFindingsPartialUpdateResponse(rsp)
}

// StubFindingsUpdateWithBodyWithResponse request with arbitrary body returning *StubFindingsUpdateResponse
func (c *ClientWithResponses) StubFindingsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StubFindingsUpdateResponse, error) {
	rsp, err := c.StubFindingsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStubFindingsUpdateResponse(rsp)
}

func (c *ClientWithResponses) StubFindingsUpdateWithResponse(ctx context.Context, id int, body StubFindingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*StubFindingsUpdateResponse, error) {
	rsp, err := c.StubFindingsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStubFindingsUpdateResponse(rsp)
}

// StubFindingsDeletePreviewListWithResponse request returning *StubFindingsDeletePreviewListResponse
func (c *ClientWithResponses) StubFindingsDeletePreviewListWithResponse(ctx context.Context, id int, params *StubFindingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*StubFindingsDeletePreviewListResponse, error) {
	rsp, err := c.StubFindingsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStubFindingsDeletePreviewListResponse(rsp)
}

// SystemSettingsListWithResponse request returning *SystemSettingsListResponse
func (c *ClientWithResponses) SystemSettingsListWithResponse(ctx context.Context, params *SystemSettingsListParams, reqEditors ...RequestEditorFn) (*SystemSettingsListResponse, error) {
	rsp, err := c.SystemSettingsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSystemSettingsListResponse(rsp)
}

// SystemSettingsPartialUpdateWithBodyWithResponse request with arbitrary body returning *SystemSettingsPartialUpdateResponse
func (c *ClientWithResponses) SystemSettingsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SystemSettingsPartialUpdateResponse, error) {
	rsp, err := c.SystemSettingsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSystemSettingsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) SystemSettingsPartialUpdateWithResponse(ctx context.Context, id int, body SystemSettingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SystemSettingsPartialUpdateResponse, error) {
	rsp, err := c.SystemSettingsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSystemSettingsPartialUpdateResponse(rsp)
}

// SystemSettingsUpdateWithBodyWithResponse request with arbitrary body returning *SystemSettingsUpdateResponse
func (c *ClientWithResponses) SystemSettingsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SystemSettingsUpdateResponse, error) {
	rsp, err := c.SystemSettingsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSystemSettingsUpdateResponse(rsp)
}

func (c *ClientWithResponses) SystemSettingsUpdateWithResponse(ctx context.Context, id int, body SystemSettingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SystemSettingsUpdateResponse, error) {
	rsp, err := c.SystemSettingsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSystemSettingsUpdateResponse(rsp)
}

// TechnologiesListWithResponse request returning *TechnologiesListResponse
func (c *ClientWithResponses) TechnologiesListWithResponse(ctx context.Context, params *TechnologiesListParams, reqEditors ...RequestEditorFn) (*TechnologiesListResponse, error) {
	rsp, err := c.TechnologiesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTechnologiesListResponse(rsp)
}

// TechnologiesCreateWithBodyWithResponse request with arbitrary body returning *TechnologiesCreateResponse
func (c *ClientWithResponses) TechnologiesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TechnologiesCreateResponse, error) {
	rsp, err := c.TechnologiesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTechnologiesCreateResponse(rsp)
}

func (c *ClientWithResponses) TechnologiesCreateWithResponse(ctx context.Context, body TechnologiesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TechnologiesCreateResponse, error) {
	rsp, err := c.TechnologiesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTechnologiesCreateResponse(rsp)
}

// TechnologiesDestroyWithResponse request returning *TechnologiesDestroyResponse
func (c *ClientWithResponses) TechnologiesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TechnologiesDestroyResponse, error) {
	rsp, err := c.TechnologiesDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTechnologiesDestroyResponse(rsp)
}

// TechnologiesRetrieveWithResponse request returning *TechnologiesRetrieveResponse
func (c *ClientWithResponses) TechnologiesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TechnologiesRetrieveResponse, error) {
	rsp, err := c.TechnologiesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTechnologiesRetrieveResponse(rsp)
}

// TechnologiesPartialUpdateWithBodyWithResponse request with arbitrary body returning *TechnologiesPartialUpdateResponse
func (c *ClientWithResponses) TechnologiesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TechnologiesPartialUpdateResponse, error) {
	rsp, err := c.TechnologiesPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTechnologiesPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) TechnologiesPartialUpdateWithResponse(ctx context.Context, id int, body TechnologiesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TechnologiesPartialUpdateResponse, error) {
	rsp, err := c.TechnologiesPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTechnologiesPartialUpdateResponse(rsp)
}

// TechnologiesUpdateWithBodyWithResponse request with arbitrary body returning *TechnologiesUpdateResponse
func (c *ClientWithResponses) TechnologiesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TechnologiesUpdateResponse, error) {
	rsp, err := c.TechnologiesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTechnologiesUpdateResponse(rsp)
}

func (c *ClientWithResponses) TechnologiesUpdateWithResponse(ctx context.Context, id int, body TechnologiesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TechnologiesUpdateResponse, error) {
	rsp, err := c.TechnologiesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTechnologiesUpdateResponse(rsp)
}

// TechnologiesDeletePreviewListWithResponse request returning *TechnologiesDeletePreviewListResponse
func (c *ClientWithResponses) TechnologiesDeletePreviewListWithResponse(ctx context.Context, id int, params *TechnologiesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*TechnologiesDeletePreviewListResponse, error) {
	rsp, err := c.TechnologiesDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTechnologiesDeletePreviewListResponse(rsp)
}

// TestImportsListWithResponse request returning *TestImportsListResponse
func (c *ClientWithResponses) TestImportsListWithResponse(ctx context.Context, params *TestImportsListParams, reqEditors ...RequestEditorFn) (*TestImportsListResponse, error) {
	rsp, err := c.TestImportsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestImportsListResponse(rsp)
}

// TestImportsCreateWithBodyWithResponse request with arbitrary body returning *TestImportsCreateResponse
func (c *ClientWithResponses) TestImportsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestImportsCreateResponse, error) {
	rsp, err := c.TestImportsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestImportsCreateResponse(rsp)
}

func (c *ClientWithResponses) TestImportsCreateWithResponse(ctx context.Context, body TestImportsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestImportsCreateResponse, error) {
	rsp, err := c.TestImportsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestImportsCreateResponse(rsp)
}

// TestImportsDestroyWithResponse request returning *TestImportsDestroyResponse
func (c *ClientWithResponses) TestImportsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TestImportsDestroyResponse, error) {
	rsp, err := c.TestImportsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestImportsDestroyResponse(rsp)
}

// TestImportsRetrieveWithResponse request returning *TestImportsRetrieveResponse
func (c *ClientWithResponses) TestImportsRetrieveWithResponse(ctx context.Context, id int, params *TestImportsRetrieveParams, reqEditors ...RequestEditorFn) (*TestImportsRetrieveResponse, error) {
	rsp, err := c.TestImportsRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestImportsRetrieveResponse(rsp)
}

// TestImportsPartialUpdateWithBodyWithResponse request with arbitrary body returning *TestImportsPartialUpdateResponse
func (c *ClientWithResponses) TestImportsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestImportsPartialUpdateResponse, error) {
	rsp, err := c.TestImportsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestImportsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) TestImportsPartialUpdateWithResponse(ctx context.Context, id int, body TestImportsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestImportsPartialUpdateResponse, error) {
	rsp, err := c.TestImportsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestImportsPartialUpdateResponse(rsp)
}

// TestImportsUpdateWithBodyWithResponse request with arbitrary body returning *TestImportsUpdateResponse
func (c *ClientWithResponses) TestImportsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestImportsUpdateResponse, error) {
	rsp, err := c.TestImportsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestImportsUpdateResponse(rsp)
}

func (c *ClientWithResponses) TestImportsUpdateWithResponse(ctx context.Context, id int, body TestImportsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestImportsUpdateResponse, error) {
	rsp, err := c.TestImportsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestImportsUpdateResponse(rsp)
}

// TestImportsDeletePreviewListWithResponse request returning *TestImportsDeletePreviewListResponse
func (c *ClientWithResponses) TestImportsDeletePreviewListWithResponse(ctx context.Context, id int, params *TestImportsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*TestImportsDeletePreviewListResponse, error) {
	rsp, err := c.TestImportsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestImportsDeletePreviewListResponse(rsp)
}

// TestTypesListWithResponse request returning *TestTypesListResponse
func (c *ClientWithResponses) TestTypesListWithResponse(ctx context.Context, params *TestTypesListParams, reqEditors ...RequestEditorFn) (*TestTypesListResponse, error) {
	rsp, err := c.TestTypesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestTypesListResponse(rsp)
}

// TestTypesCreateWithBodyWithResponse request with arbitrary body returning *TestTypesCreateResponse
func (c *ClientWithResponses) TestTypesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestTypesCreateResponse, error) {
	rsp, err := c.TestTypesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestTypesCreateResponse(rsp)
}

func (c *ClientWithResponses) TestTypesCreateWithResponse(ctx context.Context, body TestTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestTypesCreateResponse, error) {
	rsp, err := c.TestTypesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestTypesCreateResponse(rsp)
}

// TestTypesRetrieveWithResponse request returning *TestTypesRetrieveResponse
func (c *ClientWithResponses) TestTypesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TestTypesRetrieveResponse, error) {
	rsp, err := c.TestTypesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestTypesRetrieveResponse(rsp)
}

// TestTypesPartialUpdateWithBodyWithResponse request with arbitrary body returning *TestTypesPartialUpdateResponse
func (c *ClientWithResponses) TestTypesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestTypesPartialUpdateResponse, error) {
	rsp, err := c.TestTypesPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestTypesPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) TestTypesPartialUpdateWithResponse(ctx context.Context, id int, body TestTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestTypesPartialUpdateResponse, error) {
	rsp, err := c.TestTypesPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestTypesPartialUpdateResponse(rsp)
}

// TestTypesUpdateWithBodyWithResponse request with arbitrary body returning *TestTypesUpdateResponse
func (c *ClientWithResponses) TestTypesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestTypesUpdateResponse, error) {
	rsp, err := c.TestTypesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestTypesUpdateResponse(rsp)
}

func (c *ClientWithResponses) TestTypesUpdateWithResponse(ctx context.Context, id int, body TestTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestTypesUpdateResponse, error) {
	rsp, err := c.TestTypesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestTypesUpdateResponse(rsp)
}

// TestsListWithResponse request returning *TestsListResponse
func (c *ClientWithResponses) TestsListWithResponse(ctx context.Context, params *TestsListParams, reqEditors ...RequestEditorFn) (*TestsListResponse, error) {
	rsp, err := c.TestsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsListResponse(rsp)
}

// TestsCreateWithBodyWithResponse request with arbitrary body returning *TestsCreateResponse
func (c *ClientWithResponses) TestsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsCreateResponse, error) {
	rsp, err := c.TestsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsCreateResponse(rsp)
}

func (c *ClientWithResponses) TestsCreateWithResponse(ctx context.Context, body TestsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestsCreateResponse, error) {
	rsp, err := c.TestsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsCreateResponse(rsp)
}

// TestsDestroyWithResponse request returning *TestsDestroyResponse
func (c *ClientWithResponses) TestsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TestsDestroyResponse, error) {
	rsp, err := c.TestsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsDestroyResponse(rsp)
}

// TestsRetrieveWithResponse request returning *TestsRetrieveResponse
func (c *ClientWithResponses) TestsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TestsRetrieveResponse, error) {
	rsp, err := c.TestsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsRetrieveResponse(rsp)
}

// TestsPartialUpdateWithBodyWithResponse request with arbitrary body returning *TestsPartialUpdateResponse
func (c *ClientWithResponses) TestsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsPartialUpdateResponse, error) {
	rsp, err := c.TestsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) TestsPartialUpdateWithResponse(ctx context.Context, id int, body TestsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestsPartialUpdateResponse, error) {
	rsp, err := c.TestsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsPartialUpdateResponse(rsp)
}

// TestsUpdateWithBodyWithResponse request with arbitrary body returning *TestsUpdateResponse
func (c *ClientWithResponses) TestsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsUpdateResponse, error) {
	rsp, err := c.TestsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsUpdateResponse(rsp)
}

func (c *ClientWithResponses) TestsUpdateWithResponse(ctx context.Context, id int, body TestsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestsUpdateResponse, error) {
	rsp, err := c.TestsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsUpdateResponse(rsp)
}

// TestsAcceptRisksCreateWithBodyWithResponse request with arbitrary body returning *TestsAcceptRisksCreateResponse
func (c *ClientWithResponses) TestsAcceptRisksCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsAcceptRisksCreateResponse, error) {
	rsp, err := c.TestsAcceptRisksCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsAcceptRisksCreateResponse(rsp)
}

func (c *ClientWithResponses) TestsAcceptRisksCreateWithResponse(ctx context.Context, id int, body TestsAcceptRisksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestsAcceptRisksCreateResponse, error) {
	rsp, err := c.TestsAcceptRisksCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsAcceptRisksCreateResponse(rsp)
}

// TestsDeletePreviewListWithResponse request returning *TestsDeletePreviewListResponse
func (c *ClientWithResponses) TestsDeletePreviewListWithResponse(ctx context.Context, id int, params *TestsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*TestsDeletePreviewListResponse, error) {
	rsp, err := c.TestsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsDeletePreviewListResponse(rsp)
}

// TestsFilesRetrieveWithResponse request returning *TestsFilesRetrieveResponse
func (c *ClientWithResponses) TestsFilesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TestsFilesRetrieveResponse, error) {
	rsp, err := c.TestsFilesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsFilesRetrieveResponse(rsp)
}

// TestsFilesCreateWithBodyWithResponse request with arbitrary body returning *TestsFilesCreateResponse
func (c *ClientWithResponses) TestsFilesCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsFilesCreateResponse, error) {
	rsp, err := c.TestsFilesCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsFilesCreateResponse(rsp)
}

// TestsGenerateReportCreateWithBodyWithResponse request with arbitrary body returning *TestsGenerateReportCreateResponse
func (c *ClientWithResponses) TestsGenerateReportCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsGenerateReportCreateResponse, error) {
	rsp, err := c.TestsGenerateReportCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsGenerateReportCreateResponse(rsp)
}

func (c *ClientWithResponses) TestsGenerateReportCreateWithResponse(ctx context.Context, id int, body TestsGenerateReportCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestsGenerateReportCreateResponse, error) {
	rsp, err := c.TestsGenerateReportCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsGenerateReportCreateResponse(rsp)
}

// TestsNotesRetrieveWithResponse request returning *TestsNotesRetrieveResponse
func (c *ClientWithResponses) TestsNotesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*TestsNotesRetrieveResponse, error) {
	rsp, err := c.TestsNotesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsNotesRetrieveResponse(rsp)
}

// TestsNotesCreateWithBodyWithResponse request with arbitrary body returning *TestsNotesCreateResponse
func (c *ClientWithResponses) TestsNotesCreateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestsNotesCreateResponse, error) {
	rsp, err := c.TestsNotesCreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsNotesCreateResponse(rsp)
}

func (c *ClientWithResponses) TestsNotesCreateWithResponse(ctx context.Context, id int, body TestsNotesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TestsNotesCreateResponse, error) {
	rsp, err := c.TestsNotesCreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestsNotesCreateResponse(rsp)
}

// ToolConfigurationsListWithResponse request returning *ToolConfigurationsListResponse
func (c *ClientWithResponses) ToolConfigurationsListWithResponse(ctx context.Context, params *ToolConfigurationsListParams, reqEditors ...RequestEditorFn) (*ToolConfigurationsListResponse, error) {
	rsp, err := c.ToolConfigurationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolConfigurationsListResponse(rsp)
}

// ToolConfigurationsCreateWithBodyWithResponse request with arbitrary body returning *ToolConfigurationsCreateResponse
func (c *ClientWithResponses) ToolConfigurationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolConfigurationsCreateResponse, error) {
	rsp, err := c.ToolConfigurationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolConfigurationsCreateResponse(rsp)
}

func (c *ClientWithResponses) ToolConfigurationsCreateWithResponse(ctx context.Context, body ToolConfigurationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolConfigurationsCreateResponse, error) {
	rsp, err := c.ToolConfigurationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolConfigurationsCreateResponse(rsp)
}

// ToolConfigurationsDestroyWithResponse request returning *ToolConfigurationsDestroyResponse
func (c *ClientWithResponses) ToolConfigurationsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ToolConfigurationsDestroyResponse, error) {
	rsp, err := c.ToolConfigurationsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolConfigurationsDestroyResponse(rsp)
}

// ToolConfigurationsRetrieveWithResponse request returning *ToolConfigurationsRetrieveResponse
func (c *ClientWithResponses) ToolConfigurationsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ToolConfigurationsRetrieveResponse, error) {
	rsp, err := c.ToolConfigurationsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolConfigurationsRetrieveResponse(rsp)
}

// ToolConfigurationsPartialUpdateWithBodyWithResponse request with arbitrary body returning *ToolConfigurationsPartialUpdateResponse
func (c *ClientWithResponses) ToolConfigurationsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolConfigurationsPartialUpdateResponse, error) {
	rsp, err := c.ToolConfigurationsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolConfigurationsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) ToolConfigurationsPartialUpdateWithResponse(ctx context.Context, id int, body ToolConfigurationsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolConfigurationsPartialUpdateResponse, error) {
	rsp, err := c.ToolConfigurationsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolConfigurationsPartialUpdateResponse(rsp)
}

// ToolConfigurationsUpdateWithBodyWithResponse request with arbitrary body returning *ToolConfigurationsUpdateResponse
func (c *ClientWithResponses) ToolConfigurationsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolConfigurationsUpdateResponse, error) {
	rsp, err := c.ToolConfigurationsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolConfigurationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ToolConfigurationsUpdateWithResponse(ctx context.Context, id int, body ToolConfigurationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolConfigurationsUpdateResponse, error) {
	rsp, err := c.ToolConfigurationsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolConfigurationsUpdateResponse(rsp)
}

// ToolConfigurationsDeletePreviewListWithResponse request returning *ToolConfigurationsDeletePreviewListResponse
func (c *ClientWithResponses) ToolConfigurationsDeletePreviewListWithResponse(ctx context.Context, id int, params *ToolConfigurationsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ToolConfigurationsDeletePreviewListResponse, error) {
	rsp, err := c.ToolConfigurationsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolConfigurationsDeletePreviewListResponse(rsp)
}

// ToolProductSettingsListWithResponse request returning *ToolProductSettingsListResponse
func (c *ClientWithResponses) ToolProductSettingsListWithResponse(ctx context.Context, params *ToolProductSettingsListParams, reqEditors ...RequestEditorFn) (*ToolProductSettingsListResponse, error) {
	rsp, err := c.ToolProductSettingsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolProductSettingsListResponse(rsp)
}

// ToolProductSettingsCreateWithBodyWithResponse request with arbitrary body returning *ToolProductSettingsCreateResponse
func (c *ClientWithResponses) ToolProductSettingsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolProductSettingsCreateResponse, error) {
	rsp, err := c.ToolProductSettingsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolProductSettingsCreateResponse(rsp)
}

func (c *ClientWithResponses) ToolProductSettingsCreateWithResponse(ctx context.Context, body ToolProductSettingsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolProductSettingsCreateResponse, error) {
	rsp, err := c.ToolProductSettingsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolProductSettingsCreateResponse(rsp)
}

// ToolProductSettingsDestroyWithResponse request returning *ToolProductSettingsDestroyResponse
func (c *ClientWithResponses) ToolProductSettingsDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ToolProductSettingsDestroyResponse, error) {
	rsp, err := c.ToolProductSettingsDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolProductSettingsDestroyResponse(rsp)
}

// ToolProductSettingsRetrieveWithResponse request returning *ToolProductSettingsRetrieveResponse
func (c *ClientWithResponses) ToolProductSettingsRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ToolProductSettingsRetrieveResponse, error) {
	rsp, err := c.ToolProductSettingsRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolProductSettingsRetrieveResponse(rsp)
}

// ToolProductSettingsPartialUpdateWithBodyWithResponse request with arbitrary body returning *ToolProductSettingsPartialUpdateResponse
func (c *ClientWithResponses) ToolProductSettingsPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolProductSettingsPartialUpdateResponse, error) {
	rsp, err := c.ToolProductSettingsPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolProductSettingsPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) ToolProductSettingsPartialUpdateWithResponse(ctx context.Context, id int, body ToolProductSettingsPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolProductSettingsPartialUpdateResponse, error) {
	rsp, err := c.ToolProductSettingsPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolProductSettingsPartialUpdateResponse(rsp)
}

// ToolProductSettingsUpdateWithBodyWithResponse request with arbitrary body returning *ToolProductSettingsUpdateResponse
func (c *ClientWithResponses) ToolProductSettingsUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolProductSettingsUpdateResponse, error) {
	rsp, err := c.ToolProductSettingsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolProductSettingsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ToolProductSettingsUpdateWithResponse(ctx context.Context, id int, body ToolProductSettingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolProductSettingsUpdateResponse, error) {
	rsp, err := c.ToolProductSettingsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolProductSettingsUpdateResponse(rsp)
}

// ToolProductSettingsDeletePreviewListWithResponse request returning *ToolProductSettingsDeletePreviewListResponse
func (c *ClientWithResponses) ToolProductSettingsDeletePreviewListWithResponse(ctx context.Context, id int, params *ToolProductSettingsDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ToolProductSettingsDeletePreviewListResponse, error) {
	rsp, err := c.ToolProductSettingsDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolProductSettingsDeletePreviewListResponse(rsp)
}

// ToolTypesListWithResponse request returning *ToolTypesListResponse
func (c *ClientWithResponses) ToolTypesListWithResponse(ctx context.Context, params *ToolTypesListParams, reqEditors ...RequestEditorFn) (*ToolTypesListResponse, error) {
	rsp, err := c.ToolTypesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolTypesListResponse(rsp)
}

// ToolTypesCreateWithBodyWithResponse request with arbitrary body returning *ToolTypesCreateResponse
func (c *ClientWithResponses) ToolTypesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolTypesCreateResponse, error) {
	rsp, err := c.ToolTypesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolTypesCreateResponse(rsp)
}

func (c *ClientWithResponses) ToolTypesCreateWithResponse(ctx context.Context, body ToolTypesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolTypesCreateResponse, error) {
	rsp, err := c.ToolTypesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolTypesCreateResponse(rsp)
}

// ToolTypesDestroyWithResponse request returning *ToolTypesDestroyResponse
func (c *ClientWithResponses) ToolTypesDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ToolTypesDestroyResponse, error) {
	rsp, err := c.ToolTypesDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolTypesDestroyResponse(rsp)
}

// ToolTypesRetrieveWithResponse request returning *ToolTypesRetrieveResponse
func (c *ClientWithResponses) ToolTypesRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ToolTypesRetrieveResponse, error) {
	rsp, err := c.ToolTypesRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolTypesRetrieveResponse(rsp)
}

// ToolTypesPartialUpdateWithBodyWithResponse request with arbitrary body returning *ToolTypesPartialUpdateResponse
func (c *ClientWithResponses) ToolTypesPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolTypesPartialUpdateResponse, error) {
	rsp, err := c.ToolTypesPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolTypesPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) ToolTypesPartialUpdateWithResponse(ctx context.Context, id int, body ToolTypesPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolTypesPartialUpdateResponse, error) {
	rsp, err := c.ToolTypesPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolTypesPartialUpdateResponse(rsp)
}

// ToolTypesUpdateWithBodyWithResponse request with arbitrary body returning *ToolTypesUpdateResponse
func (c *ClientWithResponses) ToolTypesUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ToolTypesUpdateResponse, error) {
	rsp, err := c.ToolTypesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolTypesUpdateResponse(rsp)
}

func (c *ClientWithResponses) ToolTypesUpdateWithResponse(ctx context.Context, id int, body ToolTypesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ToolTypesUpdateResponse, error) {
	rsp, err := c.ToolTypesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolTypesUpdateResponse(rsp)
}

// ToolTypesDeletePreviewListWithResponse request returning *ToolTypesDeletePreviewListResponse
func (c *ClientWithResponses) ToolTypesDeletePreviewListWithResponse(ctx context.Context, id int, params *ToolTypesDeletePreviewListParams, reqEditors ...RequestEditorFn) (*ToolTypesDeletePreviewListResponse, error) {
	rsp, err := c.ToolTypesDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToolTypesDeletePreviewListResponse(rsp)
}

// UserContactInfosListWithResponse request returning *UserContactInfosListResponse
func (c *ClientWithResponses) UserContactInfosListWithResponse(ctx context.Context, params *UserContactInfosListParams, reqEditors ...RequestEditorFn) (*UserContactInfosListResponse, error) {
	rsp, err := c.UserContactInfosList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserContactInfosListResponse(rsp)
}

// UserContactInfosCreateWithBodyWithResponse request with arbitrary body returning *UserContactInfosCreateResponse
func (c *ClientWithResponses) UserContactInfosCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserContactInfosCreateResponse, error) {
	rsp, err := c.UserContactInfosCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserContactInfosCreateResponse(rsp)
}

func (c *ClientWithResponses) UserContactInfosCreateWithResponse(ctx context.Context, body UserContactInfosCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserContactInfosCreateResponse, error) {
	rsp, err := c.UserContactInfosCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserContactInfosCreateResponse(rsp)
}

// UserContactInfosDestroyWithResponse request returning *UserContactInfosDestroyResponse
func (c *ClientWithResponses) UserContactInfosDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*UserContactInfosDestroyResponse, error) {
	rsp, err := c.UserContactInfosDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserContactInfosDestroyResponse(rsp)
}

// UserContactInfosRetrieveWithResponse request returning *UserContactInfosRetrieveResponse
func (c *ClientWithResponses) UserContactInfosRetrieveWithResponse(ctx context.Context, id int, params *UserContactInfosRetrieveParams, reqEditors ...RequestEditorFn) (*UserContactInfosRetrieveResponse, error) {
	rsp, err := c.UserContactInfosRetrieve(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserContactInfosRetrieveResponse(rsp)
}

// UserContactInfosPartialUpdateWithBodyWithResponse request with arbitrary body returning *UserContactInfosPartialUpdateResponse
func (c *ClientWithResponses) UserContactInfosPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserContactInfosPartialUpdateResponse, error) {
	rsp, err := c.UserContactInfosPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserContactInfosPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) UserContactInfosPartialUpdateWithResponse(ctx context.Context, id int, body UserContactInfosPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserContactInfosPartialUpdateResponse, error) {
	rsp, err := c.UserContactInfosPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserContactInfosPartialUpdateResponse(rsp)
}

// UserContactInfosUpdateWithBodyWithResponse request with arbitrary body returning *UserContactInfosUpdateResponse
func (c *ClientWithResponses) UserContactInfosUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserContactInfosUpdateResponse, error) {
	rsp, err := c.UserContactInfosUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserContactInfosUpdateResponse(rsp)
}

func (c *ClientWithResponses) UserContactInfosUpdateWithResponse(ctx context.Context, id int, body UserContactInfosUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserContactInfosUpdateResponse, error) {
	rsp, err := c.UserContactInfosUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserContactInfosUpdateResponse(rsp)
}

// UserContactInfosDeletePreviewListWithResponse request returning *UserContactInfosDeletePreviewListResponse
func (c *ClientWithResponses) UserContactInfosDeletePreviewListWithResponse(ctx context.Context, id int, params *UserContactInfosDeletePreviewListParams, reqEditors ...RequestEditorFn) (*UserContactInfosDeletePreviewListResponse, error) {
	rsp, err := c.UserContactInfosDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserContactInfosDeletePreviewListResponse(rsp)
}

// UserProfileRetrieveWithResponse request returning *UserProfileRetrieveResponse
func (c *ClientWithResponses) UserProfileRetrieveWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserProfileRetrieveResponse, error) {
	rsp, err := c.UserProfileRetrieve(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserProfileRetrieveResponse(rsp)
}

// UsersListWithResponse request returning *UsersListResponse
func (c *ClientWithResponses) UsersListWithResponse(ctx context.Context, params *UsersListParams, reqEditors ...RequestEditorFn) (*UsersListResponse, error) {
	rsp, err := c.UsersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersListResponse(rsp)
}

// UsersCreateWithBodyWithResponse request with arbitrary body returning *UsersCreateResponse
func (c *ClientWithResponses) UsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error) {
	rsp, err := c.UsersCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersCreateResponse(rsp)
}

func (c *ClientWithResponses) UsersCreateWithResponse(ctx context.Context, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error) {
	rsp, err := c.UsersCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersCreateResponse(rsp)
}

// UsersDestroyWithResponse request returning *UsersDestroyResponse
func (c *ClientWithResponses) UsersDestroyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*UsersDestroyResponse, error) {
	rsp, err := c.UsersDestroy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersDestroyResponse(rsp)
}

// UsersRetrieveWithResponse request returning *UsersRetrieveResponse
func (c *ClientWithResponses) UsersRetrieveWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*UsersRetrieveResponse, error) {
	rsp, err := c.UsersRetrieve(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersRetrieveResponse(rsp)
}

// UsersPartialUpdateWithBodyWithResponse request with arbitrary body returning *UsersPartialUpdateResponse
func (c *ClientWithResponses) UsersPartialUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersPartialUpdateResponse, error) {
	rsp, err := c.UsersPartialUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersPartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) UsersPartialUpdateWithResponse(ctx context.Context, id int, body UsersPartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersPartialUpdateResponse, error) {
	rsp, err := c.UsersPartialUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersPartialUpdateResponse(rsp)
}

// UsersUpdateWithBodyWithResponse request with arbitrary body returning *UsersUpdateResponse
func (c *ClientWithResponses) UsersUpdateWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdateResponse, error) {
	rsp, err := c.UsersUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdateResponse(rsp)
}

func (c *ClientWithResponses) UsersUpdateWithResponse(ctx context.Context, id int, body UsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdateResponse, error) {
	rsp, err := c.UsersUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdateResponse(rsp)
}

// UsersDeletePreviewListWithResponse request returning *UsersDeletePreviewListResponse
func (c *ClientWithResponses) UsersDeletePreviewListWithResponse(ctx context.Context, id int, params *UsersDeletePreviewListParams, reqEditors ...RequestEditorFn) (*UsersDeletePreviewListResponse, error) {
	rsp, err := c.UsersDeletePreviewList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersDeletePreviewListResponse(rsp)
}

// ParseApiTokenAuthCreateResponse parses an HTTP response from a ApiTokenAuthCreateWithResponse call
func ParseApiTokenAuthCreateResponse(rsp *http.Response) (*ApiTokenAuthCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiTokenAuthCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConfigurationPermissionsListResponse parses an HTTP response from a ConfigurationPermissionsListWithResponse call
func ParseConfigurationPermissionsListResponse(rsp *http.Response) (*ConfigurationPermissionsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigurationPermissionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedConfigurationPermissionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConfigurationPermissionsRetrieveResponse parses an HTTP response from a ConfigurationPermissionsRetrieveWithResponse call
func ParseConfigurationPermissionsRetrieveResponse(rsp *http.Response) (*ConfigurationPermissionsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigurationPermissionsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigurationPermission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDevelopmentEnvironmentsListResponse parses an HTTP response from a DevelopmentEnvironmentsListWithResponse call
func ParseDevelopmentEnvironmentsListResponse(rsp *http.Response) (*DevelopmentEnvironmentsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevelopmentEnvironmentsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDevelopmentEnvironmentList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDevelopmentEnvironmentsCreateResponse parses an HTTP response from a DevelopmentEnvironmentsCreateWithResponse call
func ParseDevelopmentEnvironmentsCreateResponse(rsp *http.Response) (*DevelopmentEnvironmentsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevelopmentEnvironmentsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DevelopmentEnvironment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDevelopmentEnvironmentsDestroyResponse parses an HTTP response from a DevelopmentEnvironmentsDestroyWithResponse call
func ParseDevelopmentEnvironmentsDestroyResponse(rsp *http.Response) (*DevelopmentEnvironmentsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevelopmentEnvironmentsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDevelopmentEnvironmentsRetrieveResponse parses an HTTP response from a DevelopmentEnvironmentsRetrieveWithResponse call
func ParseDevelopmentEnvironmentsRetrieveResponse(rsp *http.Response) (*DevelopmentEnvironmentsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevelopmentEnvironmentsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevelopmentEnvironment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDevelopmentEnvironmentsPartialUpdateResponse parses an HTTP response from a DevelopmentEnvironmentsPartialUpdateWithResponse call
func ParseDevelopmentEnvironmentsPartialUpdateResponse(rsp *http.Response) (*DevelopmentEnvironmentsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevelopmentEnvironmentsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevelopmentEnvironment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDevelopmentEnvironmentsUpdateResponse parses an HTTP response from a DevelopmentEnvironmentsUpdateWithResponse call
func ParseDevelopmentEnvironmentsUpdateResponse(rsp *http.Response) (*DevelopmentEnvironmentsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevelopmentEnvironmentsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevelopmentEnvironment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDevelopmentEnvironmentsDeletePreviewListResponse parses an HTTP response from a DevelopmentEnvironmentsDeletePreviewListWithResponse call
func ParseDevelopmentEnvironmentsDeletePreviewListResponse(rsp *http.Response) (*DevelopmentEnvironmentsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DevelopmentEnvironmentsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDojoGroupMembersListResponse parses an HTTP response from a DojoGroupMembersListWithResponse call
func ParseDojoGroupMembersListResponse(rsp *http.Response) (*DojoGroupMembersListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupMembersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDojoGroupMemberList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDojoGroupMembersCreateResponse parses an HTTP response from a DojoGroupMembersCreateWithResponse call
func ParseDojoGroupMembersCreateResponse(rsp *http.Response) (*DojoGroupMembersCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupMembersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DojoGroupMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDojoGroupMembersDestroyResponse parses an HTTP response from a DojoGroupMembersDestroyWithResponse call
func ParseDojoGroupMembersDestroyResponse(rsp *http.Response) (*DojoGroupMembersDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupMembersDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDojoGroupMembersRetrieveResponse parses an HTTP response from a DojoGroupMembersRetrieveWithResponse call
func ParseDojoGroupMembersRetrieveResponse(rsp *http.Response) (*DojoGroupMembersRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupMembersRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DojoGroupMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDojoGroupMembersPartialUpdateResponse parses an HTTP response from a DojoGroupMembersPartialUpdateWithResponse call
func ParseDojoGroupMembersPartialUpdateResponse(rsp *http.Response) (*DojoGroupMembersPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupMembersPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DojoGroupMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDojoGroupMembersUpdateResponse parses an HTTP response from a DojoGroupMembersUpdateWithResponse call
func ParseDojoGroupMembersUpdateResponse(rsp *http.Response) (*DojoGroupMembersUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupMembersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DojoGroupMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDojoGroupMembersDeletePreviewListResponse parses an HTTP response from a DojoGroupMembersDeletePreviewListWithResponse call
func ParseDojoGroupMembersDeletePreviewListResponse(rsp *http.Response) (*DojoGroupMembersDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupMembersDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDojoGroupsListResponse parses an HTTP response from a DojoGroupsListWithResponse call
func ParseDojoGroupsListResponse(rsp *http.Response) (*DojoGroupsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDojoGroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDojoGroupsCreateResponse parses an HTTP response from a DojoGroupsCreateWithResponse call
func ParseDojoGroupsCreateResponse(rsp *http.Response) (*DojoGroupsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DojoGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDojoGroupsDestroyResponse parses an HTTP response from a DojoGroupsDestroyWithResponse call
func ParseDojoGroupsDestroyResponse(rsp *http.Response) (*DojoGroupsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDojoGroupsRetrieveResponse parses an HTTP response from a DojoGroupsRetrieveWithResponse call
func ParseDojoGroupsRetrieveResponse(rsp *http.Response) (*DojoGroupsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DojoGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDojoGroupsPartialUpdateResponse parses an HTTP response from a DojoGroupsPartialUpdateWithResponse call
func ParseDojoGroupsPartialUpdateResponse(rsp *http.Response) (*DojoGroupsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DojoGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDojoGroupsUpdateResponse parses an HTTP response from a DojoGroupsUpdateWithResponse call
func ParseDojoGroupsUpdateResponse(rsp *http.Response) (*DojoGroupsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DojoGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDojoGroupsDeletePreviewListResponse parses an HTTP response from a DojoGroupsDeletePreviewListWithResponse call
func ParseDojoGroupsDeletePreviewListResponse(rsp *http.Response) (*DojoGroupsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DojoGroupsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndpointMetaImportCreateResponse parses an HTTP response from a EndpointMetaImportCreateWithResponse call
func ParseEndpointMetaImportCreateResponse(rsp *http.Response) (*EndpointMetaImportCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointMetaImportCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EndpointMetaImporter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEndpointStatusListResponse parses an HTTP response from a EndpointStatusListWithResponse call
func ParseEndpointStatusListResponse(rsp *http.Response) (*EndpointStatusListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointStatusListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedEndpointStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndpointStatusCreateResponse parses an HTTP response from a EndpointStatusCreateWithResponse call
func ParseEndpointStatusCreateResponse(rsp *http.Response) (*EndpointStatusCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointStatusCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EndpointStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEndpointStatusDestroyResponse parses an HTTP response from a EndpointStatusDestroyWithResponse call
func ParseEndpointStatusDestroyResponse(rsp *http.Response) (*EndpointStatusDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointStatusDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEndpointStatusRetrieveResponse parses an HTTP response from a EndpointStatusRetrieveWithResponse call
func ParseEndpointStatusRetrieveResponse(rsp *http.Response) (*EndpointStatusRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointStatusRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndpointStatusPartialUpdateResponse parses an HTTP response from a EndpointStatusPartialUpdateWithResponse call
func ParseEndpointStatusPartialUpdateResponse(rsp *http.Response) (*EndpointStatusPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointStatusPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndpointStatusUpdateResponse parses an HTTP response from a EndpointStatusUpdateWithResponse call
func ParseEndpointStatusUpdateResponse(rsp *http.Response) (*EndpointStatusUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointStatusUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndpointStatusDeletePreviewListResponse parses an HTTP response from a EndpointStatusDeletePreviewListWithResponse call
func ParseEndpointStatusDeletePreviewListResponse(rsp *http.Response) (*EndpointStatusDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointStatusDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndpointsListResponse parses an HTTP response from a EndpointsListWithResponse call
func ParseEndpointsListResponse(rsp *http.Response) (*EndpointsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedEndpointList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndpointsCreateResponse parses an HTTP response from a EndpointsCreateWithResponse call
func ParseEndpointsCreateResponse(rsp *http.Response) (*EndpointsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Endpoint
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEndpointsDestroyResponse parses an HTTP response from a EndpointsDestroyWithResponse call
func ParseEndpointsDestroyResponse(rsp *http.Response) (*EndpointsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEndpointsRetrieveResponse parses an HTTP response from a EndpointsRetrieveWithResponse call
func ParseEndpointsRetrieveResponse(rsp *http.Response) (*EndpointsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoint
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndpointsPartialUpdateResponse parses an HTTP response from a EndpointsPartialUpdateWithResponse call
func ParseEndpointsPartialUpdateResponse(rsp *http.Response) (*EndpointsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoint
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndpointsUpdateResponse parses an HTTP response from a EndpointsUpdateWithResponse call
func ParseEndpointsUpdateResponse(rsp *http.Response) (*EndpointsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoint
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndpointsDeletePreviewListResponse parses an HTTP response from a EndpointsDeletePreviewListWithResponse call
func ParseEndpointsDeletePreviewListResponse(rsp *http.Response) (*EndpointsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndpointsGenerateReportCreateResponse parses an HTTP response from a EndpointsGenerateReportCreateWithResponse call
func ParseEndpointsGenerateReportCreateResponse(rsp *http.Response) (*EndpointsGenerateReportCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndpointsGenerateReportCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportGenerate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementPresetsListResponse parses an HTTP response from a EngagementPresetsListWithResponse call
func ParseEngagementPresetsListResponse(rsp *http.Response) (*EngagementPresetsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementPresetsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedEngagementPresetsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementPresetsCreateResponse parses an HTTP response from a EngagementPresetsCreateWithResponse call
func ParseEngagementPresetsCreateResponse(rsp *http.Response) (*EngagementPresetsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementPresetsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EngagementPresets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEngagementPresetsDestroyResponse parses an HTTP response from a EngagementPresetsDestroyWithResponse call
func ParseEngagementPresetsDestroyResponse(rsp *http.Response) (*EngagementPresetsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementPresetsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEngagementPresetsRetrieveResponse parses an HTTP response from a EngagementPresetsRetrieveWithResponse call
func ParseEngagementPresetsRetrieveResponse(rsp *http.Response) (*EngagementPresetsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementPresetsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementPresets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementPresetsPartialUpdateResponse parses an HTTP response from a EngagementPresetsPartialUpdateWithResponse call
func ParseEngagementPresetsPartialUpdateResponse(rsp *http.Response) (*EngagementPresetsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementPresetsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementPresets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementPresetsUpdateResponse parses an HTTP response from a EngagementPresetsUpdateWithResponse call
func ParseEngagementPresetsUpdateResponse(rsp *http.Response) (*EngagementPresetsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementPresetsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementPresets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementPresetsDeletePreviewListResponse parses an HTTP response from a EngagementPresetsDeletePreviewListWithResponse call
func ParseEngagementPresetsDeletePreviewListResponse(rsp *http.Response) (*EngagementPresetsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementPresetsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementsListResponse parses an HTTP response from a EngagementsListWithResponse call
func ParseEngagementsListResponse(rsp *http.Response) (*EngagementsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedEngagementList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementsCreateResponse parses an HTTP response from a EngagementsCreateWithResponse call
func ParseEngagementsCreateResponse(rsp *http.Response) (*EngagementsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Engagement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEngagementsDestroyResponse parses an HTTP response from a EngagementsDestroyWithResponse call
func ParseEngagementsDestroyResponse(rsp *http.Response) (*EngagementsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEngagementsRetrieveResponse parses an HTTP response from a EngagementsRetrieveWithResponse call
func ParseEngagementsRetrieveResponse(rsp *http.Response) (*EngagementsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Engagement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementsPartialUpdateResponse parses an HTTP response from a EngagementsPartialUpdateWithResponse call
func ParseEngagementsPartialUpdateResponse(rsp *http.Response) (*EngagementsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Engagement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementsUpdateResponse parses an HTTP response from a EngagementsUpdateWithResponse call
func ParseEngagementsUpdateResponse(rsp *http.Response) (*EngagementsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Engagement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementsAcceptRisksCreateResponse parses an HTTP response from a EngagementsAcceptRisksCreateWithResponse call
func ParseEngagementsAcceptRisksCreateResponse(rsp *http.Response) (*EngagementsAcceptRisksCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsAcceptRisksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []RiskAcceptance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEngagementsCloseCreateResponse parses an HTTP response from a EngagementsCloseCreateWithResponse call
func ParseEngagementsCloseCreateResponse(rsp *http.Response) (*EngagementsCloseCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsCloseCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEngagementsDeletePreviewListResponse parses an HTTP response from a EngagementsDeletePreviewListWithResponse call
func ParseEngagementsDeletePreviewListResponse(rsp *http.Response) (*EngagementsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementsFilesRetrieveResponse parses an HTTP response from a EngagementsFilesRetrieveWithResponse call
func ParseEngagementsFilesRetrieveResponse(rsp *http.Response) (*EngagementsFilesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsFilesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementToFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementsFilesCreateResponse parses an HTTP response from a EngagementsFilesCreateWithResponse call
func ParseEngagementsFilesCreateResponse(rsp *http.Response) (*EngagementsFilesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsFilesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest File
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEngagementsGenerateReportCreateResponse parses an HTTP response from a EngagementsGenerateReportCreateWithResponse call
func ParseEngagementsGenerateReportCreateResponse(rsp *http.Response) (*EngagementsGenerateReportCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsGenerateReportCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportGenerate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementsNotesRetrieveResponse parses an HTTP response from a EngagementsNotesRetrieveWithResponse call
func ParseEngagementsNotesRetrieveResponse(rsp *http.Response) (*EngagementsNotesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsNotesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EngagementToNotes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEngagementsNotesCreateResponse parses an HTTP response from a EngagementsNotesCreateWithResponse call
func ParseEngagementsNotesCreateResponse(rsp *http.Response) (*EngagementsNotesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsNotesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Note
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEngagementsReopenCreateResponse parses an HTTP response from a EngagementsReopenCreateWithResponse call
func ParseEngagementsReopenCreateResponse(rsp *http.Response) (*EngagementsReopenCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngagementsReopenCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindingTemplatesListResponse parses an HTTP response from a FindingTemplatesListWithResponse call
func ParseFindingTemplatesListResponse(rsp *http.Response) (*FindingTemplatesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingTemplatesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedFindingTemplateList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingTemplatesCreateResponse parses an HTTP response from a FindingTemplatesCreateWithResponse call
func ParseFindingTemplatesCreateResponse(rsp *http.Response) (*FindingTemplatesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingTemplatesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FindingTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseFindingTemplatesDestroyResponse parses an HTTP response from a FindingTemplatesDestroyWithResponse call
func ParseFindingTemplatesDestroyResponse(rsp *http.Response) (*FindingTemplatesDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingTemplatesDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindingTemplatesRetrieveResponse parses an HTTP response from a FindingTemplatesRetrieveWithResponse call
func ParseFindingTemplatesRetrieveResponse(rsp *http.Response) (*FindingTemplatesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingTemplatesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindingTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingTemplatesPartialUpdateResponse parses an HTTP response from a FindingTemplatesPartialUpdateWithResponse call
func ParseFindingTemplatesPartialUpdateResponse(rsp *http.Response) (*FindingTemplatesPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingTemplatesPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindingTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingTemplatesUpdateResponse parses an HTTP response from a FindingTemplatesUpdateWithResponse call
func ParseFindingTemplatesUpdateResponse(rsp *http.Response) (*FindingTemplatesUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingTemplatesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindingTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingTemplatesDeletePreviewListResponse parses an HTTP response from a FindingTemplatesDeletePreviewListWithResponse call
func ParseFindingTemplatesDeletePreviewListResponse(rsp *http.Response) (*FindingTemplatesDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingTemplatesDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsListResponse parses an HTTP response from a FindingsListWithResponse call
func ParseFindingsListResponse(rsp *http.Response) (*FindingsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedFindingList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsCreateResponse parses an HTTP response from a FindingsCreateWithResponse call
func ParseFindingsCreateResponse(rsp *http.Response) (*FindingsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FindingCreate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseFindingsAcceptRisksCreateResponse parses an HTTP response from a FindingsAcceptRisksCreateWithResponse call
func ParseFindingsAcceptRisksCreateResponse(rsp *http.Response) (*FindingsAcceptRisksCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsAcceptRisksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PaginatedRiskAcceptanceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseFindingsGenerateReportCreateResponse parses an HTTP response from a FindingsGenerateReportCreateWithResponse call
func ParseFindingsGenerateReportCreateResponse(rsp *http.Response) (*FindingsGenerateReportCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsGenerateReportCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportGenerate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsDestroyResponse parses an HTTP response from a FindingsDestroyWithResponse call
func ParseFindingsDestroyResponse(rsp *http.Response) (*FindingsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindingsRetrieveResponse parses an HTTP response from a FindingsRetrieveWithResponse call
func ParseFindingsRetrieveResponse(rsp *http.Response) (*FindingsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Finding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsPartialUpdateResponse parses an HTTP response from a FindingsPartialUpdateWithResponse call
func ParseFindingsPartialUpdateResponse(rsp *http.Response) (*FindingsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Finding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsUpdateResponse parses an HTTP response from a FindingsUpdateWithResponse call
func ParseFindingsUpdateResponse(rsp *http.Response) (*FindingsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Finding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsCloseCreateResponse parses an HTTP response from a FindingsCloseCreateWithResponse call
func ParseFindingsCloseCreateResponse(rsp *http.Response) (*FindingsCloseCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsCloseCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindingClose
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsDeletePreviewListResponse parses an HTTP response from a FindingsDeletePreviewListWithResponse call
func ParseFindingsDeletePreviewListResponse(rsp *http.Response) (*FindingsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsDuplicateListResponse parses an HTTP response from a FindingsDuplicateListWithResponse call
func ParseFindingsDuplicateListResponse(rsp *http.Response) (*FindingsDuplicateListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsDuplicateListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Finding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsDuplicateResetCreateResponse parses an HTTP response from a FindingsDuplicateResetCreateWithResponse call
func ParseFindingsDuplicateResetCreateResponse(rsp *http.Response) (*FindingsDuplicateResetCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsDuplicateResetCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindingsFilesRetrieveResponse parses an HTTP response from a FindingsFilesRetrieveWithResponse call
func ParseFindingsFilesRetrieveResponse(rsp *http.Response) (*FindingsFilesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsFilesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindingToFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsFilesCreateResponse parses an HTTP response from a FindingsFilesCreateWithResponse call
func ParseFindingsFilesCreateResponse(rsp *http.Response) (*FindingsFilesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsFilesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest File
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseFindingsMetadataDestroyResponse parses an HTTP response from a FindingsMetadataDestroyWithResponse call
func ParseFindingsMetadataDestroyResponse(rsp *http.Response) (*FindingsMetadataDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsMetadataDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindingsMetadataListResponse parses an HTTP response from a FindingsMetadataListWithResponse call
func ParseFindingsMetadataListResponse(rsp *http.Response) (*FindingsMetadataListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsMetadataListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FindingMeta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsMetadataCreateResponse parses an HTTP response from a FindingsMetadataCreateWithResponse call
func ParseFindingsMetadataCreateResponse(rsp *http.Response) (*FindingsMetadataCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsMetadataCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindingMeta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsMetadataUpdateResponse parses an HTTP response from a FindingsMetadataUpdateWithResponse call
func ParseFindingsMetadataUpdateResponse(rsp *http.Response) (*FindingsMetadataUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsMetadataUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindingMeta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsNotesRetrieveResponse parses an HTTP response from a FindingsNotesRetrieveWithResponse call
func ParseFindingsNotesRetrieveResponse(rsp *http.Response) (*FindingsNotesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsNotesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindingToNotes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsNotesCreateResponse parses an HTTP response from a FindingsNotesCreateWithResponse call
func ParseFindingsNotesCreateResponse(rsp *http.Response) (*FindingsNotesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsNotesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Note
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseFindingsOriginalCreateResponse parses an HTTP response from a FindingsOriginalCreateWithResponse call
func ParseFindingsOriginalCreateResponse(rsp *http.Response) (*FindingsOriginalCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsOriginalCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindingsRemoveNotePartialUpdateResponse parses an HTTP response from a FindingsRemoveNotePartialUpdateWithResponse call
func ParseFindingsRemoveNotePartialUpdateResponse(rsp *http.Response) (*FindingsRemoveNotePartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsRemoveNotePartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindingsRemoveTagsPartialUpdateResponse parses an HTTP response from a FindingsRemoveTagsPartialUpdateWithResponse call
func ParseFindingsRemoveTagsPartialUpdateResponse(rsp *http.Response) (*FindingsRemoveTagsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsRemoveTagsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindingsRemoveTagsUpdateResponse parses an HTTP response from a FindingsRemoveTagsUpdateWithResponse call
func ParseFindingsRemoveTagsUpdateResponse(rsp *http.Response) (*FindingsRemoveTagsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsRemoveTagsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindingsRequestResponseRetrieveResponse parses an HTTP response from a FindingsRequestResponseRetrieveWithResponse call
func ParseFindingsRequestResponseRetrieveResponse(rsp *http.Response) (*FindingsRequestResponseRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsRequestResponseRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BurpRawRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsRequestResponseCreateResponse parses an HTTP response from a FindingsRequestResponseCreateWithResponse call
func ParseFindingsRequestResponseCreateResponse(rsp *http.Response) (*FindingsRequestResponseCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsRequestResponseCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BurpRawRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseFindingsTagsRetrieveResponse parses an HTTP response from a FindingsTagsRetrieveWithResponse call
func ParseFindingsTagsRetrieveResponse(rsp *http.Response) (*FindingsTagsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsTagsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindingsTagsCreateResponse parses an HTTP response from a FindingsTagsCreateWithResponse call
func ParseFindingsTagsCreateResponse(rsp *http.Response) (*FindingsTagsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindingsTagsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGlobalRolesListResponse parses an HTTP response from a GlobalRolesListWithResponse call
func ParseGlobalRolesListResponse(rsp *http.Response) (*GlobalRolesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalRolesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedGlobalRoleList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGlobalRolesCreateResponse parses an HTTP response from a GlobalRolesCreateWithResponse call
func ParseGlobalRolesCreateResponse(rsp *http.Response) (*GlobalRolesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalRolesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GlobalRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGlobalRolesDestroyResponse parses an HTTP response from a GlobalRolesDestroyWithResponse call
func ParseGlobalRolesDestroyResponse(rsp *http.Response) (*GlobalRolesDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalRolesDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGlobalRolesRetrieveResponse parses an HTTP response from a GlobalRolesRetrieveWithResponse call
func ParseGlobalRolesRetrieveResponse(rsp *http.Response) (*GlobalRolesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalRolesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGlobalRolesPartialUpdateResponse parses an HTTP response from a GlobalRolesPartialUpdateWithResponse call
func ParseGlobalRolesPartialUpdateResponse(rsp *http.Response) (*GlobalRolesPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalRolesPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGlobalRolesUpdateResponse parses an HTTP response from a GlobalRolesUpdateWithResponse call
func ParseGlobalRolesUpdateResponse(rsp *http.Response) (*GlobalRolesUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalRolesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGlobalRolesDeletePreviewListResponse parses an HTTP response from a GlobalRolesDeletePreviewListWithResponse call
func ParseGlobalRolesDeletePreviewListResponse(rsp *http.Response) (*GlobalRolesDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalRolesDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseImportLanguagesCreateResponse parses an HTTP response from a ImportLanguagesCreateWithResponse call
func ParseImportLanguagesCreateResponse(rsp *http.Response) (*ImportLanguagesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportLanguagesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ImportLanguages
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseImportScanCreateResponse parses an HTTP response from a ImportScanCreateWithResponse call
func ParseImportScanCreateResponse(rsp *http.Response) (*ImportScanCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportScanCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ImportScan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseJiraConfigurationsListResponse parses an HTTP response from a JiraConfigurationsListWithResponse call
func ParseJiraConfigurationsListResponse(rsp *http.Response) (*JiraConfigurationsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraConfigurationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedJIRAInstanceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraConfigurationsCreateResponse parses an HTTP response from a JiraConfigurationsCreateWithResponse call
func ParseJiraConfigurationsCreateResponse(rsp *http.Response) (*JiraConfigurationsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraConfigurationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest JIRAInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseJiraConfigurationsDestroyResponse parses an HTTP response from a JiraConfigurationsDestroyWithResponse call
func ParseJiraConfigurationsDestroyResponse(rsp *http.Response) (*JiraConfigurationsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraConfigurationsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseJiraConfigurationsRetrieveResponse parses an HTTP response from a JiraConfigurationsRetrieveWithResponse call
func ParseJiraConfigurationsRetrieveResponse(rsp *http.Response) (*JiraConfigurationsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraConfigurationsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraConfigurationsPartialUpdateResponse parses an HTTP response from a JiraConfigurationsPartialUpdateWithResponse call
func ParseJiraConfigurationsPartialUpdateResponse(rsp *http.Response) (*JiraConfigurationsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraConfigurationsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraConfigurationsUpdateResponse parses an HTTP response from a JiraConfigurationsUpdateWithResponse call
func ParseJiraConfigurationsUpdateResponse(rsp *http.Response) (*JiraConfigurationsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraConfigurationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraConfigurationsDeletePreviewListResponse parses an HTTP response from a JiraConfigurationsDeletePreviewListWithResponse call
func ParseJiraConfigurationsDeletePreviewListResponse(rsp *http.Response) (*JiraConfigurationsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraConfigurationsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraFindingMappingsListResponse parses an HTTP response from a JiraFindingMappingsListWithResponse call
func ParseJiraFindingMappingsListResponse(rsp *http.Response) (*JiraFindingMappingsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraFindingMappingsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedJIRAIssueList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraFindingMappingsCreateResponse parses an HTTP response from a JiraFindingMappingsCreateWithResponse call
func ParseJiraFindingMappingsCreateResponse(rsp *http.Response) (*JiraFindingMappingsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraFindingMappingsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest JIRAIssue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseJiraFindingMappingsDestroyResponse parses an HTTP response from a JiraFindingMappingsDestroyWithResponse call
func ParseJiraFindingMappingsDestroyResponse(rsp *http.Response) (*JiraFindingMappingsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraFindingMappingsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseJiraFindingMappingsRetrieveResponse parses an HTTP response from a JiraFindingMappingsRetrieveWithResponse call
func ParseJiraFindingMappingsRetrieveResponse(rsp *http.Response) (*JiraFindingMappingsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraFindingMappingsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAIssue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraFindingMappingsPartialUpdateResponse parses an HTTP response from a JiraFindingMappingsPartialUpdateWithResponse call
func ParseJiraFindingMappingsPartialUpdateResponse(rsp *http.Response) (*JiraFindingMappingsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraFindingMappingsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAIssue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraFindingMappingsUpdateResponse parses an HTTP response from a JiraFindingMappingsUpdateWithResponse call
func ParseJiraFindingMappingsUpdateResponse(rsp *http.Response) (*JiraFindingMappingsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraFindingMappingsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAIssue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraFindingMappingsDeletePreviewListResponse parses an HTTP response from a JiraFindingMappingsDeletePreviewListWithResponse call
func ParseJiraFindingMappingsDeletePreviewListResponse(rsp *http.Response) (*JiraFindingMappingsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraFindingMappingsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraInstancesListResponse parses an HTTP response from a JiraInstancesListWithResponse call
func ParseJiraInstancesListResponse(rsp *http.Response) (*JiraInstancesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraInstancesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedJIRAInstanceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraInstancesCreateResponse parses an HTTP response from a JiraInstancesCreateWithResponse call
func ParseJiraInstancesCreateResponse(rsp *http.Response) (*JiraInstancesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraInstancesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest JIRAInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseJiraInstancesDestroyResponse parses an HTTP response from a JiraInstancesDestroyWithResponse call
func ParseJiraInstancesDestroyResponse(rsp *http.Response) (*JiraInstancesDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraInstancesDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseJiraInstancesRetrieveResponse parses an HTTP response from a JiraInstancesRetrieveWithResponse call
func ParseJiraInstancesRetrieveResponse(rsp *http.Response) (*JiraInstancesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraInstancesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraInstancesPartialUpdateResponse parses an HTTP response from a JiraInstancesPartialUpdateWithResponse call
func ParseJiraInstancesPartialUpdateResponse(rsp *http.Response) (*JiraInstancesPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraInstancesPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraInstancesUpdateResponse parses an HTTP response from a JiraInstancesUpdateWithResponse call
func ParseJiraInstancesUpdateResponse(rsp *http.Response) (*JiraInstancesUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraInstancesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraInstancesDeletePreviewListResponse parses an HTTP response from a JiraInstancesDeletePreviewListWithResponse call
func ParseJiraInstancesDeletePreviewListResponse(rsp *http.Response) (*JiraInstancesDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraInstancesDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraProductConfigurationsListResponse parses an HTTP response from a JiraProductConfigurationsListWithResponse call
func ParseJiraProductConfigurationsListResponse(rsp *http.Response) (*JiraProductConfigurationsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProductConfigurationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedJIRAProjectList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraProductConfigurationsCreateResponse parses an HTTP response from a JiraProductConfigurationsCreateWithResponse call
func ParseJiraProductConfigurationsCreateResponse(rsp *http.Response) (*JiraProductConfigurationsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProductConfigurationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest JIRAProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseJiraProductConfigurationsDestroyResponse parses an HTTP response from a JiraProductConfigurationsDestroyWithResponse call
func ParseJiraProductConfigurationsDestroyResponse(rsp *http.Response) (*JiraProductConfigurationsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProductConfigurationsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseJiraProductConfigurationsRetrieveResponse parses an HTTP response from a JiraProductConfigurationsRetrieveWithResponse call
func ParseJiraProductConfigurationsRetrieveResponse(rsp *http.Response) (*JiraProductConfigurationsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProductConfigurationsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraProductConfigurationsPartialUpdateResponse parses an HTTP response from a JiraProductConfigurationsPartialUpdateWithResponse call
func ParseJiraProductConfigurationsPartialUpdateResponse(rsp *http.Response) (*JiraProductConfigurationsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProductConfigurationsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraProductConfigurationsUpdateResponse parses an HTTP response from a JiraProductConfigurationsUpdateWithResponse call
func ParseJiraProductConfigurationsUpdateResponse(rsp *http.Response) (*JiraProductConfigurationsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProductConfigurationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraProductConfigurationsDeletePreviewListResponse parses an HTTP response from a JiraProductConfigurationsDeletePreviewListWithResponse call
func ParseJiraProductConfigurationsDeletePreviewListResponse(rsp *http.Response) (*JiraProductConfigurationsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProductConfigurationsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraProjectsListResponse parses an HTTP response from a JiraProjectsListWithResponse call
func ParseJiraProjectsListResponse(rsp *http.Response) (*JiraProjectsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProjectsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedJIRAProjectList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraProjectsCreateResponse parses an HTTP response from a JiraProjectsCreateWithResponse call
func ParseJiraProjectsCreateResponse(rsp *http.Response) (*JiraProjectsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProjectsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest JIRAProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseJiraProjectsDestroyResponse parses an HTTP response from a JiraProjectsDestroyWithResponse call
func ParseJiraProjectsDestroyResponse(rsp *http.Response) (*JiraProjectsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProjectsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseJiraProjectsRetrieveResponse parses an HTTP response from a JiraProjectsRetrieveWithResponse call
func ParseJiraProjectsRetrieveResponse(rsp *http.Response) (*JiraProjectsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProjectsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraProjectsPartialUpdateResponse parses an HTTP response from a JiraProjectsPartialUpdateWithResponse call
func ParseJiraProjectsPartialUpdateResponse(rsp *http.Response) (*JiraProjectsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProjectsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraProjectsUpdateResponse parses an HTTP response from a JiraProjectsUpdateWithResponse call
func ParseJiraProjectsUpdateResponse(rsp *http.Response) (*JiraProjectsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProjectsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JIRAProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJiraProjectsDeletePreviewListResponse parses an HTTP response from a JiraProjectsDeletePreviewListWithResponse call
func ParseJiraProjectsDeletePreviewListResponse(rsp *http.Response) (*JiraProjectsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JiraProjectsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLanguageTypesListResponse parses an HTTP response from a LanguageTypesListWithResponse call
func ParseLanguageTypesListResponse(rsp *http.Response) (*LanguageTypesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguageTypesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedLanguageTypeList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLanguageTypesCreateResponse parses an HTTP response from a LanguageTypesCreateWithResponse call
func ParseLanguageTypesCreateResponse(rsp *http.Response) (*LanguageTypesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguageTypesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LanguageType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseLanguageTypesDestroyResponse parses an HTTP response from a LanguageTypesDestroyWithResponse call
func ParseLanguageTypesDestroyResponse(rsp *http.Response) (*LanguageTypesDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguageTypesDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLanguageTypesRetrieveResponse parses an HTTP response from a LanguageTypesRetrieveWithResponse call
func ParseLanguageTypesRetrieveResponse(rsp *http.Response) (*LanguageTypesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguageTypesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LanguageType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLanguageTypesPartialUpdateResponse parses an HTTP response from a LanguageTypesPartialUpdateWithResponse call
func ParseLanguageTypesPartialUpdateResponse(rsp *http.Response) (*LanguageTypesPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguageTypesPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LanguageType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLanguageTypesUpdateResponse parses an HTTP response from a LanguageTypesUpdateWithResponse call
func ParseLanguageTypesUpdateResponse(rsp *http.Response) (*LanguageTypesUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguageTypesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LanguageType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLanguageTypesDeletePreviewListResponse parses an HTTP response from a LanguageTypesDeletePreviewListWithResponse call
func ParseLanguageTypesDeletePreviewListResponse(rsp *http.Response) (*LanguageTypesDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguageTypesDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLanguagesListResponse parses an HTTP response from a LanguagesListWithResponse call
func ParseLanguagesListResponse(rsp *http.Response) (*LanguagesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguagesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedLanguageList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLanguagesCreateResponse parses an HTTP response from a LanguagesCreateWithResponse call
func ParseLanguagesCreateResponse(rsp *http.Response) (*LanguagesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguagesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Language
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseLanguagesDestroyResponse parses an HTTP response from a LanguagesDestroyWithResponse call
func ParseLanguagesDestroyResponse(rsp *http.Response) (*LanguagesDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguagesDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLanguagesRetrieveResponse parses an HTTP response from a LanguagesRetrieveWithResponse call
func ParseLanguagesRetrieveResponse(rsp *http.Response) (*LanguagesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguagesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Language
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLanguagesPartialUpdateResponse parses an HTTP response from a LanguagesPartialUpdateWithResponse call
func ParseLanguagesPartialUpdateResponse(rsp *http.Response) (*LanguagesPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguagesPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Language
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLanguagesUpdateResponse parses an HTTP response from a LanguagesUpdateWithResponse call
func ParseLanguagesUpdateResponse(rsp *http.Response) (*LanguagesUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguagesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Language
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLanguagesDeletePreviewListResponse parses an HTTP response from a LanguagesDeletePreviewListWithResponse call
func ParseLanguagesDeletePreviewListResponse(rsp *http.Response) (*LanguagesDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LanguagesDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMetadataListResponse parses an HTTP response from a MetadataListWithResponse call
func ParseMetadataListResponse(rsp *http.Response) (*MetadataListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedMetaList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMetadataCreateResponse parses an HTTP response from a MetadataCreateWithResponse call
func ParseMetadataCreateResponse(rsp *http.Response) (*MetadataCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Meta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseMetadataDestroyResponse parses an HTTP response from a MetadataDestroyWithResponse call
func ParseMetadataDestroyResponse(rsp *http.Response) (*MetadataDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMetadataRetrieveResponse parses an HTTP response from a MetadataRetrieveWithResponse call
func ParseMetadataRetrieveResponse(rsp *http.Response) (*MetadataRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Meta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMetadataPartialUpdateResponse parses an HTTP response from a MetadataPartialUpdateWithResponse call
func ParseMetadataPartialUpdateResponse(rsp *http.Response) (*MetadataPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Meta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMetadataUpdateResponse parses an HTTP response from a MetadataUpdateWithResponse call
func ParseMetadataUpdateResponse(rsp *http.Response) (*MetadataUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Meta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMetadataDeletePreviewListResponse parses an HTTP response from a MetadataDeletePreviewListWithResponse call
func ParseMetadataDeletePreviewListResponse(rsp *http.Response) (*MetadataDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworkLocationsListResponse parses an HTTP response from a NetworkLocationsListWithResponse call
func ParseNetworkLocationsListResponse(rsp *http.Response) (*NetworkLocationsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworkLocationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedNetworkLocationsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworkLocationsCreateResponse parses an HTTP response from a NetworkLocationsCreateWithResponse call
func ParseNetworkLocationsCreateResponse(rsp *http.Response) (*NetworkLocationsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworkLocationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NetworkLocations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseNetworkLocationsDestroyResponse parses an HTTP response from a NetworkLocationsDestroyWithResponse call
func ParseNetworkLocationsDestroyResponse(rsp *http.Response) (*NetworkLocationsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworkLocationsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNetworkLocationsRetrieveResponse parses an HTTP response from a NetworkLocationsRetrieveWithResponse call
func ParseNetworkLocationsRetrieveResponse(rsp *http.Response) (*NetworkLocationsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworkLocationsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkLocations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworkLocationsPartialUpdateResponse parses an HTTP response from a NetworkLocationsPartialUpdateWithResponse call
func ParseNetworkLocationsPartialUpdateResponse(rsp *http.Response) (*NetworkLocationsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworkLocationsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkLocations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworkLocationsUpdateResponse parses an HTTP response from a NetworkLocationsUpdateWithResponse call
func ParseNetworkLocationsUpdateResponse(rsp *http.Response) (*NetworkLocationsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworkLocationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkLocations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworkLocationsDeletePreviewListResponse parses an HTTP response from a NetworkLocationsDeletePreviewListWithResponse call
func ParseNetworkLocationsDeletePreviewListResponse(rsp *http.Response) (*NetworkLocationsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworkLocationsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNoteTypeListResponse parses an HTTP response from a NoteTypeListWithResponse call
func ParseNoteTypeListResponse(rsp *http.Response) (*NoteTypeListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NoteTypeListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedNoteTypeList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNoteTypeCreateResponse parses an HTTP response from a NoteTypeCreateWithResponse call
func ParseNoteTypeCreateResponse(rsp *http.Response) (*NoteTypeCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NoteTypeCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NoteType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseNoteTypeDestroyResponse parses an HTTP response from a NoteTypeDestroyWithResponse call
func ParseNoteTypeDestroyResponse(rsp *http.Response) (*NoteTypeDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NoteTypeDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNoteTypeRetrieveResponse parses an HTTP response from a NoteTypeRetrieveWithResponse call
func ParseNoteTypeRetrieveResponse(rsp *http.Response) (*NoteTypeRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NoteTypeRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NoteType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNoteTypePartialUpdateResponse parses an HTTP response from a NoteTypePartialUpdateWithResponse call
func ParseNoteTypePartialUpdateResponse(rsp *http.Response) (*NoteTypePartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NoteTypePartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NoteType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNoteTypeUpdateResponse parses an HTTP response from a NoteTypeUpdateWithResponse call
func ParseNoteTypeUpdateResponse(rsp *http.Response) (*NoteTypeUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NoteTypeUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NoteType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNoteTypeDeletePreviewListResponse parses an HTTP response from a NoteTypeDeletePreviewListWithResponse call
func ParseNoteTypeDeletePreviewListResponse(rsp *http.Response) (*NoteTypeDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NoteTypeDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotesListResponse parses an HTTP response from a NotesListWithResponse call
func ParseNotesListResponse(rsp *http.Response) (*NotesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedNoteList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotesRetrieveResponse parses an HTTP response from a NotesRetrieveWithResponse call
func ParseNotesRetrieveResponse(rsp *http.Response) (*NotesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Note
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotesPartialUpdateResponse parses an HTTP response from a NotesPartialUpdateWithResponse call
func ParseNotesPartialUpdateResponse(rsp *http.Response) (*NotesPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotesPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Note
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotesUpdateResponse parses an HTTP response from a NotesUpdateWithResponse call
func ParseNotesUpdateResponse(rsp *http.Response) (*NotesUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Note
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotificationsListResponse parses an HTTP response from a NotificationsListWithResponse call
func ParseNotificationsListResponse(rsp *http.Response) (*NotificationsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedNotificationsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotificationsCreateResponse parses an HTTP response from a NotificationsCreateWithResponse call
func ParseNotificationsCreateResponse(rsp *http.Response) (*NotificationsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Notifications
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseNotificationsDestroyResponse parses an HTTP response from a NotificationsDestroyWithResponse call
func ParseNotificationsDestroyResponse(rsp *http.Response) (*NotificationsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNotificationsRetrieveResponse parses an HTTP response from a NotificationsRetrieveWithResponse call
func ParseNotificationsRetrieveResponse(rsp *http.Response) (*NotificationsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notifications
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotificationsPartialUpdateResponse parses an HTTP response from a NotificationsPartialUpdateWithResponse call
func ParseNotificationsPartialUpdateResponse(rsp *http.Response) (*NotificationsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notifications
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotificationsUpdateResponse parses an HTTP response from a NotificationsUpdateWithResponse call
func ParseNotificationsUpdateResponse(rsp *http.Response) (*NotificationsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notifications
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotificationsDeletePreviewListResponse parses an HTTP response from a NotificationsDeletePreviewListWithResponse call
func ParseNotificationsDeletePreviewListResponse(rsp *http.Response) (*NotificationsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOa3SchemaRetrieveResponse parses an HTTP response from a Oa3SchemaRetrieveWithResponse call
func ParseOa3SchemaRetrieveResponse(rsp *http.Response) (*Oa3SchemaRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oa3SchemaRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/vnd.oai.openapi+json) unsupported

	}

	return response, nil
}

// ParseProductApiScanConfigurationsListResponse parses an HTTP response from a ProductApiScanConfigurationsListWithResponse call
func ParseProductApiScanConfigurationsListResponse(rsp *http.Response) (*ProductApiScanConfigurationsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductApiScanConfigurationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedProductAPIScanConfigurationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductApiScanConfigurationsCreateResponse parses an HTTP response from a ProductApiScanConfigurationsCreateWithResponse call
func ParseProductApiScanConfigurationsCreateResponse(rsp *http.Response) (*ProductApiScanConfigurationsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductApiScanConfigurationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProductAPIScanConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseProductApiScanConfigurationsDestroyResponse parses an HTTP response from a ProductApiScanConfigurationsDestroyWithResponse call
func ParseProductApiScanConfigurationsDestroyResponse(rsp *http.Response) (*ProductApiScanConfigurationsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductApiScanConfigurationsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProductApiScanConfigurationsRetrieveResponse parses an HTTP response from a ProductApiScanConfigurationsRetrieveWithResponse call
func ParseProductApiScanConfigurationsRetrieveResponse(rsp *http.Response) (*ProductApiScanConfigurationsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductApiScanConfigurationsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductAPIScanConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductApiScanConfigurationsPartialUpdateResponse parses an HTTP response from a ProductApiScanConfigurationsPartialUpdateWithResponse call
func ParseProductApiScanConfigurationsPartialUpdateResponse(rsp *http.Response) (*ProductApiScanConfigurationsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductApiScanConfigurationsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductAPIScanConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductApiScanConfigurationsUpdateResponse parses an HTTP response from a ProductApiScanConfigurationsUpdateWithResponse call
func ParseProductApiScanConfigurationsUpdateResponse(rsp *http.Response) (*ProductApiScanConfigurationsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductApiScanConfigurationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductAPIScanConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductApiScanConfigurationsDeletePreviewListResponse parses an HTTP response from a ProductApiScanConfigurationsDeletePreviewListWithResponse call
func ParseProductApiScanConfigurationsDeletePreviewListResponse(rsp *http.Response) (*ProductApiScanConfigurationsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductApiScanConfigurationsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductGroupsListResponse parses an HTTP response from a ProductGroupsListWithResponse call
func ParseProductGroupsListResponse(rsp *http.Response) (*ProductGroupsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductGroupsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedProductGroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductGroupsCreateResponse parses an HTTP response from a ProductGroupsCreateWithResponse call
func ParseProductGroupsCreateResponse(rsp *http.Response) (*ProductGroupsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductGroupsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProductGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseProductGroupsDestroyResponse parses an HTTP response from a ProductGroupsDestroyWithResponse call
func ParseProductGroupsDestroyResponse(rsp *http.Response) (*ProductGroupsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductGroupsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProductGroupsRetrieveResponse parses an HTTP response from a ProductGroupsRetrieveWithResponse call
func ParseProductGroupsRetrieveResponse(rsp *http.Response) (*ProductGroupsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductGroupsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductGroupsPartialUpdateResponse parses an HTTP response from a ProductGroupsPartialUpdateWithResponse call
func ParseProductGroupsPartialUpdateResponse(rsp *http.Response) (*ProductGroupsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductGroupsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProductGroupsUpdateResponse parses an HTTP response from a ProductGroupsUpdateWithResponse call
func ParseProductGroupsUpdateResponse(rsp *http.Response) (*ProductGroupsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductGroupsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductGroupsDeletePreviewListResponse parses an HTTP response from a ProductGroupsDeletePreviewListWithResponse call
func ParseProductGroupsDeletePreviewListResponse(rsp *http.Response) (*ProductGroupsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductGroupsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductMembersListResponse parses an HTTP response from a ProductMembersListWithResponse call
func ParseProductMembersListResponse(rsp *http.Response) (*ProductMembersListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductMembersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedProductMemberList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductMembersCreateResponse parses an HTTP response from a ProductMembersCreateWithResponse call
func ParseProductMembersCreateResponse(rsp *http.Response) (*ProductMembersCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductMembersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProductMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseProductMembersDestroyResponse parses an HTTP response from a ProductMembersDestroyWithResponse call
func ParseProductMembersDestroyResponse(rsp *http.Response) (*ProductMembersDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductMembersDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProductMembersRetrieveResponse parses an HTTP response from a ProductMembersRetrieveWithResponse call
func ParseProductMembersRetrieveResponse(rsp *http.Response) (*ProductMembersRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductMembersRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductMembersPartialUpdateResponse parses an HTTP response from a ProductMembersPartialUpdateWithResponse call
func ParseProductMembersPartialUpdateResponse(rsp *http.Response) (*ProductMembersPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductMembersPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProductMembersUpdateResponse parses an HTTP response from a ProductMembersUpdateWithResponse call
func ParseProductMembersUpdateResponse(rsp *http.Response) (*ProductMembersUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductMembersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductMembersDeletePreviewListResponse parses an HTTP response from a ProductMembersDeletePreviewListWithResponse call
func ParseProductMembersDeletePreviewListResponse(rsp *http.Response) (*ProductMembersDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductMembersDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypeGroupsListResponse parses an HTTP response from a ProductTypeGroupsListWithResponse call
func ParseProductTypeGroupsListResponse(rsp *http.Response) (*ProductTypeGroupsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeGroupsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedProductTypeGroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypeGroupsCreateResponse parses an HTTP response from a ProductTypeGroupsCreateWithResponse call
func ParseProductTypeGroupsCreateResponse(rsp *http.Response) (*ProductTypeGroupsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeGroupsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProductTypeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseProductTypeGroupsDestroyResponse parses an HTTP response from a ProductTypeGroupsDestroyWithResponse call
func ParseProductTypeGroupsDestroyResponse(rsp *http.Response) (*ProductTypeGroupsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeGroupsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProductTypeGroupsRetrieveResponse parses an HTTP response from a ProductTypeGroupsRetrieveWithResponse call
func ParseProductTypeGroupsRetrieveResponse(rsp *http.Response) (*ProductTypeGroupsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeGroupsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductTypeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypeGroupsPartialUpdateResponse parses an HTTP response from a ProductTypeGroupsPartialUpdateWithResponse call
func ParseProductTypeGroupsPartialUpdateResponse(rsp *http.Response) (*ProductTypeGroupsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeGroupsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProductTypeGroupsUpdateResponse parses an HTTP response from a ProductTypeGroupsUpdateWithResponse call
func ParseProductTypeGroupsUpdateResponse(rsp *http.Response) (*ProductTypeGroupsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeGroupsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductTypeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypeGroupsDeletePreviewListResponse parses an HTTP response from a ProductTypeGroupsDeletePreviewListWithResponse call
func ParseProductTypeGroupsDeletePreviewListResponse(rsp *http.Response) (*ProductTypeGroupsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeGroupsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypeMembersListResponse parses an HTTP response from a ProductTypeMembersListWithResponse call
func ParseProductTypeMembersListResponse(rsp *http.Response) (*ProductTypeMembersListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeMembersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedProductTypeMemberList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypeMembersCreateResponse parses an HTTP response from a ProductTypeMembersCreateWithResponse call
func ParseProductTypeMembersCreateResponse(rsp *http.Response) (*ProductTypeMembersCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeMembersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProductTypeMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseProductTypeMembersDestroyResponse parses an HTTP response from a ProductTypeMembersDestroyWithResponse call
func ParseProductTypeMembersDestroyResponse(rsp *http.Response) (*ProductTypeMembersDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeMembersDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProductTypeMembersRetrieveResponse parses an HTTP response from a ProductTypeMembersRetrieveWithResponse call
func ParseProductTypeMembersRetrieveResponse(rsp *http.Response) (*ProductTypeMembersRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeMembersRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductTypeMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypeMembersPartialUpdateResponse parses an HTTP response from a ProductTypeMembersPartialUpdateWithResponse call
func ParseProductTypeMembersPartialUpdateResponse(rsp *http.Response) (*ProductTypeMembersPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeMembersPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProductTypeMembersUpdateResponse parses an HTTP response from a ProductTypeMembersUpdateWithResponse call
func ParseProductTypeMembersUpdateResponse(rsp *http.Response) (*ProductTypeMembersUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeMembersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductTypeMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypeMembersDeletePreviewListResponse parses an HTTP response from a ProductTypeMembersDeletePreviewListWithResponse call
func ParseProductTypeMembersDeletePreviewListResponse(rsp *http.Response) (*ProductTypeMembersDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypeMembersDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypesListResponse parses an HTTP response from a ProductTypesListWithResponse call
func ParseProductTypesListResponse(rsp *http.Response) (*ProductTypesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedProductTypeList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypesCreateResponse parses an HTTP response from a ProductTypesCreateWithResponse call
func ParseProductTypesCreateResponse(rsp *http.Response) (*ProductTypesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProductType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseProductTypesDestroyResponse parses an HTTP response from a ProductTypesDestroyWithResponse call
func ParseProductTypesDestroyResponse(rsp *http.Response) (*ProductTypesDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypesDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProductTypesRetrieveResponse parses an HTTP response from a ProductTypesRetrieveWithResponse call
func ParseProductTypesRetrieveResponse(rsp *http.Response) (*ProductTypesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypesPartialUpdateResponse parses an HTTP response from a ProductTypesPartialUpdateWithResponse call
func ParseProductTypesPartialUpdateResponse(rsp *http.Response) (*ProductTypesPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypesPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypesUpdateResponse parses an HTTP response from a ProductTypesUpdateWithResponse call
func ParseProductTypesUpdateResponse(rsp *http.Response) (*ProductTypesUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypesDeletePreviewListResponse parses an HTTP response from a ProductTypesDeletePreviewListWithResponse call
func ParseProductTypesDeletePreviewListResponse(rsp *http.Response) (*ProductTypesDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypesDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductTypesGenerateReportCreateResponse parses an HTTP response from a ProductTypesGenerateReportCreateWithResponse call
func ParseProductTypesGenerateReportCreateResponse(rsp *http.Response) (*ProductTypesGenerateReportCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypesGenerateReportCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportGenerate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductsListResponse parses an HTTP response from a ProductsListWithResponse call
func ParseProductsListResponse(rsp *http.Response) (*ProductsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedProductList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductsCreateResponse parses an HTTP response from a ProductsCreateWithResponse call
func ParseProductsCreateResponse(rsp *http.Response) (*ProductsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Product
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseProductsDestroyResponse parses an HTTP response from a ProductsDestroyWithResponse call
func ParseProductsDestroyResponse(rsp *http.Response) (*ProductsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProductsRetrieveResponse parses an HTTP response from a ProductsRetrieveWithResponse call
func ParseProductsRetrieveResponse(rsp *http.Response) (*ProductsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Product
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductsPartialUpdateResponse parses an HTTP response from a ProductsPartialUpdateWithResponse call
func ParseProductsPartialUpdateResponse(rsp *http.Response) (*ProductsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Product
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductsUpdateResponse parses an HTTP response from a ProductsUpdateWithResponse call
func ParseProductsUpdateResponse(rsp *http.Response) (*ProductsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Product
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductsDeletePreviewListResponse parses an HTTP response from a ProductsDeletePreviewListWithResponse call
func ParseProductsDeletePreviewListResponse(rsp *http.Response) (*ProductsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProductsGenerateReportCreateResponse parses an HTTP response from a ProductsGenerateReportCreateWithResponse call
func ParseProductsGenerateReportCreateResponse(rsp *http.Response) (*ProductsGenerateReportCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsGenerateReportCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportGenerate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegulationsListResponse parses an HTTP response from a RegulationsListWithResponse call
func ParseRegulationsListResponse(rsp *http.Response) (*RegulationsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegulationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedRegulationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegulationsCreateResponse parses an HTTP response from a RegulationsCreateWithResponse call
func ParseRegulationsCreateResponse(rsp *http.Response) (*RegulationsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegulationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Regulation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRegulationsDestroyResponse parses an HTTP response from a RegulationsDestroyWithResponse call
func ParseRegulationsDestroyResponse(rsp *http.Response) (*RegulationsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegulationsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRegulationsRetrieveResponse parses an HTTP response from a RegulationsRetrieveWithResponse call
func ParseRegulationsRetrieveResponse(rsp *http.Response) (*RegulationsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegulationsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Regulation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegulationsPartialUpdateResponse parses an HTTP response from a RegulationsPartialUpdateWithResponse call
func ParseRegulationsPartialUpdateResponse(rsp *http.Response) (*RegulationsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegulationsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Regulation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegulationsUpdateResponse parses an HTTP response from a RegulationsUpdateWithResponse call
func ParseRegulationsUpdateResponse(rsp *http.Response) (*RegulationsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegulationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Regulation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegulationsDeletePreviewListResponse parses an HTTP response from a RegulationsDeletePreviewListWithResponse call
func ParseRegulationsDeletePreviewListResponse(rsp *http.Response) (*RegulationsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegulationsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReimportScanCreateResponse parses an HTTP response from a ReimportScanCreateWithResponse call
func ParseReimportScanCreateResponse(rsp *http.Response) (*ReimportScanCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReimportScanCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ReImportScan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRolesListResponse parses an HTTP response from a RolesListWithResponse call
func ParseRolesListResponse(rsp *http.Response) (*RolesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RolesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedRoleList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRolesRetrieveResponse parses an HTTP response from a RolesRetrieveWithResponse call
func ParseRolesRetrieveResponse(rsp *http.Response) (*RolesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RolesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSlaConfigurationsListResponse parses an HTTP response from a SlaConfigurationsListWithResponse call
func ParseSlaConfigurationsListResponse(rsp *http.Response) (*SlaConfigurationsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaConfigurationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedSLAConfigurationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSlaConfigurationsCreateResponse parses an HTTP response from a SlaConfigurationsCreateWithResponse call
func ParseSlaConfigurationsCreateResponse(rsp *http.Response) (*SlaConfigurationsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaConfigurationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SLAConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSlaConfigurationsDestroyResponse parses an HTTP response from a SlaConfigurationsDestroyWithResponse call
func ParseSlaConfigurationsDestroyResponse(rsp *http.Response) (*SlaConfigurationsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaConfigurationsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSlaConfigurationsRetrieveResponse parses an HTTP response from a SlaConfigurationsRetrieveWithResponse call
func ParseSlaConfigurationsRetrieveResponse(rsp *http.Response) (*SlaConfigurationsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaConfigurationsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SLAConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSlaConfigurationsPartialUpdateResponse parses an HTTP response from a SlaConfigurationsPartialUpdateWithResponse call
func ParseSlaConfigurationsPartialUpdateResponse(rsp *http.Response) (*SlaConfigurationsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaConfigurationsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SLAConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSlaConfigurationsUpdateResponse parses an HTTP response from a SlaConfigurationsUpdateWithResponse call
func ParseSlaConfigurationsUpdateResponse(rsp *http.Response) (*SlaConfigurationsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlaConfigurationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SLAConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSonarqubeIssuesListResponse parses an HTTP response from a SonarqubeIssuesListWithResponse call
func ParseSonarqubeIssuesListResponse(rsp *http.Response) (*SonarqubeIssuesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeIssuesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedSonarqubeIssueList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSonarqubeIssuesCreateResponse parses an HTTP response from a SonarqubeIssuesCreateWithResponse call
func ParseSonarqubeIssuesCreateResponse(rsp *http.Response) (*SonarqubeIssuesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeIssuesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SonarqubeIssue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSonarqubeIssuesDestroyResponse parses an HTTP response from a SonarqubeIssuesDestroyWithResponse call
func ParseSonarqubeIssuesDestroyResponse(rsp *http.Response) (*SonarqubeIssuesDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeIssuesDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSonarqubeIssuesRetrieveResponse parses an HTTP response from a SonarqubeIssuesRetrieveWithResponse call
func ParseSonarqubeIssuesRetrieveResponse(rsp *http.Response) (*SonarqubeIssuesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeIssuesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SonarqubeIssue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSonarqubeIssuesPartialUpdateResponse parses an HTTP response from a SonarqubeIssuesPartialUpdateWithResponse call
func ParseSonarqubeIssuesPartialUpdateResponse(rsp *http.Response) (*SonarqubeIssuesPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeIssuesPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SonarqubeIssue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSonarqubeIssuesUpdateResponse parses an HTTP response from a SonarqubeIssuesUpdateWithResponse call
func ParseSonarqubeIssuesUpdateResponse(rsp *http.Response) (*SonarqubeIssuesUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeIssuesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SonarqubeIssue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSonarqubeIssuesDeletePreviewListResponse parses an HTTP response from a SonarqubeIssuesDeletePreviewListWithResponse call
func ParseSonarqubeIssuesDeletePreviewListResponse(rsp *http.Response) (*SonarqubeIssuesDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeIssuesDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSonarqubeTransitionsListResponse parses an HTTP response from a SonarqubeTransitionsListWithResponse call
func ParseSonarqubeTransitionsListResponse(rsp *http.Response) (*SonarqubeTransitionsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeTransitionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedSonarqubeIssueTransitionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSonarqubeTransitionsCreateResponse parses an HTTP response from a SonarqubeTransitionsCreateWithResponse call
func ParseSonarqubeTransitionsCreateResponse(rsp *http.Response) (*SonarqubeTransitionsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeTransitionsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SonarqubeIssueTransition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSonarqubeTransitionsDestroyResponse parses an HTTP response from a SonarqubeTransitionsDestroyWithResponse call
func ParseSonarqubeTransitionsDestroyResponse(rsp *http.Response) (*SonarqubeTransitionsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeTransitionsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSonarqubeTransitionsRetrieveResponse parses an HTTP response from a SonarqubeTransitionsRetrieveWithResponse call
func ParseSonarqubeTransitionsRetrieveResponse(rsp *http.Response) (*SonarqubeTransitionsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeTransitionsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SonarqubeIssueTransition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSonarqubeTransitionsPartialUpdateResponse parses an HTTP response from a SonarqubeTransitionsPartialUpdateWithResponse call
func ParseSonarqubeTransitionsPartialUpdateResponse(rsp *http.Response) (*SonarqubeTransitionsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeTransitionsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SonarqubeIssueTransition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSonarqubeTransitionsUpdateResponse parses an HTTP response from a SonarqubeTransitionsUpdateWithResponse call
func ParseSonarqubeTransitionsUpdateResponse(rsp *http.Response) (*SonarqubeTransitionsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeTransitionsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SonarqubeIssueTransition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSonarqubeTransitionsDeletePreviewListResponse parses an HTTP response from a SonarqubeTransitionsDeletePreviewListWithResponse call
func ParseSonarqubeTransitionsDeletePreviewListResponse(rsp *http.Response) (*SonarqubeTransitionsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SonarqubeTransitionsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStubFindingsListResponse parses an HTTP response from a StubFindingsListWithResponse call
func ParseStubFindingsListResponse(rsp *http.Response) (*StubFindingsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StubFindingsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedStubFindingList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStubFindingsCreateResponse parses an HTTP response from a StubFindingsCreateWithResponse call
func ParseStubFindingsCreateResponse(rsp *http.Response) (*StubFindingsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StubFindingsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StubFindingCreate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseStubFindingsDestroyResponse parses an HTTP response from a StubFindingsDestroyWithResponse call
func ParseStubFindingsDestroyResponse(rsp *http.Response) (*StubFindingsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StubFindingsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStubFindingsRetrieveResponse parses an HTTP response from a StubFindingsRetrieveWithResponse call
func ParseStubFindingsRetrieveResponse(rsp *http.Response) (*StubFindingsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StubFindingsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StubFinding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStubFindingsPartialUpdateResponse parses an HTTP response from a StubFindingsPartialUpdateWithResponse call
func ParseStubFindingsPartialUpdateResponse(rsp *http.Response) (*StubFindingsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StubFindingsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StubFinding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStubFindingsUpdateResponse parses an HTTP response from a StubFindingsUpdateWithResponse call
func ParseStubFindingsUpdateResponse(rsp *http.Response) (*StubFindingsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StubFindingsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StubFinding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStubFindingsDeletePreviewListResponse parses an HTTP response from a StubFindingsDeletePreviewListWithResponse call
func ParseStubFindingsDeletePreviewListResponse(rsp *http.Response) (*StubFindingsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StubFindingsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSystemSettingsListResponse parses an HTTP response from a SystemSettingsListWithResponse call
func ParseSystemSettingsListResponse(rsp *http.Response) (*SystemSettingsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SystemSettingsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedSystemSettingsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSystemSettingsPartialUpdateResponse parses an HTTP response from a SystemSettingsPartialUpdateWithResponse call
func ParseSystemSettingsPartialUpdateResponse(rsp *http.Response) (*SystemSettingsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SystemSettingsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SystemSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSystemSettingsUpdateResponse parses an HTTP response from a SystemSettingsUpdateWithResponse call
func ParseSystemSettingsUpdateResponse(rsp *http.Response) (*SystemSettingsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SystemSettingsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SystemSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTechnologiesListResponse parses an HTTP response from a TechnologiesListWithResponse call
func ParseTechnologiesListResponse(rsp *http.Response) (*TechnologiesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TechnologiesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedAppAnalysisList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTechnologiesCreateResponse parses an HTTP response from a TechnologiesCreateWithResponse call
func ParseTechnologiesCreateResponse(rsp *http.Response) (*TechnologiesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TechnologiesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppAnalysis
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTechnologiesDestroyResponse parses an HTTP response from a TechnologiesDestroyWithResponse call
func ParseTechnologiesDestroyResponse(rsp *http.Response) (*TechnologiesDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TechnologiesDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTechnologiesRetrieveResponse parses an HTTP response from a TechnologiesRetrieveWithResponse call
func ParseTechnologiesRetrieveResponse(rsp *http.Response) (*TechnologiesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TechnologiesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppAnalysis
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTechnologiesPartialUpdateResponse parses an HTTP response from a TechnologiesPartialUpdateWithResponse call
func ParseTechnologiesPartialUpdateResponse(rsp *http.Response) (*TechnologiesPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TechnologiesPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppAnalysis
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTechnologiesUpdateResponse parses an HTTP response from a TechnologiesUpdateWithResponse call
func ParseTechnologiesUpdateResponse(rsp *http.Response) (*TechnologiesUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TechnologiesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppAnalysis
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTechnologiesDeletePreviewListResponse parses an HTTP response from a TechnologiesDeletePreviewListWithResponse call
func ParseTechnologiesDeletePreviewListResponse(rsp *http.Response) (*TechnologiesDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TechnologiesDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestImportsListResponse parses an HTTP response from a TestImportsListWithResponse call
func ParseTestImportsListResponse(rsp *http.Response) (*TestImportsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestImportsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedTestImportList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestImportsCreateResponse parses an HTTP response from a TestImportsCreateWithResponse call
func ParseTestImportsCreateResponse(rsp *http.Response) (*TestImportsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestImportsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TestImport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTestImportsDestroyResponse parses an HTTP response from a TestImportsDestroyWithResponse call
func ParseTestImportsDestroyResponse(rsp *http.Response) (*TestImportsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestImportsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestImportsRetrieveResponse parses an HTTP response from a TestImportsRetrieveWithResponse call
func ParseTestImportsRetrieveResponse(rsp *http.Response) (*TestImportsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestImportsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestImport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestImportsPartialUpdateResponse parses an HTTP response from a TestImportsPartialUpdateWithResponse call
func ParseTestImportsPartialUpdateResponse(rsp *http.Response) (*TestImportsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestImportsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestImport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestImportsUpdateResponse parses an HTTP response from a TestImportsUpdateWithResponse call
func ParseTestImportsUpdateResponse(rsp *http.Response) (*TestImportsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestImportsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestImport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestImportsDeletePreviewListResponse parses an HTTP response from a TestImportsDeletePreviewListWithResponse call
func ParseTestImportsDeletePreviewListResponse(rsp *http.Response) (*TestImportsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestImportsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestTypesListResponse parses an HTTP response from a TestTypesListWithResponse call
func ParseTestTypesListResponse(rsp *http.Response) (*TestTypesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestTypesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedTestTypeList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestTypesCreateResponse parses an HTTP response from a TestTypesCreateWithResponse call
func ParseTestTypesCreateResponse(rsp *http.Response) (*TestTypesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestTypesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TestType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTestTypesRetrieveResponse parses an HTTP response from a TestTypesRetrieveWithResponse call
func ParseTestTypesRetrieveResponse(rsp *http.Response) (*TestTypesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestTypesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestTypesPartialUpdateResponse parses an HTTP response from a TestTypesPartialUpdateWithResponse call
func ParseTestTypesPartialUpdateResponse(rsp *http.Response) (*TestTypesPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestTypesPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestTypesUpdateResponse parses an HTTP response from a TestTypesUpdateWithResponse call
func ParseTestTypesUpdateResponse(rsp *http.Response) (*TestTypesUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestTypesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestsListResponse parses an HTTP response from a TestsListWithResponse call
func ParseTestsListResponse(rsp *http.Response) (*TestsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedTestList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestsCreateResponse parses an HTTP response from a TestsCreateWithResponse call
func ParseTestsCreateResponse(rsp *http.Response) (*TestsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TestCreate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTestsDestroyResponse parses an HTTP response from a TestsDestroyWithResponse call
func ParseTestsDestroyResponse(rsp *http.Response) (*TestsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestsRetrieveResponse parses an HTTP response from a TestsRetrieveWithResponse call
func ParseTestsRetrieveResponse(rsp *http.Response) (*TestsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Test
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestsPartialUpdateResponse parses an HTTP response from a TestsPartialUpdateWithResponse call
func ParseTestsPartialUpdateResponse(rsp *http.Response) (*TestsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Test
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestsUpdateResponse parses an HTTP response from a TestsUpdateWithResponse call
func ParseTestsUpdateResponse(rsp *http.Response) (*TestsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Test
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestsAcceptRisksCreateResponse parses an HTTP response from a TestsAcceptRisksCreateWithResponse call
func ParseTestsAcceptRisksCreateResponse(rsp *http.Response) (*TestsAcceptRisksCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsAcceptRisksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []RiskAcceptance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTestsDeletePreviewListResponse parses an HTTP response from a TestsDeletePreviewListWithResponse call
func ParseTestsDeletePreviewListResponse(rsp *http.Response) (*TestsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestsFilesRetrieveResponse parses an HTTP response from a TestsFilesRetrieveWithResponse call
func ParseTestsFilesRetrieveResponse(rsp *http.Response) (*TestsFilesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsFilesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestToFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestsFilesCreateResponse parses an HTTP response from a TestsFilesCreateWithResponse call
func ParseTestsFilesCreateResponse(rsp *http.Response) (*TestsFilesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsFilesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest File
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTestsGenerateReportCreateResponse parses an HTTP response from a TestsGenerateReportCreateWithResponse call
func ParseTestsGenerateReportCreateResponse(rsp *http.Response) (*TestsGenerateReportCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsGenerateReportCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportGenerate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestsNotesRetrieveResponse parses an HTTP response from a TestsNotesRetrieveWithResponse call
func ParseTestsNotesRetrieveResponse(rsp *http.Response) (*TestsNotesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsNotesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestToNotes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestsNotesCreateResponse parses an HTTP response from a TestsNotesCreateWithResponse call
func ParseTestsNotesCreateResponse(rsp *http.Response) (*TestsNotesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestsNotesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Note
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseToolConfigurationsListResponse parses an HTTP response from a ToolConfigurationsListWithResponse call
func ParseToolConfigurationsListResponse(rsp *http.Response) (*ToolConfigurationsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolConfigurationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedToolConfigurationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolConfigurationsCreateResponse parses an HTTP response from a ToolConfigurationsCreateWithResponse call
func ParseToolConfigurationsCreateResponse(rsp *http.Response) (*ToolConfigurationsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolConfigurationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ToolConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseToolConfigurationsDestroyResponse parses an HTTP response from a ToolConfigurationsDestroyWithResponse call
func ParseToolConfigurationsDestroyResponse(rsp *http.Response) (*ToolConfigurationsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolConfigurationsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseToolConfigurationsRetrieveResponse parses an HTTP response from a ToolConfigurationsRetrieveWithResponse call
func ParseToolConfigurationsRetrieveResponse(rsp *http.Response) (*ToolConfigurationsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolConfigurationsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ToolConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolConfigurationsPartialUpdateResponse parses an HTTP response from a ToolConfigurationsPartialUpdateWithResponse call
func ParseToolConfigurationsPartialUpdateResponse(rsp *http.Response) (*ToolConfigurationsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolConfigurationsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ToolConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolConfigurationsUpdateResponse parses an HTTP response from a ToolConfigurationsUpdateWithResponse call
func ParseToolConfigurationsUpdateResponse(rsp *http.Response) (*ToolConfigurationsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolConfigurationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ToolConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolConfigurationsDeletePreviewListResponse parses an HTTP response from a ToolConfigurationsDeletePreviewListWithResponse call
func ParseToolConfigurationsDeletePreviewListResponse(rsp *http.Response) (*ToolConfigurationsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolConfigurationsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolProductSettingsListResponse parses an HTTP response from a ToolProductSettingsListWithResponse call
func ParseToolProductSettingsListResponse(rsp *http.Response) (*ToolProductSettingsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolProductSettingsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedToolProductSettingsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolProductSettingsCreateResponse parses an HTTP response from a ToolProductSettingsCreateWithResponse call
func ParseToolProductSettingsCreateResponse(rsp *http.Response) (*ToolProductSettingsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolProductSettingsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ToolProductSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseToolProductSettingsDestroyResponse parses an HTTP response from a ToolProductSettingsDestroyWithResponse call
func ParseToolProductSettingsDestroyResponse(rsp *http.Response) (*ToolProductSettingsDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolProductSettingsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseToolProductSettingsRetrieveResponse parses an HTTP response from a ToolProductSettingsRetrieveWithResponse call
func ParseToolProductSettingsRetrieveResponse(rsp *http.Response) (*ToolProductSettingsRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolProductSettingsRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ToolProductSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolProductSettingsPartialUpdateResponse parses an HTTP response from a ToolProductSettingsPartialUpdateWithResponse call
func ParseToolProductSettingsPartialUpdateResponse(rsp *http.Response) (*ToolProductSettingsPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolProductSettingsPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ToolProductSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolProductSettingsUpdateResponse parses an HTTP response from a ToolProductSettingsUpdateWithResponse call
func ParseToolProductSettingsUpdateResponse(rsp *http.Response) (*ToolProductSettingsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolProductSettingsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ToolProductSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolProductSettingsDeletePreviewListResponse parses an HTTP response from a ToolProductSettingsDeletePreviewListWithResponse call
func ParseToolProductSettingsDeletePreviewListResponse(rsp *http.Response) (*ToolProductSettingsDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolProductSettingsDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolTypesListResponse parses an HTTP response from a ToolTypesListWithResponse call
func ParseToolTypesListResponse(rsp *http.Response) (*ToolTypesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolTypesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedToolTypeList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolTypesCreateResponse parses an HTTP response from a ToolTypesCreateWithResponse call
func ParseToolTypesCreateResponse(rsp *http.Response) (*ToolTypesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolTypesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ToolType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseToolTypesDestroyResponse parses an HTTP response from a ToolTypesDestroyWithResponse call
func ParseToolTypesDestroyResponse(rsp *http.Response) (*ToolTypesDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolTypesDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseToolTypesRetrieveResponse parses an HTTP response from a ToolTypesRetrieveWithResponse call
func ParseToolTypesRetrieveResponse(rsp *http.Response) (*ToolTypesRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolTypesRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ToolType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolTypesPartialUpdateResponse parses an HTTP response from a ToolTypesPartialUpdateWithResponse call
func ParseToolTypesPartialUpdateResponse(rsp *http.Response) (*ToolTypesPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolTypesPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ToolType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolTypesUpdateResponse parses an HTTP response from a ToolTypesUpdateWithResponse call
func ParseToolTypesUpdateResponse(rsp *http.Response) (*ToolTypesUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolTypesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ToolType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseToolTypesDeletePreviewListResponse parses an HTTP response from a ToolTypesDeletePreviewListWithResponse call
func ParseToolTypesDeletePreviewListResponse(rsp *http.Response) (*ToolTypesDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToolTypesDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserContactInfosListResponse parses an HTTP response from a UserContactInfosListWithResponse call
func ParseUserContactInfosListResponse(rsp *http.Response) (*UserContactInfosListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserContactInfosListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedUserContactInfoList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserContactInfosCreateResponse parses an HTTP response from a UserContactInfosCreateWithResponse call
func ParseUserContactInfosCreateResponse(rsp *http.Response) (*UserContactInfosCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserContactInfosCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UserContactInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUserContactInfosDestroyResponse parses an HTTP response from a UserContactInfosDestroyWithResponse call
func ParseUserContactInfosDestroyResponse(rsp *http.Response) (*UserContactInfosDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserContactInfosDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserContactInfosRetrieveResponse parses an HTTP response from a UserContactInfosRetrieveWithResponse call
func ParseUserContactInfosRetrieveResponse(rsp *http.Response) (*UserContactInfosRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserContactInfosRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserContactInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserContactInfosPartialUpdateResponse parses an HTTP response from a UserContactInfosPartialUpdateWithResponse call
func ParseUserContactInfosPartialUpdateResponse(rsp *http.Response) (*UserContactInfosPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserContactInfosPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserContactInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserContactInfosUpdateResponse parses an HTTP response from a UserContactInfosUpdateWithResponse call
func ParseUserContactInfosUpdateResponse(rsp *http.Response) (*UserContactInfosUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserContactInfosUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserContactInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserContactInfosDeletePreviewListResponse parses an HTTP response from a UserContactInfosDeletePreviewListWithResponse call
func ParseUserContactInfosDeletePreviewListResponse(rsp *http.Response) (*UserContactInfosDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserContactInfosDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserProfileRetrieveResponse parses an HTTP response from a UserProfileRetrieveWithResponse call
func ParseUserProfileRetrieveResponse(rsp *http.Response) (*UserProfileRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserProfileRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsersListResponse parses an HTTP response from a UsersListWithResponse call
func ParseUsersListResponse(rsp *http.Response) (*UsersListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedUserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsersCreateResponse parses an HTTP response from a UsersCreateWithResponse call
func ParseUsersCreateResponse(rsp *http.Response) (*UsersCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUsersDestroyResponse parses an HTTP response from a UsersDestroyWithResponse call
func ParseUsersDestroyResponse(rsp *http.Response) (*UsersDestroyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUsersRetrieveResponse parses an HTTP response from a UsersRetrieveWithResponse call
func ParseUsersRetrieveResponse(rsp *http.Response) (*UsersRetrieveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsersPartialUpdateResponse parses an HTTP response from a UsersPartialUpdateWithResponse call
func ParseUsersPartialUpdateResponse(rsp *http.Response) (*UsersPartialUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersPartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsersUpdateResponse parses an HTTP response from a UsersUpdateWithResponse call
func ParseUsersUpdateResponse(rsp *http.Response) (*UsersUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsersDeletePreviewListResponse parses an HTTP response from a UsersDeletePreviewListWithResponse call
func ParseUsersDeletePreviewListResponse(rsp *http.Response) (*UsersDeletePreviewListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersDeletePreviewListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDeletePreviewList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /api/v2/api-token-auth/)
	ApiTokenAuthCreate(ctx echo.Context) error

	// (GET /api/v2/configuration_permissions/)
	ConfigurationPermissionsList(ctx echo.Context, params ConfigurationPermissionsListParams) error

	// (GET /api/v2/configuration_permissions/{id}/)
	ConfigurationPermissionsRetrieve(ctx echo.Context, id int) error

	// (GET /api/v2/development_environments/)
	DevelopmentEnvironmentsList(ctx echo.Context, params DevelopmentEnvironmentsListParams) error

	// (POST /api/v2/development_environments/)
	DevelopmentEnvironmentsCreate(ctx echo.Context) error

	// (DELETE /api/v2/development_environments/{id}/)
	DevelopmentEnvironmentsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/development_environments/{id}/)
	DevelopmentEnvironmentsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/development_environments/{id}/)
	DevelopmentEnvironmentsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/development_environments/{id}/)
	DevelopmentEnvironmentsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/development_environments/{id}/delete_preview/)
	DevelopmentEnvironmentsDeletePreviewList(ctx echo.Context, id int, params DevelopmentEnvironmentsDeletePreviewListParams) error

	// (GET /api/v2/dojo_group_members/)
	DojoGroupMembersList(ctx echo.Context, params DojoGroupMembersListParams) error

	// (POST /api/v2/dojo_group_members/)
	DojoGroupMembersCreate(ctx echo.Context) error

	// (DELETE /api/v2/dojo_group_members/{id}/)
	DojoGroupMembersDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/dojo_group_members/{id}/)
	DojoGroupMembersRetrieve(ctx echo.Context, id int, params DojoGroupMembersRetrieveParams) error

	// (PATCH /api/v2/dojo_group_members/{id}/)
	DojoGroupMembersPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/dojo_group_members/{id}/)
	DojoGroupMembersUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/dojo_group_members/{id}/delete_preview/)
	DojoGroupMembersDeletePreviewList(ctx echo.Context, id int, params DojoGroupMembersDeletePreviewListParams) error

	// (GET /api/v2/dojo_groups/)
	DojoGroupsList(ctx echo.Context, params DojoGroupsListParams) error

	// (POST /api/v2/dojo_groups/)
	DojoGroupsCreate(ctx echo.Context) error

	// (DELETE /api/v2/dojo_groups/{id}/)
	DojoGroupsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/dojo_groups/{id}/)
	DojoGroupsRetrieve(ctx echo.Context, id int, params DojoGroupsRetrieveParams) error

	// (PATCH /api/v2/dojo_groups/{id}/)
	DojoGroupsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/dojo_groups/{id}/)
	DojoGroupsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/dojo_groups/{id}/delete_preview/)
	DojoGroupsDeletePreviewList(ctx echo.Context, id int, params DojoGroupsDeletePreviewListParams) error

	// (POST /api/v2/endpoint_meta_import/)
	EndpointMetaImportCreate(ctx echo.Context) error

	// (GET /api/v2/endpoint_status/)
	EndpointStatusList(ctx echo.Context, params EndpointStatusListParams) error

	// (POST /api/v2/endpoint_status/)
	EndpointStatusCreate(ctx echo.Context) error

	// (DELETE /api/v2/endpoint_status/{id}/)
	EndpointStatusDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/endpoint_status/{id}/)
	EndpointStatusRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/endpoint_status/{id}/)
	EndpointStatusPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/endpoint_status/{id}/)
	EndpointStatusUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/endpoint_status/{id}/delete_preview/)
	EndpointStatusDeletePreviewList(ctx echo.Context, id int, params EndpointStatusDeletePreviewListParams) error

	// (GET /api/v2/endpoints/)
	EndpointsList(ctx echo.Context, params EndpointsListParams) error

	// (POST /api/v2/endpoints/)
	EndpointsCreate(ctx echo.Context) error

	// (DELETE /api/v2/endpoints/{id}/)
	EndpointsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/endpoints/{id}/)
	EndpointsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/endpoints/{id}/)
	EndpointsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/endpoints/{id}/)
	EndpointsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/endpoints/{id}/delete_preview/)
	EndpointsDeletePreviewList(ctx echo.Context, id int, params EndpointsDeletePreviewListParams) error

	// (POST /api/v2/endpoints/{id}/generate_report/)
	EndpointsGenerateReportCreate(ctx echo.Context, id int) error

	// (GET /api/v2/engagement_presets/)
	EngagementPresetsList(ctx echo.Context, params EngagementPresetsListParams) error

	// (POST /api/v2/engagement_presets/)
	EngagementPresetsCreate(ctx echo.Context) error

	// (DELETE /api/v2/engagement_presets/{id}/)
	EngagementPresetsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/engagement_presets/{id}/)
	EngagementPresetsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/engagement_presets/{id}/)
	EngagementPresetsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/engagement_presets/{id}/)
	EngagementPresetsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/engagement_presets/{id}/delete_preview/)
	EngagementPresetsDeletePreviewList(ctx echo.Context, id int, params EngagementPresetsDeletePreviewListParams) error

	// (GET /api/v2/engagements/)
	EngagementsList(ctx echo.Context, params EngagementsListParams) error

	// (POST /api/v2/engagements/)
	EngagementsCreate(ctx echo.Context) error

	// (DELETE /api/v2/engagements/{id}/)
	EngagementsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/engagements/{id}/)
	EngagementsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/engagements/{id}/)
	EngagementsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/engagements/{id}/)
	EngagementsUpdate(ctx echo.Context, id int) error

	// (POST /api/v2/engagements/{id}/accept_risks/)
	EngagementsAcceptRisksCreate(ctx echo.Context, id int) error

	// (POST /api/v2/engagements/{id}/close/)
	EngagementsCloseCreate(ctx echo.Context, id int) error

	// (GET /api/v2/engagements/{id}/delete_preview/)
	EngagementsDeletePreviewList(ctx echo.Context, id int, params EngagementsDeletePreviewListParams) error

	// (GET /api/v2/engagements/{id}/files/)
	EngagementsFilesRetrieve(ctx echo.Context, id int) error

	// (POST /api/v2/engagements/{id}/files/)
	EngagementsFilesCreate(ctx echo.Context, id int) error

	// (POST /api/v2/engagements/{id}/generate_report/)
	EngagementsGenerateReportCreate(ctx echo.Context, id int) error

	// (GET /api/v2/engagements/{id}/notes/)
	EngagementsNotesRetrieve(ctx echo.Context, id int) error

	// (POST /api/v2/engagements/{id}/notes/)
	EngagementsNotesCreate(ctx echo.Context, id int) error

	// (POST /api/v2/engagements/{id}/reopen/)
	EngagementsReopenCreate(ctx echo.Context, id int) error

	// (GET /api/v2/finding_templates/)
	FindingTemplatesList(ctx echo.Context, params FindingTemplatesListParams) error

	// (POST /api/v2/finding_templates/)
	FindingTemplatesCreate(ctx echo.Context) error

	// (DELETE /api/v2/finding_templates/{id}/)
	FindingTemplatesDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/finding_templates/{id}/)
	FindingTemplatesRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/finding_templates/{id}/)
	FindingTemplatesPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/finding_templates/{id}/)
	FindingTemplatesUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/finding_templates/{id}/delete_preview/)
	FindingTemplatesDeletePreviewList(ctx echo.Context, id int, params FindingTemplatesDeletePreviewListParams) error

	// (GET /api/v2/findings/)
	FindingsList(ctx echo.Context, params FindingsListParams) error

	// (POST /api/v2/findings/)
	FindingsCreate(ctx echo.Context) error

	// (POST /api/v2/findings/accept_risks/)
	FindingsAcceptRisksCreate(ctx echo.Context, params FindingsAcceptRisksCreateParams) error

	// (POST /api/v2/findings/generate_report/)
	FindingsGenerateReportCreate(ctx echo.Context) error

	// (DELETE /api/v2/findings/{id}/)
	FindingsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/findings/{id}/)
	FindingsRetrieve(ctx echo.Context, id int, params FindingsRetrieveParams) error

	// (PATCH /api/v2/findings/{id}/)
	FindingsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/findings/{id}/)
	FindingsUpdate(ctx echo.Context, id int) error

	// (POST /api/v2/findings/{id}/close/)
	FindingsCloseCreate(ctx echo.Context, id int) error

	// (GET /api/v2/findings/{id}/delete_preview/)
	FindingsDeletePreviewList(ctx echo.Context, id int, params FindingsDeletePreviewListParams) error

	// (GET /api/v2/findings/{id}/duplicate/)
	FindingsDuplicateList(ctx echo.Context, id int) error

	// (POST /api/v2/findings/{id}/duplicate/reset/)
	FindingsDuplicateResetCreate(ctx echo.Context, id int) error

	// (GET /api/v2/findings/{id}/files/)
	FindingsFilesRetrieve(ctx echo.Context, id int) error

	// (POST /api/v2/findings/{id}/files/)
	FindingsFilesCreate(ctx echo.Context, id int) error

	// (DELETE /api/v2/findings/{id}/metadata/)
	FindingsMetadataDestroy(ctx echo.Context, id int, params FindingsMetadataDestroyParams) error

	// (GET /api/v2/findings/{id}/metadata/)
	FindingsMetadataList(ctx echo.Context, id int) error

	// (POST /api/v2/findings/{id}/metadata/)
	FindingsMetadataCreate(ctx echo.Context, id int) error

	// (PUT /api/v2/findings/{id}/metadata/)
	FindingsMetadataUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/findings/{id}/notes/)
	FindingsNotesRetrieve(ctx echo.Context, id int) error

	// (POST /api/v2/findings/{id}/notes/)
	FindingsNotesCreate(ctx echo.Context, id int) error

	// (POST /api/v2/findings/{id}/original/{new_fid}/)
	FindingsOriginalCreate(ctx echo.Context, id int, newFid int) error

	// (PATCH /api/v2/findings/{id}/remove_note/)
	FindingsRemoveNotePartialUpdate(ctx echo.Context, id int) error

	// (PATCH /api/v2/findings/{id}/remove_tags/)
	FindingsRemoveTagsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/findings/{id}/remove_tags/)
	FindingsRemoveTagsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/findings/{id}/request_response/)
	FindingsRequestResponseRetrieve(ctx echo.Context, id int) error

	// (POST /api/v2/findings/{id}/request_response/)
	FindingsRequestResponseCreate(ctx echo.Context, id int) error

	// (GET /api/v2/findings/{id}/tags/)
	FindingsTagsRetrieve(ctx echo.Context, id int) error

	// (POST /api/v2/findings/{id}/tags/)
	FindingsTagsCreate(ctx echo.Context, id int) error

	// (GET /api/v2/global_roles/)
	GlobalRolesList(ctx echo.Context, params GlobalRolesListParams) error

	// (POST /api/v2/global_roles/)
	GlobalRolesCreate(ctx echo.Context) error

	// (DELETE /api/v2/global_roles/{id}/)
	GlobalRolesDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/global_roles/{id}/)
	GlobalRolesRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/global_roles/{id}/)
	GlobalRolesPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/global_roles/{id}/)
	GlobalRolesUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/global_roles/{id}/delete_preview/)
	GlobalRolesDeletePreviewList(ctx echo.Context, id int, params GlobalRolesDeletePreviewListParams) error

	// (POST /api/v2/import-languages/)
	ImportLanguagesCreate(ctx echo.Context) error

	// (POST /api/v2/import-scan/)
	ImportScanCreate(ctx echo.Context) error

	// (GET /api/v2/jira_configurations/)
	JiraConfigurationsList(ctx echo.Context, params JiraConfigurationsListParams) error

	// (POST /api/v2/jira_configurations/)
	JiraConfigurationsCreate(ctx echo.Context) error

	// (DELETE /api/v2/jira_configurations/{id}/)
	JiraConfigurationsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/jira_configurations/{id}/)
	JiraConfigurationsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/jira_configurations/{id}/)
	JiraConfigurationsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/jira_configurations/{id}/)
	JiraConfigurationsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/jira_configurations/{id}/delete_preview/)
	JiraConfigurationsDeletePreviewList(ctx echo.Context, id int, params JiraConfigurationsDeletePreviewListParams) error

	// (GET /api/v2/jira_finding_mappings/)
	JiraFindingMappingsList(ctx echo.Context, params JiraFindingMappingsListParams) error

	// (POST /api/v2/jira_finding_mappings/)
	JiraFindingMappingsCreate(ctx echo.Context) error

	// (DELETE /api/v2/jira_finding_mappings/{id}/)
	JiraFindingMappingsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/jira_finding_mappings/{id}/)
	JiraFindingMappingsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/jira_finding_mappings/{id}/)
	JiraFindingMappingsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/jira_finding_mappings/{id}/)
	JiraFindingMappingsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/jira_finding_mappings/{id}/delete_preview/)
	JiraFindingMappingsDeletePreviewList(ctx echo.Context, id int, params JiraFindingMappingsDeletePreviewListParams) error

	// (GET /api/v2/jira_instances/)
	JiraInstancesList(ctx echo.Context, params JiraInstancesListParams) error

	// (POST /api/v2/jira_instances/)
	JiraInstancesCreate(ctx echo.Context) error

	// (DELETE /api/v2/jira_instances/{id}/)
	JiraInstancesDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/jira_instances/{id}/)
	JiraInstancesRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/jira_instances/{id}/)
	JiraInstancesPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/jira_instances/{id}/)
	JiraInstancesUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/jira_instances/{id}/delete_preview/)
	JiraInstancesDeletePreviewList(ctx echo.Context, id int, params JiraInstancesDeletePreviewListParams) error

	// (GET /api/v2/jira_product_configurations/)
	JiraProductConfigurationsList(ctx echo.Context, params JiraProductConfigurationsListParams) error

	// (POST /api/v2/jira_product_configurations/)
	JiraProductConfigurationsCreate(ctx echo.Context) error

	// (DELETE /api/v2/jira_product_configurations/{id}/)
	JiraProductConfigurationsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/jira_product_configurations/{id}/)
	JiraProductConfigurationsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/jira_product_configurations/{id}/)
	JiraProductConfigurationsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/jira_product_configurations/{id}/)
	JiraProductConfigurationsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/jira_product_configurations/{id}/delete_preview/)
	JiraProductConfigurationsDeletePreviewList(ctx echo.Context, id int, params JiraProductConfigurationsDeletePreviewListParams) error

	// (GET /api/v2/jira_projects/)
	JiraProjectsList(ctx echo.Context, params JiraProjectsListParams) error

	// (POST /api/v2/jira_projects/)
	JiraProjectsCreate(ctx echo.Context) error

	// (DELETE /api/v2/jira_projects/{id}/)
	JiraProjectsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/jira_projects/{id}/)
	JiraProjectsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/jira_projects/{id}/)
	JiraProjectsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/jira_projects/{id}/)
	JiraProjectsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/jira_projects/{id}/delete_preview/)
	JiraProjectsDeletePreviewList(ctx echo.Context, id int, params JiraProjectsDeletePreviewListParams) error

	// (GET /api/v2/language_types/)
	LanguageTypesList(ctx echo.Context, params LanguageTypesListParams) error

	// (POST /api/v2/language_types/)
	LanguageTypesCreate(ctx echo.Context) error

	// (DELETE /api/v2/language_types/{id}/)
	LanguageTypesDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/language_types/{id}/)
	LanguageTypesRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/language_types/{id}/)
	LanguageTypesPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/language_types/{id}/)
	LanguageTypesUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/language_types/{id}/delete_preview/)
	LanguageTypesDeletePreviewList(ctx echo.Context, id int, params LanguageTypesDeletePreviewListParams) error

	// (GET /api/v2/languages/)
	LanguagesList(ctx echo.Context, params LanguagesListParams) error

	// (POST /api/v2/languages/)
	LanguagesCreate(ctx echo.Context) error

	// (DELETE /api/v2/languages/{id}/)
	LanguagesDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/languages/{id}/)
	LanguagesRetrieve(ctx echo.Context, id int, params LanguagesRetrieveParams) error

	// (PATCH /api/v2/languages/{id}/)
	LanguagesPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/languages/{id}/)
	LanguagesUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/languages/{id}/delete_preview/)
	LanguagesDeletePreviewList(ctx echo.Context, id int, params LanguagesDeletePreviewListParams) error

	// (GET /api/v2/metadata/)
	MetadataList(ctx echo.Context, params MetadataListParams) error

	// (POST /api/v2/metadata/)
	MetadataCreate(ctx echo.Context) error

	// (DELETE /api/v2/metadata/{id}/)
	MetadataDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/metadata/{id}/)
	MetadataRetrieve(ctx echo.Context, id int, params MetadataRetrieveParams) error

	// (PATCH /api/v2/metadata/{id}/)
	MetadataPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/metadata/{id}/)
	MetadataUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/metadata/{id}/delete_preview/)
	MetadataDeletePreviewList(ctx echo.Context, id int, params MetadataDeletePreviewListParams) error

	// (GET /api/v2/network_locations/)
	NetworkLocationsList(ctx echo.Context, params NetworkLocationsListParams) error

	// (POST /api/v2/network_locations/)
	NetworkLocationsCreate(ctx echo.Context) error

	// (DELETE /api/v2/network_locations/{id}/)
	NetworkLocationsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/network_locations/{id}/)
	NetworkLocationsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/network_locations/{id}/)
	NetworkLocationsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/network_locations/{id}/)
	NetworkLocationsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/network_locations/{id}/delete_preview/)
	NetworkLocationsDeletePreviewList(ctx echo.Context, id int, params NetworkLocationsDeletePreviewListParams) error

	// (GET /api/v2/note_type/)
	NoteTypeList(ctx echo.Context, params NoteTypeListParams) error

	// (POST /api/v2/note_type/)
	NoteTypeCreate(ctx echo.Context) error

	// (DELETE /api/v2/note_type/{id}/)
	NoteTypeDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/note_type/{id}/)
	NoteTypeRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/note_type/{id}/)
	NoteTypePartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/note_type/{id}/)
	NoteTypeUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/note_type/{id}/delete_preview/)
	NoteTypeDeletePreviewList(ctx echo.Context, id int, params NoteTypeDeletePreviewListParams) error

	// (GET /api/v2/notes/)
	NotesList(ctx echo.Context, params NotesListParams) error

	// (GET /api/v2/notes/{id}/)
	NotesRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/notes/{id}/)
	NotesPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/notes/{id}/)
	NotesUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/notifications/)
	NotificationsList(ctx echo.Context, params NotificationsListParams) error

	// (POST /api/v2/notifications/)
	NotificationsCreate(ctx echo.Context) error

	// (DELETE /api/v2/notifications/{id}/)
	NotificationsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/notifications/{id}/)
	NotificationsRetrieve(ctx echo.Context, id int, params NotificationsRetrieveParams) error

	// (PATCH /api/v2/notifications/{id}/)
	NotificationsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/notifications/{id}/)
	NotificationsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/notifications/{id}/delete_preview/)
	NotificationsDeletePreviewList(ctx echo.Context, id int, params NotificationsDeletePreviewListParams) error

	// (GET /api/v2/oa3/schema/)
	Oa3SchemaRetrieve(ctx echo.Context, params Oa3SchemaRetrieveParams) error

	// (GET /api/v2/product_api_scan_configurations/)
	ProductApiScanConfigurationsList(ctx echo.Context, params ProductApiScanConfigurationsListParams) error

	// (POST /api/v2/product_api_scan_configurations/)
	ProductApiScanConfigurationsCreate(ctx echo.Context) error

	// (DELETE /api/v2/product_api_scan_configurations/{id}/)
	ProductApiScanConfigurationsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/product_api_scan_configurations/{id}/)
	ProductApiScanConfigurationsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/product_api_scan_configurations/{id}/)
	ProductApiScanConfigurationsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/product_api_scan_configurations/{id}/)
	ProductApiScanConfigurationsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/product_api_scan_configurations/{id}/delete_preview/)
	ProductApiScanConfigurationsDeletePreviewList(ctx echo.Context, id int, params ProductApiScanConfigurationsDeletePreviewListParams) error

	// (GET /api/v2/product_groups/)
	ProductGroupsList(ctx echo.Context, params ProductGroupsListParams) error

	// (POST /api/v2/product_groups/)
	ProductGroupsCreate(ctx echo.Context) error

	// (DELETE /api/v2/product_groups/{id}/)
	ProductGroupsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/product_groups/{id}/)
	ProductGroupsRetrieve(ctx echo.Context, id int, params ProductGroupsRetrieveParams) error

	// (PATCH /api/v2/product_groups/{id}/)
	ProductGroupsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/product_groups/{id}/)
	ProductGroupsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/product_groups/{id}/delete_preview/)
	ProductGroupsDeletePreviewList(ctx echo.Context, id int, params ProductGroupsDeletePreviewListParams) error

	// (GET /api/v2/product_members/)
	ProductMembersList(ctx echo.Context, params ProductMembersListParams) error

	// (POST /api/v2/product_members/)
	ProductMembersCreate(ctx echo.Context) error

	// (DELETE /api/v2/product_members/{id}/)
	ProductMembersDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/product_members/{id}/)
	ProductMembersRetrieve(ctx echo.Context, id int, params ProductMembersRetrieveParams) error

	// (PATCH /api/v2/product_members/{id}/)
	ProductMembersPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/product_members/{id}/)
	ProductMembersUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/product_members/{id}/delete_preview/)
	ProductMembersDeletePreviewList(ctx echo.Context, id int, params ProductMembersDeletePreviewListParams) error

	// (GET /api/v2/product_type_groups/)
	ProductTypeGroupsList(ctx echo.Context, params ProductTypeGroupsListParams) error

	// (POST /api/v2/product_type_groups/)
	ProductTypeGroupsCreate(ctx echo.Context) error

	// (DELETE /api/v2/product_type_groups/{id}/)
	ProductTypeGroupsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/product_type_groups/{id}/)
	ProductTypeGroupsRetrieve(ctx echo.Context, id int, params ProductTypeGroupsRetrieveParams) error

	// (PATCH /api/v2/product_type_groups/{id}/)
	ProductTypeGroupsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/product_type_groups/{id}/)
	ProductTypeGroupsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/product_type_groups/{id}/delete_preview/)
	ProductTypeGroupsDeletePreviewList(ctx echo.Context, id int, params ProductTypeGroupsDeletePreviewListParams) error

	// (GET /api/v2/product_type_members/)
	ProductTypeMembersList(ctx echo.Context, params ProductTypeMembersListParams) error

	// (POST /api/v2/product_type_members/)
	ProductTypeMembersCreate(ctx echo.Context) error

	// (DELETE /api/v2/product_type_members/{id}/)
	ProductTypeMembersDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/product_type_members/{id}/)
	ProductTypeMembersRetrieve(ctx echo.Context, id int, params ProductTypeMembersRetrieveParams) error

	// (PATCH /api/v2/product_type_members/{id}/)
	ProductTypeMembersPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/product_type_members/{id}/)
	ProductTypeMembersUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/product_type_members/{id}/delete_preview/)
	ProductTypeMembersDeletePreviewList(ctx echo.Context, id int, params ProductTypeMembersDeletePreviewListParams) error

	// (GET /api/v2/product_types/)
	ProductTypesList(ctx echo.Context, params ProductTypesListParams) error

	// (POST /api/v2/product_types/)
	ProductTypesCreate(ctx echo.Context) error

	// (DELETE /api/v2/product_types/{id}/)
	ProductTypesDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/product_types/{id}/)
	ProductTypesRetrieve(ctx echo.Context, id int, params ProductTypesRetrieveParams) error

	// (PATCH /api/v2/product_types/{id}/)
	ProductTypesPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/product_types/{id}/)
	ProductTypesUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/product_types/{id}/delete_preview/)
	ProductTypesDeletePreviewList(ctx echo.Context, id int, params ProductTypesDeletePreviewListParams) error

	// (POST /api/v2/product_types/{id}/generate_report/)
	ProductTypesGenerateReportCreate(ctx echo.Context, id int) error

	// (GET /api/v2/products/)
	ProductsList(ctx echo.Context, params ProductsListParams) error

	// (POST /api/v2/products/)
	ProductsCreate(ctx echo.Context) error

	// (DELETE /api/v2/products/{id}/)
	ProductsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/products/{id}/)
	ProductsRetrieve(ctx echo.Context, id int, params ProductsRetrieveParams) error

	// (PATCH /api/v2/products/{id}/)
	ProductsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/products/{id}/)
	ProductsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/products/{id}/delete_preview/)
	ProductsDeletePreviewList(ctx echo.Context, id int, params ProductsDeletePreviewListParams) error

	// (POST /api/v2/products/{id}/generate_report/)
	ProductsGenerateReportCreate(ctx echo.Context, id int) error

	// (GET /api/v2/regulations/)
	RegulationsList(ctx echo.Context, params RegulationsListParams) error

	// (POST /api/v2/regulations/)
	RegulationsCreate(ctx echo.Context) error

	// (DELETE /api/v2/regulations/{id}/)
	RegulationsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/regulations/{id}/)
	RegulationsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/regulations/{id}/)
	RegulationsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/regulations/{id}/)
	RegulationsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/regulations/{id}/delete_preview/)
	RegulationsDeletePreviewList(ctx echo.Context, id int, params RegulationsDeletePreviewListParams) error

	// (POST /api/v2/reimport-scan/)
	ReimportScanCreate(ctx echo.Context) error

	// (GET /api/v2/roles/)
	RolesList(ctx echo.Context, params RolesListParams) error

	// (GET /api/v2/roles/{id}/)
	RolesRetrieve(ctx echo.Context, id int) error

	// (GET /api/v2/sla_configurations/)
	SlaConfigurationsList(ctx echo.Context, params SlaConfigurationsListParams) error

	// (POST /api/v2/sla_configurations/)
	SlaConfigurationsCreate(ctx echo.Context) error

	// (DELETE /api/v2/sla_configurations/{id}/)
	SlaConfigurationsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/sla_configurations/{id}/)
	SlaConfigurationsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/sla_configurations/{id}/)
	SlaConfigurationsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/sla_configurations/{id}/)
	SlaConfigurationsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/sonarqube_issues/)
	SonarqubeIssuesList(ctx echo.Context, params SonarqubeIssuesListParams) error

	// (POST /api/v2/sonarqube_issues/)
	SonarqubeIssuesCreate(ctx echo.Context) error

	// (DELETE /api/v2/sonarqube_issues/{id}/)
	SonarqubeIssuesDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/sonarqube_issues/{id}/)
	SonarqubeIssuesRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/sonarqube_issues/{id}/)
	SonarqubeIssuesPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/sonarqube_issues/{id}/)
	SonarqubeIssuesUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/sonarqube_issues/{id}/delete_preview/)
	SonarqubeIssuesDeletePreviewList(ctx echo.Context, id int, params SonarqubeIssuesDeletePreviewListParams) error

	// (GET /api/v2/sonarqube_transitions/)
	SonarqubeTransitionsList(ctx echo.Context, params SonarqubeTransitionsListParams) error

	// (POST /api/v2/sonarqube_transitions/)
	SonarqubeTransitionsCreate(ctx echo.Context) error

	// (DELETE /api/v2/sonarqube_transitions/{id}/)
	SonarqubeTransitionsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/sonarqube_transitions/{id}/)
	SonarqubeTransitionsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/sonarqube_transitions/{id}/)
	SonarqubeTransitionsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/sonarqube_transitions/{id}/)
	SonarqubeTransitionsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/sonarqube_transitions/{id}/delete_preview/)
	SonarqubeTransitionsDeletePreviewList(ctx echo.Context, id int, params SonarqubeTransitionsDeletePreviewListParams) error

	// (GET /api/v2/stub_findings/)
	StubFindingsList(ctx echo.Context, params StubFindingsListParams) error

	// (POST /api/v2/stub_findings/)
	StubFindingsCreate(ctx echo.Context) error

	// (DELETE /api/v2/stub_findings/{id}/)
	StubFindingsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/stub_findings/{id}/)
	StubFindingsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/stub_findings/{id}/)
	StubFindingsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/stub_findings/{id}/)
	StubFindingsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/stub_findings/{id}/delete_preview/)
	StubFindingsDeletePreviewList(ctx echo.Context, id int, params StubFindingsDeletePreviewListParams) error

	// (GET /api/v2/system_settings/)
	SystemSettingsList(ctx echo.Context, params SystemSettingsListParams) error

	// (PATCH /api/v2/system_settings/{id}/)
	SystemSettingsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/system_settings/{id}/)
	SystemSettingsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/technologies/)
	TechnologiesList(ctx echo.Context, params TechnologiesListParams) error

	// (POST /api/v2/technologies/)
	TechnologiesCreate(ctx echo.Context) error

	// (DELETE /api/v2/technologies/{id}/)
	TechnologiesDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/technologies/{id}/)
	TechnologiesRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/technologies/{id}/)
	TechnologiesPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/technologies/{id}/)
	TechnologiesUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/technologies/{id}/delete_preview/)
	TechnologiesDeletePreviewList(ctx echo.Context, id int, params TechnologiesDeletePreviewListParams) error

	// (GET /api/v2/test_imports/)
	TestImportsList(ctx echo.Context, params TestImportsListParams) error

	// (POST /api/v2/test_imports/)
	TestImportsCreate(ctx echo.Context) error

	// (DELETE /api/v2/test_imports/{id}/)
	TestImportsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/test_imports/{id}/)
	TestImportsRetrieve(ctx echo.Context, id int, params TestImportsRetrieveParams) error

	// (PATCH /api/v2/test_imports/{id}/)
	TestImportsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/test_imports/{id}/)
	TestImportsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/test_imports/{id}/delete_preview/)
	TestImportsDeletePreviewList(ctx echo.Context, id int, params TestImportsDeletePreviewListParams) error

	// (GET /api/v2/test_types/)
	TestTypesList(ctx echo.Context, params TestTypesListParams) error

	// (POST /api/v2/test_types/)
	TestTypesCreate(ctx echo.Context) error

	// (GET /api/v2/test_types/{id}/)
	TestTypesRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/test_types/{id}/)
	TestTypesPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/test_types/{id}/)
	TestTypesUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/tests/)
	TestsList(ctx echo.Context, params TestsListParams) error

	// (POST /api/v2/tests/)
	TestsCreate(ctx echo.Context) error

	// (DELETE /api/v2/tests/{id}/)
	TestsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/tests/{id}/)
	TestsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/tests/{id}/)
	TestsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/tests/{id}/)
	TestsUpdate(ctx echo.Context, id int) error

	// (POST /api/v2/tests/{id}/accept_risks/)
	TestsAcceptRisksCreate(ctx echo.Context, id int) error

	// (GET /api/v2/tests/{id}/delete_preview/)
	TestsDeletePreviewList(ctx echo.Context, id int, params TestsDeletePreviewListParams) error

	// (GET /api/v2/tests/{id}/files/)
	TestsFilesRetrieve(ctx echo.Context, id int) error

	// (POST /api/v2/tests/{id}/files/)
	TestsFilesCreate(ctx echo.Context, id int) error

	// (POST /api/v2/tests/{id}/generate_report/)
	TestsGenerateReportCreate(ctx echo.Context, id int) error

	// (GET /api/v2/tests/{id}/notes/)
	TestsNotesRetrieve(ctx echo.Context, id int) error

	// (POST /api/v2/tests/{id}/notes/)
	TestsNotesCreate(ctx echo.Context, id int) error

	// (GET /api/v2/tool_configurations/)
	ToolConfigurationsList(ctx echo.Context, params ToolConfigurationsListParams) error

	// (POST /api/v2/tool_configurations/)
	ToolConfigurationsCreate(ctx echo.Context) error

	// (DELETE /api/v2/tool_configurations/{id}/)
	ToolConfigurationsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/tool_configurations/{id}/)
	ToolConfigurationsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/tool_configurations/{id}/)
	ToolConfigurationsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/tool_configurations/{id}/)
	ToolConfigurationsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/tool_configurations/{id}/delete_preview/)
	ToolConfigurationsDeletePreviewList(ctx echo.Context, id int, params ToolConfigurationsDeletePreviewListParams) error

	// (GET /api/v2/tool_product_settings/)
	ToolProductSettingsList(ctx echo.Context, params ToolProductSettingsListParams) error

	// (POST /api/v2/tool_product_settings/)
	ToolProductSettingsCreate(ctx echo.Context) error

	// (DELETE /api/v2/tool_product_settings/{id}/)
	ToolProductSettingsDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/tool_product_settings/{id}/)
	ToolProductSettingsRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/tool_product_settings/{id}/)
	ToolProductSettingsPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/tool_product_settings/{id}/)
	ToolProductSettingsUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/tool_product_settings/{id}/delete_preview/)
	ToolProductSettingsDeletePreviewList(ctx echo.Context, id int, params ToolProductSettingsDeletePreviewListParams) error

	// (GET /api/v2/tool_types/)
	ToolTypesList(ctx echo.Context, params ToolTypesListParams) error

	// (POST /api/v2/tool_types/)
	ToolTypesCreate(ctx echo.Context) error

	// (DELETE /api/v2/tool_types/{id}/)
	ToolTypesDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/tool_types/{id}/)
	ToolTypesRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/tool_types/{id}/)
	ToolTypesPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/tool_types/{id}/)
	ToolTypesUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/tool_types/{id}/delete_preview/)
	ToolTypesDeletePreviewList(ctx echo.Context, id int, params ToolTypesDeletePreviewListParams) error

	// (GET /api/v2/user_contact_infos/)
	UserContactInfosList(ctx echo.Context, params UserContactInfosListParams) error

	// (POST /api/v2/user_contact_infos/)
	UserContactInfosCreate(ctx echo.Context) error

	// (DELETE /api/v2/user_contact_infos/{id}/)
	UserContactInfosDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/user_contact_infos/{id}/)
	UserContactInfosRetrieve(ctx echo.Context, id int, params UserContactInfosRetrieveParams) error

	// (PATCH /api/v2/user_contact_infos/{id}/)
	UserContactInfosPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/user_contact_infos/{id}/)
	UserContactInfosUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/user_contact_infos/{id}/delete_preview/)
	UserContactInfosDeletePreviewList(ctx echo.Context, id int, params UserContactInfosDeletePreviewListParams) error

	// (GET /api/v2/user_profile/)
	UserProfileRetrieve(ctx echo.Context) error

	// (GET /api/v2/users/)
	UsersList(ctx echo.Context, params UsersListParams) error

	// (POST /api/v2/users/)
	UsersCreate(ctx echo.Context) error

	// (DELETE /api/v2/users/{id}/)
	UsersDestroy(ctx echo.Context, id int) error

	// (GET /api/v2/users/{id}/)
	UsersRetrieve(ctx echo.Context, id int) error

	// (PATCH /api/v2/users/{id}/)
	UsersPartialUpdate(ctx echo.Context, id int) error

	// (PUT /api/v2/users/{id}/)
	UsersUpdate(ctx echo.Context, id int) error

	// (GET /api/v2/users/{id}/delete_preview/)
	UsersDeletePreviewList(ctx echo.Context, id int, params UsersDeletePreviewListParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ApiTokenAuthCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ApiTokenAuthCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ApiTokenAuthCreate(ctx)
	return err
}

// ConfigurationPermissionsList converts echo context to params.
func (w *ServerInterfaceWrapper) ConfigurationPermissionsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ConfigurationPermissionsListParams
	// ------------- Optional query parameter "codename" -------------

	err = runtime.BindQueryParameter("form", true, false, "codename", ctx.QueryParams(), &params.Codename)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter codename: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConfigurationPermissionsList(ctx, params)
	return err
}

// ConfigurationPermissionsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) ConfigurationPermissionsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConfigurationPermissionsRetrieve(ctx, id)
	return err
}

// DevelopmentEnvironmentsList converts echo context to params.
func (w *ServerInterfaceWrapper) DevelopmentEnvironmentsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DevelopmentEnvironmentsListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DevelopmentEnvironmentsList(ctx, params)
	return err
}

// DevelopmentEnvironmentsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) DevelopmentEnvironmentsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DevelopmentEnvironmentsCreate(ctx)
	return err
}

// DevelopmentEnvironmentsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) DevelopmentEnvironmentsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DevelopmentEnvironmentsDestroy(ctx, id)
	return err
}

// DevelopmentEnvironmentsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) DevelopmentEnvironmentsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DevelopmentEnvironmentsRetrieve(ctx, id)
	return err
}

// DevelopmentEnvironmentsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) DevelopmentEnvironmentsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DevelopmentEnvironmentsPartialUpdate(ctx, id)
	return err
}

// DevelopmentEnvironmentsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) DevelopmentEnvironmentsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DevelopmentEnvironmentsUpdate(ctx, id)
	return err
}

// DevelopmentEnvironmentsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) DevelopmentEnvironmentsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DevelopmentEnvironmentsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DevelopmentEnvironmentsDeletePreviewList(ctx, id, params)
	return err
}

// DojoGroupMembersList converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupMembersList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DojoGroupMembersListParams
	// ------------- Optional query parameter "group_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group_id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group_id: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupMembersList(ctx, params)
	return err
}

// DojoGroupMembersCreate converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupMembersCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupMembersCreate(ctx)
	return err
}

// DojoGroupMembersDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupMembersDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupMembersDestroy(ctx, id)
	return err
}

// DojoGroupMembersRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupMembersRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DojoGroupMembersRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupMembersRetrieve(ctx, id, params)
	return err
}

// DojoGroupMembersPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupMembersPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupMembersPartialUpdate(ctx, id)
	return err
}

// DojoGroupMembersUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupMembersUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupMembersUpdate(ctx, id)
	return err
}

// DojoGroupMembersDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupMembersDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DojoGroupMembersDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupMembersDeletePreviewList(ctx, id, params)
	return err
}

// DojoGroupsList converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DojoGroupsListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "social_provider" -------------

	err = runtime.BindQueryParameter("form", true, false, "social_provider", ctx.QueryParams(), &params.SocialProvider)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter social_provider: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupsList(ctx, params)
	return err
}

// DojoGroupsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupsCreate(ctx)
	return err
}

// DojoGroupsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupsDestroy(ctx, id)
	return err
}

// DojoGroupsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DojoGroupsRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupsRetrieve(ctx, id, params)
	return err
}

// DojoGroupsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupsPartialUpdate(ctx, id)
	return err
}

// DojoGroupsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupsUpdate(ctx, id)
	return err
}

// DojoGroupsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) DojoGroupsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DojoGroupsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DojoGroupsDeletePreviewList(ctx, id, params)
	return err
}

// EndpointMetaImportCreate converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointMetaImportCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointMetaImportCreate(ctx)
	return err
}

// EndpointStatusList converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointStatusList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params EndpointStatusListParams
	// ------------- Optional query parameter "endpoint" -------------

	err = runtime.BindQueryParameter("form", true, false, "endpoint", ctx.QueryParams(), &params.Endpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endpoint: %s", err))
	}

	// ------------- Optional query parameter "false_positive" -------------

	err = runtime.BindQueryParameter("form", true, false, "false_positive", ctx.QueryParams(), &params.FalsePositive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter false_positive: %s", err))
	}

	// ------------- Optional query parameter "finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "finding", ctx.QueryParams(), &params.Finding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter finding: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "mitigated" -------------

	err = runtime.BindQueryParameter("form", true, false, "mitigated", ctx.QueryParams(), &params.Mitigated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mitigated: %s", err))
	}

	// ------------- Optional query parameter "mitigated_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "mitigated_by", ctx.QueryParams(), &params.MitigatedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mitigated_by: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "out_of_scope" -------------

	err = runtime.BindQueryParameter("form", true, false, "out_of_scope", ctx.QueryParams(), &params.OutOfScope)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter out_of_scope: %s", err))
	}

	// ------------- Optional query parameter "risk_accepted" -------------

	err = runtime.BindQueryParameter("form", true, false, "risk_accepted", ctx.QueryParams(), &params.RiskAccepted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter risk_accepted: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointStatusList(ctx, params)
	return err
}

// EndpointStatusCreate converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointStatusCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointStatusCreate(ctx)
	return err
}

// EndpointStatusDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointStatusDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointStatusDestroy(ctx, id)
	return err
}

// EndpointStatusRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointStatusRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointStatusRetrieve(ctx, id)
	return err
}

// EndpointStatusPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointStatusPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointStatusPartialUpdate(ctx, id)
	return err
}

// EndpointStatusUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointStatusUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointStatusUpdate(ctx, id)
	return err
}

// EndpointStatusDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointStatusDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params EndpointStatusDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointStatusDeletePreviewList(ctx, id, params)
	return err
}

// EndpointsList converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params EndpointsListParams
	// ------------- Optional query parameter "fragment" -------------

	err = runtime.BindQueryParameter("form", true, false, "fragment", ctx.QueryParams(), &params.Fragment)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fragment: %s", err))
	}

	// ------------- Optional query parameter "host" -------------

	err = runtime.BindQueryParameter("form", true, false, "host", ctx.QueryParams(), &params.Host)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter host: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "not_tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "not_tag", ctx.QueryParams(), &params.NotTag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tag: %s", err))
	}

	// ------------- Optional query parameter "not_tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_tags", ctx.QueryParams(), &params.NotTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tags: %s", err))
	}

	// ------------- Optional query parameter "o" -------------

	err = runtime.BindQueryParameter("form", false, false, "o", ctx.QueryParams(), &params.O)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter o: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, false, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// ------------- Optional query parameter "port" -------------

	err = runtime.BindQueryParameter("form", true, false, "port", ctx.QueryParams(), &params.Port)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter port: %s", err))
	}

	// ------------- Optional query parameter "product" -------------

	err = runtime.BindQueryParameter("form", true, false, "product", ctx.QueryParams(), &params.Product)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// ------------- Optional query parameter "protocol" -------------

	err = runtime.BindQueryParameter("form", true, false, "protocol", ctx.QueryParams(), &params.Protocol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter protocol: %s", err))
	}

	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "userinfo" -------------

	err = runtime.BindQueryParameter("form", true, false, "userinfo", ctx.QueryParams(), &params.Userinfo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userinfo: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointsList(ctx, params)
	return err
}

// EndpointsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointsCreate(ctx)
	return err
}

// EndpointsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointsDestroy(ctx, id)
	return err
}

// EndpointsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointsRetrieve(ctx, id)
	return err
}

// EndpointsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointsPartialUpdate(ctx, id)
	return err
}

// EndpointsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointsUpdate(ctx, id)
	return err
}

// EndpointsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params EndpointsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointsDeletePreviewList(ctx, id, params)
	return err
}

// EndpointsGenerateReportCreate converts echo context to params.
func (w *ServerInterfaceWrapper) EndpointsGenerateReportCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndpointsGenerateReportCreate(ctx, id)
	return err
}

// EngagementPresetsList converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementPresetsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params EngagementPresetsListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "product" -------------

	err = runtime.BindQueryParameter("form", true, false, "product", ctx.QueryParams(), &params.Product)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", ctx.QueryParams(), &params.Title)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementPresetsList(ctx, params)
	return err
}

// EngagementPresetsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementPresetsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementPresetsCreate(ctx)
	return err
}

// EngagementPresetsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementPresetsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementPresetsDestroy(ctx, id)
	return err
}

// EngagementPresetsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementPresetsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementPresetsRetrieve(ctx, id)
	return err
}

// EngagementPresetsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementPresetsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementPresetsPartialUpdate(ctx, id)
	return err
}

// EngagementPresetsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementPresetsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementPresetsUpdate(ctx, id)
	return err
}

// EngagementPresetsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementPresetsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params EngagementPresetsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementPresetsDeletePreviewList(ctx, id, params)
	return err
}

// EngagementsList converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params EngagementsListParams
	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", ctx.QueryParams(), &params.Active)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter active: %s", err))
	}

	// ------------- Optional query parameter "api_test" -------------

	err = runtime.BindQueryParameter("form", true, false, "api_test", ctx.QueryParams(), &params.ApiTest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter api_test: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "not_product__tags__name" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_product__tags__name", ctx.QueryParams(), &params.NotProductTagsName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_product__tags__name: %s", err))
	}

	// ------------- Optional query parameter "not_tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "not_tag", ctx.QueryParams(), &params.NotTag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tag: %s", err))
	}

	// ------------- Optional query parameter "not_tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_tags", ctx.QueryParams(), &params.NotTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tags: %s", err))
	}

	// ------------- Optional query parameter "o" -------------

	err = runtime.BindQueryParameter("form", false, false, "o", ctx.QueryParams(), &params.O)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter o: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "pen_test" -------------

	err = runtime.BindQueryParameter("form", true, false, "pen_test", ctx.QueryParams(), &params.PenTest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pen_test: %s", err))
	}

	// ------------- Optional query parameter "product" -------------

	err = runtime.BindQueryParameter("form", true, false, "product", ctx.QueryParams(), &params.Product)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// ------------- Optional query parameter "product__prod_type" -------------

	err = runtime.BindQueryParameter("form", false, false, "product__prod_type", ctx.QueryParams(), &params.ProductProdType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product__prod_type: %s", err))
	}

	// ------------- Optional query parameter "product__tags__name" -------------

	err = runtime.BindQueryParameter("form", false, false, "product__tags__name", ctx.QueryParams(), &params.ProductTagsName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product__tags__name: %s", err))
	}

	// ------------- Optional query parameter "report_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "report_type", ctx.QueryParams(), &params.ReportType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter report_type: %s", err))
	}

	// ------------- Optional query parameter "requester" -------------

	err = runtime.BindQueryParameter("form", true, false, "requester", ctx.QueryParams(), &params.Requester)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requester: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "target_end" -------------

	err = runtime.BindQueryParameter("form", true, false, "target_end", ctx.QueryParams(), &params.TargetEnd)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter target_end: %s", err))
	}

	// ------------- Optional query parameter "target_start" -------------

	err = runtime.BindQueryParameter("form", true, false, "target_start", ctx.QueryParams(), &params.TargetStart)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter target_start: %s", err))
	}

	// ------------- Optional query parameter "threat_model" -------------

	err = runtime.BindQueryParameter("form", true, false, "threat_model", ctx.QueryParams(), &params.ThreatModel)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter threat_model: %s", err))
	}

	// ------------- Optional query parameter "updated" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated", ctx.QueryParams(), &params.Updated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated: %s", err))
	}

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", ctx.QueryParams(), &params.Version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsList(ctx, params)
	return err
}

// EngagementsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsCreate(ctx)
	return err
}

// EngagementsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsDestroy(ctx, id)
	return err
}

// EngagementsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsRetrieve(ctx, id)
	return err
}

// EngagementsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsPartialUpdate(ctx, id)
	return err
}

// EngagementsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsUpdate(ctx, id)
	return err
}

// EngagementsAcceptRisksCreate converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsAcceptRisksCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsAcceptRisksCreate(ctx, id)
	return err
}

// EngagementsCloseCreate converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsCloseCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsCloseCreate(ctx, id)
	return err
}

// EngagementsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params EngagementsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsDeletePreviewList(ctx, id, params)
	return err
}

// EngagementsFilesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsFilesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsFilesRetrieve(ctx, id)
	return err
}

// EngagementsFilesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsFilesCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsFilesCreate(ctx, id)
	return err
}

// EngagementsGenerateReportCreate converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsGenerateReportCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsGenerateReportCreate(ctx, id)
	return err
}

// EngagementsNotesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsNotesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsNotesRetrieve(ctx, id)
	return err
}

// EngagementsNotesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsNotesCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsNotesCreate(ctx, id)
	return err
}

// EngagementsReopenCreate converts echo context to params.
func (w *ServerInterfaceWrapper) EngagementsReopenCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EngagementsReopenCreate(ctx, id)
	return err
}

// FindingTemplatesList converts echo context to params.
func (w *ServerInterfaceWrapper) FindingTemplatesList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindingTemplatesListParams
	// ------------- Optional query parameter "cwe" -------------

	err = runtime.BindQueryParameter("form", true, false, "cwe", ctx.QueryParams(), &params.Cwe)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cwe: %s", err))
	}

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "mitigation" -------------

	err = runtime.BindQueryParameter("form", true, false, "mitigation", ctx.QueryParams(), &params.Mitigation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mitigation: %s", err))
	}

	// ------------- Optional query parameter "not_tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "not_tag", ctx.QueryParams(), &params.NotTag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tag: %s", err))
	}

	// ------------- Optional query parameter "not_tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_tags", ctx.QueryParams(), &params.NotTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tags: %s", err))
	}

	// ------------- Optional query parameter "o" -------------

	err = runtime.BindQueryParameter("form", false, false, "o", ctx.QueryParams(), &params.O)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter o: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "severity" -------------

	err = runtime.BindQueryParameter("form", true, false, "severity", ctx.QueryParams(), &params.Severity)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter severity: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", ctx.QueryParams(), &params.Title)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingTemplatesList(ctx, params)
	return err
}

// FindingTemplatesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingTemplatesCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingTemplatesCreate(ctx)
	return err
}

// FindingTemplatesDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) FindingTemplatesDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingTemplatesDestroy(ctx, id)
	return err
}

// FindingTemplatesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) FindingTemplatesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingTemplatesRetrieve(ctx, id)
	return err
}

// FindingTemplatesPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingTemplatesPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingTemplatesPartialUpdate(ctx, id)
	return err
}

// FindingTemplatesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingTemplatesUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingTemplatesUpdate(ctx, id)
	return err
}

// FindingTemplatesDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) FindingTemplatesDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindingTemplatesDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingTemplatesDeletePreviewList(ctx, id, params)
	return err
}

// FindingsList converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindingsListParams
	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", ctx.QueryParams(), &params.Active)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter active: %s", err))
	}

	// ------------- Optional query parameter "component_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "component_name", ctx.QueryParams(), &params.ComponentName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter component_name: %s", err))
	}

	// ------------- Optional query parameter "component_version" -------------

	err = runtime.BindQueryParameter("form", true, false, "component_version", ctx.QueryParams(), &params.ComponentVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter component_version: %s", err))
	}

	// ------------- Optional query parameter "created" -------------

	err = runtime.BindQueryParameter("form", true, false, "created", ctx.QueryParams(), &params.Created)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created: %s", err))
	}

	// ------------- Optional query parameter "cvssv3" -------------

	err = runtime.BindQueryParameter("form", true, false, "cvssv3", ctx.QueryParams(), &params.Cvssv3)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cvssv3: %s", err))
	}

	// ------------- Optional query parameter "cvssv3_score" -------------

	err = runtime.BindQueryParameter("form", true, false, "cvssv3_score", ctx.QueryParams(), &params.Cvssv3Score)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cvssv3_score: %s", err))
	}

	// ------------- Optional query parameter "cwe" -------------

	err = runtime.BindQueryParameter("form", false, false, "cwe", ctx.QueryParams(), &params.Cwe)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cwe: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "defect_review_requested_by" -------------

	err = runtime.BindQueryParameter("form", false, false, "defect_review_requested_by", ctx.QueryParams(), &params.DefectReviewRequestedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter defect_review_requested_by: %s", err))
	}

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
	}

	// ------------- Optional query parameter "duplicate" -------------

	err = runtime.BindQueryParameter("form", true, false, "duplicate", ctx.QueryParams(), &params.Duplicate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duplicate: %s", err))
	}

	// ------------- Optional query parameter "duplicate_finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "duplicate_finding", ctx.QueryParams(), &params.DuplicateFinding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duplicate_finding: %s", err))
	}

	// ------------- Optional query parameter "dynamic_finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "dynamic_finding", ctx.QueryParams(), &params.DynamicFinding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dynamic_finding: %s", err))
	}

	// ------------- Optional query parameter "endpoints" -------------

	err = runtime.BindQueryParameter("form", false, false, "endpoints", ctx.QueryParams(), &params.Endpoints)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endpoints: %s", err))
	}

	// ------------- Optional query parameter "false_p" -------------

	err = runtime.BindQueryParameter("form", true, false, "false_p", ctx.QueryParams(), &params.FalseP)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter false_p: %s", err))
	}

	// ------------- Optional query parameter "file_path" -------------

	err = runtime.BindQueryParameter("form", true, false, "file_path", ctx.QueryParams(), &params.FilePath)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter file_path: %s", err))
	}

	// ------------- Optional query parameter "finding_group" -------------

	err = runtime.BindQueryParameter("form", false, false, "finding_group", ctx.QueryParams(), &params.FindingGroup)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter finding_group: %s", err))
	}

	// ------------- Optional query parameter "found_by" -------------

	err = runtime.BindQueryParameter("form", false, false, "found_by", ctx.QueryParams(), &params.FoundBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter found_by: %s", err))
	}

	// ------------- Optional query parameter "has_jira" -------------

	err = runtime.BindQueryParameter("form", true, false, "has_jira", ctx.QueryParams(), &params.HasJira)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter has_jira: %s", err))
	}

	// ------------- Optional query parameter "hash_code" -------------

	err = runtime.BindQueryParameter("form", true, false, "hash_code", ctx.QueryParams(), &params.HashCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hash_code: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "impact" -------------

	err = runtime.BindQueryParameter("form", true, false, "impact", ctx.QueryParams(), &params.Impact)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter impact: %s", err))
	}

	// ------------- Optional query parameter "is_mitigated" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_mitigated", ctx.QueryParams(), &params.IsMitigated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_mitigated: %s", err))
	}

	// ------------- Optional query parameter "jira_change" -------------

	err = runtime.BindQueryParameter("form", true, false, "jira_change", ctx.QueryParams(), &params.JiraChange)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jira_change: %s", err))
	}

	// ------------- Optional query parameter "jira_creation" -------------

	err = runtime.BindQueryParameter("form", true, false, "jira_creation", ctx.QueryParams(), &params.JiraCreation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jira_creation: %s", err))
	}

	// ------------- Optional query parameter "last_reviewed" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_reviewed", ctx.QueryParams(), &params.LastReviewed)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_reviewed: %s", err))
	}

	// ------------- Optional query parameter "last_reviewed_by" -------------

	err = runtime.BindQueryParameter("form", false, false, "last_reviewed_by", ctx.QueryParams(), &params.LastReviewedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_reviewed_by: %s", err))
	}

	// ------------- Optional query parameter "last_status_update" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_status_update", ctx.QueryParams(), &params.LastStatusUpdate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_status_update: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "mitigated" -------------

	err = runtime.BindQueryParameter("form", true, false, "mitigated", ctx.QueryParams(), &params.Mitigated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mitigated: %s", err))
	}

	// ------------- Optional query parameter "mitigated_by" -------------

	err = runtime.BindQueryParameter("form", false, false, "mitigated_by", ctx.QueryParams(), &params.MitigatedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mitigated_by: %s", err))
	}

	// ------------- Optional query parameter "mitigation" -------------

	err = runtime.BindQueryParameter("form", true, false, "mitigation", ctx.QueryParams(), &params.Mitigation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mitigation: %s", err))
	}

	// ------------- Optional query parameter "nb_occurences" -------------

	err = runtime.BindQueryParameter("form", false, false, "nb_occurences", ctx.QueryParams(), &params.NbOccurences)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nb_occurences: %s", err))
	}

	// ------------- Optional query parameter "not_tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "not_tag", ctx.QueryParams(), &params.NotTag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tag: %s", err))
	}

	// ------------- Optional query parameter "not_tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_tags", ctx.QueryParams(), &params.NotTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tags: %s", err))
	}

	// ------------- Optional query parameter "not_test__engagement__product__tags__name" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_test__engagement__product__tags__name", ctx.QueryParams(), &params.NotTestEngagementProductTagsName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_test__engagement__product__tags__name: %s", err))
	}

	// ------------- Optional query parameter "not_test__engagement__tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_test__engagement__tags", ctx.QueryParams(), &params.NotTestEngagementTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_test__engagement__tags: %s", err))
	}

	// ------------- Optional query parameter "not_test__tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_test__tags", ctx.QueryParams(), &params.NotTestTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_test__tags: %s", err))
	}

	// ------------- Optional query parameter "numerical_severity" -------------

	err = runtime.BindQueryParameter("form", true, false, "numerical_severity", ctx.QueryParams(), &params.NumericalSeverity)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter numerical_severity: %s", err))
	}

	// ------------- Optional query parameter "o" -------------

	err = runtime.BindQueryParameter("form", false, false, "o", ctx.QueryParams(), &params.O)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter o: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "out_of_scope" -------------

	err = runtime.BindQueryParameter("form", true, false, "out_of_scope", ctx.QueryParams(), &params.OutOfScope)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter out_of_scope: %s", err))
	}

	// ------------- Optional query parameter "param" -------------

	err = runtime.BindQueryParameter("form", true, false, "param", ctx.QueryParams(), &params.Param)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter param: %s", err))
	}

	// ------------- Optional query parameter "payload" -------------

	err = runtime.BindQueryParameter("form", true, false, "payload", ctx.QueryParams(), &params.Payload)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payload: %s", err))
	}

	// ------------- Optional query parameter "planned_remediation_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "planned_remediation_date", ctx.QueryParams(), &params.PlannedRemediationDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter planned_remediation_date: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "publish_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "publish_date", ctx.QueryParams(), &params.PublishDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter publish_date: %s", err))
	}

	// ------------- Optional query parameter "references" -------------

	err = runtime.BindQueryParameter("form", true, false, "references", ctx.QueryParams(), &params.References)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter references: %s", err))
	}

	// ------------- Optional query parameter "related_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "related_fields", ctx.QueryParams(), &params.RelatedFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter related_fields: %s", err))
	}

	// ------------- Optional query parameter "reporter" -------------

	err = runtime.BindQueryParameter("form", false, false, "reporter", ctx.QueryParams(), &params.Reporter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reporter: %s", err))
	}

	// ------------- Optional query parameter "review_requested_by" -------------

	err = runtime.BindQueryParameter("form", false, false, "review_requested_by", ctx.QueryParams(), &params.ReviewRequestedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter review_requested_by: %s", err))
	}

	// ------------- Optional query parameter "reviewers" -------------

	err = runtime.BindQueryParameter("form", false, false, "reviewers", ctx.QueryParams(), &params.Reviewers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reviewers: %s", err))
	}

	// ------------- Optional query parameter "risk_acceptance" -------------

	err = runtime.BindQueryParameter("form", true, false, "risk_acceptance", ctx.QueryParams(), &params.RiskAcceptance)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter risk_acceptance: %s", err))
	}

	// ------------- Optional query parameter "risk_accepted" -------------

	err = runtime.BindQueryParameter("form", true, false, "risk_accepted", ctx.QueryParams(), &params.RiskAccepted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter risk_accepted: %s", err))
	}

	// ------------- Optional query parameter "sast_sink_object" -------------

	err = runtime.BindQueryParameter("form", true, false, "sast_sink_object", ctx.QueryParams(), &params.SastSinkObject)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sast_sink_object: %s", err))
	}

	// ------------- Optional query parameter "sast_source_file_path" -------------

	err = runtime.BindQueryParameter("form", true, false, "sast_source_file_path", ctx.QueryParams(), &params.SastSourceFilePath)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sast_source_file_path: %s", err))
	}

	// ------------- Optional query parameter "sast_source_line" -------------

	err = runtime.BindQueryParameter("form", false, false, "sast_source_line", ctx.QueryParams(), &params.SastSourceLine)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sast_source_line: %s", err))
	}

	// ------------- Optional query parameter "sast_source_object" -------------

	err = runtime.BindQueryParameter("form", true, false, "sast_source_object", ctx.QueryParams(), &params.SastSourceObject)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sast_source_object: %s", err))
	}

	// ------------- Optional query parameter "scanner_confidence" -------------

	err = runtime.BindQueryParameter("form", false, false, "scanner_confidence", ctx.QueryParams(), &params.ScannerConfidence)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanner_confidence: %s", err))
	}

	// ------------- Optional query parameter "service" -------------

	err = runtime.BindQueryParameter("form", true, false, "service", ctx.QueryParams(), &params.Service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// ------------- Optional query parameter "severity" -------------

	err = runtime.BindQueryParameter("form", true, false, "severity", ctx.QueryParams(), &params.Severity)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter severity: %s", err))
	}

	// ------------- Optional query parameter "severity_justification" -------------

	err = runtime.BindQueryParameter("form", true, false, "severity_justification", ctx.QueryParams(), &params.SeverityJustification)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter severity_justification: %s", err))
	}

	// ------------- Optional query parameter "sla_start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "sla_start_date", ctx.QueryParams(), &params.SlaStartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sla_start_date: %s", err))
	}

	// ------------- Optional query parameter "sonarqube_issue" -------------

	err = runtime.BindQueryParameter("form", false, false, "sonarqube_issue", ctx.QueryParams(), &params.SonarqubeIssue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sonarqube_issue: %s", err))
	}

	// ------------- Optional query parameter "static_finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "static_finding", ctx.QueryParams(), &params.StaticFinding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter static_finding: %s", err))
	}

	// ------------- Optional query parameter "steps_to_reproduce" -------------

	err = runtime.BindQueryParameter("form", true, false, "steps_to_reproduce", ctx.QueryParams(), &params.StepsToReproduce)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter steps_to_reproduce: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "test" -------------

	err = runtime.BindQueryParameter("form", true, false, "test", ctx.QueryParams(), &params.Test)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test: %s", err))
	}

	// ------------- Optional query parameter "test__engagement" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__engagement", ctx.QueryParams(), &params.TestEngagement)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__engagement: %s", err))
	}

	// ------------- Optional query parameter "test__engagement__product" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__engagement__product", ctx.QueryParams(), &params.TestEngagementProduct)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__engagement__product: %s", err))
	}

	// ------------- Optional query parameter "test__engagement__product__prod_type" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__engagement__product__prod_type", ctx.QueryParams(), &params.TestEngagementProductProdType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__engagement__product__prod_type: %s", err))
	}

	// ------------- Optional query parameter "test__engagement__product__tags__name" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__engagement__product__tags__name", ctx.QueryParams(), &params.TestEngagementProductTagsName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__engagement__product__tags__name: %s", err))
	}

	// ------------- Optional query parameter "test__engagement__tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__engagement__tags", ctx.QueryParams(), &params.TestEngagementTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__engagement__tags: %s", err))
	}

	// ------------- Optional query parameter "test__tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__tags", ctx.QueryParams(), &params.TestTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__tags: %s", err))
	}

	// ------------- Optional query parameter "test__test_type" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__test_type", ctx.QueryParams(), &params.TestTestType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__test_type: %s", err))
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", ctx.QueryParams(), &params.Title)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
	}

	// ------------- Optional query parameter "under_defect_review" -------------

	err = runtime.BindQueryParameter("form", true, false, "under_defect_review", ctx.QueryParams(), &params.UnderDefectReview)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter under_defect_review: %s", err))
	}

	// ------------- Optional query parameter "under_review" -------------

	err = runtime.BindQueryParameter("form", true, false, "under_review", ctx.QueryParams(), &params.UnderReview)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter under_review: %s", err))
	}

	// ------------- Optional query parameter "unique_id_from_tool" -------------

	err = runtime.BindQueryParameter("form", true, false, "unique_id_from_tool", ctx.QueryParams(), &params.UniqueIdFromTool)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unique_id_from_tool: %s", err))
	}

	// ------------- Optional query parameter "verified" -------------

	err = runtime.BindQueryParameter("form", true, false, "verified", ctx.QueryParams(), &params.Verified)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter verified: %s", err))
	}

	// ------------- Optional query parameter "vuln_id_from_tool" -------------

	err = runtime.BindQueryParameter("form", true, false, "vuln_id_from_tool", ctx.QueryParams(), &params.VulnIdFromTool)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vuln_id_from_tool: %s", err))
	}

	// ------------- Optional query parameter "vulnerability_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "vulnerability_id", ctx.QueryParams(), &params.VulnerabilityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vulnerability_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsList(ctx, params)
	return err
}

// FindingsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsCreate(ctx)
	return err
}

// FindingsAcceptRisksCreate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsAcceptRisksCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindingsAcceptRisksCreateParams
	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", ctx.QueryParams(), &params.Active)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter active: %s", err))
	}

	// ------------- Optional query parameter "component_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "component_name", ctx.QueryParams(), &params.ComponentName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter component_name: %s", err))
	}

	// ------------- Optional query parameter "component_version" -------------

	err = runtime.BindQueryParameter("form", true, false, "component_version", ctx.QueryParams(), &params.ComponentVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter component_version: %s", err))
	}

	// ------------- Optional query parameter "created" -------------

	err = runtime.BindQueryParameter("form", true, false, "created", ctx.QueryParams(), &params.Created)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created: %s", err))
	}

	// ------------- Optional query parameter "cvssv3" -------------

	err = runtime.BindQueryParameter("form", true, false, "cvssv3", ctx.QueryParams(), &params.Cvssv3)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cvssv3: %s", err))
	}

	// ------------- Optional query parameter "cvssv3_score" -------------

	err = runtime.BindQueryParameter("form", true, false, "cvssv3_score", ctx.QueryParams(), &params.Cvssv3Score)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cvssv3_score: %s", err))
	}

	// ------------- Optional query parameter "cwe" -------------

	err = runtime.BindQueryParameter("form", false, false, "cwe", ctx.QueryParams(), &params.Cwe)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cwe: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "defect_review_requested_by" -------------

	err = runtime.BindQueryParameter("form", false, false, "defect_review_requested_by", ctx.QueryParams(), &params.DefectReviewRequestedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter defect_review_requested_by: %s", err))
	}

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
	}

	// ------------- Optional query parameter "duplicate" -------------

	err = runtime.BindQueryParameter("form", true, false, "duplicate", ctx.QueryParams(), &params.Duplicate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duplicate: %s", err))
	}

	// ------------- Optional query parameter "duplicate_finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "duplicate_finding", ctx.QueryParams(), &params.DuplicateFinding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duplicate_finding: %s", err))
	}

	// ------------- Optional query parameter "dynamic_finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "dynamic_finding", ctx.QueryParams(), &params.DynamicFinding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dynamic_finding: %s", err))
	}

	// ------------- Optional query parameter "endpoints" -------------

	err = runtime.BindQueryParameter("form", false, false, "endpoints", ctx.QueryParams(), &params.Endpoints)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endpoints: %s", err))
	}

	// ------------- Optional query parameter "false_p" -------------

	err = runtime.BindQueryParameter("form", true, false, "false_p", ctx.QueryParams(), &params.FalseP)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter false_p: %s", err))
	}

	// ------------- Optional query parameter "file_path" -------------

	err = runtime.BindQueryParameter("form", true, false, "file_path", ctx.QueryParams(), &params.FilePath)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter file_path: %s", err))
	}

	// ------------- Optional query parameter "finding_group" -------------

	err = runtime.BindQueryParameter("form", false, false, "finding_group", ctx.QueryParams(), &params.FindingGroup)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter finding_group: %s", err))
	}

	// ------------- Optional query parameter "found_by" -------------

	err = runtime.BindQueryParameter("form", false, false, "found_by", ctx.QueryParams(), &params.FoundBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter found_by: %s", err))
	}

	// ------------- Optional query parameter "has_jira" -------------

	err = runtime.BindQueryParameter("form", true, false, "has_jira", ctx.QueryParams(), &params.HasJira)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter has_jira: %s", err))
	}

	// ------------- Optional query parameter "hash_code" -------------

	err = runtime.BindQueryParameter("form", true, false, "hash_code", ctx.QueryParams(), &params.HashCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hash_code: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "impact" -------------

	err = runtime.BindQueryParameter("form", true, false, "impact", ctx.QueryParams(), &params.Impact)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter impact: %s", err))
	}

	// ------------- Optional query parameter "is_mitigated" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_mitigated", ctx.QueryParams(), &params.IsMitigated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_mitigated: %s", err))
	}

	// ------------- Optional query parameter "jira_change" -------------

	err = runtime.BindQueryParameter("form", true, false, "jira_change", ctx.QueryParams(), &params.JiraChange)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jira_change: %s", err))
	}

	// ------------- Optional query parameter "jira_creation" -------------

	err = runtime.BindQueryParameter("form", true, false, "jira_creation", ctx.QueryParams(), &params.JiraCreation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jira_creation: %s", err))
	}

	// ------------- Optional query parameter "last_reviewed" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_reviewed", ctx.QueryParams(), &params.LastReviewed)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_reviewed: %s", err))
	}

	// ------------- Optional query parameter "last_reviewed_by" -------------

	err = runtime.BindQueryParameter("form", false, false, "last_reviewed_by", ctx.QueryParams(), &params.LastReviewedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_reviewed_by: %s", err))
	}

	// ------------- Optional query parameter "last_status_update" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_status_update", ctx.QueryParams(), &params.LastStatusUpdate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_status_update: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "mitigated" -------------

	err = runtime.BindQueryParameter("form", true, false, "mitigated", ctx.QueryParams(), &params.Mitigated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mitigated: %s", err))
	}

	// ------------- Optional query parameter "mitigated_by" -------------

	err = runtime.BindQueryParameter("form", false, false, "mitigated_by", ctx.QueryParams(), &params.MitigatedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mitigated_by: %s", err))
	}

	// ------------- Optional query parameter "mitigation" -------------

	err = runtime.BindQueryParameter("form", true, false, "mitigation", ctx.QueryParams(), &params.Mitigation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mitigation: %s", err))
	}

	// ------------- Optional query parameter "nb_occurences" -------------

	err = runtime.BindQueryParameter("form", false, false, "nb_occurences", ctx.QueryParams(), &params.NbOccurences)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nb_occurences: %s", err))
	}

	// ------------- Optional query parameter "not_tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "not_tag", ctx.QueryParams(), &params.NotTag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tag: %s", err))
	}

	// ------------- Optional query parameter "not_tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_tags", ctx.QueryParams(), &params.NotTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tags: %s", err))
	}

	// ------------- Optional query parameter "not_test__engagement__product__tags__name" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_test__engagement__product__tags__name", ctx.QueryParams(), &params.NotTestEngagementProductTagsName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_test__engagement__product__tags__name: %s", err))
	}

	// ------------- Optional query parameter "not_test__engagement__tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_test__engagement__tags", ctx.QueryParams(), &params.NotTestEngagementTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_test__engagement__tags: %s", err))
	}

	// ------------- Optional query parameter "not_test__tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_test__tags", ctx.QueryParams(), &params.NotTestTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_test__tags: %s", err))
	}

	// ------------- Optional query parameter "numerical_severity" -------------

	err = runtime.BindQueryParameter("form", true, false, "numerical_severity", ctx.QueryParams(), &params.NumericalSeverity)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter numerical_severity: %s", err))
	}

	// ------------- Optional query parameter "o" -------------

	err = runtime.BindQueryParameter("form", false, false, "o", ctx.QueryParams(), &params.O)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter o: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "out_of_scope" -------------

	err = runtime.BindQueryParameter("form", true, false, "out_of_scope", ctx.QueryParams(), &params.OutOfScope)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter out_of_scope: %s", err))
	}

	// ------------- Optional query parameter "param" -------------

	err = runtime.BindQueryParameter("form", true, false, "param", ctx.QueryParams(), &params.Param)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter param: %s", err))
	}

	// ------------- Optional query parameter "payload" -------------

	err = runtime.BindQueryParameter("form", true, false, "payload", ctx.QueryParams(), &params.Payload)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payload: %s", err))
	}

	// ------------- Optional query parameter "planned_remediation_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "planned_remediation_date", ctx.QueryParams(), &params.PlannedRemediationDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter planned_remediation_date: %s", err))
	}

	// ------------- Optional query parameter "publish_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "publish_date", ctx.QueryParams(), &params.PublishDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter publish_date: %s", err))
	}

	// ------------- Optional query parameter "references" -------------

	err = runtime.BindQueryParameter("form", true, false, "references", ctx.QueryParams(), &params.References)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter references: %s", err))
	}

	// ------------- Optional query parameter "reporter" -------------

	err = runtime.BindQueryParameter("form", false, false, "reporter", ctx.QueryParams(), &params.Reporter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reporter: %s", err))
	}

	// ------------- Optional query parameter "review_requested_by" -------------

	err = runtime.BindQueryParameter("form", false, false, "review_requested_by", ctx.QueryParams(), &params.ReviewRequestedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter review_requested_by: %s", err))
	}

	// ------------- Optional query parameter "reviewers" -------------

	err = runtime.BindQueryParameter("form", false, false, "reviewers", ctx.QueryParams(), &params.Reviewers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reviewers: %s", err))
	}

	// ------------- Optional query parameter "risk_acceptance" -------------

	err = runtime.BindQueryParameter("form", true, false, "risk_acceptance", ctx.QueryParams(), &params.RiskAcceptance)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter risk_acceptance: %s", err))
	}

	// ------------- Optional query parameter "risk_accepted" -------------

	err = runtime.BindQueryParameter("form", true, false, "risk_accepted", ctx.QueryParams(), &params.RiskAccepted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter risk_accepted: %s", err))
	}

	// ------------- Optional query parameter "sast_sink_object" -------------

	err = runtime.BindQueryParameter("form", true, false, "sast_sink_object", ctx.QueryParams(), &params.SastSinkObject)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sast_sink_object: %s", err))
	}

	// ------------- Optional query parameter "sast_source_file_path" -------------

	err = runtime.BindQueryParameter("form", true, false, "sast_source_file_path", ctx.QueryParams(), &params.SastSourceFilePath)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sast_source_file_path: %s", err))
	}

	// ------------- Optional query parameter "sast_source_line" -------------

	err = runtime.BindQueryParameter("form", false, false, "sast_source_line", ctx.QueryParams(), &params.SastSourceLine)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sast_source_line: %s", err))
	}

	// ------------- Optional query parameter "sast_source_object" -------------

	err = runtime.BindQueryParameter("form", true, false, "sast_source_object", ctx.QueryParams(), &params.SastSourceObject)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sast_source_object: %s", err))
	}

	// ------------- Optional query parameter "scanner_confidence" -------------

	err = runtime.BindQueryParameter("form", false, false, "scanner_confidence", ctx.QueryParams(), &params.ScannerConfidence)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanner_confidence: %s", err))
	}

	// ------------- Optional query parameter "service" -------------

	err = runtime.BindQueryParameter("form", true, false, "service", ctx.QueryParams(), &params.Service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// ------------- Optional query parameter "severity" -------------

	err = runtime.BindQueryParameter("form", true, false, "severity", ctx.QueryParams(), &params.Severity)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter severity: %s", err))
	}

	// ------------- Optional query parameter "severity_justification" -------------

	err = runtime.BindQueryParameter("form", true, false, "severity_justification", ctx.QueryParams(), &params.SeverityJustification)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter severity_justification: %s", err))
	}

	// ------------- Optional query parameter "sla_start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "sla_start_date", ctx.QueryParams(), &params.SlaStartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sla_start_date: %s", err))
	}

	// ------------- Optional query parameter "sonarqube_issue" -------------

	err = runtime.BindQueryParameter("form", false, false, "sonarqube_issue", ctx.QueryParams(), &params.SonarqubeIssue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sonarqube_issue: %s", err))
	}

	// ------------- Optional query parameter "static_finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "static_finding", ctx.QueryParams(), &params.StaticFinding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter static_finding: %s", err))
	}

	// ------------- Optional query parameter "steps_to_reproduce" -------------

	err = runtime.BindQueryParameter("form", true, false, "steps_to_reproduce", ctx.QueryParams(), &params.StepsToReproduce)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter steps_to_reproduce: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "test" -------------

	err = runtime.BindQueryParameter("form", true, false, "test", ctx.QueryParams(), &params.Test)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test: %s", err))
	}

	// ------------- Optional query parameter "test__engagement" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__engagement", ctx.QueryParams(), &params.TestEngagement)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__engagement: %s", err))
	}

	// ------------- Optional query parameter "test__engagement__product" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__engagement__product", ctx.QueryParams(), &params.TestEngagementProduct)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__engagement__product: %s", err))
	}

	// ------------- Optional query parameter "test__engagement__product__prod_type" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__engagement__product__prod_type", ctx.QueryParams(), &params.TestEngagementProductProdType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__engagement__product__prod_type: %s", err))
	}

	// ------------- Optional query parameter "test__engagement__product__tags__name" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__engagement__product__tags__name", ctx.QueryParams(), &params.TestEngagementProductTagsName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__engagement__product__tags__name: %s", err))
	}

	// ------------- Optional query parameter "test__engagement__tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__engagement__tags", ctx.QueryParams(), &params.TestEngagementTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__engagement__tags: %s", err))
	}

	// ------------- Optional query parameter "test__tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__tags", ctx.QueryParams(), &params.TestTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__tags: %s", err))
	}

	// ------------- Optional query parameter "test__test_type" -------------

	err = runtime.BindQueryParameter("form", false, false, "test__test_type", ctx.QueryParams(), &params.TestTestType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test__test_type: %s", err))
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", ctx.QueryParams(), &params.Title)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
	}

	// ------------- Optional query parameter "under_defect_review" -------------

	err = runtime.BindQueryParameter("form", true, false, "under_defect_review", ctx.QueryParams(), &params.UnderDefectReview)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter under_defect_review: %s", err))
	}

	// ------------- Optional query parameter "under_review" -------------

	err = runtime.BindQueryParameter("form", true, false, "under_review", ctx.QueryParams(), &params.UnderReview)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter under_review: %s", err))
	}

	// ------------- Optional query parameter "unique_id_from_tool" -------------

	err = runtime.BindQueryParameter("form", true, false, "unique_id_from_tool", ctx.QueryParams(), &params.UniqueIdFromTool)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unique_id_from_tool: %s", err))
	}

	// ------------- Optional query parameter "verified" -------------

	err = runtime.BindQueryParameter("form", true, false, "verified", ctx.QueryParams(), &params.Verified)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter verified: %s", err))
	}

	// ------------- Optional query parameter "vuln_id_from_tool" -------------

	err = runtime.BindQueryParameter("form", true, false, "vuln_id_from_tool", ctx.QueryParams(), &params.VulnIdFromTool)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vuln_id_from_tool: %s", err))
	}

	// ------------- Optional query parameter "vulnerability_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "vulnerability_id", ctx.QueryParams(), &params.VulnerabilityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vulnerability_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsAcceptRisksCreate(ctx, params)
	return err
}

// FindingsGenerateReportCreate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsGenerateReportCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsGenerateReportCreate(ctx)
	return err
}

// FindingsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsDestroy(ctx, id)
	return err
}

// FindingsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindingsRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "related_fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "related_fields", ctx.QueryParams(), &params.RelatedFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter related_fields: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsRetrieve(ctx, id, params)
	return err
}

// FindingsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsPartialUpdate(ctx, id)
	return err
}

// FindingsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsUpdate(ctx, id)
	return err
}

// FindingsCloseCreate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsCloseCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsCloseCreate(ctx, id)
	return err
}

// FindingsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindingsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsDeletePreviewList(ctx, id, params)
	return err
}

// FindingsDuplicateList converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsDuplicateList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsDuplicateList(ctx, id)
	return err
}

// FindingsDuplicateResetCreate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsDuplicateResetCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsDuplicateResetCreate(ctx, id)
	return err
}

// FindingsFilesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsFilesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsFilesRetrieve(ctx, id)
	return err
}

// FindingsFilesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsFilesCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsFilesCreate(ctx, id)
	return err
}

// FindingsMetadataDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsMetadataDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindingsMetadataDestroyParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsMetadataDestroy(ctx, id, params)
	return err
}

// FindingsMetadataList converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsMetadataList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsMetadataList(ctx, id)
	return err
}

// FindingsMetadataCreate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsMetadataCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsMetadataCreate(ctx, id)
	return err
}

// FindingsMetadataUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsMetadataUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsMetadataUpdate(ctx, id)
	return err
}

// FindingsNotesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsNotesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsNotesRetrieve(ctx, id)
	return err
}

// FindingsNotesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsNotesCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsNotesCreate(ctx, id)
	return err
}

// FindingsOriginalCreate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsOriginalCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "new_fid" -------------
	var newFid int

	err = runtime.BindStyledParameterWithLocation("simple", false, "new_fid", runtime.ParamLocationPath, ctx.Param("new_fid"), &newFid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter new_fid: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsOriginalCreate(ctx, id, newFid)
	return err
}

// FindingsRemoveNotePartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsRemoveNotePartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsRemoveNotePartialUpdate(ctx, id)
	return err
}

// FindingsRemoveTagsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsRemoveTagsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsRemoveTagsPartialUpdate(ctx, id)
	return err
}

// FindingsRemoveTagsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsRemoveTagsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsRemoveTagsUpdate(ctx, id)
	return err
}

// FindingsRequestResponseRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsRequestResponseRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsRequestResponseRetrieve(ctx, id)
	return err
}

// FindingsRequestResponseCreate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsRequestResponseCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsRequestResponseCreate(ctx, id)
	return err
}

// FindingsTagsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsTagsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsTagsRetrieve(ctx, id)
	return err
}

// FindingsTagsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) FindingsTagsCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindingsTagsCreate(ctx, id)
	return err
}

// GlobalRolesList converts echo context to params.
func (w *ServerInterfaceWrapper) GlobalRolesList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GlobalRolesListParams
	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", ctx.QueryParams(), &params.Role)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter role: %s", err))
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", true, false, "user", ctx.QueryParams(), &params.User)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GlobalRolesList(ctx, params)
	return err
}

// GlobalRolesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) GlobalRolesCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GlobalRolesCreate(ctx)
	return err
}

// GlobalRolesDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) GlobalRolesDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GlobalRolesDestroy(ctx, id)
	return err
}

// GlobalRolesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) GlobalRolesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GlobalRolesRetrieve(ctx, id)
	return err
}

// GlobalRolesPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) GlobalRolesPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GlobalRolesPartialUpdate(ctx, id)
	return err
}

// GlobalRolesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) GlobalRolesUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GlobalRolesUpdate(ctx, id)
	return err
}

// GlobalRolesDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) GlobalRolesDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GlobalRolesDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GlobalRolesDeletePreviewList(ctx, id, params)
	return err
}

// ImportLanguagesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ImportLanguagesCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ImportLanguagesCreate(ctx)
	return err
}

// ImportScanCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ImportScanCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ImportScanCreate(ctx)
	return err
}

// JiraConfigurationsList converts echo context to params.
func (w *ServerInterfaceWrapper) JiraConfigurationsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params JiraConfigurationsListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "url" -------------

	err = runtime.BindQueryParameter("form", true, false, "url", ctx.QueryParams(), &params.Url)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter url: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraConfigurationsList(ctx, params)
	return err
}

// JiraConfigurationsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraConfigurationsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraConfigurationsCreate(ctx)
	return err
}

// JiraConfigurationsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) JiraConfigurationsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraConfigurationsDestroy(ctx, id)
	return err
}

// JiraConfigurationsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) JiraConfigurationsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraConfigurationsRetrieve(ctx, id)
	return err
}

// JiraConfigurationsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraConfigurationsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraConfigurationsPartialUpdate(ctx, id)
	return err
}

// JiraConfigurationsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraConfigurationsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraConfigurationsUpdate(ctx, id)
	return err
}

// JiraConfigurationsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) JiraConfigurationsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params JiraConfigurationsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraConfigurationsDeletePreviewList(ctx, id, params)
	return err
}

// JiraFindingMappingsList converts echo context to params.
func (w *ServerInterfaceWrapper) JiraFindingMappingsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params JiraFindingMappingsListParams
	// ------------- Optional query parameter "engagement" -------------

	err = runtime.BindQueryParameter("form", true, false, "engagement", ctx.QueryParams(), &params.Engagement)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter engagement: %s", err))
	}

	// ------------- Optional query parameter "finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "finding", ctx.QueryParams(), &params.Finding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter finding: %s", err))
	}

	// ------------- Optional query parameter "finding_group" -------------

	err = runtime.BindQueryParameter("form", true, false, "finding_group", ctx.QueryParams(), &params.FindingGroup)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter finding_group: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "jira_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "jira_id", ctx.QueryParams(), &params.JiraId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jira_id: %s", err))
	}

	// ------------- Optional query parameter "jira_key" -------------

	err = runtime.BindQueryParameter("form", true, false, "jira_key", ctx.QueryParams(), &params.JiraKey)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jira_key: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraFindingMappingsList(ctx, params)
	return err
}

// JiraFindingMappingsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraFindingMappingsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraFindingMappingsCreate(ctx)
	return err
}

// JiraFindingMappingsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) JiraFindingMappingsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraFindingMappingsDestroy(ctx, id)
	return err
}

// JiraFindingMappingsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) JiraFindingMappingsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraFindingMappingsRetrieve(ctx, id)
	return err
}

// JiraFindingMappingsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraFindingMappingsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraFindingMappingsPartialUpdate(ctx, id)
	return err
}

// JiraFindingMappingsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraFindingMappingsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraFindingMappingsUpdate(ctx, id)
	return err
}

// JiraFindingMappingsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) JiraFindingMappingsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params JiraFindingMappingsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraFindingMappingsDeletePreviewList(ctx, id, params)
	return err
}

// JiraInstancesList converts echo context to params.
func (w *ServerInterfaceWrapper) JiraInstancesList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params JiraInstancesListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "url" -------------

	err = runtime.BindQueryParameter("form", true, false, "url", ctx.QueryParams(), &params.Url)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter url: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraInstancesList(ctx, params)
	return err
}

// JiraInstancesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraInstancesCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraInstancesCreate(ctx)
	return err
}

// JiraInstancesDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) JiraInstancesDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraInstancesDestroy(ctx, id)
	return err
}

// JiraInstancesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) JiraInstancesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraInstancesRetrieve(ctx, id)
	return err
}

// JiraInstancesPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraInstancesPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraInstancesPartialUpdate(ctx, id)
	return err
}

// JiraInstancesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraInstancesUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraInstancesUpdate(ctx, id)
	return err
}

// JiraInstancesDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) JiraInstancesDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params JiraInstancesDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraInstancesDeletePreviewList(ctx, id, params)
	return err
}

// JiraProductConfigurationsList converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProductConfigurationsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params JiraProductConfigurationsListParams
	// ------------- Optional query parameter "component" -------------

	err = runtime.BindQueryParameter("form", true, false, "component", ctx.QueryParams(), &params.Component)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter component: %s", err))
	}

	// ------------- Optional query parameter "enable_engagement_epic_mapping" -------------

	err = runtime.BindQueryParameter("form", true, false, "enable_engagement_epic_mapping", ctx.QueryParams(), &params.EnableEngagementEpicMapping)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter enable_engagement_epic_mapping: %s", err))
	}

	// ------------- Optional query parameter "engagement" -------------

	err = runtime.BindQueryParameter("form", true, false, "engagement", ctx.QueryParams(), &params.Engagement)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter engagement: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "jira_instance" -------------

	err = runtime.BindQueryParameter("form", true, false, "jira_instance", ctx.QueryParams(), &params.JiraInstance)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jira_instance: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "product" -------------

	err = runtime.BindQueryParameter("form", true, false, "product", ctx.QueryParams(), &params.Product)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// ------------- Optional query parameter "project_key" -------------

	err = runtime.BindQueryParameter("form", true, false, "project_key", ctx.QueryParams(), &params.ProjectKey)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_key: %s", err))
	}

	// ------------- Optional query parameter "push_all_issues" -------------

	err = runtime.BindQueryParameter("form", true, false, "push_all_issues", ctx.QueryParams(), &params.PushAllIssues)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter push_all_issues: %s", err))
	}

	// ------------- Optional query parameter "push_notes" -------------

	err = runtime.BindQueryParameter("form", true, false, "push_notes", ctx.QueryParams(), &params.PushNotes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter push_notes: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProductConfigurationsList(ctx, params)
	return err
}

// JiraProductConfigurationsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProductConfigurationsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProductConfigurationsCreate(ctx)
	return err
}

// JiraProductConfigurationsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProductConfigurationsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProductConfigurationsDestroy(ctx, id)
	return err
}

// JiraProductConfigurationsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProductConfigurationsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProductConfigurationsRetrieve(ctx, id)
	return err
}

// JiraProductConfigurationsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProductConfigurationsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProductConfigurationsPartialUpdate(ctx, id)
	return err
}

// JiraProductConfigurationsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProductConfigurationsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProductConfigurationsUpdate(ctx, id)
	return err
}

// JiraProductConfigurationsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProductConfigurationsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params JiraProductConfigurationsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProductConfigurationsDeletePreviewList(ctx, id, params)
	return err
}

// JiraProjectsList converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProjectsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params JiraProjectsListParams
	// ------------- Optional query parameter "component" -------------

	err = runtime.BindQueryParameter("form", true, false, "component", ctx.QueryParams(), &params.Component)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter component: %s", err))
	}

	// ------------- Optional query parameter "enable_engagement_epic_mapping" -------------

	err = runtime.BindQueryParameter("form", true, false, "enable_engagement_epic_mapping", ctx.QueryParams(), &params.EnableEngagementEpicMapping)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter enable_engagement_epic_mapping: %s", err))
	}

	// ------------- Optional query parameter "engagement" -------------

	err = runtime.BindQueryParameter("form", true, false, "engagement", ctx.QueryParams(), &params.Engagement)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter engagement: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "jira_instance" -------------

	err = runtime.BindQueryParameter("form", true, false, "jira_instance", ctx.QueryParams(), &params.JiraInstance)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jira_instance: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "product" -------------

	err = runtime.BindQueryParameter("form", true, false, "product", ctx.QueryParams(), &params.Product)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// ------------- Optional query parameter "project_key" -------------

	err = runtime.BindQueryParameter("form", true, false, "project_key", ctx.QueryParams(), &params.ProjectKey)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_key: %s", err))
	}

	// ------------- Optional query parameter "push_all_issues" -------------

	err = runtime.BindQueryParameter("form", true, false, "push_all_issues", ctx.QueryParams(), &params.PushAllIssues)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter push_all_issues: %s", err))
	}

	// ------------- Optional query parameter "push_notes" -------------

	err = runtime.BindQueryParameter("form", true, false, "push_notes", ctx.QueryParams(), &params.PushNotes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter push_notes: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProjectsList(ctx, params)
	return err
}

// JiraProjectsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProjectsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProjectsCreate(ctx)
	return err
}

// JiraProjectsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProjectsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProjectsDestroy(ctx, id)
	return err
}

// JiraProjectsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProjectsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProjectsRetrieve(ctx, id)
	return err
}

// JiraProjectsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProjectsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProjectsPartialUpdate(ctx, id)
	return err
}

// JiraProjectsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProjectsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProjectsUpdate(ctx, id)
	return err
}

// JiraProjectsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) JiraProjectsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params JiraProjectsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JiraProjectsDeletePreviewList(ctx, id, params)
	return err
}

// LanguageTypesList converts echo context to params.
func (w *ServerInterfaceWrapper) LanguageTypesList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LanguageTypesListParams
	// ------------- Optional query parameter "color" -------------

	err = runtime.BindQueryParameter("form", true, false, "color", ctx.QueryParams(), &params.Color)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter color: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "language" -------------

	err = runtime.BindQueryParameter("form", true, false, "language", ctx.QueryParams(), &params.Language)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter language: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguageTypesList(ctx, params)
	return err
}

// LanguageTypesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) LanguageTypesCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguageTypesCreate(ctx)
	return err
}

// LanguageTypesDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) LanguageTypesDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguageTypesDestroy(ctx, id)
	return err
}

// LanguageTypesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) LanguageTypesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguageTypesRetrieve(ctx, id)
	return err
}

// LanguageTypesPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) LanguageTypesPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguageTypesPartialUpdate(ctx, id)
	return err
}

// LanguageTypesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) LanguageTypesUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguageTypesUpdate(ctx, id)
	return err
}

// LanguageTypesDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) LanguageTypesDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LanguageTypesDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguageTypesDeletePreviewList(ctx, id, params)
	return err
}

// LanguagesList converts echo context to params.
func (w *ServerInterfaceWrapper) LanguagesList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LanguagesListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "language" -------------

	err = runtime.BindQueryParameter("form", true, false, "language", ctx.QueryParams(), &params.Language)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter language: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "product" -------------

	err = runtime.BindQueryParameter("form", true, false, "product", ctx.QueryParams(), &params.Product)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguagesList(ctx, params)
	return err
}

// LanguagesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) LanguagesCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguagesCreate(ctx)
	return err
}

// LanguagesDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) LanguagesDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguagesDestroy(ctx, id)
	return err
}

// LanguagesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) LanguagesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LanguagesRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguagesRetrieve(ctx, id, params)
	return err
}

// LanguagesPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) LanguagesPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguagesPartialUpdate(ctx, id)
	return err
}

// LanguagesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) LanguagesUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguagesUpdate(ctx, id)
	return err
}

// LanguagesDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) LanguagesDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LanguagesDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LanguagesDeletePreviewList(ctx, id, params)
	return err
}

// MetadataList converts echo context to params.
func (w *ServerInterfaceWrapper) MetadataList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params MetadataListParams
	// ------------- Optional query parameter "endpoint" -------------

	err = runtime.BindQueryParameter("form", true, false, "endpoint", ctx.QueryParams(), &params.Endpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endpoint: %s", err))
	}

	// ------------- Optional query parameter "finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "finding", ctx.QueryParams(), &params.Finding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter finding: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "product" -------------

	err = runtime.BindQueryParameter("form", true, false, "product", ctx.QueryParams(), &params.Product)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// ------------- Optional query parameter "value" -------------

	err = runtime.BindQueryParameter("form", true, false, "value", ctx.QueryParams(), &params.Value)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter value: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MetadataList(ctx, params)
	return err
}

// MetadataCreate converts echo context to params.
func (w *ServerInterfaceWrapper) MetadataCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MetadataCreate(ctx)
	return err
}

// MetadataDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) MetadataDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MetadataDestroy(ctx, id)
	return err
}

// MetadataRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) MetadataRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params MetadataRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MetadataRetrieve(ctx, id, params)
	return err
}

// MetadataPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) MetadataPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MetadataPartialUpdate(ctx, id)
	return err
}

// MetadataUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) MetadataUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MetadataUpdate(ctx, id)
	return err
}

// MetadataDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) MetadataDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params MetadataDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MetadataDeletePreviewList(ctx, id, params)
	return err
}

// NetworkLocationsList converts echo context to params.
func (w *ServerInterfaceWrapper) NetworkLocationsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params NetworkLocationsListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "location" -------------

	err = runtime.BindQueryParameter("form", true, false, "location", ctx.QueryParams(), &params.Location)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter location: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NetworkLocationsList(ctx, params)
	return err
}

// NetworkLocationsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) NetworkLocationsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NetworkLocationsCreate(ctx)
	return err
}

// NetworkLocationsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) NetworkLocationsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NetworkLocationsDestroy(ctx, id)
	return err
}

// NetworkLocationsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) NetworkLocationsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NetworkLocationsRetrieve(ctx, id)
	return err
}

// NetworkLocationsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) NetworkLocationsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NetworkLocationsPartialUpdate(ctx, id)
	return err
}

// NetworkLocationsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) NetworkLocationsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NetworkLocationsUpdate(ctx, id)
	return err
}

// NetworkLocationsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) NetworkLocationsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params NetworkLocationsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NetworkLocationsDeletePreviewList(ctx, id, params)
	return err
}

// NoteTypeList converts echo context to params.
func (w *ServerInterfaceWrapper) NoteTypeList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params NoteTypeListParams
	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "is_active" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_active", ctx.QueryParams(), &params.IsActive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_active: %s", err))
	}

	// ------------- Optional query parameter "is_mandatory" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_mandatory", ctx.QueryParams(), &params.IsMandatory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_mandatory: %s", err))
	}

	// ------------- Optional query parameter "is_single" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_single", ctx.QueryParams(), &params.IsSingle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_single: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NoteTypeList(ctx, params)
	return err
}

// NoteTypeCreate converts echo context to params.
func (w *ServerInterfaceWrapper) NoteTypeCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NoteTypeCreate(ctx)
	return err
}

// NoteTypeDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) NoteTypeDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NoteTypeDestroy(ctx, id)
	return err
}

// NoteTypeRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) NoteTypeRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NoteTypeRetrieve(ctx, id)
	return err
}

// NoteTypePartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) NoteTypePartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NoteTypePartialUpdate(ctx, id)
	return err
}

// NoteTypeUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) NoteTypeUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NoteTypeUpdate(ctx, id)
	return err
}

// NoteTypeDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) NoteTypeDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params NoteTypeDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NoteTypeDeletePreviewList(ctx, id, params)
	return err
}

// NotesList converts echo context to params.
func (w *ServerInterfaceWrapper) NotesList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params NotesListParams
	// ------------- Optional query parameter "author" -------------

	err = runtime.BindQueryParameter("form", true, false, "author", ctx.QueryParams(), &params.Author)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter author: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "edit_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "edit_time", ctx.QueryParams(), &params.EditTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter edit_time: %s", err))
	}

	// ------------- Optional query parameter "edited" -------------

	err = runtime.BindQueryParameter("form", true, false, "edited", ctx.QueryParams(), &params.Edited)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter edited: %s", err))
	}

	// ------------- Optional query parameter "editor" -------------

	err = runtime.BindQueryParameter("form", true, false, "editor", ctx.QueryParams(), &params.Editor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter editor: %s", err))
	}

	// ------------- Optional query parameter "entry" -------------

	err = runtime.BindQueryParameter("form", true, false, "entry", ctx.QueryParams(), &params.Entry)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entry: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "private" -------------

	err = runtime.BindQueryParameter("form", true, false, "private", ctx.QueryParams(), &params.Private)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter private: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NotesList(ctx, params)
	return err
}

// NotesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) NotesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NotesRetrieve(ctx, id)
	return err
}

// NotesPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) NotesPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NotesPartialUpdate(ctx, id)
	return err
}

// NotesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) NotesUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NotesUpdate(ctx, id)
	return err
}

// NotificationsList converts echo context to params.
func (w *ServerInterfaceWrapper) NotificationsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params NotificationsListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "product" -------------

	err = runtime.BindQueryParameter("form", true, false, "product", ctx.QueryParams(), &params.Product)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// ------------- Optional query parameter "template" -------------

	err = runtime.BindQueryParameter("form", true, false, "template", ctx.QueryParams(), &params.Template)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter template: %s", err))
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", true, false, "user", ctx.QueryParams(), &params.User)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NotificationsList(ctx, params)
	return err
}

// NotificationsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) NotificationsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NotificationsCreate(ctx)
	return err
}

// NotificationsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) NotificationsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NotificationsDestroy(ctx, id)
	return err
}

// NotificationsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) NotificationsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params NotificationsRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NotificationsRetrieve(ctx, id, params)
	return err
}

// NotificationsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) NotificationsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NotificationsPartialUpdate(ctx, id)
	return err
}

// NotificationsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) NotificationsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NotificationsUpdate(ctx, id)
	return err
}

// NotificationsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) NotificationsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params NotificationsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NotificationsDeletePreviewList(ctx, id, params)
	return err
}

// Oa3SchemaRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) Oa3SchemaRetrieve(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params Oa3SchemaRetrieveParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "lang" -------------

	err = runtime.BindQueryParameter("form", true, false, "lang", ctx.QueryParams(), &params.Lang)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lang: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Oa3SchemaRetrieve(ctx, params)
	return err
}

// ProductApiScanConfigurationsList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductApiScanConfigurationsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductApiScanConfigurationsListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "product" -------------

	err = runtime.BindQueryParameter("form", true, false, "product", ctx.QueryParams(), &params.Product)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// ------------- Optional query parameter "service_key_1" -------------

	err = runtime.BindQueryParameter("form", true, false, "service_key_1", ctx.QueryParams(), &params.ServiceKey1)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_key_1: %s", err))
	}

	// ------------- Optional query parameter "service_key_2" -------------

	err = runtime.BindQueryParameter("form", true, false, "service_key_2", ctx.QueryParams(), &params.ServiceKey2)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_key_2: %s", err))
	}

	// ------------- Optional query parameter "service_key_3" -------------

	err = runtime.BindQueryParameter("form", true, false, "service_key_3", ctx.QueryParams(), &params.ServiceKey3)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_key_3: %s", err))
	}

	// ------------- Optional query parameter "tool_configuration" -------------

	err = runtime.BindQueryParameter("form", true, false, "tool_configuration", ctx.QueryParams(), &params.ToolConfiguration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tool_configuration: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductApiScanConfigurationsList(ctx, params)
	return err
}

// ProductApiScanConfigurationsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductApiScanConfigurationsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductApiScanConfigurationsCreate(ctx)
	return err
}

// ProductApiScanConfigurationsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) ProductApiScanConfigurationsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductApiScanConfigurationsDestroy(ctx, id)
	return err
}

// ProductApiScanConfigurationsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) ProductApiScanConfigurationsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductApiScanConfigurationsRetrieve(ctx, id)
	return err
}

// ProductApiScanConfigurationsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductApiScanConfigurationsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductApiScanConfigurationsPartialUpdate(ctx, id)
	return err
}

// ProductApiScanConfigurationsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductApiScanConfigurationsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductApiScanConfigurationsUpdate(ctx, id)
	return err
}

// ProductApiScanConfigurationsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductApiScanConfigurationsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductApiScanConfigurationsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductApiScanConfigurationsDeletePreviewList(ctx, id, params)
	return err
}

// ProductGroupsList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductGroupsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductGroupsListParams
	// ------------- Optional query parameter "group_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group_id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group_id: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "product_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "product_id", ctx.QueryParams(), &params.ProductId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductGroupsList(ctx, params)
	return err
}

// ProductGroupsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductGroupsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductGroupsCreate(ctx)
	return err
}

// ProductGroupsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) ProductGroupsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductGroupsDestroy(ctx, id)
	return err
}

// ProductGroupsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) ProductGroupsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductGroupsRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductGroupsRetrieve(ctx, id, params)
	return err
}

// ProductGroupsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductGroupsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductGroupsPartialUpdate(ctx, id)
	return err
}

// ProductGroupsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductGroupsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductGroupsUpdate(ctx, id)
	return err
}

// ProductGroupsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductGroupsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductGroupsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductGroupsDeletePreviewList(ctx, id, params)
	return err
}

// ProductMembersList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductMembersList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductMembersListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "product_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "product_id", ctx.QueryParams(), &params.ProductId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product_id: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductMembersList(ctx, params)
	return err
}

// ProductMembersCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductMembersCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductMembersCreate(ctx)
	return err
}

// ProductMembersDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) ProductMembersDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductMembersDestroy(ctx, id)
	return err
}

// ProductMembersRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) ProductMembersRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductMembersRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductMembersRetrieve(ctx, id, params)
	return err
}

// ProductMembersPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductMembersPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductMembersPartialUpdate(ctx, id)
	return err
}

// ProductMembersUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductMembersUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductMembersUpdate(ctx, id)
	return err
}

// ProductMembersDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductMembersDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductMembersDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductMembersDeletePreviewList(ctx, id, params)
	return err
}

// ProductTypeGroupsList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeGroupsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductTypeGroupsListParams
	// ------------- Optional query parameter "group_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group_id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group_id: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "product_type_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "product_type_id", ctx.QueryParams(), &params.ProductTypeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product_type_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeGroupsList(ctx, params)
	return err
}

// ProductTypeGroupsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeGroupsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeGroupsCreate(ctx)
	return err
}

// ProductTypeGroupsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeGroupsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeGroupsDestroy(ctx, id)
	return err
}

// ProductTypeGroupsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeGroupsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductTypeGroupsRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeGroupsRetrieve(ctx, id, params)
	return err
}

// ProductTypeGroupsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeGroupsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeGroupsPartialUpdate(ctx, id)
	return err
}

// ProductTypeGroupsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeGroupsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeGroupsUpdate(ctx, id)
	return err
}

// ProductTypeGroupsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeGroupsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductTypeGroupsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeGroupsDeletePreviewList(ctx, id, params)
	return err
}

// ProductTypeMembersList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeMembersList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductTypeMembersListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "product_type_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "product_type_id", ctx.QueryParams(), &params.ProductTypeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product_type_id: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeMembersList(ctx, params)
	return err
}

// ProductTypeMembersCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeMembersCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeMembersCreate(ctx)
	return err
}

// ProductTypeMembersDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeMembersDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeMembersDestroy(ctx, id)
	return err
}

// ProductTypeMembersRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeMembersRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductTypeMembersRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeMembersRetrieve(ctx, id, params)
	return err
}

// ProductTypeMembersPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeMembersPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeMembersPartialUpdate(ctx, id)
	return err
}

// ProductTypeMembersUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeMembersUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeMembersUpdate(ctx, id)
	return err
}

// ProductTypeMembersDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypeMembersDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductTypeMembersDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypeMembersDeletePreviewList(ctx, id, params)
	return err
}

// ProductTypesList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypesList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductTypesListParams
	// ------------- Optional query parameter "created" -------------

	err = runtime.BindQueryParameter("form", true, false, "created", ctx.QueryParams(), &params.Created)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created: %s", err))
	}

	// ------------- Optional query parameter "critical_product" -------------

	err = runtime.BindQueryParameter("form", true, false, "critical_product", ctx.QueryParams(), &params.CriticalProduct)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter critical_product: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "key_product" -------------

	err = runtime.BindQueryParameter("form", true, false, "key_product", ctx.QueryParams(), &params.KeyProduct)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key_product: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "updated" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated", ctx.QueryParams(), &params.Updated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypesList(ctx, params)
	return err
}

// ProductTypesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypesCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypesCreate(ctx)
	return err
}

// ProductTypesDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypesDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypesDestroy(ctx, id)
	return err
}

// ProductTypesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductTypesRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypesRetrieve(ctx, id, params)
	return err
}

// ProductTypesPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypesPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypesPartialUpdate(ctx, id)
	return err
}

// ProductTypesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypesUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypesUpdate(ctx, id)
	return err
}

// ProductTypesDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypesDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductTypesDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypesDeletePreviewList(ctx, id, params)
	return err
}

// ProductTypesGenerateReportCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypesGenerateReportCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypesGenerateReportCreate(ctx, id)
	return err
}

// ProductsList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductsListParams
	// ------------- Optional query parameter "business_criticality" -------------

	err = runtime.BindQueryParameter("form", true, false, "business_criticality", ctx.QueryParams(), &params.BusinessCriticality)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter business_criticality: %s", err))
	}

	// ------------- Optional query parameter "created" -------------

	err = runtime.BindQueryParameter("form", true, false, "created", ctx.QueryParams(), &params.Created)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created: %s", err))
	}

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
	}

	// ------------- Optional query parameter "external_audience" -------------

	err = runtime.BindQueryParameter("form", true, false, "external_audience", ctx.QueryParams(), &params.ExternalAudience)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter external_audience: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "internet_accessible" -------------

	err = runtime.BindQueryParameter("form", true, false, "internet_accessible", ctx.QueryParams(), &params.InternetAccessible)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter internet_accessible: %s", err))
	}

	// ------------- Optional query parameter "lifecycle" -------------

	err = runtime.BindQueryParameter("form", true, false, "lifecycle", ctx.QueryParams(), &params.Lifecycle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lifecycle: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "not_tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "not_tag", ctx.QueryParams(), &params.NotTag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tag: %s", err))
	}

	// ------------- Optional query parameter "not_tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_tags", ctx.QueryParams(), &params.NotTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tags: %s", err))
	}

	// ------------- Optional query parameter "o" -------------

	err = runtime.BindQueryParameter("form", false, false, "o", ctx.QueryParams(), &params.O)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter o: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "origin" -------------

	err = runtime.BindQueryParameter("form", true, false, "origin", ctx.QueryParams(), &params.Origin)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter origin: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "prod_numeric_grade" -------------

	err = runtime.BindQueryParameter("form", false, false, "prod_numeric_grade", ctx.QueryParams(), &params.ProdNumericGrade)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prod_numeric_grade: %s", err))
	}

	// ------------- Optional query parameter "prod_type" -------------

	err = runtime.BindQueryParameter("form", false, false, "prod_type", ctx.QueryParams(), &params.ProdType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prod_type: %s", err))
	}

	// ------------- Optional query parameter "product_manager" -------------

	err = runtime.BindQueryParameter("form", false, false, "product_manager", ctx.QueryParams(), &params.ProductManager)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product_manager: %s", err))
	}

	// ------------- Optional query parameter "regulations" -------------

	err = runtime.BindQueryParameter("form", false, false, "regulations", ctx.QueryParams(), &params.Regulations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter regulations: %s", err))
	}

	// ------------- Optional query parameter "revenue" -------------

	err = runtime.BindQueryParameter("form", true, false, "revenue", ctx.QueryParams(), &params.Revenue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter revenue: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "team_manager" -------------

	err = runtime.BindQueryParameter("form", false, false, "team_manager", ctx.QueryParams(), &params.TeamManager)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter team_manager: %s", err))
	}

	// ------------- Optional query parameter "technical_contact" -------------

	err = runtime.BindQueryParameter("form", false, false, "technical_contact", ctx.QueryParams(), &params.TechnicalContact)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter technical_contact: %s", err))
	}

	// ------------- Optional query parameter "tid" -------------

	err = runtime.BindQueryParameter("form", false, false, "tid", ctx.QueryParams(), &params.Tid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tid: %s", err))
	}

	// ------------- Optional query parameter "updated" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated", ctx.QueryParams(), &params.Updated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated: %s", err))
	}

	// ------------- Optional query parameter "user_records" -------------

	err = runtime.BindQueryParameter("form", false, false, "user_records", ctx.QueryParams(), &params.UserRecords)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_records: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductsList(ctx, params)
	return err
}

// ProductsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductsCreate(ctx)
	return err
}

// ProductsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) ProductsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductsDestroy(ctx, id)
	return err
}

// ProductsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) ProductsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductsRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductsRetrieve(ctx, id, params)
	return err
}

// ProductsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductsPartialUpdate(ctx, id)
	return err
}

// ProductsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductsUpdate(ctx, id)
	return err
}

// ProductsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) ProductsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductsDeletePreviewList(ctx, id, params)
	return err
}

// ProductsGenerateReportCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ProductsGenerateReportCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductsGenerateReportCreate(ctx, id)
	return err
}

// RegulationsList converts echo context to params.
func (w *ServerInterfaceWrapper) RegulationsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegulationsListParams
	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegulationsList(ctx, params)
	return err
}

// RegulationsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) RegulationsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegulationsCreate(ctx)
	return err
}

// RegulationsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) RegulationsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegulationsDestroy(ctx, id)
	return err
}

// RegulationsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) RegulationsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegulationsRetrieve(ctx, id)
	return err
}

// RegulationsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) RegulationsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegulationsPartialUpdate(ctx, id)
	return err
}

// RegulationsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) RegulationsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegulationsUpdate(ctx, id)
	return err
}

// RegulationsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) RegulationsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegulationsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegulationsDeletePreviewList(ctx, id, params)
	return err
}

// ReimportScanCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ReimportScanCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ReimportScanCreate(ctx)
	return err
}

// RolesList converts echo context to params.
func (w *ServerInterfaceWrapper) RolesList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RolesListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RolesList(ctx, params)
	return err
}

// RolesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) RolesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RolesRetrieve(ctx, id)
	return err
}

// SlaConfigurationsList converts echo context to params.
func (w *ServerInterfaceWrapper) SlaConfigurationsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SlaConfigurationsListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SlaConfigurationsList(ctx, params)
	return err
}

// SlaConfigurationsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) SlaConfigurationsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SlaConfigurationsCreate(ctx)
	return err
}

// SlaConfigurationsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) SlaConfigurationsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SlaConfigurationsDestroy(ctx, id)
	return err
}

// SlaConfigurationsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) SlaConfigurationsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SlaConfigurationsRetrieve(ctx, id)
	return err
}

// SlaConfigurationsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SlaConfigurationsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SlaConfigurationsPartialUpdate(ctx, id)
	return err
}

// SlaConfigurationsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SlaConfigurationsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SlaConfigurationsUpdate(ctx, id)
	return err
}

// SonarqubeIssuesList converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeIssuesList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SonarqubeIssuesListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "key" -------------

	err = runtime.BindQueryParameter("form", true, false, "key", ctx.QueryParams(), &params.Key)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeIssuesList(ctx, params)
	return err
}

// SonarqubeIssuesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeIssuesCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeIssuesCreate(ctx)
	return err
}

// SonarqubeIssuesDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeIssuesDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeIssuesDestroy(ctx, id)
	return err
}

// SonarqubeIssuesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeIssuesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeIssuesRetrieve(ctx, id)
	return err
}

// SonarqubeIssuesPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeIssuesPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeIssuesPartialUpdate(ctx, id)
	return err
}

// SonarqubeIssuesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeIssuesUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeIssuesUpdate(ctx, id)
	return err
}

// SonarqubeIssuesDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeIssuesDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SonarqubeIssuesDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeIssuesDeletePreviewList(ctx, id, params)
	return err
}

// SonarqubeTransitionsList converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeTransitionsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SonarqubeTransitionsListParams
	// ------------- Optional query parameter "finding_status" -------------

	err = runtime.BindQueryParameter("form", true, false, "finding_status", ctx.QueryParams(), &params.FindingStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter finding_status: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "sonarqube_issue" -------------

	err = runtime.BindQueryParameter("form", true, false, "sonarqube_issue", ctx.QueryParams(), &params.SonarqubeIssue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sonarqube_issue: %s", err))
	}

	// ------------- Optional query parameter "sonarqube_status" -------------

	err = runtime.BindQueryParameter("form", true, false, "sonarqube_status", ctx.QueryParams(), &params.SonarqubeStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sonarqube_status: %s", err))
	}

	// ------------- Optional query parameter "transitions" -------------

	err = runtime.BindQueryParameter("form", true, false, "transitions", ctx.QueryParams(), &params.Transitions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transitions: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeTransitionsList(ctx, params)
	return err
}

// SonarqubeTransitionsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeTransitionsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeTransitionsCreate(ctx)
	return err
}

// SonarqubeTransitionsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeTransitionsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeTransitionsDestroy(ctx, id)
	return err
}

// SonarqubeTransitionsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeTransitionsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeTransitionsRetrieve(ctx, id)
	return err
}

// SonarqubeTransitionsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeTransitionsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeTransitionsPartialUpdate(ctx, id)
	return err
}

// SonarqubeTransitionsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeTransitionsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeTransitionsUpdate(ctx, id)
	return err
}

// SonarqubeTransitionsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) SonarqubeTransitionsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SonarqubeTransitionsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SonarqubeTransitionsDeletePreviewList(ctx, id, params)
	return err
}

// StubFindingsList converts echo context to params.
func (w *ServerInterfaceWrapper) StubFindingsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StubFindingsListParams
	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "severity" -------------

	err = runtime.BindQueryParameter("form", true, false, "severity", ctx.QueryParams(), &params.Severity)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter severity: %s", err))
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", ctx.QueryParams(), &params.Title)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StubFindingsList(ctx, params)
	return err
}

// StubFindingsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) StubFindingsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StubFindingsCreate(ctx)
	return err
}

// StubFindingsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) StubFindingsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StubFindingsDestroy(ctx, id)
	return err
}

// StubFindingsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) StubFindingsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StubFindingsRetrieve(ctx, id)
	return err
}

// StubFindingsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) StubFindingsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StubFindingsPartialUpdate(ctx, id)
	return err
}

// StubFindingsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) StubFindingsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StubFindingsUpdate(ctx, id)
	return err
}

// StubFindingsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) StubFindingsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StubFindingsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StubFindingsDeletePreviewList(ctx, id, params)
	return err
}

// SystemSettingsList converts echo context to params.
func (w *ServerInterfaceWrapper) SystemSettingsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SystemSettingsListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SystemSettingsList(ctx, params)
	return err
}

// SystemSettingsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SystemSettingsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SystemSettingsPartialUpdate(ctx, id)
	return err
}

// SystemSettingsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SystemSettingsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SystemSettingsUpdate(ctx, id)
	return err
}

// TechnologiesList converts echo context to params.
func (w *ServerInterfaceWrapper) TechnologiesList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TechnologiesListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "not_tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "not_tag", ctx.QueryParams(), &params.NotTag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tag: %s", err))
	}

	// ------------- Optional query parameter "not_tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_tags", ctx.QueryParams(), &params.NotTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tags: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "product" -------------

	err = runtime.BindQueryParameter("form", true, false, "product", ctx.QueryParams(), &params.Product)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", true, false, "user", ctx.QueryParams(), &params.User)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user: %s", err))
	}

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", ctx.QueryParams(), &params.Version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TechnologiesList(ctx, params)
	return err
}

// TechnologiesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TechnologiesCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TechnologiesCreate(ctx)
	return err
}

// TechnologiesDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) TechnologiesDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TechnologiesDestroy(ctx, id)
	return err
}

// TechnologiesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) TechnologiesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TechnologiesRetrieve(ctx, id)
	return err
}

// TechnologiesPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TechnologiesPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TechnologiesPartialUpdate(ctx, id)
	return err
}

// TechnologiesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TechnologiesUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TechnologiesUpdate(ctx, id)
	return err
}

// TechnologiesDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) TechnologiesDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TechnologiesDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TechnologiesDeletePreviewList(ctx, id, params)
	return err
}

// TestImportsList converts echo context to params.
func (w *ServerInterfaceWrapper) TestImportsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TestImportsListParams
	// ------------- Optional query parameter "branch_tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "branch_tag", ctx.QueryParams(), &params.BranchTag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter branch_tag: %s", err))
	}

	// ------------- Optional query parameter "build_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "build_id", ctx.QueryParams(), &params.BuildId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter build_id: %s", err))
	}

	// ------------- Optional query parameter "commit_hash" -------------

	err = runtime.BindQueryParameter("form", true, false, "commit_hash", ctx.QueryParams(), &params.CommitHash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter commit_hash: %s", err))
	}

	// ------------- Optional query parameter "findings_affected" -------------

	err = runtime.BindQueryParameter("form", true, false, "findings_affected", ctx.QueryParams(), &params.FindingsAffected)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findings_affected: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "test" -------------

	err = runtime.BindQueryParameter("form", true, false, "test", ctx.QueryParams(), &params.Test)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test: %s", err))
	}

	// ------------- Optional query parameter "test_import_finding_action__action" -------------

	err = runtime.BindQueryParameter("form", true, false, "test_import_finding_action__action", ctx.QueryParams(), &params.TestImportFindingActionAction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test_import_finding_action__action: %s", err))
	}

	// ------------- Optional query parameter "test_import_finding_action__created" -------------

	err = runtime.BindQueryParameter("form", true, false, "test_import_finding_action__created", ctx.QueryParams(), &params.TestImportFindingActionCreated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test_import_finding_action__created: %s", err))
	}

	// ------------- Optional query parameter "test_import_finding_action__finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "test_import_finding_action__finding", ctx.QueryParams(), &params.TestImportFindingActionFinding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test_import_finding_action__finding: %s", err))
	}

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", ctx.QueryParams(), &params.Version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestImportsList(ctx, params)
	return err
}

// TestImportsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TestImportsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestImportsCreate(ctx)
	return err
}

// TestImportsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) TestImportsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestImportsDestroy(ctx, id)
	return err
}

// TestImportsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) TestImportsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TestImportsRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestImportsRetrieve(ctx, id, params)
	return err
}

// TestImportsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TestImportsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestImportsPartialUpdate(ctx, id)
	return err
}

// TestImportsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TestImportsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestImportsUpdate(ctx, id)
	return err
}

// TestImportsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) TestImportsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TestImportsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestImportsDeletePreviewList(ctx, id, params)
	return err
}

// TestTypesList converts echo context to params.
func (w *ServerInterfaceWrapper) TestTypesList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TestTypesListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestTypesList(ctx, params)
	return err
}

// TestTypesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TestTypesCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestTypesCreate(ctx)
	return err
}

// TestTypesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) TestTypesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestTypesRetrieve(ctx, id)
	return err
}

// TestTypesPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TestTypesPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestTypesPartialUpdate(ctx, id)
	return err
}

// TestTypesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TestTypesUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestTypesUpdate(ctx, id)
	return err
}

// TestsList converts echo context to params.
func (w *ServerInterfaceWrapper) TestsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TestsListParams
	// ------------- Optional query parameter "actual_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "actual_time", ctx.QueryParams(), &params.ActualTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter actual_time: %s", err))
	}

	// ------------- Optional query parameter "api_scan_configuration" -------------

	err = runtime.BindQueryParameter("form", true, false, "api_scan_configuration", ctx.QueryParams(), &params.ApiScanConfiguration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter api_scan_configuration: %s", err))
	}

	// ------------- Optional query parameter "branch_tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "branch_tag", ctx.QueryParams(), &params.BranchTag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter branch_tag: %s", err))
	}

	// ------------- Optional query parameter "build_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "build_id", ctx.QueryParams(), &params.BuildId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter build_id: %s", err))
	}

	// ------------- Optional query parameter "commit_hash" -------------

	err = runtime.BindQueryParameter("form", true, false, "commit_hash", ctx.QueryParams(), &params.CommitHash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter commit_hash: %s", err))
	}

	// ------------- Optional query parameter "engagement" -------------

	err = runtime.BindQueryParameter("form", true, false, "engagement", ctx.QueryParams(), &params.Engagement)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter engagement: %s", err))
	}

	// ------------- Optional query parameter "engagement__product__tags__name" -------------

	err = runtime.BindQueryParameter("form", false, false, "engagement__product__tags__name", ctx.QueryParams(), &params.EngagementProductTagsName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter engagement__product__tags__name: %s", err))
	}

	// ------------- Optional query parameter "engagement__tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "engagement__tags", ctx.QueryParams(), &params.EngagementTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter engagement__tags: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "not_engagement__product__tags__name" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_engagement__product__tags__name", ctx.QueryParams(), &params.NotEngagementProductTagsName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_engagement__product__tags__name: %s", err))
	}

	// ------------- Optional query parameter "not_engagement__tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_engagement__tags", ctx.QueryParams(), &params.NotEngagementTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_engagement__tags: %s", err))
	}

	// ------------- Optional query parameter "not_tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "not_tag", ctx.QueryParams(), &params.NotTag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tag: %s", err))
	}

	// ------------- Optional query parameter "not_tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "not_tags", ctx.QueryParams(), &params.NotTags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter not_tags: %s", err))
	}

	// ------------- Optional query parameter "notes" -------------

	err = runtime.BindQueryParameter("form", true, false, "notes", ctx.QueryParams(), &params.Notes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter notes: %s", err))
	}

	// ------------- Optional query parameter "o" -------------

	err = runtime.BindQueryParameter("form", false, false, "o", ctx.QueryParams(), &params.O)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter o: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "percent_complete" -------------

	err = runtime.BindQueryParameter("form", true, false, "percent_complete", ctx.QueryParams(), &params.PercentComplete)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter percent_complete: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", false, false, "tags", ctx.QueryParams(), &params.Tags)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tags: %s", err))
	}

	// ------------- Optional query parameter "target_end" -------------

	err = runtime.BindQueryParameter("form", true, false, "target_end", ctx.QueryParams(), &params.TargetEnd)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter target_end: %s", err))
	}

	// ------------- Optional query parameter "target_start" -------------

	err = runtime.BindQueryParameter("form", true, false, "target_start", ctx.QueryParams(), &params.TargetStart)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter target_start: %s", err))
	}

	// ------------- Optional query parameter "test_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "test_type", ctx.QueryParams(), &params.TestType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter test_type: %s", err))
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", ctx.QueryParams(), &params.Title)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
	}

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", ctx.QueryParams(), &params.Version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsList(ctx, params)
	return err
}

// TestsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TestsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsCreate(ctx)
	return err
}

// TestsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) TestsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsDestroy(ctx, id)
	return err
}

// TestsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) TestsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsRetrieve(ctx, id)
	return err
}

// TestsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TestsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsPartialUpdate(ctx, id)
	return err
}

// TestsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TestsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsUpdate(ctx, id)
	return err
}

// TestsAcceptRisksCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TestsAcceptRisksCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsAcceptRisksCreate(ctx, id)
	return err
}

// TestsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) TestsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TestsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsDeletePreviewList(ctx, id, params)
	return err
}

// TestsFilesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) TestsFilesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsFilesRetrieve(ctx, id)
	return err
}

// TestsFilesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TestsFilesCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsFilesCreate(ctx, id)
	return err
}

// TestsGenerateReportCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TestsGenerateReportCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsGenerateReportCreate(ctx, id)
	return err
}

// TestsNotesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) TestsNotesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsNotesRetrieve(ctx, id)
	return err
}

// TestsNotesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TestsNotesCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TestsNotesCreate(ctx, id)
	return err
}

// ToolConfigurationsList converts echo context to params.
func (w *ServerInterfaceWrapper) ToolConfigurationsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ToolConfigurationsListParams
	// ------------- Optional query parameter "authentication_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "authentication_type", ctx.QueryParams(), &params.AuthenticationType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authentication_type: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "tool_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tool_type", ctx.QueryParams(), &params.ToolType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tool_type: %s", err))
	}

	// ------------- Optional query parameter "url" -------------

	err = runtime.BindQueryParameter("form", true, false, "url", ctx.QueryParams(), &params.Url)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter url: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolConfigurationsList(ctx, params)
	return err
}

// ToolConfigurationsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ToolConfigurationsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolConfigurationsCreate(ctx)
	return err
}

// ToolConfigurationsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) ToolConfigurationsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolConfigurationsDestroy(ctx, id)
	return err
}

// ToolConfigurationsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) ToolConfigurationsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolConfigurationsRetrieve(ctx, id)
	return err
}

// ToolConfigurationsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ToolConfigurationsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolConfigurationsPartialUpdate(ctx, id)
	return err
}

// ToolConfigurationsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ToolConfigurationsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolConfigurationsUpdate(ctx, id)
	return err
}

// ToolConfigurationsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) ToolConfigurationsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ToolConfigurationsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolConfigurationsDeletePreviewList(ctx, id, params)
	return err
}

// ToolProductSettingsList converts echo context to params.
func (w *ServerInterfaceWrapper) ToolProductSettingsList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ToolProductSettingsListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "product" -------------

	err = runtime.BindQueryParameter("form", true, false, "product", ctx.QueryParams(), &params.Product)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// ------------- Optional query parameter "tool_configuration" -------------

	err = runtime.BindQueryParameter("form", true, false, "tool_configuration", ctx.QueryParams(), &params.ToolConfiguration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tool_configuration: %s", err))
	}

	// ------------- Optional query parameter "tool_project_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "tool_project_id", ctx.QueryParams(), &params.ToolProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tool_project_id: %s", err))
	}

	// ------------- Optional query parameter "url" -------------

	err = runtime.BindQueryParameter("form", true, false, "url", ctx.QueryParams(), &params.Url)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter url: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolProductSettingsList(ctx, params)
	return err
}

// ToolProductSettingsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ToolProductSettingsCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolProductSettingsCreate(ctx)
	return err
}

// ToolProductSettingsDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) ToolProductSettingsDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolProductSettingsDestroy(ctx, id)
	return err
}

// ToolProductSettingsRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) ToolProductSettingsRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolProductSettingsRetrieve(ctx, id)
	return err
}

// ToolProductSettingsPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ToolProductSettingsPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolProductSettingsPartialUpdate(ctx, id)
	return err
}

// ToolProductSettingsUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ToolProductSettingsUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolProductSettingsUpdate(ctx, id)
	return err
}

// ToolProductSettingsDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) ToolProductSettingsDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ToolProductSettingsDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolProductSettingsDeletePreviewList(ctx, id, params)
	return err
}

// ToolTypesList converts echo context to params.
func (w *ServerInterfaceWrapper) ToolTypesList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ToolTypesListParams
	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolTypesList(ctx, params)
	return err
}

// ToolTypesCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ToolTypesCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolTypesCreate(ctx)
	return err
}

// ToolTypesDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) ToolTypesDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolTypesDestroy(ctx, id)
	return err
}

// ToolTypesRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) ToolTypesRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolTypesRetrieve(ctx, id)
	return err
}

// ToolTypesPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ToolTypesPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolTypesPartialUpdate(ctx, id)
	return err
}

// ToolTypesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) ToolTypesUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolTypesUpdate(ctx, id)
	return err
}

// ToolTypesDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) ToolTypesDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ToolTypesDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ToolTypesDeletePreviewList(ctx, id, params)
	return err
}

// UserContactInfosList converts echo context to params.
func (w *ServerInterfaceWrapper) UserContactInfosList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserContactInfosListParams
	// ------------- Optional query parameter "block_execution" -------------

	err = runtime.BindQueryParameter("form", true, false, "block_execution", ctx.QueryParams(), &params.BlockExecution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter block_execution: %s", err))
	}

	// ------------- Optional query parameter "cell_number" -------------

	err = runtime.BindQueryParameter("form", true, false, "cell_number", ctx.QueryParams(), &params.CellNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cell_number: %s", err))
	}

	// ------------- Optional query parameter "force_password_reset" -------------

	err = runtime.BindQueryParameter("form", true, false, "force_password_reset", ctx.QueryParams(), &params.ForcePasswordReset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter force_password_reset: %s", err))
	}

	// ------------- Optional query parameter "github_username" -------------

	err = runtime.BindQueryParameter("form", true, false, "github_username", ctx.QueryParams(), &params.GithubUsername)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter github_username: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "phone_number" -------------

	err = runtime.BindQueryParameter("form", true, false, "phone_number", ctx.QueryParams(), &params.PhoneNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter phone_number: %s", err))
	}

	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// ------------- Optional query parameter "slack_user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "slack_user_id", ctx.QueryParams(), &params.SlackUserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slack_user_id: %s", err))
	}

	// ------------- Optional query parameter "slack_username" -------------

	err = runtime.BindQueryParameter("form", true, false, "slack_username", ctx.QueryParams(), &params.SlackUsername)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slack_username: %s", err))
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", ctx.QueryParams(), &params.Title)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter title: %s", err))
	}

	// ------------- Optional query parameter "twitter_username" -------------

	err = runtime.BindQueryParameter("form", true, false, "twitter_username", ctx.QueryParams(), &params.TwitterUsername)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter twitter_username: %s", err))
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", true, false, "user", ctx.QueryParams(), &params.User)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserContactInfosList(ctx, params)
	return err
}

// UserContactInfosCreate converts echo context to params.
func (w *ServerInterfaceWrapper) UserContactInfosCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserContactInfosCreate(ctx)
	return err
}

// UserContactInfosDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) UserContactInfosDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserContactInfosDestroy(ctx, id)
	return err
}

// UserContactInfosRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) UserContactInfosRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserContactInfosRetrieveParams
	// ------------- Optional query parameter "prefetch" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefetch", ctx.QueryParams(), &params.Prefetch)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefetch: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserContactInfosRetrieve(ctx, id, params)
	return err
}

// UserContactInfosPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserContactInfosPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserContactInfosPartialUpdate(ctx, id)
	return err
}

// UserContactInfosUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserContactInfosUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserContactInfosUpdate(ctx, id)
	return err
}

// UserContactInfosDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) UserContactInfosDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserContactInfosDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserContactInfosDeletePreviewList(ctx, id, params)
	return err
}

// UserProfileRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) UserProfileRetrieve(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserProfileRetrieve(ctx)
	return err
}

// UsersList converts echo context to params.
func (w *ServerInterfaceWrapper) UsersList(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersListParams
	// ------------- Optional query parameter "email" -------------

	err = runtime.BindQueryParameter("form", true, false, "email", ctx.QueryParams(), &params.Email)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// ------------- Optional query parameter "first_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "first_name", ctx.QueryParams(), &params.FirstName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first_name: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "is_active" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_active", ctx.QueryParams(), &params.IsActive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_active: %s", err))
	}

	// ------------- Optional query parameter "is_superuser" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_superuser", ctx.QueryParams(), &params.IsSuperuser)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_superuser: %s", err))
	}

	// ------------- Optional query parameter "last_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_name", ctx.QueryParams(), &params.LastName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_name: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersList(ctx, params)
	return err
}

// UsersCreate converts echo context to params.
func (w *ServerInterfaceWrapper) UsersCreate(ctx echo.Context) error {
	var err error

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersCreate(ctx)
	return err
}

// UsersDestroy converts echo context to params.
func (w *ServerInterfaceWrapper) UsersDestroy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersDestroy(ctx, id)
	return err
}

// UsersRetrieve converts echo context to params.
func (w *ServerInterfaceWrapper) UsersRetrieve(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersRetrieve(ctx, id)
	return err
}

// UsersPartialUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UsersPartialUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersPartialUpdate(ctx, id)
	return err
}

// UsersUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UsersUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersUpdate(ctx, id)
	return err
}

// UsersDeletePreviewList converts echo context to params.
func (w *ServerInterfaceWrapper) UsersDeletePreviewList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(CookieAuthScopes, []string{""})

	ctx.Set(BasicAuthScopes, []string{""})

	ctx.Set(TokenAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersDeletePreviewListParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersDeletePreviewList(ctx, id, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/api/v2/api-token-auth/", wrapper.ApiTokenAuthCreate)
	router.GET(baseURL+"/api/v2/configuration_permissions/", wrapper.ConfigurationPermissionsList)
	router.GET(baseURL+"/api/v2/configuration_permissions/:id/", wrapper.ConfigurationPermissionsRetrieve)
	router.GET(baseURL+"/api/v2/development_environments/", wrapper.DevelopmentEnvironmentsList)
	router.POST(baseURL+"/api/v2/development_environments/", wrapper.DevelopmentEnvironmentsCreate)
	router.DELETE(baseURL+"/api/v2/development_environments/:id/", wrapper.DevelopmentEnvironmentsDestroy)
	router.GET(baseURL+"/api/v2/development_environments/:id/", wrapper.DevelopmentEnvironmentsRetrieve)
	router.PATCH(baseURL+"/api/v2/development_environments/:id/", wrapper.DevelopmentEnvironmentsPartialUpdate)
	router.PUT(baseURL+"/api/v2/development_environments/:id/", wrapper.DevelopmentEnvironmentsUpdate)
	router.GET(baseURL+"/api/v2/development_environments/:id/delete_preview/", wrapper.DevelopmentEnvironmentsDeletePreviewList)
	router.GET(baseURL+"/api/v2/dojo_group_members/", wrapper.DojoGroupMembersList)
	router.POST(baseURL+"/api/v2/dojo_group_members/", wrapper.DojoGroupMembersCreate)
	router.DELETE(baseURL+"/api/v2/dojo_group_members/:id/", wrapper.DojoGroupMembersDestroy)
	router.GET(baseURL+"/api/v2/dojo_group_members/:id/", wrapper.DojoGroupMembersRetrieve)
	router.PATCH(baseURL+"/api/v2/dojo_group_members/:id/", wrapper.DojoGroupMembersPartialUpdate)
	router.PUT(baseURL+"/api/v2/dojo_group_members/:id/", wrapper.DojoGroupMembersUpdate)
	router.GET(baseURL+"/api/v2/dojo_group_members/:id/delete_preview/", wrapper.DojoGroupMembersDeletePreviewList)
	router.GET(baseURL+"/api/v2/dojo_groups/", wrapper.DojoGroupsList)
	router.POST(baseURL+"/api/v2/dojo_groups/", wrapper.DojoGroupsCreate)
	router.DELETE(baseURL+"/api/v2/dojo_groups/:id/", wrapper.DojoGroupsDestroy)
	router.GET(baseURL+"/api/v2/dojo_groups/:id/", wrapper.DojoGroupsRetrieve)
	router.PATCH(baseURL+"/api/v2/dojo_groups/:id/", wrapper.DojoGroupsPartialUpdate)
	router.PUT(baseURL+"/api/v2/dojo_groups/:id/", wrapper.DojoGroupsUpdate)
	router.GET(baseURL+"/api/v2/dojo_groups/:id/delete_preview/", wrapper.DojoGroupsDeletePreviewList)
	router.POST(baseURL+"/api/v2/endpoint_meta_import/", wrapper.EndpointMetaImportCreate)
	router.GET(baseURL+"/api/v2/endpoint_status/", wrapper.EndpointStatusList)
	router.POST(baseURL+"/api/v2/endpoint_status/", wrapper.EndpointStatusCreate)
	router.DELETE(baseURL+"/api/v2/endpoint_status/:id/", wrapper.EndpointStatusDestroy)
	router.GET(baseURL+"/api/v2/endpoint_status/:id/", wrapper.EndpointStatusRetrieve)
	router.PATCH(baseURL+"/api/v2/endpoint_status/:id/", wrapper.EndpointStatusPartialUpdate)
	router.PUT(baseURL+"/api/v2/endpoint_status/:id/", wrapper.EndpointStatusUpdate)
	router.GET(baseURL+"/api/v2/endpoint_status/:id/delete_preview/", wrapper.EndpointStatusDeletePreviewList)
	router.GET(baseURL+"/api/v2/endpoints/", wrapper.EndpointsList)
	router.POST(baseURL+"/api/v2/endpoints/", wrapper.EndpointsCreate)
	router.DELETE(baseURL+"/api/v2/endpoints/:id/", wrapper.EndpointsDestroy)
	router.GET(baseURL+"/api/v2/endpoints/:id/", wrapper.EndpointsRetrieve)
	router.PATCH(baseURL+"/api/v2/endpoints/:id/", wrapper.EndpointsPartialUpdate)
	router.PUT(baseURL+"/api/v2/endpoints/:id/", wrapper.EndpointsUpdate)
	router.GET(baseURL+"/api/v2/endpoints/:id/delete_preview/", wrapper.EndpointsDeletePreviewList)
	router.POST(baseURL+"/api/v2/endpoints/:id/generate_report/", wrapper.EndpointsGenerateReportCreate)
	router.GET(baseURL+"/api/v2/engagement_presets/", wrapper.EngagementPresetsList)
	router.POST(baseURL+"/api/v2/engagement_presets/", wrapper.EngagementPresetsCreate)
	router.DELETE(baseURL+"/api/v2/engagement_presets/:id/", wrapper.EngagementPresetsDestroy)
	router.GET(baseURL+"/api/v2/engagement_presets/:id/", wrapper.EngagementPresetsRetrieve)
	router.PATCH(baseURL+"/api/v2/engagement_presets/:id/", wrapper.EngagementPresetsPartialUpdate)
	router.PUT(baseURL+"/api/v2/engagement_presets/:id/", wrapper.EngagementPresetsUpdate)
	router.GET(baseURL+"/api/v2/engagement_presets/:id/delete_preview/", wrapper.EngagementPresetsDeletePreviewList)
	router.GET(baseURL+"/api/v2/engagements/", wrapper.EngagementsList)
	router.POST(baseURL+"/api/v2/engagements/", wrapper.EngagementsCreate)
	router.DELETE(baseURL+"/api/v2/engagements/:id/", wrapper.EngagementsDestroy)
	router.GET(baseURL+"/api/v2/engagements/:id/", wrapper.EngagementsRetrieve)
	router.PATCH(baseURL+"/api/v2/engagements/:id/", wrapper.EngagementsPartialUpdate)
	router.PUT(baseURL+"/api/v2/engagements/:id/", wrapper.EngagementsUpdate)
	router.POST(baseURL+"/api/v2/engagements/:id/accept_risks/", wrapper.EngagementsAcceptRisksCreate)
	router.POST(baseURL+"/api/v2/engagements/:id/close/", wrapper.EngagementsCloseCreate)
	router.GET(baseURL+"/api/v2/engagements/:id/delete_preview/", wrapper.EngagementsDeletePreviewList)
	router.GET(baseURL+"/api/v2/engagements/:id/files/", wrapper.EngagementsFilesRetrieve)
	router.POST(baseURL+"/api/v2/engagements/:id/files/", wrapper.EngagementsFilesCreate)
	router.POST(baseURL+"/api/v2/engagements/:id/generate_report/", wrapper.EngagementsGenerateReportCreate)
	router.GET(baseURL+"/api/v2/engagements/:id/notes/", wrapper.EngagementsNotesRetrieve)
	router.POST(baseURL+"/api/v2/engagements/:id/notes/", wrapper.EngagementsNotesCreate)
	router.POST(baseURL+"/api/v2/engagements/:id/reopen/", wrapper.EngagementsReopenCreate)
	router.GET(baseURL+"/api/v2/finding_templates/", wrapper.FindingTemplatesList)
	router.POST(baseURL+"/api/v2/finding_templates/", wrapper.FindingTemplatesCreate)
	router.DELETE(baseURL+"/api/v2/finding_templates/:id/", wrapper.FindingTemplatesDestroy)
	router.GET(baseURL+"/api/v2/finding_templates/:id/", wrapper.FindingTemplatesRetrieve)
	router.PATCH(baseURL+"/api/v2/finding_templates/:id/", wrapper.FindingTemplatesPartialUpdate)
	router.PUT(baseURL+"/api/v2/finding_templates/:id/", wrapper.FindingTemplatesUpdate)
	router.GET(baseURL+"/api/v2/finding_templates/:id/delete_preview/", wrapper.FindingTemplatesDeletePreviewList)
	router.GET(baseURL+"/api/v2/findings/", wrapper.FindingsList)
	router.POST(baseURL+"/api/v2/findings/", wrapper.FindingsCreate)
	router.POST(baseURL+"/api/v2/findings/accept_risks/", wrapper.FindingsAcceptRisksCreate)
	router.POST(baseURL+"/api/v2/findings/generate_report/", wrapper.FindingsGenerateReportCreate)
	router.DELETE(baseURL+"/api/v2/findings/:id/", wrapper.FindingsDestroy)
	router.GET(baseURL+"/api/v2/findings/:id/", wrapper.FindingsRetrieve)
	router.PATCH(baseURL+"/api/v2/findings/:id/", wrapper.FindingsPartialUpdate)
	router.PUT(baseURL+"/api/v2/findings/:id/", wrapper.FindingsUpdate)
	router.POST(baseURL+"/api/v2/findings/:id/close/", wrapper.FindingsCloseCreate)
	router.GET(baseURL+"/api/v2/findings/:id/delete_preview/", wrapper.FindingsDeletePreviewList)
	router.GET(baseURL+"/api/v2/findings/:id/duplicate/", wrapper.FindingsDuplicateList)
	router.POST(baseURL+"/api/v2/findings/:id/duplicate/reset/", wrapper.FindingsDuplicateResetCreate)
	router.GET(baseURL+"/api/v2/findings/:id/files/", wrapper.FindingsFilesRetrieve)
	router.POST(baseURL+"/api/v2/findings/:id/files/", wrapper.FindingsFilesCreate)
	router.DELETE(baseURL+"/api/v2/findings/:id/metadata/", wrapper.FindingsMetadataDestroy)
	router.GET(baseURL+"/api/v2/findings/:id/metadata/", wrapper.FindingsMetadataList)
	router.POST(baseURL+"/api/v2/findings/:id/metadata/", wrapper.FindingsMetadataCreate)
	router.PUT(baseURL+"/api/v2/findings/:id/metadata/", wrapper.FindingsMetadataUpdate)
	router.GET(baseURL+"/api/v2/findings/:id/notes/", wrapper.FindingsNotesRetrieve)
	router.POST(baseURL+"/api/v2/findings/:id/notes/", wrapper.FindingsNotesCreate)
	router.POST(baseURL+"/api/v2/findings/:id/original/:new_fid/", wrapper.FindingsOriginalCreate)
	router.PATCH(baseURL+"/api/v2/findings/:id/remove_note/", wrapper.FindingsRemoveNotePartialUpdate)
	router.PATCH(baseURL+"/api/v2/findings/:id/remove_tags/", wrapper.FindingsRemoveTagsPartialUpdate)
	router.PUT(baseURL+"/api/v2/findings/:id/remove_tags/", wrapper.FindingsRemoveTagsUpdate)
	router.GET(baseURL+"/api/v2/findings/:id/request_response/", wrapper.FindingsRequestResponseRetrieve)
	router.POST(baseURL+"/api/v2/findings/:id/request_response/", wrapper.FindingsRequestResponseCreate)
	router.GET(baseURL+"/api/v2/findings/:id/tags/", wrapper.FindingsTagsRetrieve)
	router.POST(baseURL+"/api/v2/findings/:id/tags/", wrapper.FindingsTagsCreate)
	router.GET(baseURL+"/api/v2/global_roles/", wrapper.GlobalRolesList)
	router.POST(baseURL+"/api/v2/global_roles/", wrapper.GlobalRolesCreate)
	router.DELETE(baseURL+"/api/v2/global_roles/:id/", wrapper.GlobalRolesDestroy)
	router.GET(baseURL+"/api/v2/global_roles/:id/", wrapper.GlobalRolesRetrieve)
	router.PATCH(baseURL+"/api/v2/global_roles/:id/", wrapper.GlobalRolesPartialUpdate)
	router.PUT(baseURL+"/api/v2/global_roles/:id/", wrapper.GlobalRolesUpdate)
	router.GET(baseURL+"/api/v2/global_roles/:id/delete_preview/", wrapper.GlobalRolesDeletePreviewList)
	router.POST(baseURL+"/api/v2/import-languages/", wrapper.ImportLanguagesCreate)
	router.POST(baseURL+"/api/v2/import-scan/", wrapper.ImportScanCreate)
	router.GET(baseURL+"/api/v2/jira_configurations/", wrapper.JiraConfigurationsList)
	router.POST(baseURL+"/api/v2/jira_configurations/", wrapper.JiraConfigurationsCreate)
	router.DELETE(baseURL+"/api/v2/jira_configurations/:id/", wrapper.JiraConfigurationsDestroy)
	router.GET(baseURL+"/api/v2/jira_configurations/:id/", wrapper.JiraConfigurationsRetrieve)
	router.PATCH(baseURL+"/api/v2/jira_configurations/:id/", wrapper.JiraConfigurationsPartialUpdate)
	router.PUT(baseURL+"/api/v2/jira_configurations/:id/", wrapper.JiraConfigurationsUpdate)
	router.GET(baseURL+"/api/v2/jira_configurations/:id/delete_preview/", wrapper.JiraConfigurationsDeletePreviewList)
	router.GET(baseURL+"/api/v2/jira_finding_mappings/", wrapper.JiraFindingMappingsList)
	router.POST(baseURL+"/api/v2/jira_finding_mappings/", wrapper.JiraFindingMappingsCreate)
	router.DELETE(baseURL+"/api/v2/jira_finding_mappings/:id/", wrapper.JiraFindingMappingsDestroy)
	router.GET(baseURL+"/api/v2/jira_finding_mappings/:id/", wrapper.JiraFindingMappingsRetrieve)
	router.PATCH(baseURL+"/api/v2/jira_finding_mappings/:id/", wrapper.JiraFindingMappingsPartialUpdate)
	router.PUT(baseURL+"/api/v2/jira_finding_mappings/:id/", wrapper.JiraFindingMappingsUpdate)
	router.GET(baseURL+"/api/v2/jira_finding_mappings/:id/delete_preview/", wrapper.JiraFindingMappingsDeletePreviewList)
	router.GET(baseURL+"/api/v2/jira_instances/", wrapper.JiraInstancesList)
	router.POST(baseURL+"/api/v2/jira_instances/", wrapper.JiraInstancesCreate)
	router.DELETE(baseURL+"/api/v2/jira_instances/:id/", wrapper.JiraInstancesDestroy)
	router.GET(baseURL+"/api/v2/jira_instances/:id/", wrapper.JiraInstancesRetrieve)
	router.PATCH(baseURL+"/api/v2/jira_instances/:id/", wrapper.JiraInstancesPartialUpdate)
	router.PUT(baseURL+"/api/v2/jira_instances/:id/", wrapper.JiraInstancesUpdate)
	router.GET(baseURL+"/api/v2/jira_instances/:id/delete_preview/", wrapper.JiraInstancesDeletePreviewList)
	router.GET(baseURL+"/api/v2/jira_product_configurations/", wrapper.JiraProductConfigurationsList)
	router.POST(baseURL+"/api/v2/jira_product_configurations/", wrapper.JiraProductConfigurationsCreate)
	router.DELETE(baseURL+"/api/v2/jira_product_configurations/:id/", wrapper.JiraProductConfigurationsDestroy)
	router.GET(baseURL+"/api/v2/jira_product_configurations/:id/", wrapper.JiraProductConfigurationsRetrieve)
	router.PATCH(baseURL+"/api/v2/jira_product_configurations/:id/", wrapper.JiraProductConfigurationsPartialUpdate)
	router.PUT(baseURL+"/api/v2/jira_product_configurations/:id/", wrapper.JiraProductConfigurationsUpdate)
	router.GET(baseURL+"/api/v2/jira_product_configurations/:id/delete_preview/", wrapper.JiraProductConfigurationsDeletePreviewList)
	router.GET(baseURL+"/api/v2/jira_projects/", wrapper.JiraProjectsList)
	router.POST(baseURL+"/api/v2/jira_projects/", wrapper.JiraProjectsCreate)
	router.DELETE(baseURL+"/api/v2/jira_projects/:id/", wrapper.JiraProjectsDestroy)
	router.GET(baseURL+"/api/v2/jira_projects/:id/", wrapper.JiraProjectsRetrieve)
	router.PATCH(baseURL+"/api/v2/jira_projects/:id/", wrapper.JiraProjectsPartialUpdate)
	router.PUT(baseURL+"/api/v2/jira_projects/:id/", wrapper.JiraProjectsUpdate)
	router.GET(baseURL+"/api/v2/jira_projects/:id/delete_preview/", wrapper.JiraProjectsDeletePreviewList)
	router.GET(baseURL+"/api/v2/language_types/", wrapper.LanguageTypesList)
	router.POST(baseURL+"/api/v2/language_types/", wrapper.LanguageTypesCreate)
	router.DELETE(baseURL+"/api/v2/language_types/:id/", wrapper.LanguageTypesDestroy)
	router.GET(baseURL+"/api/v2/language_types/:id/", wrapper.LanguageTypesRetrieve)
	router.PATCH(baseURL+"/api/v2/language_types/:id/", wrapper.LanguageTypesPartialUpdate)
	router.PUT(baseURL+"/api/v2/language_types/:id/", wrapper.LanguageTypesUpdate)
	router.GET(baseURL+"/api/v2/language_types/:id/delete_preview/", wrapper.LanguageTypesDeletePreviewList)
	router.GET(baseURL+"/api/v2/languages/", wrapper.LanguagesList)
	router.POST(baseURL+"/api/v2/languages/", wrapper.LanguagesCreate)
	router.DELETE(baseURL+"/api/v2/languages/:id/", wrapper.LanguagesDestroy)
	router.GET(baseURL+"/api/v2/languages/:id/", wrapper.LanguagesRetrieve)
	router.PATCH(baseURL+"/api/v2/languages/:id/", wrapper.LanguagesPartialUpdate)
	router.PUT(baseURL+"/api/v2/languages/:id/", wrapper.LanguagesUpdate)
	router.GET(baseURL+"/api/v2/languages/:id/delete_preview/", wrapper.LanguagesDeletePreviewList)
	router.GET(baseURL+"/api/v2/metadata/", wrapper.MetadataList)
	router.POST(baseURL+"/api/v2/metadata/", wrapper.MetadataCreate)
	router.DELETE(baseURL+"/api/v2/metadata/:id/", wrapper.MetadataDestroy)
	router.GET(baseURL+"/api/v2/metadata/:id/", wrapper.MetadataRetrieve)
	router.PATCH(baseURL+"/api/v2/metadata/:id/", wrapper.MetadataPartialUpdate)
	router.PUT(baseURL+"/api/v2/metadata/:id/", wrapper.MetadataUpdate)
	router.GET(baseURL+"/api/v2/metadata/:id/delete_preview/", wrapper.MetadataDeletePreviewList)
	router.GET(baseURL+"/api/v2/network_locations/", wrapper.NetworkLocationsList)
	router.POST(baseURL+"/api/v2/network_locations/", wrapper.NetworkLocationsCreate)
	router.DELETE(baseURL+"/api/v2/network_locations/:id/", wrapper.NetworkLocationsDestroy)
	router.GET(baseURL+"/api/v2/network_locations/:id/", wrapper.NetworkLocationsRetrieve)
	router.PATCH(baseURL+"/api/v2/network_locations/:id/", wrapper.NetworkLocationsPartialUpdate)
	router.PUT(baseURL+"/api/v2/network_locations/:id/", wrapper.NetworkLocationsUpdate)
	router.GET(baseURL+"/api/v2/network_locations/:id/delete_preview/", wrapper.NetworkLocationsDeletePreviewList)
	router.GET(baseURL+"/api/v2/note_type/", wrapper.NoteTypeList)
	router.POST(baseURL+"/api/v2/note_type/", wrapper.NoteTypeCreate)
	router.DELETE(baseURL+"/api/v2/note_type/:id/", wrapper.NoteTypeDestroy)
	router.GET(baseURL+"/api/v2/note_type/:id/", wrapper.NoteTypeRetrieve)
	router.PATCH(baseURL+"/api/v2/note_type/:id/", wrapper.NoteTypePartialUpdate)
	router.PUT(baseURL+"/api/v2/note_type/:id/", wrapper.NoteTypeUpdate)
	router.GET(baseURL+"/api/v2/note_type/:id/delete_preview/", wrapper.NoteTypeDeletePreviewList)
	router.GET(baseURL+"/api/v2/notes/", wrapper.NotesList)
	router.GET(baseURL+"/api/v2/notes/:id/", wrapper.NotesRetrieve)
	router.PATCH(baseURL+"/api/v2/notes/:id/", wrapper.NotesPartialUpdate)
	router.PUT(baseURL+"/api/v2/notes/:id/", wrapper.NotesUpdate)
	router.GET(baseURL+"/api/v2/notifications/", wrapper.NotificationsList)
	router.POST(baseURL+"/api/v2/notifications/", wrapper.NotificationsCreate)
	router.DELETE(baseURL+"/api/v2/notifications/:id/", wrapper.NotificationsDestroy)
	router.GET(baseURL+"/api/v2/notifications/:id/", wrapper.NotificationsRetrieve)
	router.PATCH(baseURL+"/api/v2/notifications/:id/", wrapper.NotificationsPartialUpdate)
	router.PUT(baseURL+"/api/v2/notifications/:id/", wrapper.NotificationsUpdate)
	router.GET(baseURL+"/api/v2/notifications/:id/delete_preview/", wrapper.NotificationsDeletePreviewList)
	router.GET(baseURL+"/api/v2/oa3/schema/", wrapper.Oa3SchemaRetrieve)
	router.GET(baseURL+"/api/v2/product_api_scan_configurations/", wrapper.ProductApiScanConfigurationsList)
	router.POST(baseURL+"/api/v2/product_api_scan_configurations/", wrapper.ProductApiScanConfigurationsCreate)
	router.DELETE(baseURL+"/api/v2/product_api_scan_configurations/:id/", wrapper.ProductApiScanConfigurationsDestroy)
	router.GET(baseURL+"/api/v2/product_api_scan_configurations/:id/", wrapper.ProductApiScanConfigurationsRetrieve)
	router.PATCH(baseURL+"/api/v2/product_api_scan_configurations/:id/", wrapper.ProductApiScanConfigurationsPartialUpdate)
	router.PUT(baseURL+"/api/v2/product_api_scan_configurations/:id/", wrapper.ProductApiScanConfigurationsUpdate)
	router.GET(baseURL+"/api/v2/product_api_scan_configurations/:id/delete_preview/", wrapper.ProductApiScanConfigurationsDeletePreviewList)
	router.GET(baseURL+"/api/v2/product_groups/", wrapper.ProductGroupsList)
	router.POST(baseURL+"/api/v2/product_groups/", wrapper.ProductGroupsCreate)
	router.DELETE(baseURL+"/api/v2/product_groups/:id/", wrapper.ProductGroupsDestroy)
	router.GET(baseURL+"/api/v2/product_groups/:id/", wrapper.ProductGroupsRetrieve)
	router.PATCH(baseURL+"/api/v2/product_groups/:id/", wrapper.ProductGroupsPartialUpdate)
	router.PUT(baseURL+"/api/v2/product_groups/:id/", wrapper.ProductGroupsUpdate)
	router.GET(baseURL+"/api/v2/product_groups/:id/delete_preview/", wrapper.ProductGroupsDeletePreviewList)
	router.GET(baseURL+"/api/v2/product_members/", wrapper.ProductMembersList)
	router.POST(baseURL+"/api/v2/product_members/", wrapper.ProductMembersCreate)
	router.DELETE(baseURL+"/api/v2/product_members/:id/", wrapper.ProductMembersDestroy)
	router.GET(baseURL+"/api/v2/product_members/:id/", wrapper.ProductMembersRetrieve)
	router.PATCH(baseURL+"/api/v2/product_members/:id/", wrapper.ProductMembersPartialUpdate)
	router.PUT(baseURL+"/api/v2/product_members/:id/", wrapper.ProductMembersUpdate)
	router.GET(baseURL+"/api/v2/product_members/:id/delete_preview/", wrapper.ProductMembersDeletePreviewList)
	router.GET(baseURL+"/api/v2/product_type_groups/", wrapper.ProductTypeGroupsList)
	router.POST(baseURL+"/api/v2/product_type_groups/", wrapper.ProductTypeGroupsCreate)
	router.DELETE(baseURL+"/api/v2/product_type_groups/:id/", wrapper.ProductTypeGroupsDestroy)
	router.GET(baseURL+"/api/v2/product_type_groups/:id/", wrapper.ProductTypeGroupsRetrieve)
	router.PATCH(baseURL+"/api/v2/product_type_groups/:id/", wrapper.ProductTypeGroupsPartialUpdate)
	router.PUT(baseURL+"/api/v2/product_type_groups/:id/", wrapper.ProductTypeGroupsUpdate)
	router.GET(baseURL+"/api/v2/product_type_groups/:id/delete_preview/", wrapper.ProductTypeGroupsDeletePreviewList)
	router.GET(baseURL+"/api/v2/product_type_members/", wrapper.ProductTypeMembersList)
	router.POST(baseURL+"/api/v2/product_type_members/", wrapper.ProductTypeMembersCreate)
	router.DELETE(baseURL+"/api/v2/product_type_members/:id/", wrapper.ProductTypeMembersDestroy)
	router.GET(baseURL+"/api/v2/product_type_members/:id/", wrapper.ProductTypeMembersRetrieve)
	router.PATCH(baseURL+"/api/v2/product_type_members/:id/", wrapper.ProductTypeMembersPartialUpdate)
	router.PUT(baseURL+"/api/v2/product_type_members/:id/", wrapper.ProductTypeMembersUpdate)
	router.GET(baseURL+"/api/v2/product_type_members/:id/delete_preview/", wrapper.ProductTypeMembersDeletePreviewList)
	router.GET(baseURL+"/api/v2/product_types/", wrapper.ProductTypesList)
	router.POST(baseURL+"/api/v2/product_types/", wrapper.ProductTypesCreate)
	router.DELETE(baseURL+"/api/v2/product_types/:id/", wrapper.ProductTypesDestroy)
	router.GET(baseURL+"/api/v2/product_types/:id/", wrapper.ProductTypesRetrieve)
	router.PATCH(baseURL+"/api/v2/product_types/:id/", wrapper.ProductTypesPartialUpdate)
	router.PUT(baseURL+"/api/v2/product_types/:id/", wrapper.ProductTypesUpdate)
	router.GET(baseURL+"/api/v2/product_types/:id/delete_preview/", wrapper.ProductTypesDeletePreviewList)
	router.POST(baseURL+"/api/v2/product_types/:id/generate_report/", wrapper.ProductTypesGenerateReportCreate)
	router.GET(baseURL+"/api/v2/products/", wrapper.ProductsList)
	router.POST(baseURL+"/api/v2/products/", wrapper.ProductsCreate)
	router.DELETE(baseURL+"/api/v2/products/:id/", wrapper.ProductsDestroy)
	router.GET(baseURL+"/api/v2/products/:id/", wrapper.ProductsRetrieve)
	router.PATCH(baseURL+"/api/v2/products/:id/", wrapper.ProductsPartialUpdate)
	router.PUT(baseURL+"/api/v2/products/:id/", wrapper.ProductsUpdate)
	router.GET(baseURL+"/api/v2/products/:id/delete_preview/", wrapper.ProductsDeletePreviewList)
	router.POST(baseURL+"/api/v2/products/:id/generate_report/", wrapper.ProductsGenerateReportCreate)
	router.GET(baseURL+"/api/v2/regulations/", wrapper.RegulationsList)
	router.POST(baseURL+"/api/v2/regulations/", wrapper.RegulationsCreate)
	router.DELETE(baseURL+"/api/v2/regulations/:id/", wrapper.RegulationsDestroy)
	router.GET(baseURL+"/api/v2/regulations/:id/", wrapper.RegulationsRetrieve)
	router.PATCH(baseURL+"/api/v2/regulations/:id/", wrapper.RegulationsPartialUpdate)
	router.PUT(baseURL+"/api/v2/regulations/:id/", wrapper.RegulationsUpdate)
	router.GET(baseURL+"/api/v2/regulations/:id/delete_preview/", wrapper.RegulationsDeletePreviewList)
	router.POST(baseURL+"/api/v2/reimport-scan/", wrapper.ReimportScanCreate)
	router.GET(baseURL+"/api/v2/roles/", wrapper.RolesList)
	router.GET(baseURL+"/api/v2/roles/:id/", wrapper.RolesRetrieve)
	router.GET(baseURL+"/api/v2/sla_configurations/", wrapper.SlaConfigurationsList)
	router.POST(baseURL+"/api/v2/sla_configurations/", wrapper.SlaConfigurationsCreate)
	router.DELETE(baseURL+"/api/v2/sla_configurations/:id/", wrapper.SlaConfigurationsDestroy)
	router.GET(baseURL+"/api/v2/sla_configurations/:id/", wrapper.SlaConfigurationsRetrieve)
	router.PATCH(baseURL+"/api/v2/sla_configurations/:id/", wrapper.SlaConfigurationsPartialUpdate)
	router.PUT(baseURL+"/api/v2/sla_configurations/:id/", wrapper.SlaConfigurationsUpdate)
	router.GET(baseURL+"/api/v2/sonarqube_issues/", wrapper.SonarqubeIssuesList)
	router.POST(baseURL+"/api/v2/sonarqube_issues/", wrapper.SonarqubeIssuesCreate)
	router.DELETE(baseURL+"/api/v2/sonarqube_issues/:id/", wrapper.SonarqubeIssuesDestroy)
	router.GET(baseURL+"/api/v2/sonarqube_issues/:id/", wrapper.SonarqubeIssuesRetrieve)
	router.PATCH(baseURL+"/api/v2/sonarqube_issues/:id/", wrapper.SonarqubeIssuesPartialUpdate)
	router.PUT(baseURL+"/api/v2/sonarqube_issues/:id/", wrapper.SonarqubeIssuesUpdate)
	router.GET(baseURL+"/api/v2/sonarqube_issues/:id/delete_preview/", wrapper.SonarqubeIssuesDeletePreviewList)
	router.GET(baseURL+"/api/v2/sonarqube_transitions/", wrapper.SonarqubeTransitionsList)
	router.POST(baseURL+"/api/v2/sonarqube_transitions/", wrapper.SonarqubeTransitionsCreate)
	router.DELETE(baseURL+"/api/v2/sonarqube_transitions/:id/", wrapper.SonarqubeTransitionsDestroy)
	router.GET(baseURL+"/api/v2/sonarqube_transitions/:id/", wrapper.SonarqubeTransitionsRetrieve)
	router.PATCH(baseURL+"/api/v2/sonarqube_transitions/:id/", wrapper.SonarqubeTransitionsPartialUpdate)
	router.PUT(baseURL+"/api/v2/sonarqube_transitions/:id/", wrapper.SonarqubeTransitionsUpdate)
	router.GET(baseURL+"/api/v2/sonarqube_transitions/:id/delete_preview/", wrapper.SonarqubeTransitionsDeletePreviewList)
	router.GET(baseURL+"/api/v2/stub_findings/", wrapper.StubFindingsList)
	router.POST(baseURL+"/api/v2/stub_findings/", wrapper.StubFindingsCreate)
	router.DELETE(baseURL+"/api/v2/stub_findings/:id/", wrapper.StubFindingsDestroy)
	router.GET(baseURL+"/api/v2/stub_findings/:id/", wrapper.StubFindingsRetrieve)
	router.PATCH(baseURL+"/api/v2/stub_findings/:id/", wrapper.StubFindingsPartialUpdate)
	router.PUT(baseURL+"/api/v2/stub_findings/:id/", wrapper.StubFindingsUpdate)
	router.GET(baseURL+"/api/v2/stub_findings/:id/delete_preview/", wrapper.StubFindingsDeletePreviewList)
	router.GET(baseURL+"/api/v2/system_settings/", wrapper.SystemSettingsList)
	router.PATCH(baseURL+"/api/v2/system_settings/:id/", wrapper.SystemSettingsPartialUpdate)
	router.PUT(baseURL+"/api/v2/system_settings/:id/", wrapper.SystemSettingsUpdate)
	router.GET(baseURL+"/api/v2/technologies/", wrapper.TechnologiesList)
	router.POST(baseURL+"/api/v2/technologies/", wrapper.TechnologiesCreate)
	router.DELETE(baseURL+"/api/v2/technologies/:id/", wrapper.TechnologiesDestroy)
	router.GET(baseURL+"/api/v2/technologies/:id/", wrapper.TechnologiesRetrieve)
	router.PATCH(baseURL+"/api/v2/technologies/:id/", wrapper.TechnologiesPartialUpdate)
	router.PUT(baseURL+"/api/v2/technologies/:id/", wrapper.TechnologiesUpdate)
	router.GET(baseURL+"/api/v2/technologies/:id/delete_preview/", wrapper.TechnologiesDeletePreviewList)
	router.GET(baseURL+"/api/v2/test_imports/", wrapper.TestImportsList)
	router.POST(baseURL+"/api/v2/test_imports/", wrapper.TestImportsCreate)
	router.DELETE(baseURL+"/api/v2/test_imports/:id/", wrapper.TestImportsDestroy)
	router.GET(baseURL+"/api/v2/test_imports/:id/", wrapper.TestImportsRetrieve)
	router.PATCH(baseURL+"/api/v2/test_imports/:id/", wrapper.TestImportsPartialUpdate)
	router.PUT(baseURL+"/api/v2/test_imports/:id/", wrapper.TestImportsUpdate)
	router.GET(baseURL+"/api/v2/test_imports/:id/delete_preview/", wrapper.TestImportsDeletePreviewList)
	router.GET(baseURL+"/api/v2/test_types/", wrapper.TestTypesList)
	router.POST(baseURL+"/api/v2/test_types/", wrapper.TestTypesCreate)
	router.GET(baseURL+"/api/v2/test_types/:id/", wrapper.TestTypesRetrieve)
	router.PATCH(baseURL+"/api/v2/test_types/:id/", wrapper.TestTypesPartialUpdate)
	router.PUT(baseURL+"/api/v2/test_types/:id/", wrapper.TestTypesUpdate)
	router.GET(baseURL+"/api/v2/tests/", wrapper.TestsList)
	router.POST(baseURL+"/api/v2/tests/", wrapper.TestsCreate)
	router.DELETE(baseURL+"/api/v2/tests/:id/", wrapper.TestsDestroy)
	router.GET(baseURL+"/api/v2/tests/:id/", wrapper.TestsRetrieve)
	router.PATCH(baseURL+"/api/v2/tests/:id/", wrapper.TestsPartialUpdate)
	router.PUT(baseURL+"/api/v2/tests/:id/", wrapper.TestsUpdate)
	router.POST(baseURL+"/api/v2/tests/:id/accept_risks/", wrapper.TestsAcceptRisksCreate)
	router.GET(baseURL+"/api/v2/tests/:id/delete_preview/", wrapper.TestsDeletePreviewList)
	router.GET(baseURL+"/api/v2/tests/:id/files/", wrapper.TestsFilesRetrieve)
	router.POST(baseURL+"/api/v2/tests/:id/files/", wrapper.TestsFilesCreate)
	router.POST(baseURL+"/api/v2/tests/:id/generate_report/", wrapper.TestsGenerateReportCreate)
	router.GET(baseURL+"/api/v2/tests/:id/notes/", wrapper.TestsNotesRetrieve)
	router.POST(baseURL+"/api/v2/tests/:id/notes/", wrapper.TestsNotesCreate)
	router.GET(baseURL+"/api/v2/tool_configurations/", wrapper.ToolConfigurationsList)
	router.POST(baseURL+"/api/v2/tool_configurations/", wrapper.ToolConfigurationsCreate)
	router.DELETE(baseURL+"/api/v2/tool_configurations/:id/", wrapper.ToolConfigurationsDestroy)
	router.GET(baseURL+"/api/v2/tool_configurations/:id/", wrapper.ToolConfigurationsRetrieve)
	router.PATCH(baseURL+"/api/v2/tool_configurations/:id/", wrapper.ToolConfigurationsPartialUpdate)
	router.PUT(baseURL+"/api/v2/tool_configurations/:id/", wrapper.ToolConfigurationsUpdate)
	router.GET(baseURL+"/api/v2/tool_configurations/:id/delete_preview/", wrapper.ToolConfigurationsDeletePreviewList)
	router.GET(baseURL+"/api/v2/tool_product_settings/", wrapper.ToolProductSettingsList)
	router.POST(baseURL+"/api/v2/tool_product_settings/", wrapper.ToolProductSettingsCreate)
	router.DELETE(baseURL+"/api/v2/tool_product_settings/:id/", wrapper.ToolProductSettingsDestroy)
	router.GET(baseURL+"/api/v2/tool_product_settings/:id/", wrapper.ToolProductSettingsRetrieve)
	router.PATCH(baseURL+"/api/v2/tool_product_settings/:id/", wrapper.ToolProductSettingsPartialUpdate)
	router.PUT(baseURL+"/api/v2/tool_product_settings/:id/", wrapper.ToolProductSettingsUpdate)
	router.GET(baseURL+"/api/v2/tool_product_settings/:id/delete_preview/", wrapper.ToolProductSettingsDeletePreviewList)
	router.GET(baseURL+"/api/v2/tool_types/", wrapper.ToolTypesList)
	router.POST(baseURL+"/api/v2/tool_types/", wrapper.ToolTypesCreate)
	router.DELETE(baseURL+"/api/v2/tool_types/:id/", wrapper.ToolTypesDestroy)
	router.GET(baseURL+"/api/v2/tool_types/:id/", wrapper.ToolTypesRetrieve)
	router.PATCH(baseURL+"/api/v2/tool_types/:id/", wrapper.ToolTypesPartialUpdate)
	router.PUT(baseURL+"/api/v2/tool_types/:id/", wrapper.ToolTypesUpdate)
	router.GET(baseURL+"/api/v2/tool_types/:id/delete_preview/", wrapper.ToolTypesDeletePreviewList)
	router.GET(baseURL+"/api/v2/user_contact_infos/", wrapper.UserContactInfosList)
	router.POST(baseURL+"/api/v2/user_contact_infos/", wrapper.UserContactInfosCreate)
	router.DELETE(baseURL+"/api/v2/user_contact_infos/:id/", wrapper.UserContactInfosDestroy)
	router.GET(baseURL+"/api/v2/user_contact_infos/:id/", wrapper.UserContactInfosRetrieve)
	router.PATCH(baseURL+"/api/v2/user_contact_infos/:id/", wrapper.UserContactInfosPartialUpdate)
	router.PUT(baseURL+"/api/v2/user_contact_infos/:id/", wrapper.UserContactInfosUpdate)
	router.GET(baseURL+"/api/v2/user_contact_infos/:id/delete_preview/", wrapper.UserContactInfosDeletePreviewList)
	router.GET(baseURL+"/api/v2/user_profile/", wrapper.UserProfileRetrieve)
	router.GET(baseURL+"/api/v2/users/", wrapper.UsersList)
	router.POST(baseURL+"/api/v2/users/", wrapper.UsersCreate)
	router.DELETE(baseURL+"/api/v2/users/:id/", wrapper.UsersDestroy)
	router.GET(baseURL+"/api/v2/users/:id/", wrapper.UsersRetrieve)
	router.PATCH(baseURL+"/api/v2/users/:id/", wrapper.UsersPartialUpdate)
	router.PUT(baseURL+"/api/v2/users/:id/", wrapper.UsersUpdate)
	router.GET(baseURL+"/api/v2/users/:id/delete_preview/", wrapper.UsersDeletePreviewList)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+z9e3fbtvYoin4VXO19R5L7U+w82q7u3LHGOo7tJG5tx8tykl93ms0DkVMiIhBgAdCK",
	"0tXz2c/AiwQpUqJkx0lb/ZOYEB4TwMR8Y+L3QcyznDNgSg6e/T6QcQoZNn8exDHkCpJLImeX8FsBUuni",
	"XPAchCJgKmFXKRov9GcCMhYkV4SzwbPBOc4AcYEgw4QiPkE5CMkZmqcc2YYSqRSQIHI2GA4y/OkU2FSl",
	"g2dPHj0aDjLC/Pfj4UAtchg8G0glCJsO/hgOPhZSkQmJsR2tOfhP4c9owoUbkrApmhCWEDaVaE5UilRK",
	"JLouKAOBx4QStUAkGawdv9YiIskyCAcMkUTPGze7ZwgjCXEh9BdOronkYoGwlDwmWEESAOZg3UOHmKEx",
	"IIwOeZZxht4GXRKQCLMEHX/KuSwEoPuHb48f6LWfCJ4hrlIQSPJCxCD36kv9/bqV/mM4EPBbQQQkg2fv",
	"azve3ISWRflQ9sfHHyFWeuUOkuQc5i8IhddmqTqxa0IomP+5yLAaPBuMCcNCj7u0G4ooWzeY2uNHG87N",
	"jOf76ob8nKt1kANTwpyINUjEuILIlv4+YAWleKynoUQBZW3CFExB6Oq5INdYmcruxzHnFDBbmooFoHUO",
	"eX7AMF1IIpfhjjmbkARY7NeSZEU2ePbk8Xf/+O7Hpz989w+zoLbwYVn643AZdrsfg8OyQ0ThGuigbVqx",
	"AI31ta1OsIKHimR6QwTg5DWji8bCVMtIYksCmiSkY0WDhmbQjv4DCBnOoG2ApQ5zwZMiVsEOBb0oPDWr",
	"TBRkMqgSoLEtwELghf4uJIj2vq5BSNJz1m4v3tom6LzIxiDaTtEcxpKo+pkrBKlTjO96razrKprwgiU3",
	"77CB3h5jzA667akW363bGuzvPLxf5xBsjcNduLmG9GyGqWs62+FtP7zdAFELlV7xGbBl/FS+eA1dbIxt",
	"m60cq/NI5FjKORfJOlQYDuaCKKiAcrhQ4uhGbRsTKIEI+mybzvNC5Jd47iZzCTLnTMLypAT8FgmQeQ3R",
	"cZIQzdoxvagvegfKV8PWz0AD9nKs/gB3bsZGcPc7uLcxC0PlpoUwsuAFiIxIf9Kb9DWBFqL1uJWh3oRD",
	"f//9Wj7iQQkZSdvkjoCCggsB1wTmy1OyUDZpwXqoM54A7XGUq/ltduatImMGWT05hUcKKyIVidvEQsql",
	"lc/+p4DJ4Nngf+xXeuO+Uxr3R3ANWqPRPRUy6K8u4m3bBYWJQgVTvIjTm/UkAMfKSNI36KaJSXaJhoFo",
	"0gC4Pm77PlwD5XkGTB2zayI40392YdutSa1tOLMCV9pg7KRVWwknbUyzFRb+kb8UvMg7ZDhPjKK8pEZ1",
	"qWa9xtUUbGoa/u8NaeBLaxwt9EzLEjABFactTNtKGdFUL9FKJrHqBFw4WeWPTnpWbYgfUf9wO8Ne6SH6",
	"DK0lgq0HeyNBjFQx7jFSG880Zhsa5YJfk8QKvnVLkEFSRLKcCwWJNcpgZJsh32xvMBwA00rF+8HB50LA",
	"wdFgOBgMNUp96JaOR7YXLcMBU97gdeFhacGYcqmaemiAfh2r0C4WhDqY7XzlaT0DI8cv4evUH+UW5ajn",
	"qek+DGXn2+BHRWj6oKLg1hS1zUiXum1ffP9K6O7nV8fxq5RIpH9CCShNbxlY825AfBGfmCINPFIcZZjh",
	"KZgisz97gwqv7ZkxY7XtdJeG2UBNu+1OunOddepcDQztZGorEPXPuDa9l2W1xeRb5LZdXHSNVvSnIuh9",
	"paVjluScsFZrtf0lyrHA2c1Yw3DgvSs37UbgqRd/m6cJkP8VkUQv0oSAQPOUxCmacEr53B6vFMsUZVjM",
	"9tBV+IlkyguaoDEgnhGlINlDL7hA8AlnOQV0T0KsB3v4+Om9Ibqnl2UqcJ4+fHJvyX3SBw1TLjvmoX9B",
	"zDnKTi4QThIBUu6hE4WyQv/GFSIspkViaYHGOMSMJawB8+Mn/9h7tPdo77EGmfIYU925/ljwQiQ8w4Tt",
	"xTzbbgq9OTBWaftUNUgGlR2hE2A9UkNEgrlKhYWy/i+M7u3fq0/SY+r+d08e7UNC1DZT0UvYDiIDNedi",
	"Zhd52R1Xje+WcGvDcIvgUlpje1VWPOa0fRIxz7KCebrh61rmD0gWcYqwRPdSpXKNHBP7X8LkvSECFe81",
	"XbE9VvS3AsSiHRrzE7JVh2YNDQ/RoHWcxBpSGx71z+9+LR49evKDApz988d7dQAf9+ME2/leCJvw5Xlp",
	"+Qnpn8xCYkpi0Es45uPWJfx+cztxkyIHVNUcxVX0/QwUPrGcqUXItuaJKOEfeZSBwnZ2E1xQNXg2wVRW",
	"sJW+RW/UiDxYstaqNqHlRn7l19Zfcvdai/tmnguvgvbXGGx9Lyn08hAHg/TdiW7Z6U+0Id3+91570scL",
	"0Lriqxa5O3pgJ0B8SwLETjDYCQZ/CsFgC1f3XYoJnYTQuiiW6WCCG55xU9AyMwgUxGXcMqwoyrkkily3",
	"hiCVQsrNbHgUSxVlPNE0uTsmqKevrZpdRhSZepfPMujlzy6Ucf1hq1oYkG4NUF6oiE8iGfO8Y5kFkbPI",
	"B+L1CgZzG1vtkLOI1dd6aU4f1qJbJ/f9VrDu1rf9TranfeGneArtHkHjV1zlHw7AwzmJlNuz5V/HArM4",
	"1TJiC9nGUy1l2CqeWzsG5bigBxHpESBpkLjH368I83luut2/wtM2NBkXhCatYbbP9S/o5Oj2AGofW4K4",
	"brMF2vHtr1p2yTmTZEzBBB0fnuwfHpmxB324fZxCPIso6dodzcKJirQcugzIofnRCqnGIikg59vMd108",
	"5sYkLYGkyKmTPCLOIqjhcn0aJxMETHefoFo7NCeUIs7owgoI2MdGI8JsrHSw21gi3xRMCDazQdBlkwka",
	"c5VWoeBYQEs/e+hkghIiDTjDBjxEIs5qKGei+0JD/VFjAiptgVVPadB2UrvN30/6yTYJZ2DOuiOP64lD",
	"BVYZluxN2CdMgXCEZjgwiN1ty25CotW4upi1ykH1gqz0ggWmZiFVFHOmcNyGsINbNGxSwEk/DtHidHja",
	"z1vB1QaLdM5Vr0XiIk5BKuecATYlrMVF9TqsZagZieGm5CwHtoLV5AIktBCAEShlzyRLkFkTM3YOQm+u",
	"Pr3NUzrYUJNq/XGq9eZesVgCsNz2SGqaLNQGMf/CSliW8/SoXgkf2EUw38AJYxXxKOYJRNYhaUhDFysc",
	"mepIV/cMcT3WeLfX4Rka2X7b5tUBSSHIMhiXzoCAKGEzpLi7+mLg0kJWZ0TvD6vCkC8tN112FpZ6l6eU",
	"51yhkcLChoE9pzyemb8O9Y5Qav/mWo+1NU6Me8/i33DwmqFXnOryd5jY+0pcID+n/iR3c4u3wmIKKgKW",
	"9JLcXXVjmOnXAKSuLrCC6WJ1bHW/0HeVakklKqMol2mMMr9F3vi0seSiBI5nbah+6lALchJroViReAYK",
	"yYVUkFm7UJxiNgWpa7mo972V2NdvzkWe3K5wFkTk16fo4+63kas3d3mUkkUVQFkTX7wM4SN1Da8MQ+nz",
	"6gg1iWANtRuIW8eRan1Xq2AXhnfJLnP+Te4y9Q0QtCbJyFtP1/nbm4e9FDbqm35UfemNn6dYIQaQGDQe",
	"g9tujfHSsmlU5AiqSFBDrKo925xBrmTTpdbd4Du6WIN7XMdLY1o8ubgn9z35lPtvLk/vyQd10H5sDT03",
	"5Moz6g1WtryL2NATBYEJSurra2WgNkvgRheg/KL1QtruYN0dSv2lUWoTv1s/jOq+GL4zMu2MTKttEzub",
	"0FexCX05C8/NbTF3YGPZWUN6WEO+ZQPHziTxFzJJbOhr/ysaKL45A8M3Yg+oFPtu3X21cHrFX3ivQzPe",
	"vWSBpCe/2c5/sfLWVB0KP8S6KZ17HevGU9rO27DRlOwQrVP6BHGhBY1RkWXYxgh1zqh39pVQttmMVCy3",
	"3JBqBPpqf3hr9CYyq7+W5nTolN3T9ZanlQ3bZ7um6SKHDebKFaZReDlkzfWkJgJ0bW/35nVtTdvCL69j",
	"2wItzXxpXm3I/sLF0a7JbtUR7tzXINiZAqtXSLM5r92Zr15UMTYdGeAEkbP+5OSSyNlBZaDt4YqqQlya",
	"1iUrFJOJS5hG8VyrYba+5pyMG5m4JRJmCv2WtpxAie5tme4sW8STCWgFCJWN0H1KxgKLhYnTHaIcC2XT",
	"wllmPkR7e3sP9rbh1RVgfbn2MnhbsOpaiMhyaKcmHWYwr1nPsUSuBSJMkgTQEWg4jvhHXpNZbuTJiK+l",
	"vH7abrNoZMxboFHMdTs0sgKVWz/0FN0/fDsaXT99gGTMBXRk5aN43ly3x/9YBjnHSoHQMPyfg7fP3p8f",
	"nF58+M/B4bP3p68+/Ofi8tn7N+f6rzcnz96fX374z+jZ+zeHH/7z/vDk4MOz9/qnwG6gwULXTwedE48M",
	"wC3YWWQgSIwpsjNzEzNW1RTquQmNccOUQqy40AdpSq6B2Qhd25BI5JwkaJ4SCkjia6uHljte21JejOkK",
	"9d/GoptpzKEdoQ7fHbuQ9bXbcXuR1z6CcRV+a1qjkTshMubXIKzgu1ZiSAzyRzabTOQV4PYsmkc8LjTr",
	"kiZvZlkXYWR7QbYXt53BYvSYYd2W1NA/OJuCQJne8fKXazABzXp6+rDgMS9UuRJ7rVMlMqd4EVUq6fpo",
	"MW+k24DY1y17zq5H8Vwia4+wG9NiTvPNoiCKtF0R09PkgkwJwzS0GYZpOhuw7PWnYuG2LBjOSNwN0Qs9",
	"6xRLNAZg5kp5HNxCPrLN0UFeWRlHPtnolXVhIMU5RfePDkZXD2q2SdfWT8fWGLRHitWuHrXdS5GVdTNU",
	"F7EyllVZSJOQdUzBLq/HXfRf5rKNxRjPt/xw3QQA3fcEnsIQnfnA3oq73uQysg1D7omQwdZAZo6qaY98",
	"GDMaL8ycjKoswvV/Yepd+HDnrktZUftlmhN/lSlButZ9+QAZeyxhJXle5ls9b9KXCnADFXWxHkgANXvi",
	"Doof6Ob3yIM8Mj11b9NsXbqOpWH83btNBjnTbfqMwQvWTt3N5aJAepQxZgyEPSWk2s9bWtMUy9QYLFuy",
	"FVufjuZiCKMyo4M+nRKMvDohQBPpQJOokBrPuKj8JTVXyN42ElxfXYdkOY7b7mrBJ+W41djjvK3bOJ6c",
	"OeFbDj1lkkMETIHIBZFQXtBZHz8qo9odg03ow4R86mJMH4nAkTXwbR9LYjvRgrdj8dt1Y26JWDGjbY4u",
	"NYW9MbksG+nW6J7LgnZP0z4cUL7bkfxrELYetBqQQSJyA51vWTtmmzNuA4VlW5GVkFswlGQgFc5yfaI0",
	"yZTKczrbBN23u44I8z942moP4INbXLZW59eo9FSAl7q98qgUjmdON7ipwO1Y3mk1zGC47gLPxodLo5tU",
	"VtMr0ZMog5jl6bvlC2Y9xHgNZIbFzKCchzwEaYtUknb4Vlm+SRZTPrexN1LpIVei/XKU+jjicVwIYHGb",
	"RHBeYkxVCzkZ0Dm9jPA5T4EhCdcgMK3poCDRHIx+WrDEeD3xdCrALK2XnBybvCUUbAN5cHsm83VMmXn9",
	"PJIu22SHnFDq8QKMt5ip2r1p3xrdHz0aotHjIRo9GaLR0yEafdc0L33X4+Jhj8M2wZRKxAtlbDrORJCX",
	"0oyhbpgl+1w0HNQt/m8scNZCt3UxKBBW3tDipSDTKVjbBZGygECPWXts3I6XvbbmMsALynEbo7M/lJA4",
	"cmjX3oYI7CMcqF0aeUNwx8UU7Wt5Y0wh20pAyqlG/CQSWrEgNoihr6GCSASfcqsr2sg730u72aJHXF1X",
	"tr3VBo4vnLOuQ6vfZlRv9u4zaJmzxYVxbDNemaNrkwHlnYxWKoDbrWPPtIY1pe8mK9lTDQxGDnS0bQa8",
	"Atk/W2mbvPrFT0VTQPniA5bscpuR1nDPIB0lVLmOvviUvhZFc7hyJylul+5P3OQc9nb0hel0GRa/FWOI",
	"DHvfduSR7+bE9NJnZB+dt+357z1IZFNH3mRh9Xg2udSWaVzzYkyJTDvEhyMtOhgZveV9rLlRXxJApo+Y",
	"LhC+xsQIC9sJEoVMI8Wjj0T0zH+lJY8uDURLPvBJgWCYosTpXU4g82D2dpeEgY1GC4+sFm62jdLXk8Gz",
	"97040aVt/sK2/uNDc88alGy1E8jlHQ31tvUaoiNakQhexOg3hY4XNTomcSOn1pI3y71/1suhVaOSq0ds",
	"MfhscB9jKcXHGl3JuVNK24TT/bFEmCHfj3kIr105ksayRNgscud32WhD2AzZH9H9ayyIdYNMCmYSke3t",
	"7T1YZcXZLFGWBceGv67wRzhDkq6BdI0+APR0R4QQfAtWrNHB6Aq5IddZtELYO7fTdnVnG2rtKVH96atm",
	"FEX9FSs9eoMtmPx5RCJZaCW41VyzuWHLqdZtHguvdRuvqwQ6eej8XZCgnEBsDBF+xbCF0XokMXIPDOwh",
	"k5ybmJPIc1vRWlqr+RiFn7DGXQ/jEvEvSVprltoqime12ac065SrHrg8DwVRJMZ0iF6RaTpEZ5CQIhui",
	"Uz4fopPKVY9pa4BRJyjRmuc1mxbFebpAGMUg9OpXIGtBYWXExvq1oThK8EJGAjLryOznIdLtTMxeh3xz",
	"X3fBGV08KA0lZpexdJkGTZFmQ6PTAxRjGhfU+rXQCJRGbPiUE2NX1mQbVdKy3EPHWa4Wuo4TZIYoxoXU",
	"dY0rmI6N2Yije3qQe1uJTC1C8jLqGBH438XYG8pWvjDai8NKLUhtHZpg3s/pFZkwakYmuKZlYMKoMzBB",
	"KsilliYFWM8e9PMTmnbWu2mSTo7BpQK1Z5+LxCbmL7utLGv7aFxMe6HzFkkZoCv1p7Guem/sylPWI3g0",
	"1XWijWNNlyhyyoVq3kjtiDz4/nHbnY+CJSCimgGxv4ClabVuX4+Napep7EBrR5D1SKO4EAKYogs0BnP4",
	"nSTZNQb5rYCIJJE+AZHG7ZYIzRoTVRCnzFj5iTs3Dc/JHjpwCWo5MrdHkB2lxoxJy0O/vbJLiBYAj70y",
	"VWpdFu1y71M1QWJtgWErKH2fvBRlCshN/H4ZZgWmdIF8By3hNksbpdduzTadc/bQrfTaPWrNEVsXljQM",
	"vbbIv4JZa31y5MbVoPZ4nbq/16o2zkmy9s5HIwDcRlXXsngEq7gUD9hmqw8t21XWj0Y4UCNwJ7DfhlEu",
	"Lq49DKZoRkU0wxtajLOtnv3QM92wrVbZSVpce97TVfmZlkwLgSWgRWtvldYDIbJVZnJ8JCT0HrXsoV8R",
	"9H9IedvzmbUwzZY4tSpkbvnHZtDMisSc/S+lrMvM+ceaKXbnMv0rzdScy1UZRG/tesXu1sTu1sTu1sTu",
	"1sTu1sTmtyZ2VyB2VyB2VyD+9lcggpiUDbxTuyj/P0uU/y6yfhdZv4us30XW7yLrlyLr+0R77OLqd3H1",
	"f8W4+l1k3oaReVXcXFdQ2C4gbReQtgtI2wWk7QLSdgFpNw5I2wWW7QLL/jKBZWuCwUqJ79EuEOzvFwjW",
	"J1vwLkrrzxCltfy6Uj0uq28Y1oowq68fSLUuMsoHQbnApxJ5P6wLmOl+6GQXN3MHcTNfPUSlnqh+F7Cy",
	"C1j5WwesrHm34U7DV/4UoSK76IktYxn+BjEAfx5X8c4F+iVdoF/HXbmGlH9l5+XOLbdzy+3ccju33M4t",
	"92245Xaury/m+lrDiHeOsJ0jbOcIu4M3Jr8tt9ga6HdOsm/ASbbaOLxzmX2TLjPv0entOav7ywI/WKtv",
	"6mZOp+PaW+h1j9Pu8fxWz9QdPFnf997S1o+TB49y98go6aTmb+jNXrIGqct3OJex+gZr+2T9I5f2NVrd",
	"dAV8Nlf01pCZtCJVxtpeiTV/Ork8cOlp23Jptk32++873mPt8aRqlQzFwulGcO1XLM2ZexypvjIt4D1+",
	"0hbEd41p0XoiVu+aA862XgNdp4O+C8g1glUnyCvbbTkBfZKv3IP5t3csWjBlm2NxURGlLwqbJX+RcuvQ",
	"kwDalOvbzKuekHdpdt60eisHuUwsvUnGYJtRerm7xmQNoOuP8C6CZRfBsotg2UWw7CJYdhEsuwiWbXxJ",
	"u1CUXSjKLhRlF4qyC0X5E4ai7IJNdsEmu2CTXbDJLthkF2yyCzbZBZt8I8EmuziRv0OcyC7i488U8VEP",
	"9Fgb3WEmtcLxcgVZTltz7ldOgTvJiL5kjJ97t9wt2qLrltpbC6mobG9ruzRXzDXz73xPYdsElH0n1W4+",
	"2XjUup68kTC5sSS6TfoQi9ZRht0T8I1Hg5ge0NF5X9lIYKaBpfKlKQXhRAv0e+hM/4jmhFLNsbFL26Q4",
	"wpQ61+OwIoelGD5eoMN3x6GE4Y+d69GCk7RSzPpUog6mbPoBM5SpgZSWOu47xUMiCVjE6QNjyWvAYkEo",
	"IRov0JXpwVVtB8pDUfc1PvqSFLIkVetIZJXuwRy0DirZmzR2+qa7KeQduDO/SXrZnw5uSLS+KrXZOEZ7",
	"R3u+Du1ZFzV125Sor8zWg9TIG8XSGkVyjqWLlRwaq7B9xR1leOFTjDu9CejdBtZ+Gei2jrL9olBALTa6",
	"RxxVEExtmteiUHu1r1psILKad/43iGbTGGqj2doPoImZ66Nq+rimLxnLWwL7LQbyXvEX/qmOOmzlCx69",
	"SJLupI37+IcH7UzX8fjGBJrPGa5ZZn7uE6M3Z7IJDG351VfNXA+6luQGIPj+22bykvIxppectuDK1Edc",
	"r59AX7QSnHZYT6cGEKQrdPH4Mjx+kYM0HNKHabRaAx31fll13OpaKaS9A78hpnRgRrWenVLzBsv6516u",
	"pcU5MczmFLNpgaddFKBmFygEGay+idHjQA+qBh/WQ9W5b0vAjQnDYnFH8I1izFZHBzvHvt2OhmsQKMTK",
	"mjFBQiUcYwGBddf21m63xDmJZIxZVL5KtEZ3CXAGF4rbJ11BN9fScftjm6sEvufu1pRAWvQrRSobg5Ps",
	"bSaaVbedTJ1+3cWUS4g4TbxHRrZFVHStPKeBUsI4ojYw0gXm+NgkG4uIpqCQGc74yMpgMuvPtDIbYVMT",
	"ZeudraVZWoIaIs7oIoyklVV4hG/gyYYdpyNUfGnKkUPVMNCn3wIs9+UolvQUqyz3AUo4A0O+UP2Jtj30",
	"PPD2EfMSlg1gzAC7UEKs7BrUlr2r3+CyFRb2BSI9u87w+bVydj98siei/nRyNOEiwpS241jb4TY4oPQa",
	"2g0oHUO2Q7vPZi30ZrsXS138Edg4bBOdq1LMEGdg21UqdHtUbOhyjziL6nJ/92t8keIRTjoeWT25QDhJ",
	"BEg5NO/zmSsG+shPCkrRm8vTPXRSOQyvMSVJK5NqBab19whY0uG0PmYJOvKWiUpL2UNHdjcCzxhSJAP0",
	"X+jpD9+jBC/kHrp0NB5ZboEWgMXDjDOVPkzwok9wdwBjX+kqaOLl95ZuawpW6zN6fViwQZLWQK3DlHMJ",
	"VdyGOd2F4hk2IRF0YREMMZjXrDT6IMYpl+Ab7pkkt0Wm+WTjzkrzEst/LV8dCQORP7Q5IgD3lM6d9bAR",
	"belO5OCETfigeSbPbJNmkIiNLrT021ic/PRcJ6d8PhgObLDIYDh4RabpYDjwwSSt0/DkuC+O+PqdCOIr",
	"6B827tU06u5642BEI3G0H08tEJlrPxQMlhnjhedpJrqEsxpX6XWlwgzozQJ+dw7igoEin5ARwobl99Mf",
	"HpVFLE41ET1mU8JgudQHkaMLTkm8QIcpxLOgxkuhxyy/D69ObU3NHS+NTFD/8W1BWfBDno9ykoAoB/6t",
	"wOXfAscpI+VnkRD106j8fDdCF4LPadD4nf6VF+pJrcTHjrwqxmX550JA9cuhCZZHl6BZJLDEMAfpKz/H",
	"LCGq/KI4nh0V8QwdXJz470R/H5Y3zS6JnNV+CoZ+LvAMMszK72IaCz5PdHfIisy29NCUlrVYQkE8NItQ",
	"FYo83KKw+KXAefrvUw+kLro8Hl2F3676IRZTXuvX7HGGxSf0enRQ+16qYJA5AYWJtUSbX/h1WZFiItDP",
	"FIt6SfnBi0TmlAdjay1O7RFeX4+quKzHlMAyaOcIlp3gocAyNXHY5Sb/NHp9jl5YtaXl5/8+O61+hcRM",
	"zPe9iClncPTfvuAIz9nIxtCXRZADS4D5I9JSfmXiP5wJBl3geIan+q8XltPef3Hx4gE6/uRmfGSioh5K",
	"iAWoEhcTHs9APBwDi1P9m4Xdj8XjGS3R4Ei8AqyPlpm4XUkTpXk0en3hKx0nU5DBVI9Hp4SVi/pCi+uT",
	"sv+XwECQ2E9BVtvzcipTE+LoaxKVFuOl+4f+t1M8Ntv7ovj8Wa+ApQeNCocu9FI0yo8ORlcVBfGF1TKb",
	"jal6reqM2hqOzPoiu9qaHIcVKOBZufQvuYQYuW3XTA7rrXjNAB1iaYxvr3DCqV6+I7NLJhY4dvTyFRZj",
	"LtpX5BUXhe9bfxZytjg8qSB5tUhESRVPnp8hTTb1puml0EVZVjAyh5LGnDA1ItNUBST4pxeCT9F/C2xO",
	"CBoVWYbFAh3oDcZxufZBteWSN8y6qNwvP58cltT4Z1LMKyyaFWOwOOpLzkCBIFWNMxILPuFxIdE7GBMm",
	"c6iAOOPj0YvgQ05CFD3jnwmlGL0ea4UQKy5KWM9BykI2vt4djKoSJXMsZhVOnUPx1t70vG9YMsEshgf1",
	"HzTdtEWfcl6R2XMyUyU5Os9wSVDPeRLwlguKlebe5a8XZ6hGbc+LmELJ5V7nwGSM83ZM0b++PRihw9Fb",
	"/XV5heAa08JoRhlPgIbn/LWUJyyBT+gIrrEd8fDAUuywVqFyLtWT7/wYF68uKugtpNdPfPkim3C2CDin",
	"Q++c5A9xOKuLs6Pyz3fn5uwNhoN/F5guJDphE027RRErw4c1SPffwfjlmxNNhx9UNV0X7usdjHFervMl",
	"KCJg72NZS7Ndw8RZwDzMJC+LMY951bKQWh7gU18wOrg8eaH/jzFTpOIqRppAo4KocttHkE0F5Jaqlsdr",
	"9HOJsCO2KKn/iGvWd5DnMhYAAS2rYm5rbK4qXqrX5LT6F2MKqMXJulY5V8+Labkwo9EpOsXj6ltSWf61",
	"+AxBPf+F7usJ6p0YKRzPXuH5DOl/XM0rEAKHp/IKpJKSlp8vRhVBuxLkelF9FJMJhbRa/KrkaVAk1Rxf",
	"A3pRmEvqhmY1f7NwHo7eajCv5kQqyuMZOsnwtJzS28OX5Z8gcGzOZvPbhCUeUqjEFHv6NFF/h3OiyuP5",
	"TrMsu/fC7/27lMgcRLm671Ki4BXWsgVThAH1ZS780VfL3R78N2ZEkc8VcvyCBavTiP994Dj2hz/ThQbM",
	"EmM808yYNwyJ5QUH273Nh2Af+56nnIamrX3vEEgMkze9MbTghWiM17R9hXHw5gaK3u0ow8wbGwpBllft",
	"0u8TJczE37tP9yRNw74Q+Bl/aH9pTmFNUUgs+2fqcJbzqmV79g88bbn8dZAkSP9iTXkp0NyHsDsXuca6",
	"titg63MX9nROb+bJ9i7pNdHN2zgJUk0kjGnZ99UR2rwuaUcPq2jDPVI3gtWsHcuWilB7ryFMleTNretq",
	"N0uvXCx/e2/Lmlijm/le1nS+88TsPDE38MSsw66dX2bnl+njlymDpFbjU8Plsqb2BmEGOx/Mt+WD6YkP",
	"rc6SdW12rpOd62TnOtm5Tnauk53rZOc62blOdq6Tnetk5zrZuU52rpNv0nWyLoPTnTlS1t3dvSXnxxbP",
	"OFU+i3XXVr9tD8YmTw5UOvIKF0TN09XwQEzci539HGAjZ/rQXRay4Qhr5JJySkHlNrHZubiw5+rIJhc6",
	"4h85MlD4RLqaAv0xHIxh4rKGf1XQLBgN2BKgaoPXAo509U0h4hMt/pTJ2FwWT2dS8/ds99BrFqb0tDTo",
	"6vLg8Ofo5Ozi9eVV9OpkdPX68heUYikR4wolRJr76XvLbx8ZZGhDJPPeAZMmQ1qbG8smj4wynOeETSMB",
	"ktOiPYec7gpVFYzlVxpRNcMPJeRYGNHPPKIhH7iMXji3ngSGDnyiyhel0Xrjd3esu0IaRIlm0JaPT2Am",
	"iYHv5EiPfKibIAO7ScYmh+iaSKJQqlQun+3v/1o8evQ0/uX1m0tb683lqSmCfQFS7eOc7FOsqdS+ae/q",
	"H5z/gt4enJ4coZPR6M0x+vn4F9dKlRDIf8GnHLPkn0HRnmFWZk00TTI4cXJkDNiGiVhA/YZtlF2yTOtv",
	"ZlxbiFYTfM2h2PEAhDHoIGyt/Iqb1P0m85Ym/XWPZDN34aNWf4q1nZb41p1Y8cxhjl6gexeCcF3tnuP1",
	"hKGfiMB76AUXCD7hLKfwDJWW2eG6y8pDzz1sFr/SVlkH4RdeICvoTggz6W4Fdhn97E1KkzpRKWMXzReB",
	"AfkKG5vbSOuDg+HgOCexkYTJDKw9zcjuVm1pFaMgJ7HZkla/6RVHfGwyN5rV0d3bHSLJvc2x+8m+XVQt",
	"Idn8FNafons9xxnsoUOeW+rlU6EW5p2PePLeFnywd0qxVID02CBgw8yoy9jp0ti79PJfnkChej77m1Ap",
	"7y70/vYliYo4wdUkB7GChL+4myT22m7gJm7FdkRYTIukTJ4eVNdCiXcicmEyFitus+vHyiZXMY9uVLlH",
	"e6VQtPeMjdshkhRHjK9MOGq92uZwmEM0BmSsokkCDGH7xoOT6q07ZtC8eUwXSAJLTCLQcDDD861xXP2r",
	"VXhLyTT9MiTG+YDWkpfe6dLYhH8ZSJ0Paz2klgD67DYJEZ0+RINknCYgmm81HH3EbMrLDD5OBzNJO00+",
	"Sl2nYsFhukytcmkBHQsI5LiEf+T7ZW+W8T402R5ByD10ClqKB5PtVXE9mBnB0XRkUNT4o8sumql1e6Xo",
	"oHz+ZfbGOhbXbk1mPI9fBoTSq7kWCp4D20zkuoSHr3Ngfyuh6xL0OvWQutxTtA0tooUo+0cxvJQFZhuH",
	"SBMVe+iMsmN0nVoC/r2VpgAnmTmw/eK3eXELCaI9+cva7C9Lcvoq0a8h7XSR76HNKdNOMTsOa/cZWsZr",
	"uzXBtNepUyuCA3da1U6r+mJa1dqYta+kY617qWunce00rp3GtdO4bkXjWkNs7lyvWgfPTsv6RrSsNRv1",
	"VXSude+p7TSw29TAcizlnIukVa9ZtRXDwVwQBbUrY9+GOteA+qbK3SZ+zC+k6n05La/c/v4Kn3/pp67m",
	"1a8wrA9cDx7v6V05+gKZNw3hjlPMpuveRKSEzSAxiOp4ipZ0KJbKeThbXkXseruhRErdmenCZhluQ04L",
	"oRaoOiQdByNuguaFMPc+Sv2VpX5gtsJCkh4ZcF1dR6H7Vc4F90+4rd9gR2vWvEfRlojXTyIA0Xa3EuU7",
	"DRzfGubvMPqWMHqNILIKv/s03QDbG1jcgsBdqHtRDdIwyyVJ1Mx77y/SRBSPwZwuv6sHSdJ4PenEPrlp",
	"ZRVbv+Mqog0j6UUF4kIqnkVWPHJQOmX1IoS++QSFZe62tRM6TSCgY4GITzS8ilvde4hgb7qHfv/VjWca",
	"RI8fPX7y5NfBM/T+919Nrm7996+DH/ce7T3+dfDHhz+6salacm/WwVKSKQPoMBJ4rcFXQ/f1gA/MbVkK",
	"E4XGFLOZPqMMEeWrG4FxnmKlGToKjGNWgdE9b/WeI5iHHqLwkqGWS9zidV2P3Izo9XYB7lTD1ZQqiF7q",
	"yQrM4ZQdmGhXwFZBMscxIAk5GEvVNrgUZHheD56/8Ndp0ynfXdzODuMobG8hxFwmxJRaq2xb/GftqmiG",
	"iUE7lGPh43PtKUQHdI4Xnl8Z66R7RcIsuiLxDJS98F7GYhL37rUP7m2fkYawzIrf8kh19ZiyxpLIPA/q",
	"jO+r1tbE5x+U7VDVbqMl75cLPuBL3V6jHXvasac7ZE87trNjOzu28+dlO0ukzr9b0fJ6liZeN30Sz83i",
	"vHwN35JESpi5b9rmCU/g1gc1d6RWjZllFW+7zWFNv6tGtop651uma18RLd88ulXA/TNG2+snNECrNsoC",
	"E3Bv+9WRLmzXITWsvHvh0dk/tdUBaYX/AUXcZjxHDnoN5Z++2WacNxLESBXjHgP9sXqWt/aCkcfdoX8v",
	"1O3c6tdo/AZ1SrQ7svPlyc5dU4111OD2kXNDbGx/7C7mlIuGaPKP7pV4dXV2imybGwR3h2vVfOOvh9G+",
	"bL5uut2v8t7mrFfNZhOH4cppnYG9ntf0N9jMZF/A23CDVxAfP2kVbTsZYjiLbRjHsW/fh0MFi7DNWD4W",
	"65viu2vY4frNNsaGxi4+3eQtS99FF+qu8Jh9MQzuwsx+qcduuHCbHPy1K3gOas7F7JQ7HWj7N0sp74qS",
	"851rLsfseOYVXMKmz9CxjdSRz9Dbi/MhOmEKBAOFuHB/Y9owKHzfl5Z7gPrMuxOL7nZaGxH1lfPjqu3u",
	"caFSvsEN9kpubkvd7NPbbad7QUJUZCp3ddE8I726tOpgi60uIWrrqa+GxFgClVi0JoBOiTTx0Zs8L/vK",
	"tekmz2Uqh968lKsqALyP8Ypcu91dY313KDX0iQmrbS3X3C9PtRjDLqN9OPtl0cqmFY1utJVtWIxbd+4L",
	"Le1tonxTp6wvkJub0zDNCF1r3s1EVx0pj/Rr2N4Xwz0LQNec2rWSGg3//RZvlcqoSlC+vFZERhlmCfaY",
	"3VpDEjalHR20iRzrGWE42+GaB8L9mnXiwpqlWxuO/XUWaBOWWl+uVStVWY1buSyPbIxm3UNUps95P8AU",
	"hFGqS6bgb9VIik1GtUwqwJk0QgKhg2HVZG1+n686Nk8gEnBNYH6XwwZ+O3O75C7H3igI1MWr3SF4XKUg",
	"7nLAbnX8b2cu7u8mvHOsreXBvvPRLYWIhOU1dzx2px/xLqEwycjufN0lxdFYAI7TOx1VYfq1GJKPS+iX",
	"t92kxrvzXSnymGeETb/SEvX1EtiakQaPcHaXS9Qv5Ksml3UHfe3Es7+VePb3Ebt2YsdO7NiJHTuxYyd2",
	"3J7YsSRkXOApYVhBcpDnBwzThSTylLSHAhR2Qd1t9MGzx0+etlqQXQqNst4gVSp/tr+Pc7LnCve4mO7j",
	"2PQp9//FJxMJ6p/fPXr0a/Ho0ZMfKMmI+ufjR4+Wby73CGuFa8ILuR0IT24DBAGyoEr29pIEa7/hrh2G",
	"qX4uQGRESsLZbgfveAc79mHD3TwCCgouLFvf7eEd72Ft9TfeuWugPNdE/bh6oW+3hXe+hW3bsOle8o/8",
	"peBF/qffvtV2a/cY6V2Yr2tq0q0M2zumWwtb8quZzv98J8gj/7aH5gyyMYi/6tEpU0psg021tV2LuILT",
	"rW8+XOq237xf6c97OCySb3hEfPTtTiq4420Lw5632C/7qsxu177Srtnl33jvvAlot293vm+l9W3bPbsQ",
	"IEHtjtzX2zq3AxvuoLvz8VcV/hKTXzFqel3co/lfWIQaDvzbgBDd4dUcf+0kknA31478gPKOLjlRkNuv",
	"Y08pu5aQ7iYr6XauvxIx4QW7CYJegeyvalMs/em4u1OREUWm+A6PYZnSYZuRzEWWXtofuNd+72JKX4ui",
	"OVy5E/vMssf6BufwkshZlYKj1+iSMyx+K8ZgM5ZsO/LId2NTyvYZWbm4oW3Pf+9BIvsw5U0WVo93Ur61",
	"+fewKgTseHNZ68o55ney8tfZNb/+G+6efS3hktPdxt31xlVLv+GehS837Xbtjnet9grxFvumueVu077G",
	"pnk5ZcMdc8kud3v2FfbMJ8DebNd8Qpm/qvlnl45s5wes7+SWB0QjwI6ufaU986dvg307A4X/qkRtl1Lq",
	"i6SU+tMdD5M2bbNj0Uw6tCNpd7xnS9muNtw/vjMb3f2e8Y1tRT6TyW6vvsJebSEu1O7t/sVjiHe6yTeI",
	"tEE2n80w1+3KwcXJKMasdqdlR3zueB9X7MV2u/qXvtJwh3HZd0j57iAE/C9C9UIc3+54/FVPhs1oST7b",
	"l0Vudvdms4OSmSD5u4nt0IeyTMp4F9eK/I2mDDM8vbMwnWlBqzR9W1GFsot+QSsUR3GN9WwbtnJ6sMTC",
	"esSU4OxOF1hBnDLz7rR5pWp7Iv/3EzsDtrY57f1r3xn7awkMO31sq4Ox1Y2xgCntpPdbld7vVFbYifEb",
	"HpYS4bc/Lztx/s8rzv/1kHl7PP5biEZ/NWq8k5G2PilbyUmVVrszU9/x1tUNCpvsWe0KzW7f7nrflm4w",
	"bbJ3u3sLX2HHNr+x0LS67fbsjveszey5yf7VLvvtdu+ud2/pruXWe3clMJNkdwa/+i5WG7Hpfqpi/FfJ",
	"b/Gn28Jq7TfdtYVUkI1AKcKmuwjVO9+42vJvuHfVXfC/qvnDxcPLCE8mELsE/l86Mv4O0gH8RcwS9WQE",
	"G2LujtZ8hd3aYp92kdVfaa+2sItfcU53Cu1X3bjmDmyxg87auxPKvuIeNvZgi13c0c2vtHVb0M03EsSh",
	"jWg7YRP+VxWnd063TXCpgRRboNTu+H+FLeu7TypOa486dT4gaeJ7E2Cxf2+cZEU2ePbk8Xf/+O7Hpz98",
	"9w/z6LgtfFiW/tgyPaLMEh6WHSIK10AHrQ/Mx+3Prq9ds5aH0fu81x4EYS4Do/C0vglrOut6+mu552sQ",
	"kvScqVu+t7YJOi+MJ7xl+DmMJbFvsTUwLhjju16r6bqKTJ7Qm3e4AhXbn2bpxMqttnnV8PXU/Z3jlqGI",
	"y3vpA0fCZ/WfDa5SIpH+CSWgQGSEgUQqBZSXr0BJxCemSOMJUhzZmHZTZMbbG1Tbb4A0HQ663o5rA6/P",
	"1FeTAC/RRwHgtUOx/mG75rmordTvDWTa9rB///3awy55TDCNcsGvSeKfLQ03zS6yTVcJCZoIniGMbDPk",
	"m+ld8W/vHXwuBBwcDYaDwVBD/aH7/I5sLweFSoEpdxMTXXhYNkFan1yjc+MmAk+rdw7raAnI/4o0NVZk",
	"QkCgeUriFE04pXxu8TTFMkUZFrM9dBV+IpnygiZoDIhnRClI9tALLpBji+iehFgP9vDx03tDdC/HAk8F",
	"ztOHT+7t1SnH9732OuWyYx76F6RRAXGBTi4QThIBUu6hE4WyQv/GFSIspkViD5XeVsQM/WzA/PjJP/Ye",
	"7T3ae6xBpjzGVHeuPxa8EAnPMGF7Mc+2m0KOVdo+BepyNHhKIEDyQsQwRCSYg1RYKDQnKkUY3du/Vwfe",
	"p2rZ/+7Jo31IiNoKRC46VpnZbBJ28bA0h0EfDgOOhtmP75ZmazGh6/Xe3k/9Kh5z2j6JmGdZwfyh83Wt",
	"AAVIFnGKsET3tJSnN31i/0uYvDdEoOLGrj/ps6K/FSAW7dCYn5CtOjRraM6xBq3jhNWQ1fCGf35n5UwF",
	"OPvnj/fqAD7uR0ZvQ74hWkdYmqWWSJH+ySwrpiQGvaBjPm5d0O9vJkPUnwTppIr+bexSljEFLfMMkx8t",
	"Y5p53jbKuSSKXENQJ3jpNshotNxBmZq8vW0zc/l63OeFivgkkjHPO+AJcly3D7tydRuvP3QLZ5ZURLTM",
	"PBMi13q5oEyhXkemo+pL08l5ihViAInUMtMYkDLJyTUTkNZuhYocQSVMogkXppLekcZB7kccVykJ5arX",
	"gR7pYg1utXwehiE6ubgn9y8drZf7by5P78kHddB+1JAtn0CQVVT0BivrhJAmkM8FgQlK6uubm11uO6Hb",
	"CtnVEnSiDs5J5D2Qy+g7FpjFaaTwtIWg4qneelvF81G3Y44/1TYAksbUHn+/Qut6brrdv8LTNkIxLghN",
	"IpK0rKz+BZ0c3R5A7WNLENdtkqwd3/6qpYqcM0nGFMxZODzZPzwyYw/68OE4hXgWUdK1O5q5EhVpCXEZ",
	"kEPzoxUfjTwtIOfbzDcB/9CJVkY4W3rOOxz1ZIKA6e4SVGuH5oRSxBldWE6LkaPUiDCktMoWbA6WqHxb",
	"Re8jZlylIKomEzTmKvXfEmEBLf3soZMJSog04Awb8BCJOKthiLGNhJrfUWMCKm2BVU9p0Pbmereu1ZP4",
	"VYOUhMdrPydMgcCxYYPDgcGqbjWo2e+ECKn8hWpI2hjz2j4o4KQfi2zRGJ/2mj4XcQpSOR0Y2JSwFkL6",
	"Oqxljh2J4abnLge2giZaMt3CeJzvBmGWIMNRzdg5CL28Gm+b+DnYUBhvMYEAltvil33RpMSt9ZD450h6",
	"vqpvmWwU8wRc0gCDy12Ec2SqI13dk8/1W+dV/MMzNLL9bgBJIcgyGF44QJSwmZZzZAXXskU5WPUfVtkQ",
	"Ly3tXTaM2Lf0gqN9zhUaabUTksFw8JzyeGb+OsQsBkrt31zrI7bGiTFlTLX+PRgOXjP0ilNd/g4TI5Hp",
	"NfRz6k8jbqqgKCymoCJgSS+531U36na/BlocM8cepovVZtJ+VmyVCsAqyngCtP3YK4HjWRvinjpEgZzE",
	"WiBSJJ6BQtKE2lltPU4xm4IRm50Bem8lLvWDObBl1yHyFuttRKCbKYQu7u2cK+hWVrgCJ7ptYDR1PXfL",
	"sbFXCps6jCXFZGLJ74TiuWb+tr7eL8YNJW4Vr6zDJ/JMrN71ubGA2TX2AYOobITuUzIWWCyMpWyIciyU",
	"EWYcZgzR3t7eg71tNr4CrC8KLIO3xb4PB/G1lNdP22VNztDbgjIQeEwoUQs0irluh2zMqUd89BTdP3w7",
	"Gl0/fYBkzAW0mLbcNjVBfPyPpibUBDjHSoHQEP2fg7fP3p8fnF58+M/B4bP3p68+/Ofi8tn7N+f6rzcn",
	"z96fX374z+jZ+zeHH/7z/vDk4MOz9/qnQPrTQKLrp4POZYgM+C1oUWQgSIwpsvN00zS6cAroOlwkI6Ka",
	"UogVFxoxp+QamDVO2YZEoiJP7PqkhAKS+NpKE+Al4JCYJLwY0xVCnDXDmmnMod1Mdvju2Flr127O7Rkd",
	"vZFoGRz9i52tPrtzrR0QGfNrEJZ8reUWq9+JbNALHheaPEo0Tzkq6yKMbC/I9uK2M1iMHjOsawQNLsLZ",
	"FATK9I6Xv1yDseXp6emjg8e8UOVKmB1YzZZLLWoDulhXvZziRfFcIvcEXtJOLZMFwxmJw7cw6yO+0COk",
	"WKIxADPOuTjw9RzZ5uggr1SuEcSF0KTkytpvkOKcovtHB6OrBzVFzbX1+qGt0QqlsyH2XI8AWsgMEpj2",
	"yNsg0XhhtsOwUhGC9MLUu/C2ylZQCIWo3UNx4v1DCdK17ssHyOhrhJUHf5k+9nThkSx3ibQaJw0+KYd5",
	"Yz+KrdtYEK1nGZIuh160kEMEWiXNBZFQ2pnXgyKjmkl2kx2ZkE9dmEhbNcVRKdaDJ26eOSqF45kjwTel",
	"a27/T6thWlUSN+9WUtDciZTPrcFVKj3t2v6v99iOIx7HhQAWt5l4z8uVqGpZUwp4zcccunkKWr2+BoFp",
	"jYWBRHMw7K1giVF98XQqwOypPx4yxozBbS1tG8ita8w8I44M4ER1eIXKeprCaeWeqZpv0LdG90ePhmj0",
	"eIhGT4Zo9HSIRt81Bbjv1tLkps+gB9JPMKUS8UJJ4hyq0hu5PfXRK7/PRcO60GK8oHorkkhoekasbaUv",
	"5yUSwafcUm3rAPC9tPPh9eb9YkyJTDsAONKDG7wzK1GTm4wUkOEEkOkjpguErzExw20JikwjxaOPRGD3",
	"tDQuqBo8MwS/bSUFTKDrVOm1g09aFMUUJU6icDzcg9lbgggtNjcSYJYkF8su+wkvtadhV49o3xuukakN",
	"PCZLHrM1B8Tx/JIxZFjM9HQlwgz5fpDutf1ESCxVJAmbRU7nXOYcWsG3P6L711gQvVJDNCmYibfQatwq",
	"VrJZPIAFxxqsVkgIjpvpGkjX6ANATwEhhOBbYKWjg9EVckOuY6sh7J3babu6sw21NullOA5Kc7URuyXQ",
	"yUMn5UGCcgKxofAeKmzpnvVCYOQuDOwhE+9GDLbz3FZEEwI0caFFWn2UkGimXveA6L69A8Wxd7WVOWI1",
	"dy25p/Gv2HX1jO3+oSBKc94hekWm6RCdQUKKbIhO+XyITirVB9NWS8m6sDM3dPSxkFUS/vUC1zxdIIxi",
	"EHovqglonrNSH16/UhRbI2cHy7svACec0cWDkvuavcPShSKZIk3AR6cHKMY0drl+9tAIlBa34FNOjNVF",
	"EzxUPa4t99BxlquFruN42xDFuJC6rlFr6FgjuuLonh7k3lZctOVN7WWEMPf//12MNd7Losv+swlvkpq3",
	"bq15jkzrPornqKl4uqal3jnq1DulglxqAUOLmPrkQj8NzLRDKsUuKm0MLlbQnmguEhvBWnZbiWv7aFxM",
	"e6Hlja397UEOB0imXKhmmEOH+vr948drD3TBEhBRzZzTX0LQhFC3rxty2oUCO9DaEWTddhIXQgBTdIHG",
	"YM6gE4W6xiC/FRCRJNKIGGkUa7Hj1qTeMh82Ig59G3raHjpwgaQcGYcFsqPUpGcCcitOpsnghGyuqmeY",
	"FZjSBfIdtJhNllZHA7xmbc45e+imt3ZhWgMo6yqFhqHXuvh7AbXWJ0duXA1q2+KFtSOS9L9kUhvnJPEe",
	"kE2unTTeRu+OOy/t+1/B7r5kZZ/f+ALMOhPsBsaytVXrFp0eulyoPm4kY23u3LwpfXd4E2XY3fOrH8Rj",
	"E/HjiKGvbMQU08CSwtLegHCipd49dKZ/tIFBY0BY819rWcCUOv/csKIZpaw6XqDDd8chG/Z47Xq04CSt",
	"ZKU+laiDc5l+wAxlaiClWfN9J51LJAGLOH1gzF0NWCwIJUTjBboyPbiq7UB5KJYiidds1K0RlSZl2IS4",
	"VO/3r7/E08PO0HGpB9DUjGOv9nQgTenpXuRg43C8gXpvRfTIy6rjlVd81gG/Yo3C1/JXuLCtsSLKcJ4T",
	"No0ESE6Ldp1F94iqCsbJLDWKZhl+KCHHwvC6a0wLkA+cBIlzIxlghg68YeRF6UHcOEIrplxCZENYohm0",
	"6X9lci/NHxVHh7oJMrAb4V8O0TWRRKFUqVw+29//tXj06Gn8y+s3l7bWm8tTUwT7AqTaxznZ13gq1b5p",
	"7+ofnP+C3h6cnhyhk9HozTH6+fgX10qVEMh/waccs+SfQdGeUZTNmmjyYoQCzci5QAteCAeo27fNrBml",
	"G9nMuLYQrUhWv/LVHnBwzBQIhO3VG8WNq9hIepru1p+FaYm2XkNLYqeKl9jXrdafOTzSy3XvQhCuq91z",
	"VgfC0E9E4NpVmWfIK/qbK/FOW7UaZRmtVgfoF16gGGvVbkKYMb0K7LRLSwqMGm/D8/byRXCP7ArL2WA4",
	"GCkudPFxTmL9mZOZ3u/nhT4YXhscfGiL0sxJbLarNRr5iiM+NlYEs1a6e7t7JLm3OeY/2bdLrAmbZUEG",
	"VU2v5ziDPXTIcytae7NcYWJO4sl7W/DBEkUsFSA9NgjY0Eq37lrGlydeqO5bvQkFczJFpNzN94b+WqYt",
	"sPzfgFFyniSxfCcIw2jFfXcRrnTkBdXnWKJYAHaXKOYp1x26yFwrP5kAkMoO1kudt4zSuDIiSXHE+Erj",
	"lyYe/v6GPkRjQFyf/CQBhrCNN7gIY6QHTdZJF0gCS4xRKhxMIj1BnmXA1L9aJZ+UTNMvQ3BekWm6ObHR",
	"S/1l4DEpHTaHxxI9L7QmpCX+8DDlmsUYxOI0AdGMFTj6iNmUl4K5swcbo5Gxh+g6FUsOzTXmBqoEE18v",
	"FRfOjMw/8v2yN8uIH7rwSLmHTgFfAwJjbVRcD2ZGcHQcGbScFJRWADVNu99/3ycEnc+/zE6d8vnmG5UZ",
	"w/WXAcgaxTeHiefANhPPLuHh6xzY30pAuwS9Tj0ktBxLOeciaY22X7UVw8FcEAVVBhutU4gWg9aLForv",
	"oz+8eAcGQ4ZIALbLcWSsmUf8I697mtdGGC9D7VbE72ubUUbrQu2pIG5wTc1oRxpbOlWj+pWj9Vpk4Aro",
	"XTnaQEs1RMxGda+JnKCEzSAxm+boq+b6FEuFMp4Y08aSq+WhIhmsUFhNZ6YLGxjatlEWQi1cdHB9ByNu",
	"guYFEmdFrfti+oHZCgtJtsgSY1o62rVN01xw7wS+ofZ+YXvqVt6TJGqaY3xASUTx2F0rcDt4kCQN6/OJ",
	"DVmwFM3WXxmT3rYiyzpdIRXPIktEV2TialpGLQmwrR1r+mn0+hw59qZVihMjQRgJfYhgb7qHfv/VjWca",
	"RI8fPX7y5NfBM/T+91/NLTD996+DH/ce7T3+dfDHhz+6MafaAK/8YSnJlAF0qBJetvDV0H094AMTXU1h",
	"otCYYjbT55FptcdVN2xlnmKlmTUKVGgr5uiet/KH2wuQwTXJyCiJbvHab5dsSuB2guEaauNlgv7k3Bw6",
	"2YFhdgVsFSRzHAOSkIPRU7fBkU1TbJhXuTo1utIfvZ0W5qhkF6FtD5bDlFqbTMuSHRSKa/ElNrphholB",
	"O5Rj4WNY7OlCB3SOF57nGNuE5WgW7exNKnuNsjT/+zu4PgCmfUYawjKrwcq0DBpLIhM24Uxvq9b2ksgZ",
	"qp7pQVW7jZZ8Ba85xWxa4Gm3KGRI2S1lhqtCaS2BpIR1xNKa64+3Pai567lqzCyrON1tDmv6XTHyhFC7",
	"2Lc6ru21bTzqNr09QnLlDeBbcE54lLta5Ctcw5xy0aAO/+ie9aurs1Nk27Tp7sF8m5fQtlUizkDhFfpD",
	"lVjmlrWHFm3o8ZON8h+uH8OIWW236LddrHObMObU54vpXDifUabtwlIVR+hTVbk8K8/QsbVdyGfo7cX5",
	"EJl8BQyUyRfGbFz0beY5WXnfFBLSmfIHmLK5otbslrmz2v+mfC7ItQvw24D061msPIMrU0r0sCVG1SXZ",
	"5aUgMsowS7DxhHTVkIRNaUcHbQfhhptaMdRuvatQPLKeyGZeEhfB/36AKQg1+BCEoXv3j6Q4nmlElApw",
	"Jg1KEq15lU3WBkd81bF5ArUotbsZNtBsjBvkLsc2MrAze9zhsOYe5F0OuJWCcOe7Eb4XfPejN+/D3OnY",
	"nRrEXUIhY8zuft21CjoWgH0s2B2NqjD9WoTWWyT6XQ0z2UnufFeKPOYZYdOvtER9FRFbM9LgEc7ucolW",
	"yBrOmHBwcTKKMas9qNIpeaxOTmiv9kQzWESPtwraDHt4cuMenm4XOMo5jeqBRZtlbXHr2m3MKKRWwmXk",
	"o4+cz9Tv+TWIBUqtK9/9l3lvKDV+WlPD/sk4g5UJoZdDi1anw14jUDs776SgNGqwgxaTmI3LN/bNxt0c",
	"5G/hNMsnXGTD0MakpZ4hKnLKcQImuJFPyuv2bdqNAVASrYv1BtFWXwJmvEAmHyFh0/2C+T8RtqVj/qkD",
	"BncNNsJFQqB13FEOMZks7O0BF9NZZekzNunxAuXANVjhLWguppiRz6W7s0VlcYqnmbc0CeE2Hb9qWV0s",
	"sJeOke+9Kw3BBOJFTGuZ+2LOpBJF7IL0HA2xHwIUEZZub4LFW+Zk54JMCQthUykRiclTtEAud5EGsRBx",
	"iqUxc8ecKYFjZaw6xCnyAxtpgHyOsYHeIvN3stE8NIPVGB+CNIexvyU5MOd1pniux+Ym2TYfExOzO4fx",
	"ZkMJnkTu2n80FTi5/ZsGZghvMeiW2G06OtE3AZ9/23/TBL8CroG1Xcg7lopk3lcdYP49iVybutsXYpKZ",
	"LV9xBeThv379Nfn90fDx0z/u/+vZr7/u2c8nfzz41/8cdNyKXMtkbuMWA842W+/yVpHPlrmBfCMg5iKR",
	"a1a8uj1tnqJwjapco7U9WR+p+Wh4EzuwY9arzcA+SnhZ+umV+7TnHXQtsqwcYSuit2Lul+XRWhGeLzhb",
	"ZJ33HIFB0pFBREPbksp+XUQ2VjDlXbnsZWEvsJcPGPgJhM9kGENkrMn4hDAXIwVJEZdB4pC4qOyYi5wL",
	"G0xijR0f1ktMjaxFramqKsDuSZQXIucS9lojVgpBZELi7oAVBUIQxcXCBKi6++31MdyNkKbn+If1eVna",
	"Q+6v3O61L3PN5v/j2iHKO18tOMSqhCFvLk87g3/X5Izsj/Cj04N+ao4/8cswV8QrwQtp4wZcPhgtFrp2",
	"YfjQNvcnfDcuzNu4t4/wot2R1k14vn/8pM+bJ1rH2HCius0NJ/lKd9FrglrT2RA+yuc3BO+Uz/tB53Sz",
	"DQG0rW4Iow2S7Qdm+1E/8HelzXn36RolGBI7Oj2QPU68R1obOaWBOMcZbPTG0MjnUFgdEdka0NtMraAr",
	"Na5FrE+aUaYkXt23q7cpU2u/wNPs3NTarOveS1pF+nY/4+QiQqu12Mip1ZoIoy0tta/UOs73PRazipS+",
	"Tc/bSBXjdfl2e7/psumV65vddN7uJu2qtTCpDn1u968d/okp5fMIMy2I8kJGshDXsIgE5JIzCV1XsxFm",
	"C87Av2TlU5sb+mZ6sLdC5dxcL7RFwS0fYxhCB35UNLJtLm2W/TCmpRapSouMRXOSqHQJO79vD1cVYBJf",
	"YiqXgx0erbgbWEZuNxJEwNzoVbK6tWUDRJPy1mT53F+f3AHBYBFkmNCo1HrXDG0evlgav4p9NH0OfbY7",
	"IAKZ/v3LavYevb9hL2AKn5AbukoAVWZ/ijmzUb576yXE5rTar1+vW0gNcG0qQSYf3WPfBaagICrzz8q2",
	"7Py/FUSARAw+KX9r7Rly8kKgTledWGlDYdJhInQPhNiTOodxyvkskhCLtjcenImUMOtq8en1rMauNR6M",
	"bFN03+QoLgSeQoIoTHGsESDF14QX4kGYvNaOj+YwRnps10EXrDHFJGtLQ39SvrdnMtEYAaSqj7RqRGkz",
	"SpElaArMhrG6/L5y6SLloyXB5qiCow2jBLmGyIYcRydHbZxp2ZZujpND9xpfAefl6dnFRPCsVxCrM47j",
	"IiGK8pasUe9KFPa3I1UhNMpzNkTmvo0PbLWpBnVHiHITHe8T/psUlYojTdU0q0D3HV+VQ5NbSg6DZ6rk",
	"EF0IHhf6j729vQcnE7TgBRIFQ2Myda9jmqIML9AcM6W7dvhrIR1DjH1c9RwvUGIivB/6SQYZiuZczKRJ",
	"My7gnuY8egj3Vomx96dE7aFjmUNMTBRvUpi8YvcFPHxgQZFh3gvPaPwqTO3Np06nxBhYnGZYzLrTiTz3",
	"VWT5UKCe1+t3B6MLdDB6O0L3W5N2vTUpQ3ypwizBInmwDGvV/ypAY0xB97AJgkwmNoH7oWtbkk3/GpFP",
	"sVvY5/oUiAmOYaUXx7hZKJFKbgpJ1fJW4Kgz6Y0AqZreBiS1dIbbnN+qA5C1/DIxz3Js0N0Hjsohiudg",
	"78LIoSGcBpukzeA/51V7mWKh1do3l6emXoqvXdJerVcevju2j4QoCiUZ0ShuLotpXi8gNm/nOU0W13Ky",
	"76F3KbDlt6zco1tDI91Jo7IGswuy5xBZv7oePAhSpkNbev+qvLK+8qT4tYoyUDjBCkeWTmyKJr4f5Pvx",
	"pO8WcKZ2109uc6a9hcE8WbyMx71GlxR3k73AhHHP3n1QxOb7KI0mLYS31moVDFOi0mIcaiOuh5cnV6/e",
	"PDfrOC2ziHR3w/mUQiRTALXVOr40HSDbQTjqJtvcmIHtcmS7POk3EZ/xudGXu1ncuwstOkZaflteiwsK",
	"WIJ5EuwZOlH6CEolOJvShfH4ZBkwdyI17y5FyDFotUuTkH330PI8JQrM+S6vZrmnsnwIQS74p0XJLs+n",
	"hH1aiZFGZqoJhV2B0ra6jb1paVFfvTMSCy75RKErXb8udq6Cx1RcmEtOXS/6+HNi4oMXTmdqnhCE45iL",
	"xObubBwpLSeZ6DVNF7nwTwF5yawFsWwo8sK1f24atzXdaGZRdz7FLzTFIJva9pNt6aTntM0xMe8lfvkJ",
	"e9Bs0hbNkN1FbMXD7AabTL/sst7Tqsl7L38ZYtBIm0lkTvFCM3hTA1HQOr1Vbk2qmzKhGUfSZ4/h5hEG",
	"ilLAVKUtM/DJWl4KnKyRwsv4XYFNOE9U3nzalJyXkLqe7G2n22DZ/oluhrXmvyls9da3AY8oKMhoInAG",
	"WonaZrFMF0h3Ya7N3AJQJjhyA0LeN6WjT7q3lL7R8KUyvSNnRrDVZSbdobkfbLMm+ckJyCmO3fGskmUO",
	"/SMzum2VFNPYK0qXEHojYVJQ+56m4NfEnPyYM0mk0qJrrY8lUAVMsUiMcO2f9KheJGkcnsug+UHiAo86",
	"l9GEeuSCm0z9kBCFWyPMjMxeah/OlBZjhnQTZz9zvchlkAwauJ/NEswFUd0Hu7qbUV6NabkbrouN3SJ8",
	"d3eiqc9T66S77wx6D0y6MJQULmFElc4qyEDRspDB89sHheIPzYj9QY40EBvBbfbVhPJp3tRwOfacw20m",
	"QkuJVK3RG0HGFnM4cOO2tJjVsoQZBbDx7pQLVVx6/CIXcE14IV0/7h2MRus9zePMQ+7mSTlgTnqsKZVD",
	"c3hcPgDGldaJx4QZTVaC1njb6dHdX6U3I7o9qiVe8kEwQe5BlxWszKhkcz253Fz94wd72YpHVop360xY",
	"GddRWo/Ncryz3ayLV+nMBRP00ZW0h/I5iBhLiOIUCxwrE59mLOnJChu7pTsu65EsU9MRkxVO6zQKcQao",
	"7N2LL/fxw8+1NPkXrg+bwt530ta2FaWWdZRI8V423gx/ipIib5UaNN6XVhNi3uU0lxsdflph0pplVrkX",
	"LEPnNAEZGCiMJyPZQ0elAcX8pM9R9bM9eyY/iUmKsYcObEIVPcIj20JAxq/BmO6rMW/pYZUz/KkCsCOg",
	"w44SeSyIqFvv1UijxVVQAe4Y3qtSzMq1tB3dmOb6c39TAKcmA4VwMNpObw1GpzS35vzScpK5FKCpg5NO",
	"SgIxb6MN37WiusXNL3LAEzIlCt1/9PB/9TzVpkFXppG6QhTM68f2XCNhi6jFbHYBIgam8BSCh1YxQ/cO",
	"7iGbY+6f20UUvTQq2cFg1YVLC9W4L1To3vNbAep5D6Di/kAd3gpQhz2ASvoDdXQrQB31AGqyAVK9cFDF",
	"N4LqRStUzSulEy6yyLvn28XhI+d0N3eEFigHQbjVsNruEt36m71NiJ2xZwwTLpavxNbf7jCGnv+20rlt",
	"sASz6QCWM0c5PfmW2OBl26gu9yLgRKIiN1C2Pzhm9O441epkC3V/7WIy9tC5EwOtT9c7b03aXKdj1ySc",
	"vT4ebzu44jNoC5jWxchzASd4KtDcwbAWolI00h3soZdgCT2u0nzinOyZ7vdinu2bIWR/kMIskV0L8k6L",
	"NwrPwGbyHGuVxARaqxTEnEjotwTWP/1F+J7rG5V9o/v3H7z/8Psf//n11//7//n//F//43/+f/+PJgZP",
	"fvj/RQ//65///2f3fh0MLXWwlGtv/189OebSUB2PV+As6kqz0RILl0H0mbPa/bODiSAx3j8Yk+QjZoNh",
	"WRDHAgefSUJkdDDG47CQTgkIGRTIDNdayQzC7+c4wzMefrNpQWrfHwsafBMpcRF8U8zUQkBQIvDnz/ia",
	"UBoWFh+LbFyEIx9iInj4qQkGZnFYBQoVfnKGZ+bCmys4wjMswk8RgYxGmGKcBcUfyZgXKpjUES8wDTo+",
	"ptEBJkWw1i8EgOLzoOQlHnNhb6+6kldY4HDiP3FDYuS4ENOgtAj352ec5bWhf06xULwIwP2ZTDEl4TeT",
	"KZZBm1M85cEWn5KxgMZ6n/Is/CowS8IOinGRjbFMSVgm8Syoc4YpHvPwOy9U7VuCCBDhTCNiuDxnfIoT",
	"ItOwDmeCX5NglHONBOMAjPPkI86AhVUIziDY9HNe4FmccqWqstcFnuKEF1MejHbBheIPz/l1APUI8+iq",
	"tjZXJBsXMxW0uxIk5+EOXBWMBOv9jrAk5aBF/gP7KvH+QYJrnyxOucBTqJVNC0Lt1pdFikyLWonA0wIT",
	"Vi+bAlOE6UMEjMvowNjY2yocYoUzLOL25oc848klucYJdnvQUkUkfNz+20/Fx2LR+sspji4J/9je7AxY",
	"wj+3/3ZJePQSUwoOn5cqjDBVuOMXFv1UWPLY+uNpQdr7vCriIuto+EamBW6sTVFfD1mw2PqayyJFZnxW",
	"71HNwkbPcUqWvqPnmCUgsKz9IMY4qS3Gc6CQ1b/J5xCxNAWOH47wmNages5x9JbI2vI951PeKCCy1lc7",
	"hh3ibCxIMoXoOV7Uy3MevRR6IrViFhesViBwjOs9LmPqIV4AY/WOFvWdOkxJjKe8XpIWOK2dokMuMI1e",
	"YTHmhaiXN7D7kEulkbcOhwCpamt5WBBcb1foCYVwHGFmYoRSfM1qxXPJlwuiQwE1AnIE7BpErUAJbjT0",
	"soRrmbkG6XGScVYH9ZiIgkEeruIx1SzxGic8HOCYSWA4Cbt7wYWKzoHWITal7/CitjO6EFOoneuXFMdN",
	"DHnJE5Xica2Ey6VaGoOiq0LMaoVN+F4WOAHKi9rsXhZYQYZpo+IC/1aYmNSqbIFrdPUVpmSCP9VKrhtV",
	"QGRcEkrDnT5hCcGs/F+zCtny88+Mf2opPsMC2LStvwtQIErhofHjFVAaHRK1aPntLVzj1nLCYn2g2qB7",
	"RxjOcLz8y/J0imsSbsvJb5gWNcT8CWe4jpdNVvFTwcAKja7gZ2CqiGeL/VNeEFnKLs1fzzhTJIb6+uuF",
	"jU7OwxJhYjjJxxDOUxxd4M9hAclCGE81nWNToLX1aYXnlM9BRBeCmKcAq/IzHAPhtQKG6wxdlxT1NoJM",
	"uaqXKGJutdUKFc644PWmn7GiNXq4zFzPgGk6AbXOQJCkXklRPNOd1Qo/kZg3kexMA1bnLGecxapZokAI",
	"WDTLrkkCvFEoANNGkQQhcLgm59hrGb4A5tEvvEYfzklOpjUwzp1gV34KzlJcL1FpdIRnXGlGWlCcdv16",
	"CEzVCHLtVw3OCNcZ83lRhOC9/kgYnoajX2B95uoFU0aEKti0Vio0ayTjcOEuUg6MhARFS7cPcfHQomXj",
	"h4hPolGOCWuU8+ggFrBU+BZoWhutAF18SeJ6KVM4OtBkOUTLS0zYIrokdf51idmMsOiEUQg39hJiMoFa",
	"wbQu7l7aJ6dqdQiPngvMatBccolF7fSNsIbvRLqbWbViUdsqXUTqcoQu4pHhsY1yHl3gokaBRjEXIMcL",
	"WbAkLE5JLngcIsGI1AXBkYqeY6FSLdMt6uU/8ZTJetHPRKlG0WkRk0aHVynPcKOaJf3hwo/mZKKiQ3u3",
	"ICi/gmkRa40zD7u9SosaBbxK7WvLdbZ9RT4WdYZ5pY+c4vUSxWt05q3eyKKOLW+JmNaQ9V1KFKRc1KTT",
	"d4QxkkN4WH7Bs0LVSMcvml3MZ8yhmd77WDkDgyVQVdERvrbMLigqtEh19EaUTKD67QzHvxVYkKViL+MF",
	"ZfFZIRJeL7zA1F7HCcoujS0N1wtHvFBpdMGbAIwWfN6oeiU4pfWit1wq45A6MAX7p5xNF4DFeAEGSkm0",
	"whr8TTNsab75ypzIbT4YThai/PpNWaLsPvgYyi+ZTvHYboT7nqV4jJOyQC1E1fg5nqZJ9eNznApHrOzn",
	"LKjJpjM7G/spGLb2KPMJRBTloM+JTGdQ1dWSMPFfh5jGhbLaj/lOSfjByRhTWc38MOVs+puN4HEFBZvO",
	"wgJOeWaJtP48wnGMq48My9gyfvOdOtuK+SC0hOqoGOPgQ6aYVYv6Amd4WsgKzJf4c/m3Vm+qJXsFY8Gr",
	"Lx4dpiQ6Iyytitg0+plX4L/i1+X6n4hZoWS5cCdSYTauVvknPMOiguInvMC5M+WZbxCF9MxQF/yMg8Y/",
	"4yxOsaqm/7NWBlNSfWrUEdWnSjPMkiIoqH+nmCWLadUdpzNcAfezwJLxBRbVdH4uMMXRaZHlRTVMYYLi",
	"qs85JiUenXndzn8U1ccUJxWSnOGZFlRE9c0ILUE5K2RcnYhzEnNJyh/P+TWfFZ8ZBOuuyyQZkwD211nw",
	"t8Dlql6kjGfRBVQbfKFlZcxwWf1ioc89rib5b6wqUP+tNV+Gy2P/78XnBeUiKQG8xGzKK5S6JAuclION",
	"sBe97NcsxZQE31oVxqzErxHwCiFGKWbTtML6EWFTnHNRov1IQMJgxukimPwVJnl1mK+wPumsXNyrMaFE",
	"Vj9DKqpdugIaHVyT6/I7Jdm4CL/ytPrkswWvPgII3nws2DS6wCwJ1vQNxZiNcbiybyhm0XNsE7DZElFk",
	"v5XAvZHq4TlUx+ctMfetWDn/txQn5Lok4rrIsDkZfLJg+X+BGVYgCPO6oy0UcG3XQOsMmg8cfObOrONL",
	"noPICrvlvugQM5tTLijJIXoLwpp4fOkLDII3ShoFP2EWnWHHdHzhGU6AiNqQl7CYfcROy/SFlgW+BC6m",
	"pFZ7pKJXQJ2FuCrEjFruXkglMNUc5/Cq/p0AxcTOoix8Loj0ZuugkM+ARa+I5axl+aEmzsICXxUWwkkE",
	"ZdERFnN7Gsqi4yKm9Xav+BgLVSs6fXVS/yYsAceNq0IukugVn9eHPAM65oVoTOR89K7+rXWYWskFNEv+",
	"XQAwSd3pLYvNftRLFglrLPkVlhlmpD7RtyRWXDQK34Gsz/0XLRXOCTP7+lzgz4TuO13FfR1BpdC5omNs",
	"enFfrs/DY73vh6OrHw6PzF+Y4UQLIBZXqhKt4lmS6gp0dyBYVXDGC+P/q0rOYT7hBUvc+rjSCxyTSdj1",
	"CMuZSQcwx0HjX4qZObWHKaGwf6gJNgOmLAimzEJw4pf/0Nqej82Mjkfu3++PzbyOp4tcz/eYmFU6VvH+",
	"y7Or6q//ehT8/Tj8u/ZD7ZcnwUf499Pg7++Cv78P/v4h+Psfwd8/Bn//r+rvhwEUDx+Hf9d+qP3yJPx4",
	"Gn4EQD0Ma4WVwjoB4A8DwB8GgD8MAH8YAF6CJwDYnMSp+35z6Bf/zdWh/4tptViaHdbf/7ugmtMcF4Ln",
	"sH+Q6d1OjK/SF7GEWwrjC/QBmaUGjXyRSq2n330/BzqxB6EqsMFbQYmw/Nl/C6yIpPgah2WFlEDDjos4",
	"xQJqXRcJzhslkrApBJ0fpkQShoOJHvIcWIprtY6KcQ2kl2QsMLV81BcVIJhV2lzJK6CSsBmpSk4khYhP",
	"orNwhQIB1pX8BKLW0c9aXiFML1NQSOA6/BI8/FyQ4OuUyDEPRjz9WIzpR6sM+yLOklqV4hNkmkhPq7Iz",
	"nAiShN/W31V+CgIpzoJezggzcoD/5Awbs0j5LWMTL+2+K6nTFbyWNKh+gQUJNvyCJ1MurC3XFwk8LQJM",
	"uiTT4NdLa3FzX0buw+G3FgAEYTwsE/gjXDdKVLjSI5JNQPCcB/s3mvH8YzgUn4SzGikez1JOg5N0hSkl",
	"LFi5KyIsow++ZW2QN3SBGb8O1/fN53TKBf9/2fvX7rZxZH8U/ip4vOdZnT5t2e5LZvbkrL32duxc3Ikd",
	"j+Uke3rSfzZEQiIsEmADoGVlTs5nPwsXkiDFm2RRtiX2i7QJ4VIACoXCD4Uqa4o+QS/+an/KM7fVjFTn",
	"bDb4hAOCY2uQP9FgQvOM9xkyDq1Z+w1OmHKXm35HlNGv/twi/7eYadnz5qX6Z2D2Ab0HJPI/EbRGbtky",
	"663aT+S5cKqPhWcuMvuOvgs4PCbyiEAgw2q+TOqJb8wP0m+GudAQVJJE3VwOGlJm1fAOsUksdbgs6Rz6",
	"yP4KPHyLuJ0SMyz0OKZJcyqEVeoKxUTfzJ5p7f+MM6igwOyG4lcYqZ/ezeANDJASQO/xaC5/O1fb7PnQ",
	"/Pu3c7XNalj88CW8gVJ9QvmkoTpSmoQ3yk2LbPDiN/XP4OTtsazjAt7CGzkAl1dyZ7gcXv/nparcKA6H",
	"x5Hi5vQzdqdmKpKklzSeQEwSVCpJPvGh8NUGkqVoHDr51iqFnTDWXsDSb+IhNoqV0p+kvYZTSNWDizQF",
	"32D7MyZwrG1qkqQ3MICRYY0sLRzhXOtvYujBwIXaKbWVavfhLSU00FtlkqTgUX3rkCS9g6SQgCWPhDBH",
	"1jsqucBOsKY+STuHNzGjuQT2Z4w4tDtzjr0ZtEfpAsbMpvECx3ZDF5SNaTDNpcQhsif6Ek6oc6mR6Cwt",
	"gHatl1i4EDOb3EvqE30azlIIjFAugQnnXOPUVvIVZFRQMrGJGEKsF0WWEFI7wzX0cW5MryGDs1wOWaWA",
	"kU33Ncvx4Wc4RbnPQF80Jgn/hJH8ognfUybiiWKSqw8n6t93e/t7NlhwHTPtPFFrXh+Hh8eB1LuTv1Es",
	"j9Xmi+GvlJifMsX/41Ctj4G5/MxS9DHg4/DwLZxBjPXfJtdgKCBTnfk4PDzHro8nSTPWgeHj0DoWfBym",
	"g6qVQ1sx/DwYfpT/U+JHaYhlbn3jKOrwgVBae/pA6HjwW0vDyGLZUrvImAVOxNAY3y0S+/HqPdC/ATy2",
	"g6VjrgPHB+bBLRbfcUBnBNxiJmIYAB6PPMyQPGDODxacYi3jQ/AaVvtRvJ9X87pGERdnym9KdfQNBonr",
	"OwKWeL+6hhNAGdBZ9Cv6GeQqwp92M8OQ8coSwnkStdWEC0eBVzTefX5UbYCtrt/8w2s4KXu8Nopx4Jno",
	"4XkSX8pfwNlpR9QteCekYYiF40Ne8rzoRP0I5I/dUqErdMzL8oag3o3xtRNvrMu5ypbSZdHD8o8tXms2",
	"8Gu1e80IOyrW1UKcgOZHCj2XPz0uX9ZpLCK3mFHSPn56gKDXMraefgrkuDSMAiTWHylE8XW6EOsf/S7s",
	"BveNiQHZBAkHEW/Bl+9A4LDUoa8pwwXUrr1alkJc1MRDKXPc2y7ce2fCqDYORl0kVW9OYIhdR1AatI9e",
	"cdTONXdtvd0pE5QG7cIFSEm9GEf+r83Tsb83Y1igD8o/kMzwbX8PxsJ3SlnjqEbSKg8k6sHTcPj28Pjy",
	"DLzT7oyL3ZfVIyLMm6uUO9O3Mpdn6gyhdVN5QBi+XVN8sZ/ahUFBd4LBsvj66Y4PPDTGRLsANzuEeYPu",
	"UsLjUMfOMu5OCt4VWi2vFVk1ORWshw+43ozyFa1Uk4poVy2GzBPt5WfKfvG2pAeLhmVnvDk1eiC/N7Ot",
	"OtP1YRAV1cnT9yZx1CrcoMkXMSpHy+hMS3sNWXGmGyZr9fDdnc1QDcUfOWInOrLVGRnT6nNiQN2pg+6Q",
	"G1dF/uECQQ/QMYB8TlztSkZ7JEx81Fj+aiw3XDIf8oAs5DNKtOsaSDyd4zvV8neZM6yYCBwAo4pVRv1z",
	"URA42iFCydNun5I08JbCG0YIKIPczPGWVmlegO9++Hvy33cH4GMEBAU/Ptf+DThQzvjRooKbC4b25csP",
	"//2jCoj29/0fn38rDYA2psxFmQsLhniZP5nXMpdxAZ84sVBZEwdSCYhCifYgF9BJldNz7QTUqZBa7XT0",
	"SA7kUxrm7G1yidBosxc2PW5+lfPZDzmnLlbed9Vja/XMWVWhHBnGysKo7elRvdQGuoFj4yW9bfyLVrMp",
	"ZlgO5v1YIokBvETQOSmDqmNP2XuBEyEWYs4Xwh+2CORXDGCvfMo3eJn/6fkvllMze2pL1zBmXDhVI7cI",
	"4/BK/6aniOMJUT6pZz4SvvJKk6x57tM48ORaEspjjXbw5Wq3Xh8JRwFyhc6PM6GsHA4pcawZL+f38ljT",
	"URo+lTs8jhBL5rWSUKV5ZlT6UC1bYM1YGiEB3UUBdrGQcl4FkTCbQ2jTNExazcIMlQRYhcuMeE4jrdkw",
	"y7TG6iVvsHDvAPz4/Ch7vs8BZWCMZogdgPcKuOb7qTwjHvifw4PDHw4Hh46KDFIGkeRJtCTdv758mR38",
	"zw+D33/4S8u4UpmCVjiqxcKnzMTPtTxi18QVZQh62cgsLqyHjefs6iVRCUoUK6joTfsA0X1I6KcXEjrR",
	"QR29Bb/4dxUb2J4dkzIB1tvUPZaIVj2a29yF0NUhkurhfYVOVSzYPuR17piOxsi4+m23DVRcK+39haHx",
	"3ou9/ziUxzBKEBH8kLs+CiE/PKU3VAVGqJm3bGeypn+VxqTqOBTxqFVbuXjcq7RmRUdu3WAhwnfnnSwE",
	"CF+lvSwQcqsWS2N3r9JuMR5tq9aLIb07H+DSiOAdt/qtipufXgD7tBASMCf0Wyy8c1mmxW7QB8kv63Yf",
	"Fr8xLH5m8PSv8j0xO2DkTwYLOmVRYVRKX7bdGY3FXmKFpfF79THu+PJs6EJyUmSF/J7eVslsAO+VFuJM",
	"0dz5cSWQ3a7hp3vX8PNqIWFbXSoU5l/NVzI4pXUsOUWVEFc/A+UzsOrgv0lCweaHOY0QW3LQar1WqjTo",
	"tPLuVWaLXe6hxLZTJk0o2JW0SFl2ddWmckEkNDUwj56Q/eIyVqWbeKdypdaw0Dppbk/uOUquXlYV/lUM",
	"vV1clt1LPJCmvjRr1N6k1OxTTHv1UIUbGWe1LeneJK9ArT4s5Iksw/1/KoNkVUSFxXDiZdC5TaZR0XTp",
	"GuqqL80fFApvQq4bLDF6HPvR49i7gA9XIbsN3LvbOO+TRIZ61OZeZtw9hrOoaOQhmgXIpWZPvza83fl1",
	"+dovrBNdw1nU4WwD9QbloPkRUssTxhTN6ynZ8AXgbl+ClR1P9HOdtXHgsjBqOS6aENWwRHcD6tnopeXD",
	"Yj41SsU9gJ8EYW+CU1KWugcCtL4erEB853jQtrHiYwCGVuCYldChHCM1gy4ZPzXBRF12YHXaq02KN6Mh",
	"NWo+Kx1tyzCqsoG4Qvrl/9CFpO7togkul/SiGL9W2RJr6IBbjzcgQ8DVzp6DeWJ8XIoT3OfZtg4FrTQF",
	"dUZBdxUjWfe+Wz+6BpSBazjJXlDr93DewXIvsc9OkwCdKk+76nQwaxp4TjJ+Sww8Dbxs2AkFASUTFQsc",
	"cRX1XJ+jGFKvrydIANWasgk3EdaTKLP6hTYmk4oXMwtUJtzrcJdGeWZR0aSriV6sS5/0kPIQAoMg61IS",
	"jR2GCEiikh6Ztg/Ayzkwze4DLADmJpR1iKCxG4dCmVDnh6qqXjtmOFOpqncqIDayjNhVjQnR1DxWwYwL",
	"4Er61cMbPaIDOfcVY9riJX07FtKLwPTOqNHOmDIHBkF7tjobq5i3guox3E9fZukK9Ysr1fMRAkZF18wj",
	"fCRHi4OQMqRD5FKCdDmUDnvpIORiijuUONkUVEhe6hAqHIaUXIFiKdZTwXO1LwLzUAJPiKRZC6mMQVK4",
	"U6+dfRBzNI4D9WhYMAwnaKBCFpuHs9yEK5wiFAF0h7l6TJHWplfdfvrEISU+fdoAXlOmRw8Tfc7ClGh4",
	"WZHhUZdXAd1eRDERjqAO9Lzy7dSKoI+I53jpsOXQGeKBUyj0y+gsOv8BSIKIYp6IdSBPf+AH8PNfn6vQ",
	"lwfgyoojGUIB5giyQUiJ8Aee8luVOz3ulV4ppDS2VUitIsl22eT5oeRdjtZBUvpihsvIU8zsjErC9Z/4",
	"lHIEJNOrJCXFciH7VVlA0CxjidFczavrU46SgnKCM7Dc6JOOOfPmE37IPhP/BrorTgSFX+rDqb1Hi7JY",
	"+ekKS4Lh58fg3ETEToqAAN0iJQhHyYpT5/mke6YSHV4/jbZvou+n8fh/r4n3vKQFUzWD2Drk0rWqQtVV",
	"x9yX6/IGM1gmphZXs1KGypen1NWsl63qQix9J6tuiijJ7Z4HbVZdzrlI6tjAjQkS+A4MtXfJ5Pvnvx6l",
	"SSrKIJJyAhO0mCoQixjmCFzSALtzcCJFmZXjDdMqu/k+uX6vc8oN9UrJ3PyPn+KAWD9E0TDCHmJpw3/G",
	"MP2bQdcnOP2MPSx+Haafn4fgktFZYBX+LH+lsfgpl4LcWLHy23iUpn+NGcp+0XF6wBWSWzkinr6fSDK/",
	"hMTDIv0KoDs9jd0p0G4j1Lcnv0+SpQyusHL/mf1kNf2SwSkKIUm/44nL6MyT1QGtzevUE5Wa5iJegNhA",
	"DUKWyCJ7iuzkNwxG/j/eJ0TKpKtXw2v722Q/gWxCc/WqOQ4huwMfhse574UMipk9JCAOlFxQv9DbNGMA",
	"MQPvAsjyKekHjT0eBdRqm45gIA4wzY9HlpzmI4JBbpUzAkt38IRB7gskf08m+dfhhwvwWl+2lfz8v+fv",
	"s1+RpzqW1D13A0rQ6f8mCadwRoZaY0iTUISIh0iyRErSrxl0p+C1UcYuoTuFE/nXa73TPnt9+fp78OrO",
	"9PgUCeSKAUcuQyLlRY+6U8QGI0RcX/6maU/aou40SNnglL1FUC4t1XE9kso1yOnww2WS6ZU3Qdzq6qvh",
	"e0zSQX0tjxLjtH7lmhS7SRd4Nj1vJtzHKEjZ9Y16dq4WO2JwhAOLyjdYvIcjNb2v469f5QhoeVDIcKK9",
	"A2ZDbNJPj4fXmQRJErNhVhOT1ZrlGZYVHKrxBXq0pTi2MwQITtOhf0M5csEw9bDyFsqp+EAQOIFcuZl9",
	"Cz0ayOE7VbMkt3Gt+qnf2Iiy8hF5S1mc1C0/Yz6dn5xllLydeyyVimcvz4EUm3LS5FDIpDCMCZ6hVMac",
	"ETHEE19YIvjX14xOwP8yqFYIGMZhCNkcHMsJhm469la2xZSPBI8xSif53dlJKo3f4XiWcdE0HiHNo0nK",
	"ORKI4SzHOXYZHVM35uAzGmHCI5QRcU5Hw9fWBx/bLHpOv+IggODDiCN2CwVlKa0XiPOYF74+Hw+zFMEj",
	"yKYZT12g+JPy/AieqS0ZQ+Ki7/M/SLmpk+4imonZCzwVqTi6CGEqUC+oZ+0tl8YkIP318hzkpO1F7AYo",
	"3eU+RIhwF0blnCJ//XQ8BCfDT/Lr6hqgWxjE6gQXUg8F9jr/wPkZ8dAdOEW3ULd4cqwltp0rFhHl4qdf",
	"kjYu315m1GtKb39K0ufhmJK5tXMa9o5wNIB2ry7PT9M/P1+otbe3v/ePGAZzDs7IWMpuFrtC7cOSpGef",
	"0ejNxzMph7/PcpoqzNdnNIJROs5Xytbk4CbNpQL8y02cWJuH6uRVPKIuzUrGXOoDdJIkDI+vzl7L/7uQ",
	"CJztKkqbAMMYi3TahyicMBRpqZour+G7lGGHZJ5K/yGVW99xFHGXIWTJsiElkP0jHqH8NpclL+Qr7rTy",
	"FwV5HFu2PkmpiIqX8SQdmOHwPXgPR9k3D3j61/wrsvIlX+CZ7KCciaGA7vQtnE2B/MfkvEaMQXtVXiMu",
	"OA/Sz9fDTKBdM3w7zz7i8ThAfjb4WcrPVhIXM3iLwOtYHoq0zCr+puk8GX6SZF7PMBcBdafgLISTtEuf",
	"Tt6kfyIGXbU2i9/K0uckQJmaolefFOqfYYRFujw/yy1Lzz1L5v6zj3mEWDq6KuzcWyh1CxWcI0jStEVR",
	"mi0yc/C/kGCBv2bM8U/ISF5G/HZsduzfqw33S4zhErsjZQMGOArGA+NzF3kgwshFgI7BOCauvhORK9rY",
	"bUBwmWBz18rJBM8OxjDQHh/BzMeunxq4YQJyKJBygOAGVFkG0gLIqfAmjpLq4XiMXMHVWXrm08CG8A7N",
	"IQ14apNXtRHtZSXfnsb4Sk9HauQdOdvGfEaBDTHDZZ4ezDwFmEzlydd8ysL2SUzjC0WfZ+W+/LjArobk",
	"g+DDeO/Fv+pvnAyon5X89nvx6skyJiqc4KknVbYUvJK5NPzooyACOvPIOO5MQM1lXpHxCoNh5fix7blb",
	"e4lMnNiU+XpUqsbqdxe+FBAjhAhI6iqH3SyvkvmaP+kf8r72OBKS99LBlVIP6OuYA/AeyTZRGIm5ZJtA",
	"fyZZlYGxXCNRAN0yLi3c+eRhtBxesoh12Of/HMtl09J0fdTCA2Z/i9Rkr3e/O6WGyvsbpv6GabkbpiaG",
	"6u+b+vumbbpvSm0tmh695K6SGnIvXCyNsIlu2d8tPfK7pZb8UHoJ1FSmvxLqr4T6K6H+Sqi/EuqvhPor",
	"of5KqL8S6q+E+iuh/kqovxJ6lFdCTRGXNnZB1PTiu4NLnaUfmdde8WShBxqDB27/Hc4yr3iy83j5XUzq",
	"j7XkCoZRMg9Ll7MvNzS5eBkyYL7mfANcExiigtv5Uu85LhRoQlkJdHXtI8BjRWdSaebEwYajIoZvoTvX",
	"XhGVe5b9PeTFeiUarzeucrzgUhZRpmELKvzcK69K1zbFSDQZ3AlHckvOE/YdB1HMpHJWeiHc9p7yJmaY",
	"e9gtJ0IOjUCMYaVxyuOmkX95WhL8vzAPf/2lxhPKYkPyl/IJyLlG+s+SShkaI1buuOZYrgTtBAV8vHqv",
	"MNwinnxQK9V+avaxlPCvxWbm6W5ufPfrHrolHa65p1z3Imm6PtmtJdP1UmgY7XUsjIYmHuUyab9CpO6p",
	"8BiDMeeXR3Lf094K5VVSotT6JKmPt/bvnNXX7Okjf5vXlt60TDnFOq7ZLXK4hjqWqDopakAS1UD+kiSL",
	"HuEQKlD7YTHQ2TW9UMWqozmng2PfzC7TRJuB96mWrQ2cm3dQ2moMU2eRZXOz4HhgmSq1q4GyavWBzJGL",
	"tFWnTP6q+HslwW5huExuvsR4Sb20wvCrKlBqZZyudi1mjg7KWrXiqTW85k9FjS0lcmu6bDFafG3Y0PZ4",
	"WfQQYE1sftrsSTFDnoyYGY+sK81y9ENUq3Ng4gaxh5xS0dJ8JZgUTwQHDuEE8dXKpkKnfVGhXCvSsTaY",
	"MqK8qXiZi4srzKfHOa+MRdVM/oa80qtxuYVHiPHknKYz63M/w3y6D1xI5MEtcZtIx+AUjZErTukNPSjZ",
	"ZRudNqT0lErSZld0Te68WsSbcnH5kVUBlirkm7ItSjKC0Vx7s6QzfdWQ3ufu7e992tvfO9/b33u9t793",
	"XaEX6mocjRaWIAxnYwDVFTQiXNuXKEeJNNCnX2VwlRiC2SE+AWWASZU1mSzhIwICzLV2WVbjM/79wV6r",
	"oMiJ09CKa/PPxoZowc+nKon4fnks0swEyAPPYqLscTzMJS0eGKGAzr5fuF+vcpPVRLTjQ+IFqMQg8Jlk",
	"EkqC+fegvh9ab55BDkxd4FkISayMRihLjEQ8iIM5uKGjNdI+g4w0kK7sfqAwuj6hArvIPlzUd0gexFYn",
	"t+0ZvvzkcJp83ZoThEEujYlerK4hQjgHMOA0tcMQ1BjqFHom18dEx3CUWjznFlipIwGaDYzn5dXPpdv2",
	"ogK5vK88LSgWui33eNnJTIJKkaLtyYynWN2jAyBr1z5qZVWqE1zAsfbzyJVURh4unWjrAGk/tobCL3mi",
	"XxUK9ZJROt4r1dKSBezole6VgbRJngLAXCEr/tsKSllWViGGCfOWopAsZypSRpH9e2YpmF7ZS73loFG0",
	"J4Ezk1L5asuHy85RvQW8uosCSFJgJKWLFVuojF1bThM4NS2W0sYFZMLhAayeSyUftSNoT8v04ftjdQRP",
	"pwdzYKqybEur5vogN9eqlKqxeY6bvCgu6TVxQQ1ZcJlo1FgtEJJFXe848co441rNNxzmTio52juzqu9n",
	"1pMyehcCglW68lrkjMz3rAfnXFtTh8jDalcCSbmETZqdz+YcJCcskpgapnY6kldO4ZyXCrlqj2LPf/yp",
	"xa6mXMQv2VFZ5p6dfCuraNXBtpwU0Nmy/Qjo7J7deE9n7XphXPAvSaAudU8atSlrOzLLdZdjEBP8Z2wU",
	"F2Vb7puLrbGsj5feCiTsHHNBQ9XshTkkr3H1Nvrj6xfxY1jE/eJ8XIuzcDOx4lKtXqXG5H6ogqwPc09S",
	"q5dpbRjPYk0W1y9bLoFnly1nmHjZYhl3LVtSULHKyBRmKR3iNB6MgTF1CJg0OIxurXQ6KYHsz3iEzjiP",
	"76HsTVEJHpfZl2FZO5CZCmfWimfOMW+uLQ3z32SQkNwE1Fdn4OD6yso2NN2rlJpKs4z8UFfubquPZJNh",
	"0j3HtZXtz2qjvIzty2rDfc0g4bjqUHBPDDYBzrMRtoVyKS7Tdl3xpBcOThZoXaZSCp6XLop0QNoQvCB3",
	"kqNloevmrFmkuoTEPAXLTGDlymmehkbTvfUMdtNKqR/6ZRbDwvCvZ+Qb9/bsJX+JxmuMJit+VpdBTlW0",
	"Be6kb8TLc9BYOHScPQAvgTOzyF5VlaS77+JPtq1hU8RfPQh2j7PuFfpSILxIZUKS1X75xMSj5AZ+YU6S",
	"m43G13yFI8na0HF9d6oBnxaSzXruuXx8WCMAWrgHKbnh/vHoqN3WnvaocP3bMDcnSjz2M1Sx+B5sRip3",
	"js4mZuNDuMzmscwAPrWhW88AVY/MnAsUDpEQyZ1/YX/0POfWfmPlYC954+0EcIT07mMO58eeB3K5wZly",
	"lwLBr2dXx0DnL3VzEwR05kBCyTykMXd4zG7R3GEo4pTwUgcLctgAJHNKkHqNAWD6+ECBC6oG5VOA8Bli",
	"AJok66JDRcYEx0mrYKjLXCEeyVZ5heORIA6JM8Oe8BfUnuelOrLLkIeIwDDgi8FYj0pZTBmcOGnQnXzn",
	"L9DMXDgm9/eQczwh+jJWXVqqkjUmBTlgz2rMQSHEgZOG/WtoOnFhkm8fJW5lNBn76e0TZkDVD6DnMcQ5",
	"CKFwfcQ1zQxN0B0wTWcPatLXNC4lOlLNQbMZabFbSTiW5QZSEpzriuY0TS0NUNsBDpBATqpc8bKLULVY",
	"OSDoTgCul+MLYMA6K55gVomG+gTEFQ5yjPmGXqkzNPIpnTr6nXRljFhMXBpiMgFMS0meulmBQBcFzzzM",
	"XRozOEEeCNAEupIBfHiLacy+txbXqW4fzNAIyLZNBVW0ugHEYdnt/Jm2zNKD7mr0L8ufeIEgVOCxeeGk",
	"jQsmxlzNM0/QFq0MjhZQxdOMjjKOYvgWOWMaeIg5Z6etjsd6ORl2z20v6pcC7FlTxZjRsJV9o4kOrJ6Z",
	"BrTEo9fnlIUNnwERM6IcauwDZf0QQqyev6nHbPq9akDV4zTXh2SC5LqVM0KBlGpyqwDPktfu++rxEN+3",
	"vN7wfXDJqBvLPw4ODr4/G4M5jQGLCRjhSeJESCaFcA5mkCjHSYZ/NaUj5MKYayurGZwD7waSCR0knbSc",
	"qc0om2orJ4a+kzuPbCJCTI07cRHwsTgAr3iEXKzshbxYjhx4xtDge01K7jI82WiSUZhUeV8y467ec4eQ",
	"Tav2LA5eJlk44LHryw1S9uvD5+PhJTgefhqCZ7nXqokJwSd1okpSBSQeZN73i7Rm9dcR6sIAyRqWYZDx",
	"WNsanJiyqdhMbcWMrVCsTWoEYuO8Z78SOnzkTgPMBV+WkqzkWujIb9JLEZIVXQclueeaq6zfrALEc66T",
	"XBpGULF7aoS8D9wZ0g9V+b4SnIqb+AE4GwMxo1l57kOGAFRvPWQ+9RQxdQR38vkVoEwXTsWIZHGZQ9kT",
	"MuQiIlIjSaUWpnQeaIu//EtVzDMTF6gNKOUWmPXOy1m7QM/LNBDLGd0tRjN7SZ9mFQDLzKRyPlK3YCES",
	"0IMCOlpOLMsmST0gqScRfWvgmbzDulXWdHK998byUGfR1Kp1HsBqsWfdH37H9SUgDlHuxrJE8OZK1dEw",
	"Uc5U7NOIqeHN2fXbjy/VOE5q7JiSaiidBMjhPkJipXF8oyoAugK71WWmudADXeVQV3nWriOJF65CXeog",
	"httXIVVHR+pvi2NxGSDIkVS90AtwpnzaccEomQSWgZxekXLvTlVIZU+sRMihFBlnl2DmY4FSA2lFIkfs",
	"FjEQq2fxEESM3s3T7fJigsldLUcqnSmnFJZbbyXZuUAw5CUl8qOnHLJwOhbgWubPq5119KiMc2XTZzuP",
	"LVsnFyqrOTMVVwiArkuZWhGCFpaU1JMYgq6vXQcmjhhfWw7SCt1RTeG5Kf9SFS4rulTPnPwr9w10cT99",
	"DH+PzpZU0rLbaplQhUB23uHUqZR+F8K0xwW9yPTS5jxGS3U/rTJfU13nk5dHEwa9MjtyzKMAzuUGr3KA",
	"AMkzvT7cCqqXs/JVISjgPp1pk+pbxORRzkcwEH5JD8zTNvCGQa9BC0+fRjHoTuXONMYBWkmcp5SamoCq",
	"aR1btjphY0oIlCf/ZWnLl14HPSwOEHfGDIZIHqJWGSxVBZBVyBrWQRQPoDtdQpALFEYBFHIDMNGcyxfk",
	"JKAjGKRrUD3D9pQTGLkvqcLGg4pUbGXatWTGA6Afdd8J6+mM8nyhl6e5J8NSFcdhBF2hyqavqJXRPEzt",
	"scDHzBVuxOgt9sybII65UD6o7ToWSGVoApmnlOvEJ7P2u1ayeK6s4seqeN2wq9eAEaPKNSrysNAIV/lr",
	"o+T0UfIIAqt+6cW3QJJiA/OzGoIZw6J6YacubbVf84CW4cInMlnhFrY36rGUPj9rC7lnBtD7HkSQC+DF",
	"SPsW1S8A5fgHMl2bk5cMZIZrgONY0IFqsT3JjiRiKbrVvEbI1XtTwd6vZR+WsfqruuimHKvt3cdclLp4",
	"sN7PqMWRd+YrT4O5V3LqAKgdjid1J36lkyw+5NrZTcTQLaYxN/Ugr6y0cjQOCEJe8uBBa4+5Q+W+Wjzm",
	"3RKhQp6JR5gg42hHzGi5PGrtHSW9GCmZ5WyH1nchHPAIughwFGmscpWXm6rFMt/DyaOZk8y4zngKTj0H",
	"a0fCxqvw3r5s6/e2TTZhysZnpJkPTFInESnKrIbjs65m0flF1ZMau5SsswyqDegMMRdy5Lg+ZNAViDnZ",
	"hVgl+q4lEuR8RpmnEHbjCAxAAeRpRyhn7GntiWLzDA6+fm/LiktTBwhjLtJKysqWMtvi6cUR7V7rh/DO",
	"8eKoVJ/IPRnCY3kgw0QeLDVHajVTAzZ1Fw96q6eBh7gFXag7Du8AnKbQivpJrrDsZ70qAzQW2p/UATg2",
	"DqToGBzpEgyF9BYpUD9rc0kZVsU65/AuI7DCzlq34iRc4ARmvOuZRiqySFi8o3Zl5b4/GUtd0b2lcbLS",
	"70vgRFkSMEOj8UO+LhrNcTpmQfnj9nEcaKcxRm9JRcKsTBr8Uv4iVPFmJwvcwxMswLOjwd9brmpVoHQp",
	"LxyVrH79Z50XEV3CKQHULhFzERFwIvU9yrTuBAn47vg78CU+OvoZ/ddqhv5v1GHteK8uKrCmatSWKvDd",
	"y7UQ9bIFUW57ok7WQtRJC6K89kSdroWo0xZEjZdgqteGKvdeVL0upcqyHYTERc6YstBJLu7LFeUkgIZ6",
	"lToHEWKY6rNX8WWrrOy++0YjxQYGGqExZebpdcW1jYGA/lfr7bpA5WvcotNFc4Je0zZ4Ve2CwEfQ4yCO",
	"FJWlc6ZP5K4vD5ol0v2DsdY4ABdG8dO3vcm1LkfES07fOQ3noM1duG5c0Ckq87cmkwGzoqdokAG6CqxQ",
	"phtDWcEBeIO0oIcC+EJE/MXhIYzwgar+wKXhoWqCtydJbizlb5+yAVFhbQScIu2VdSQPK8pPm/ARm2GO",
	"2g2BvrnuZN8zdYO0bvDs2ff/+v3f3/6fL1/++H//f//zH3/5//8fKQx++uv/5Qx++K//+8V3X/b2tXTQ",
	"kuvg8L9b7pgLTZXunlXOpMqHRuAQOV8pyUf3GDPswsPjEfZudFQLk+C6DFqfnoe5czyCIzsxmGDt3zhJ",
	"4CHMleIhsr9fwhBOqf1NJjHOfd/EgfWNOYex9R1AIuYMWSkMfv0Kb3EQ2InxTRyOYrvlE4gZtT+lwIDE",
	"tbOgWNiflMCpcjJlEk7hFDL7kzmIO0MYQBhayTd4RGNhdeqUxjCwKn4VOMcQx9ZYv2YICTqzUt7AEWVy",
	"ptKUt5BBu+O/UiVi+ChmEys1tufnHQyjXNPvfMgEjS1y3+EJDLD9TbgPuVXmPZxQa4rf4xFDhfF+T0P7",
	"K4bEsyuIR3E4gtzHdhqHUyvPOQzgiNrfUSxy3xwxixHOJSPaw3NOJ9DD3LfzUMLoLbZauZBMMLLIuPBu",
	"YIiInQXDEFmTfkFjOHV9KkSW9iGGE+jReEKt1i4pE3RwQW8tqoeQOte5sbnG4SieCqvcNcMRtWfgOibY",
	"Gu/PmHg+RSpaTojMWoS5TxUXB05QLm0S40BPfZok8CTOpTA4iSEm+bSJ8jcuFxEilDvHCn0vy3ACBQwh",
	"c8uLn9CQelf4FnrQzEFJFubRUflvv8Y38bz0l/fQucL0przYOSIe/Vr+2xWmzhsYBMjw80KGIQwErPiF",
	"OL/GWjyW/vg+xuV1XsduHFYU/Mj9GBbGJs6PB4+Jq2+h0ySBp3Sar1FM7UIvoY8Xvp2XkHiIQZ77gY2g",
	"lxuMlyhAYf4bf7UZS0pgdzCEoyBH1UsKnU+Y54bvJZ3QQgLmubrKOewEhiOGvQlyXsJ5Pj2izhsmO5JL",
	"Jm5McgkMujBf4yKnnsA5IiRf0Tw/Uyc+duGE5lP8GPq5VXRCGQwcFZklZvn0AnefUC4k8+bpYIiL3Fie",
	"xBjmy8WyQzYdp5Ao6yEf3pJc8ozTxQTnhKGcADlF5BaxXIJgVJ3Q0xQqdeYcpa+8kJI8qa8wiwmK7FF8",
	"Fcgt8RZ61G7gFeGIQM+u7jVlwrlAQZ5ilfoZznMzIxNhgHLr+k0A3SKHvKGe8OEol0L5Qi7JQc51zKa5",
	"xCJ9b2LooYDGud69iaFAIQwKGefwz1hZq2Zpc5iTq29hgMfwLpdyW8iCWEg5DgJ7ps+IhyFJ/y+3Cl7y",
	"8ztC70qSzyFDZFJW3yUSiKXKQ+HHaxQEzgkW85LfPqFbWJqOiSsXVBl1nzGBIXQXf1nsTnyL7Wk5+xMG",
	"cY4xf4UhzPNlcav4NSZIK40m4R0iInan88P3NMY81V2Kv55TIrCL8uMvB9Y5u7BTmLLuxDc2ne+hcwm/",
	"2gk4tGl8L+UcmaAgNz6l9LynM8ScSybH0858Dl2EaS6BwPyGLlPifBmGJ1TkUwRWziZyiQKGlNF80a9Q",
	"BDl5uLi5niMi5QTKVYYY9vKZRACnsrJc4h12aZHJziVh+Z3lnBJXFFMEYgzNi2m32EO0kMgQDApJHDEG",
	"7TG5gMkpI0lAM+efNCcfLnCEJzkyLoxil34ySnyYTxG+cwqnVMiNNA6gX/WrDh1Y9askZwjzG/NFHNvk",
	"fbjBBE7s1i+hXHP5hAnBTMRkkktlcmvEI3vgLn2KCLYFitRuBzAeaLYs/ODQsTOMICaFdOocuwwtJH5C",
	"gZ9rLUYy+Qq7+VQioHMsxbLNllcQk7lzhfP71xUkU0ycMxIge2KvkIvHKJcwyau7V4jTIBa5PJg6Kqq3",
	"Tc0V5ZDlVt8QSvrOuHmzlUtmuamSSTivR8gk6qg9tpBOnUsY5yTQ0KUM8dGcx8Szk30cMeraTDDEeUVw",
	"KJyXkAlf6nTzfPqv1Cc8n/QOC1FIeh+7uFDhtU9DWMimRb898MMZHgvnRL86sNKv0SR25Ykzsqu99uOc",
	"BLz2Y6mrFrbta3wT5zfMa7nkBM2nCJqTM5/kRMZ5bvmE2STHrCqukk9ZTjv9jAnBEbIXyz/hNBY50fFP",
	"uV3MpsSwmZx7VxiAQQuoLOkU3urNzkqKpUp1+pGlm0D22zl0/4whwwvJiY5npbnnMfNoPvESBvqhjpV2",
	"pbA0mE8c0lj4ziUtEjCc01kh6zWjQZBP+kS5UBdSxyrh8D0lkzmCbDRHikqO5YHV+jsIoZb56is0Krf6",
	"INCbs/TrT6GFsvmgI5R+cX8CR3oizPfUhyPopQlizrLCL+HE97IfX0KfGWGlP6dWTjKZ6t7oT0agxqPU",
	"J8IsTht9ibk/RVleqQnj5OsEBm4s9OlHffvY/qB4BAOe9fzEp2Typ7btMQkxmUztBBrQUAtp+XkKXRdm",
	"HyHkrt741bdvsBX1gYOUqtN4BK0P7kOSDeprGMJJzDMy38Cv6d/yeJMN2Vs0YjT7os6Jj51zTPwsiUyc",
	"dzQj/y29Tcf/jE1jwdOBO+MCklE2yr/CKWQZFb/COYwMlKe+EYt5shnKhHfQKvwOhq4PRdb9d/Iw6OPs",
	"U7IOyz6FH0LixVZC/tuHxJtPsupoMIUZce8Y5ITOIcu68y6GAXTex2EUZ83Eylwu+5xBnPLReXK2Sz7i",
	"7GMCvYxJzuFUKios+yY4SEk5j7mbrYgL7FKO0x8v6C2dxl8JssZdpnE8whbtH0LrbwbTUb30CQ2dS5RN",
	"8KXUlSGBafbLuVz3MOvkP6DISP2HPPkSmC77f8y/zgPKvJTAK0gmNGOpKzyHXtrYECaql/6a+jDA1rc8",
	"CkOS8tcQ0Ywhhj4kEz/j+iEmExhRlrL9kCGPoCkN5lbnryGOssV8DeVKJ+ngXo9wgHn2M/JZNkvXKHCO",
	"b/Ft+u3jcBTbX5GffdLpnGYfFgUfb2IycS4h8awx/RhASEbQHtmPASTOSyholsLi8M+UuI9cDC5Qtnw+",
	"YfUSi6T9/xRAD9+mQlwmqW2OW5/EGv5/oikUiGGSnB11IkO3egzkmUHuA8dfqYF1kpSXiIWxnvIk6QSa",
	"uPhWSoScT4hpiCdJfQ0Ro4WUQsKvkDjn0Gw6SeI59BBmuSav0Hx6A80pM0nUW+AbRNkE53IPhfMWBQYh",
	"zhIhCfTuHnPBYCB3nJPr/LeHAoh1L9LElwzzBLa2EukUEect1jtrmn4ihTPTxGeJMTMaQZp0CtlMr4Y0",
	"6VXsBvlyb+kI6ljpadL7t2f5b0w8ZHbjLJEyz3lLZ/kmz1EwojErdORi+Dn/Lc8wuZRLVEz5R4wQ4YFZ",
	"vWmymo98ytwjhSG/hjyEBOc7+gm7grJC4mftACNL+KfUCmeYqHl9yeBXHByas4r5OkXZgc4kvYKqFvNl",
	"6jx5Jef9ZHj915NT9Rck0JMKiOaVLEUe8bRINQmyOsRIlnBOY3X/l6VcoNmYxsQz42NSL6GLx3bVQ8in",
	"ylHADFqF/xlPqQ6zjgN0eEJVFFGinQ/pNE3BWTL8Jxp7fqV69Gpo/n3+SvXr1WQeyf6+wmqUXgn38M35",
	"dfbXD0fW3z/af+d+yP3yk/Vh//2z9fcv1t/Prb//av39N+vv/7T+/nv298CiYvCj/Xfuh9wvP9kfP9sf",
	"FlEDO5edyc5jET6wCB9YhA8swgcW4Sl5DCEyw65vvj+eJIP/8fok+YvIYzFXMyy/f4sDudO8ihmN0OFx",
	"KGfbU3eVSRLxqJYwSYJcIFNfB3E3ScLXN/3m+yUKxnohZAnaeMtKYXp/Tr4ZFJgH8BbaaTHnKLArjl0f",
	"MpSrOvZgVEjhmEyQVfmJjzkm0OroCY0Q8WEu12k8ypH0Bo8YDPQ+miTFiBF9aDMpb1HAMZniLOWM6+g3",
	"5/YIWQqsSfkVsVxF76S+gokcJisRo1v7i1H7c46tr/eYj6jV4vubeBTc6MNwkkSJl8sS36FQCulJlnYO",
	"PYY9+1vfd6WfDCMfhlYt55goPSD5pAQqWCT95q6ykDbfmdZpEj7wwMp+CRm2JvySehPKNJabJDE4iS1O",
	"usIT69crjbiZL6X3QftbKgAME2qnMXiDbgspwh7pIQ7HiNGIWvM3nNLoxm6Kju1eDQV1pz4NrJV0DYMA",
	"E2vkrjHTG731zXONfAzmkNBbe3w/fvUnlFFrij5BL/5qf8ozt9WMVOdsNviEA4Jja5A/0WBC84z3GTIO",
	"rVn7DU4YGtnfEWX0qz+3yP8tZlr2vHmp/hmYfUDvAYn8TwStkVu2zHqr9hN5LpzqY+GZi8y+o+8CDo+J",
	"PCIQyLCaL5N64hvzg/SbYS40BJUkUTeXg4aUWTW8Q2wSSx0uSzqHPrK/Ag/fIm6nxAwLPY5p0pwKYZW6",
	"QjHRN7NnWvs/4wwqKDC7ofgVRuqndzN4AwOkBNB7PJrL387VNns+NP/+7VxtsxoWP3wJb6BUn1A+aaiO",
	"lCZBxxuTDV78pv4ZnLw9lnVcwFt4Iwfg8kruDJfD6/+8VJUbxeHwOFLcnH7G7tRMRZL0ksYTiEmCSiXJ",
	"Jz4UvtpAshSNQyffWqWwE8baTVj6TTzERrFS+pO013AKqXpikabgG2x/xgSOtU1NkvQGBjAyrJGlhSOc",
	"a/1NDD0YuJCocbJS7T68pYQGeqtMkhQ8qm8dkqR3kBQSsOSREObIekclF9gJ1tQnaefwJmY0l8D+jBGH",
	"dmfOsTeD9ihdwJjZNF7g2G7ogrIxDaa5lDhE9kRfwgl1LjUSnaUF0K71EgsXYmaTe0l9ok/DWQqBEcol",
	"MOGca5zaSr6CjApKJjYRQ4j1osgSQmpnuIY+zo3pNWRwlsshqxQwsum+Zjk+/AynKPcZ6IvGJOGfMJJf",
	"NOF7ykQ8UUxy9eFE/ftub3/PBguuY6Y9EmvN6+Pw8DiQenfyN4rlsdp8MfyVEvNTpvh/HKr1MTCXn1mK",
	"PgZ8HB6+hTOIsf7b5BoMBWSqMx+Hh+fY9fEkacY6MHwcWseCj8N0ULVyaCuGnwfDj/J/SvwoDbEs+lsc",
	"RR0+EEprTx8IHQ9+a2kYWSxbHnSHBU7E0BjflYSzunoP9G8A22EBAeYAEy5gYJ7iYvEdB3RGwC1mIoYB",
	"4PHIwwzJA+b8oDko16Jby2YPg9WhqntHg72jwd7RYO9osHc02Dsa7B0N9o4Ge0eDvaPB3tFg72iwdzTY",
	"OxrsHQ32jgZ7R4O9o8He0WDvaLB3NNg7GuwdDfaOBrfV0WDvQHBdDgTzEbJ6d4K9O8HenWDvTrB3J9i7",
	"E+zdCfbuBHt3gr07wd6dYO9OsHcn2LsT7N0J9u4Ee3eCvTvB3p1g706wdyfYuxPs3Qn27gR7d4K9O8He",
	"nWDvTrB3J9i7E+zdCfbuBHt3gr07wd6dYO9OsHcn2LsT7N0J9u4Ee3eCvTvB3p1g706wdyfYuxPs3Qn2",
	"7gR7d4K9O8HenWDvTrB3J7i6O8EF54HXcLLoKlDAifo/Fii0H+lalps6ATIG5wt+ClXx38sbq3RPuNBm",
	"/nHZuigod43oyuF0BNZ2q6ljL5WwaJbNEPQ+KCcBFY/vYIQd7kLiuJSM8STOTMybDdZHDBLXdwQs8fd1",
	"DSeAMqCzaL8BM8iBQFxoxzoMGT80IZybN6P6mbfyClQ0V35+VG1yri4c/UPJHiUdHMU48BxcsvJeyl/A",
	"2WlH1C34Y6RhiIXjQ17yoOpE/Qjkjx1ToZ5meTnekfUOVmWgXD/+3UxA9tJYZq+o3mIyRG4xoyQp0MyV",
	"iCvNAnnrWySpH4d0xf+FofHei73/OHRpGFGCiOCH3PVRCPnhaxwg9Z6jvFojBmStRe9JLatXxZTHpDbN",
	"aNZvHugAQa/dCBMqlhiOCypaDUekXwk5sooAicQsf33va5SY08kt+HTZjUWWYBMkHESqV1dJK6oMF1B7",
	"9mpZCnGR9mSxo+nP6fOGRg43sjT/Cvj58xYCRYulNQoUqW0ZYVJ8ldFATGFntbfKTPDlJNCCtEjW+sLq",
	"VOsoYf3cXBcm0Z6dhanIhqtqxz9RZPb7fr/vb/W+/1T2+ZJXmo9gu20u02+unW2u/U5Z2Cmxt8SG2G7/",
	"q44M0G9bO7VtPfgus81iusEnUqPQXgr22goRvjaJm5Os7WRnlcQ8S91C50VlL+62T0tvocFqt6oOHI+R",
	"a6ragDarR8IxLjqTID5Yu6e4tPnyW+UwZGwdUi/15bvaOEQMjZHxxZlfFqUjVEFrGxyuZhSzDgmjzKzS",
	"jroHaG7kW02zzfOnxIyZxAT5gK4kVc5pa6wvk0dmdI5VHW04Ld2U8n77uhPBmZq7yBJGqU350Axl4zjV",
	"y+j8mJRBPCY98S9ysbe/p25U9/b3Pi7lU3FdgqTl6m8pJe6/rq3xb9Nk05RXTHTSQv10Vh5S+p336e28",
	"693AKoRZg8J8L9FWyqj9Obpn7xXP0Z2dk/sz7o6cce93rL2mrxM0vqjAr3IZvzBRaptvxbKFbqV+5U0N",
	"1R24SBChfAdWuz5fXwfSO8ymDhjmWtRSb1F5OARvTmCIXUdQGpTnaKsplvjlK3dKzQUUtS3e00BM3/pK",
	"auqGqXqfvddoVY1Cg1BafkzuY8BWPTiUBidF9aIwPLHwnVJRdVSz86ugGMoH53D49vD48gy80xF2Fy65",
	"Y+EjIowb0FRapu4bL8+UWas2l9zb3xsO3y51yirsqnn622zL6E4wWOKJ9jhVPYGHxphgHWFUayzGLbpL",
	"CY9D5IHRPInAUXD430rcr31FSrar2ZiM3+7lx8p2g7pkWIPKNW1T24qFaxXqKZoXlf5m4vb3ZgwLlA2+",
	"4dt+WTzoslhR9Cb22+vhA67PDPmKVqrp8S/K1uvRBOQaWif1/FK8N/utXSQuanzLI/HGy3p5YQNbJEER",
	"ymXywlG/5NQg80WMyvE2yuXSEWRW5KUaGZ0orMkQ5Ptb2ruWzFMpzu/NQ6vKjyVmuUlpe3JzbqZ7DdNc",
	"fnR5bIJhuaOG6dYjY9m2h4GPXIfZz9Ocm00nQizEnCfh9u5hR6HD3DcEvv/p+S9WnDX5O0hC5pdeiDAu",
	"Sv3FPz+6B6tgXhma9RRxPCEqnPbMR8JXAXWweSjGfRoHnlR4hL7UULHJXB2R7CPhKECu0Pkx4QJBT0ex",
	"DpAKWABdl8YkH3T+WNNR9iYMc4fHEWKxmcVKQpUqllHpS6KCAFgzq2Il0FhF2Qiwi0UwB5DLClRsRx+F",
	"Nk3DpFUgD7VxeXDUAHLhBHSCyeoXS6qO1rNbHZLBPOfzDsCPz4+yCAQcUAbGaIbYAXiv3t7xfR3Zh6s4",
	"i/9zeHD4w+Hg0AGUBPMyiDeCQr11fLH3f/715cvs4H9+GPz+w1/2WgkVa4As2quW6QklArpCxXFbvNsK",
	"qDt10B1y4/JYJGcZt0E+J64OhKfjKScR9qxoe1YQUZkPeUAW8hklOvCeHByV4zvV8ndZKM+YCBwAgyJj",
	"Ssoj6LkoCBwdzqkkMI1PCUoCkanXkiMElDvRLGyoZqcX4Lsf/p78990B+BgBQcGPz9M5DAI6Q4vYfG7e",
	"vnz54b9//O8vX7x//33/x+ff/lIqZihzURaAiyFeFg3vtczFrYWmIvtylIa/TJ6AUqLj36rJLx8hHcLc",
	"qdDkW96etZR2kRzwpzQd1XYkiShcxaRDrrKhiEcrmnVkYWFK9LU2h9umuDK5zVBKZ+pitceoODcqwoyq",
	"ItlGlri1U0FygG7guHq3LQM/2rGimGE5w/fj52RyG5B0JVxV3haytNpcoBepvUhdlDxPTVT2UumRSKVa",
	"gXSpI1+XHB/pDdWPHZ0QJUzX6obylN5Q9Rr5XJcrOY/poGwOo7rlutreqKxXVF/bJrEFlyTJwDzVBKWh",
	"+ucRWrFyeRivbiCZqyY1IMnruHqncLBRu5sK2lp6kQMW5zI/BQvjWj4gphdlBFaxV+Umt8Un/f4Ev54T",
	"fOsRz12y1IBTZRchD3Byz5O44jm+8dSuzhMlxjKdoFZbjZbUDvWnOCCIwREOsJifeYsjfmtnWNSEnjfC",
	"wAsVtCCjUuy2oGYZeHcV2q5RGAWlPg0eZKgSch7RkKmrHTdmWMyHcoc3x0LIsXsc6/DraudXQlOmZnzs",
	"CxFpK1M6xSjJjSXj66TkSuHFHkdKfOvXumYXjfA7pK3J6BSRpHhJ6NvBCHK5Q+UsB7TinQbFNY7BvugS",
	"X/b29jUhPoKeUiMMIbIZyvBXfYWzQIwcjkQJWojPLLdE5XBsAD5EiIAhjZmLQG6QgQrupB7XgRB6CCDI",
	"5wfg0kA5gKFAbbcRZDBUobwOGeIRJRxxQKgAcySSM5TWuOz9zCbi+PIM3P60Z9lM7v108OPfDo7kkNII",
	"ERjhvRd7Px8cHfy8p4SSr6b2EEb48PYn+b+BGvmBHNhDxYtU86TkSDVAUsbsHUf4Opkh4yFEcxni4iX1",
	"5kbDEsZcF0ZyY1bFD2+4hhR0T5o0S9mAailZHt+Ur5CsurvBbDYbSGVrELMAEZd6+j3HPeoP40DgCDJx",
	"qOr1oID3qjG3As2+n86wrO+no6P1j5huOM+xubW99+Jf/84t1H/9/m0/t851grUW//X7t98Tc71/7eXZ",
	"Ze93WXnCSpX6teKqCSphqpxh02VW4j1WT52y5aEIV0v5zxgp76NmJcvJN5e22WAtiMPyskoOLZSyzrQL",
	"Qc412EHHgCEeB4JrhEbEjEjtFERwoqJclzUW4FAFDalvr6xkm+4V5KWPgDJNggHAxEN3YMxoCGY+dn2L",
	"ZCldTEeqqKbjMUcNZP/eIWtfwgmWhwKvglMUo3TO9dUnx5YL4N/Y+7b8KrhCgmGkTlOFlVCwSQOxCgkI",
	"zJyAWxjIL0/uk+O5PhJhbh2g0umW+0FhQeTl1oPNfMWgPJrJ9tAtCmgkt3jHeqpSI+xOsxKvrALlsm7T",
	"gmfrBUj56G9GflTxyt7v3/Yr1K0KZulU8ypvsyM1rLmxe+lkTdW3UNB+7HhgH5Tv2kiydNdSiB9qzaSn",
	"iAtG5+vatmz6gEVgZ5vYL4vnvgt1E6cygZFcc5uTD8vsJevWGDY+9EfbvObU8VsbcrSazUvI5A78UT2/",
	"fUpTuv6t6VIFyPI2ukO1bvNeG1XLVr5927m1EreXe/0S6bW3XVodrbU3rbk5EUO3GM2WPpuequKXunSb",
	"g+ojWWL7/QG6gwN0kRceywoomprUYTB5Q6ElgGbdQAvI+IkgzQ/JrwvNy2mQnVXeZbh6QJw2ndg/g5B6",
	"KNAxfoiL9DU89DwgfMqRzGmoU+uggrrUmNqmL7X9SZ4fq7mWEkdbKhWs2aqdEpRPfmKP+AiWcJ77N7SI",
	"F5ZnHexVWJ/d4l35xrpSlapbuZ+OVFXvZqGtouXlg7BT/W7QjGMVuG7dAJYkCWiagCZqi7Cr8uXdavdd",
	"O1zV2UBv6Y7VKQD3KCRDNeZW4MVuwLZuV353ONtGdsbmxtaCrFXuk992gfvjFnJ4x5l+d/XAo93TA1sj",
	"Ygs6YVdQ2OaUlh4Fe5IoWGtObwN8LQF59faRO4F2Je/u0jCTuYd4aao8U/CWMFi+v4rvgHYojTw91hCo",
	"t7MBiBi9xZ4l8wp90NmcJFuuK6m7wK8xQ8ene7/XPK/VrR3nXw9cZrUWmWazgNymJUkrDG5D6FvX+tb6",
	"Na2Hxto2zSkVm017XK1DRG0bkbQ2EFqX4NmOgGbr3vg2gqY9wC7RAKB1Dp09LchsQ2BZZzDZpgGyB2Do",
	"WkyM7ygf74o+drTd+tjS+NZGkK0e0eoRrRbcjIgXUUyEEyIBTQi83Jv0glc6lYEDCE6Gn8AYB4olKYDA",
	"aHJasaQRnUCBAGQjLBhkcyCrV4qlpAhQApKG+cEX8oW8nIMLGCL+4gsZJBgB+CPRDuUE/iFZDt1hrhzh",
	"mF9M0bPTXDnJC1g5zpF/JYSZx/1JpX9krgBkLWdEryDuIgIZpsB+8q8c5wWUTkEc5eoczZNP2bAHPCQg",
	"DhQH5tf+K9PbcySgHsMWJ/17ierFFh/MYqWMlO5ZvoyzK3hfOymqltxJB4YqX3s4N2lgJZB1DAOOnIhy",
	"bPw7LVSR+lKqrCINePn4MeUQCzwxgTqX72la2hnNH7shZmnRWDh07HCXRqtNNcN86kDXRVHjEG5kjytZ",
	"Mptb8cbpWDXgmqeuU9A131RHmn51I2vZQ4rVPsjuoYl4CC6q2TIaAdk89WsGZVNqjJu97UFmy5Zyi615",
	"3Qjtxgb4aIuWSyV+mSetEwyzywnrDMjcyBbR2NY6IM3KDePbtnN83CibdpnRd1QJOtohJagtClpUiDpC",
	"QjtaHz0cuhVwaCv2bgEILYEFjRmcqFfsK7hN9CkXW+JusXiIEOAaToCsAihf85jwivoJFY6Ak+XsDk9o",
	"GELAkZo95IHA2EOgO+gKjUUTKkDEEEdEAEq0McTe/h66iwLqob0XCoerJYmXGz00GC/s73ExV5ZyclPa",
	"W6T9A/OQcWnehhhab3oxMEw0yCItmpQkodneopHkR4GlGQm/9GpRAPFKDWaxK1cpK6hLg1UITj6XscNt",
	"udg6WGgt2Xid66nqbbjyNF3XvY1CpJvd8trAoptBRDs+Bqz9AFB7nF0/3rlZlijVf1qjm10Bm9sHaLaA",
	"MjtDMZ8QerlxeViPWHYLVj4pkHIz8GRXwOSGIcmNs3EdDMl3kXu3Utk42lplY1kUsXsAsQcOe+BwWS6e",
	"IKKOwQ5DC/aUFXz8xhS5QjnjwB2S1LrnyTh8UJ3sSGo3NXUvCV5feafSPN/0A66GiQnF5ShgtR5JT/Je",
	"6qxP+rH8Y0RD7wFO6qfcjwAoK+ORDXB3kY1robMCjR1DaIXWOlNva9q5p55bWfOGrQsLdDwQX9WLzxZA",
	"XKEbawfkUpqAIWqbsLnShd5uv1o/WLe5kT7aumVUg+QVCOwI0et08joE9zazn7Rpbj1wX/Xu8m03lkHc",
	"RnjtOPfvuhp1tItqVHuIcUGl6gxq7Grd9KjjlqCObVm9FdKyBMYC3ZUfn8IIOwKVGy42Ft5aR4jLGyRm",
	"AE5bk8Tk2byyTXScBSLXZqHYm29uznzTVXiSXBaDAEH1fzOxA2PEvL83EJBNkHAQ8awvLqAybBzESttT",
	"P90ipmI77+9l9ZpqE3ZJKs3VWagyqzGpcGuMSBFZXXq1xVzz/T5XimCAtJrAQQjnYIQk90PN/aM5cOWC",
	"UP1tw1OpIJB/KB9rtaye0rb0lLVYpytLtA6lWelDenWHsjhYbRnHnFMKflPblk5X3aLL1ZcBdadqrZ1A",
	"4qIg0H/TMJL6iPz7TLlXnTDEZQ1SOA/lOlW/fSDgLQ3kX58hVi5UxpSBK8RpzFxU6se1tyVu4pWcaMxa",
	"kWWg2HuxZw7XLc25C7L1/vX5UrQ7yY64vBjLpHsFLQOBwyUIyjadR3OhtGn9vd0V0qYujzqHOzrAOR78",
	"nmjT7FJxzlviSqi7y6BtvANqdfnT4bXPk7rteQDZ2XS/0/XNzhO70NnUTU53Vzgbv7t5AKauv63hu8nL",
	"O6SoHG25oqI90zkM8ymvNYdNyx2rEleywLqtYR8P96fn0boZPTZe/eRYpEy1GANm2YWx1rYb18waW1u7",
	"3t+KNkmTpg8SF5WT9TjWmhtQjtotshOZ9Sksr0Vh+XCHg7qxX/5yeRPXyv1tcn+bvAo3j3GA2t0ov5Y5",
	"+zOxIvaaqtF4hLCiouspa1P3Us2PPe8CzeQYLDzK2SSSKAl4TIt8mcdqadFun6s9jeNp/2DtCT5Ya7sq",
	"CBUtt74LmbPf+szWp0bjEW59iq7dlFN635MD0KmMqmtmDft2WcUb3bclAY9JQjFEI0TabddXKm9/0F95",
	"9E0kFUegMApg7dbwWme9TnK2N7Z1Z6uZHNkjtB1eQmtCvLToZG+k+mBGqoqDB8m7cf2pv7bFMJSjW6Rk",
	"Te93czlbucfhS6AgnTeDuC3sHjU6a3H76NQUrNBYR5phTSv3Ugwr690wnpOj4mG4qVZVaTQVK/Lcmu3F",
	"EopAQtL2mI2Vr+xWeuG6IYPNjfLRdq2dSpuy4ox1YljW6bR1Zl+2mY2jubF1WJpVbyPfdoD14xaiaqc5",
	"fnd1pKNd05HaWm8s6ksdmXB0tVR6S46tsORox+XNWOVmHAKkg+e0eTZfX0Obp2SlTCc3MsVWZnDADHJg",
	"3kADTDj2kAn9fkpvaBXTZY+mF99p7u3/uP/T/s/7v+w/3//r/t9+3y9/M9fiuWVpy7ec3/680uCpkg53",
	"KUPlT/rGAYUie85HlEzYzEvlIvS9vqfJ+UkP4EzNuIe5S28RQ17VFBuNZ+n53Wvxcnb94+cplnW08HGS",
	"N8gL0dDvM6wd3Dx4sZa6q8mTtLTTNs59aS1zAkPs1tWRo6Trmcx86nY5cYoAJ1pp3Mc4QE6bIFtdD1Wy",
	"/U0YjaPa4UpE2dLSowOiaUw6X5c+5M4NZnCl+fUh9x15fHno+S1cTK57kHAYQXe1uIrcMbeRyFtSYOS2",
	"owCTKfLAr5hBgDmPkdqbAsgFCKmHx7h6e5Kz67g+JBO0Vi1E3dK82FMkKULiqO2ulnYNFnuU6FdKx7cP",
	"NvW9k6WKO8v6tax8Jy4ZvcUe4mp+FvUGNSTfCRq7PvK+kywNgVDuPipPR5An+3LnCmPXCzLXl65lmGpM",
	"+0NxUiZc3hHFw55zT5EyJAR4bPheMpIPORghRMAY3+lp4IIyfeg3TIeFYjeVoYqechH09Lgq7UfXHLWq",
	"Bcn6u0xGDnXdmCHiIt7Rwae3e7mfw6p7u+GT+4LjWL4bN+eYb/nuZWTeq4ePacaM+7blOtO1GQyJQ8Sw",
	"CwNnNUOiNRtspXDeYAGdG5ShbbYbQmPsZXbmgX2YHyyeqgfZkXNgnYEGSskfFDTqQVFrGpRqA4PS0RzQ",
	"WDh07HCXKh9uA1MPUy4S7YyyvjyRNWs2GZbEkGkQEw8xJ4e8ZMnZt2xOavJ7+xl4ujDYZWOdDbUeadNp",
	"e5wXhzkbZWuQ1RgXhrg4wqUDXDq+heG1R9fm6eLYNg9tMrLlA1sY13RYt8WwsDCsK3idhAyGKwU+h/OA",
	"Qm+logEkBHkOQyHysNKtnHpVvY2W/t7I9jFGgceVp8J0LiKGxki4vlYmACZcPcjnABIPQM8DwqccyZxm",
	"utS1z16Vb0ldWb2UrAVXy1DIBMNzNC/YkJ56Uqv+b2FXJp+1YktOWgU1WZ0r1PKLKNPuJssJtNcnw3zq",
	"wNSLgWmXUwLZn/EIOerIbtZqsmRxqBxiyqzNS62ST+JRgLm/Em+Ue9kcoxLtuZGzXt1Fkk+Syx90JxAj",
	"MAAMBYp5OXiWSah9gMgtZpToDyOu9sEy/yUyTlK2r1QS/a9K+L6CLRU1yHM0/z84JG2xWBcHlS4I7u4a",
	"ZDO0m+20s6NwQRCUsZh9/ddQRQsUtNSUXqkcmEwdOrpBq0Gxug7lxNZ5NBcTNlEBJqjTqbQbazeOnXff",
	"lUoBc1xKxthDRf5a+wAgdovdlQwK2p7B6so6NzEXeGysR1aqKYDa6+8aVKcOZnNBO+hwKouHhhWEikAR",
	"dwR1GNJ7L+pf6iz5UqfC7f1GXdcXT4tPZv+uPOY+/R487TgCjxuOvQ8U+8hg2NUg2PXDr5tZJ+lhrtON",
	"sfn1ZJUP/1IsbYVYAHn0bZUK8J8xcrDnjBkNHUFpsEp/LDR1eRpu44Dcn4I4IIjBEQ6k8oe9R/OmdaM2",
	"xy2esG7k6apuo9tHGYttrONJRrHWh3i0amZok0xTZp/e0jtwwlctXAP3puu96Xpvut6brvem673pem+6",
	"3puu96brvel6b7rem673puu96Xpvut6brvem673pem+63puu96brvel6b7rem67fw3T9MZs797bAvS1w",
	"bwvc2wL3tsC9LXBvC9zbAve2wL0tcG8L3NsC97bAvS1wbwv8ELbAqxnCrjVW/5IGsmttu9Fwdo2tbdSg",
	"NjXGljQdp4fpjdtkl5nXto/wm1jYVoT37aPo9lF0m9mtbbihjsIMbV1woeaYQl3FEuoq2kDv3+Up+3fZ",
	"do8qGwh4telnWrXxrTqNa/WUolltJIpVR9GrNhu1atP8WxOkiu8g23bLr+tm1EUOfYDQU49DK3YDylGL",
	"89eJzLfecO1PibFV9zt+01tsYi1PevOVbkISqyYfB3MvGT2t86hpfay0PlbakhycnPVaMG+S9fEy7n1n",
	"shUUm26vZfDr45lPhjhqA3ym03olCzz6HfjR4FOVU6DwkObl9Fpme9wo1ibiYFM1Do/KiYui6MmqovfS",
	"6o497wLN5AAswPmb9dUSPBINL0QCyiFshe6fm8yPGuVfULaUuRcdK20q6a5RspRsOgBnY20ThjlAYSTm",
	"+4kCBoNAFWvzX1o15Jy6WBkdzLDwbf8uVQ/etGnK/SVXvuNXqhPI0+89rc6rV9CUMeSKYA70rHtyv/+l",
	"RTVMv6KGIGJ0FKAw62RaPybasFGWV7X+Ul9rgjR7FOl3U+gOmzPcA9y8JFzeq4GSZDka7VTBxzjR9Rth",
	"MtO7C8vIEegWlSm2sA5QJl/nQ2CPelVUrYLdEKK1EH6ytHYXyu+XVr+01qysKwOC5pP3hczWn7ypGodH",
	"dfJWFO2gtqGP3bL3nVoD1jWzBtigrOKNwgaSgMcBG1CGJ5jA4PDfBM2ccWIeWM/9H0yhx7wAEqvwfC2m",
	"k1sJ5zIU0lvkyL1Fz2FiWVTcD2U2IFkQvGY0BGZWVcrefqUVoywls/QWSZpWORYbsUoqNrRGy6R81SV3",
	"4o+Z0WWRFox+DSfP+Pf6XjbR/5LXUOYZUx3LX8PeCM+7hh0b4BUaWAeL56p8ZKydnrm74tgdZNXueHSd",
	"zJnnymad85EKYNUDJyGj+SRr+nxlCuzumfZlzKIrOCuMx6M62xZo28FTbvkkdSRdmhu7l8Bpqn6j595H",
	"wP2VQi1VJ2sFmdxcd1d6XcPJoxJVcjZ2UD5tp6rz45NlU0umTAI6goHDaK1p3RuV60pmKjdOKDMuWYxH",
	"0dYHZLnzg501o65ylEfLXXc0Fox5wefiwxhuZ0y1Gattm9VrZLXF6506K8ja6Ug2ljdwLxFZVuW3LiVj",
	"1uDG+aNKSDa6JLAYaM32ioYOIAnZHtPvhXXZtAWtW5/dyLAebcOaqHz+bc1OJ+BzV1PUGQLduXSvbWcd",
	"eHRLWb8tfB3Xy5xdZect1lKOtl5LafuKNqexdPSQtgOW71/TbsVr2mqO1u6EBgEkkxhOUF085zOV9X2S",
	"s8XJ7V4iptDcA+FGBSq6n6rihJROF3chyc1UniJNNAcQyIxA+6SS0oMCaDupBZQl/pkOvpAv5OUcnJ2+",
	"+EIGQE8ugOBS/wyeUQZijlT5O8yFFDqm6Pd2AQJeZdWbKNdycZq8MqsJfKiSsZe83kJ2MZXyR5b0B0gF",
	"pKTzjGiBx11EIMMUQEDQDFwjLsAMBwEYoWKk7XwTSW8vYIj4xjr8R+ILS0qkP3K/WB6A0x+1OSIMgrms",
	"LF+DlFxJzpLx0HHFwSm9oXpAAkqnII4UZRa9o3lCq6zeAx4SEAdcDc9nHxEQc9lv2RAHcxoDyU4BEnru",
	"Qu3qDMBY0BAK7Cpa9cBbrfD9ZFC1Vzjz4VzPI8S/kNHctPKHrEfH4kSOWrx34r+uWYz+yOgpy/MHkF2X",
	"RFHwh8qfkion8A8PJQ/LMSUOJY7NV2oL4YJhV4BcRjCm7AsxffQSizieeLIjaJb21bM6e7BgiaEX49CF",
	"ZDMSU7b0oMJSErAxOSkFXF5E6oiulIzxJNbTUIO6/4oZPMnlbQ++9xB6KyScBc1ulrtWuX49uzo+M64p",
	"N6NxlXBhDSC+yIad4uL2cHR05qxq4l4CrrzSjYo4m4SH4qIGYdeIni9y25pB9BvMAHRSZ7Dbg6NXreqW",
	"e8u6UfVNjfPRVi2fSoR9ccI6Ado7nLXOsPYN7BgNLa0Db6/YP75tP8PHreTTDvP5zqlERzunErWF6svU",
	"o44Q+26WSA/abwVo347Tk8gFIYwiZblcy9eJHwaTuT3YURHOry0KUBMWsm1Zp1Njx7JianzxStGqVdEp",
	"WjLkfr9O14P0cB5vEuYpLsEGoKewBrtHeuRwdKnTFOu/v0KTr3HzAI+Ku/JgzNMo4lshPAU26wjikSO1",
	"ZfhO6XJuu6N2BfF0Os5H27R6auGdwmx1iu+se8q6BXc63CTqmlkbrFPYMr5tPZPH7QTSrvL2rmg+R7un",
	"+SwD5CxoQR0jOWtcGP3xcHtgnBa8nobOrGfoBGntDVV6Q5W1sWfKew3QRcp8vXlKb55SwjvVMq0VZJGy",
	"V2+PsvLibd44eiuUB14ltQhFOk297Ulve/LU2TxukkW9xUlvcbJtWs4y8ISl8fQmJj028SDYRB1rJ+/N",
	"lnlPY953rfqsJh2iVewuEIGjAFkvvBwUYTeBXcpqHFEaIPVgab8Ty5d72Z4kMq5fi40DZjh11bI3yBVt",
	"DHZKi8fcd2AQOAr95StxmapDxYCpL74xFOpSj8kG5VC5rGlApEqFTefolBmcDtW2khburbUt1PmtayjK",
	"tPjQDNRyV2uFUZUyXDd4lRFLWwZX1Szz5VSKjnCsrkf9aBtXWC2kVTp7XcJbHUxhp+hWt9tJfUPrwrba",
	"bC7byvrxMmJrdzl+uzWno13XnJbBvSq0qG4xsPUukh4C2x4IbBn+lyzUjICpXD3o1YNePejVg171kkeJ",
	"imaYS2Xrka1dRbYSLqnckdqiVyp3D1ituEQb9/welXrI1dGEQ6l8PfTUQ09Pl7/jBgHU40s9vvRk9Zcl",
	"MSSjy/SwUQ8bPRBsVMLWiet25aS7BilKnMorP9jLQEUBZauc2FcEZZLu9K5sNszVNn9shqnznFsDSeRY",
	"t1NMwm6po029qol77erllW70LZhNwgPwTrVEbEQqcuy1ZqgipQVIYrYHqihZu827zrrBig0N7tG2rJFK",
	"uCI3S53gFd1NVWd4xQb2goaW1oFYVOwM37aay+MmSbS7zL1zGs7Rjmg4bbGMgrbTEZjRyZLoj31bAWa0",
	"4ewWQMZ6XdIsi0Xssm1Ivnk5DbKzY4wCj4MxZVnTEUNjJFwfhNRDQfosVEdmg54HhE85SqKcJdxeQV1S",
	"WY4+LFCoVgcicWhzl+SM1F4l5ojtSRbMA0lpAmQMzu9p+LJRlGazK7UNOLMZYKZjlWXt6soDgzGbZZFS",
	"Od4afukKeuHbh7q0AFw6A1t4V8rcNu0jmwCRNi7+67GjbnEj/qQgo83ARV1BRRuGiTbOx3XoEN9J9t0J",
	"7epoa7WrZaGf7mEf3iM+PeLTyMYhElAu/GqOPTc5lokc5UUUP0DcqEfo9rispPrfUrY1PbxkHwss/sq4",
	"JTkgdIwwVZRVsvjhnUnLtboZcZLIjRpUKhEcnYJSspGOVKZi1fdSl/KVbRSIkk1vlCHKtpdGCCrhljUj",
	"UB69oUBSsT0IVG7p1W7Z68af1j2Y277RdCnzN76qK9GnhNs6AZ86Wb+dgU8d7kYVLawDdCrsTd+2jGvj",
	"Ggm5k8y6tTrT0RbqTG2BpUx/6ghX6nzz73Glp4grlfMwQWJG2dQJqNvkQPpCZ32f5HzSUa5KS5qePWbI",
	"ZyPcWTrTnTPoAivWQBZFCjuFLoqNdbQl1zVzr+25uuKNwhtFMh6Go2plXyP4UezDmkGQhCKQkrQ9aEj5",
	"8m6106wbHtngMB9t2fKpBBeK5HUCMnQ7cZ2hDRvaQFq0tg4UomY7+bYL/B+3kFi7zfY7rTAd7ZzC1Bb5",
	"WFSeOkJAOlsvPRSyFVBIE5tTod9b1bAyFZnzj1YYiN2fzXmIwdyBrsC3aCUnsJg7ISQeFJTNV62AYzIJ",
	"mpvvzX0eC/Zjc3b3KzFZanVYj6GoW4zHNNKVqlJS/f1UlIUKN4vlmOY3yyGlMroZszG0rhurkRRsmaea",
	"/HKs3fnWjsl0P5xHT5z9q7EXQ043mEsnE9Md1tKtIK9pZS3YyqJY/7aNfBzXSJbdZN+dUECOtlYBaY2B",
	"pMpIV9jHuvm9xzy2A/OoZmNez65LGHrAWPjlHnAbD99G5mcFpUyCwvwyEFidzduGXfKwcEyR9dWIvNUC",
	"NnlYrDgoiAg27wgu6mM07UUM3xbZ7mEiHMl1tjk5wMtkQHqOrhYEXZz5+BM57m1uZmqPebyzMx5/Mse7",
	"7o92XRzrNnik2yivVh3l+M6xaIe8uVamLHDjpo9tD7XH4TFutnG2sz1pA+f+XXr1c8HN+jqsKCtQGAWN",
	"2mdFYUX3o7gsLCyXTaztrMn6W8MsX9dXh1lL3cn/8jbuuxGU1fqt45tDa/42zi6VW0Kba8Qs+/rvErO6",
	"t+o6sbBWmzfdDs6Yax/a7dvfOj49P+SKrztOZxm7OlZ3s6y7PF53vpc1NbWmA3fLnW2b+DxuEq47y967",
	"oKMd7YaOtsRNq62vdXfd2r160d+4PtEb1yq2pvBnQ6LNv3liPkSIHEf4Z6AzKqVSsdzx5dkBeK3uMoEL",
	"CRghwFGAXIE8cIshMAMHCJpQgVXzB1/IFzIA/zw+f/8C2KN5S7wDCvEBjRCBEZaZfh1+uKjN9IOagv3C",
	"cvsAfx4qQqsV+FIvkvpO1maQRIs1zcxhGJSosHVxSEqrg+O9/T3I1D8D76v8vxIDUP45kuSOZMGRbHMk",
	"s4343v6eC+U/6i/ZiCc/PZnZ46O9/T0UyH+I+mcAY/3/ifqFyn+4+megmkV84OrEQXin/0+w/r8aLbVO",
	"kKxjDJUjK/mPLDiWLU9k2kRKkols05clfJnFl1l8RY0vC/syN5a5ldzBslNYtoslMUoW3Mhfp/ofWW46",
	"lf+E8h/ZlanMPZXVBPLXQBYJbvf290KZL5TNhzJfKFsO1djLfESSROSvRLEHVxwg/5FpkRK5YqCGlskW",
	"mKSWyyq5zMD/lP8oVIsNAijUMwnZKp/tyUUl/1EX9rJDSrwKWVbIEkKddTzZg1gmxjIxlhN7K4foqz/w",
	"IeHpX2U+we4thqDnYfkTDC6ZXBoCq3qysxYdmbDeea2jsLo6qfSH9ZGrluOKNXUhcPf/bctcCn/OS1pz",
	"FHZghB3uQuK4lIzxJGZNNwGXuuBxhIcuJCe5Uv3FwLrtMFaH0Tlit9hFzhTNnR9XMZWxK/jpvhX8vEoF",
	"gtIgz5ePQGFK+P/ybIH/N6M+NazcGui/bul2ehNQM2ZdYSntWrwfpNKmjY2+Pqqh6DHw5RLbT+OtQx0v",
	"r/kSIqMVYAcoakGO3O25mGgjW5bWCtZ9c/Fw83G0Kyu18m6gbp47uSrY6GR3dn3wABvgUg2v42qh3Xb4",
	"bacXVbyk6OzXUq9FbtwWccu0yLb3IvUaZUfXJJtakv3VyVZcnay0OiaMxlEzovdGZWsP4alqnVX97/T4",
	"31MynFJznQtiy2iA7m8g3Mg+m4T01ALY7DrWS7MZstNrcxMYnWqpW3VqoYl16E+FSh8CdlMkPADvVIv8",
	"tiiaZq+OYDOgiNk+jMxau83balcY2FoHd3t3oQ1AeQ+1+pugOs1/nWJzna7wX46eP4IVXofc6BF+KkPb",
	"aw731hyOdkRzWBI5SbSIjqGSbre8Hhd5yrhIHWeHSM5sMw5yrvP1tkxb/8hZaY/reuu8KhImW39UMIjm",
	"/82uW7M2m4EQszg3gYToprpVaBbbWIdGU6z1IcAQTcNDcFCN6G+Lhxgu6woQ0eRsHyJir+IWO2xnmMha",
	"x3drt7MNYCIPJwSaUBHDgt3CIp2u8wfERXLDHDeu8yczur0qsQ5V4mh3VIklAZJUregaIel2A+whkqcM",
	"kdRytxyNtvYi1/MI9TYjPc7S8rZO+9hem+GI4tTHBJuky2Gzy9lasc3oSbZkNwGgpK11q/iUNrMO3aek",
	"4odAUlIyHoqpGvaJtqBKxnxd4SqKqm01Nyku9HZbc2cYy/rHesv3sw3ALQ8uKZpQl4wvuwVeuhcED4i+",
	"LAx53EYQPK2R7nWSteokRzupkyyJztj6SdcAzQZ2zx6lecooTTtub2vSIlm7N2vZCbOWnFq6NtuWVmjL",
	"UzFwyVbDA6zp1pYu1prdFFiziWuq8nbWpRo9BsuXjI4HY62m/WIZyKZjWxitCW2rRczCkm+5S3cM2+yi",
	"gcyKG+OGYJsHFhhtgJuNmMxsQBw8NHTT1nrGGvMnNti9krJuJeVoV5WUFTCcjVnZbGIv7VGcJ4/iNHJ8",
	"O/xmCeTGVedFb20xvl2GBXZh4NT4I26MzLciejBF89bNbnrplJVU/2vwddzDWNXauo6Uj7+qNZAgoPt7",
	"6SJaGcqKlQ61wqLYNDS1eRHVEo3aGA7VvXLXhVr38KjT5rmmckdbBmHqFFvaTkypHZjULYy0I/DR/Tek",
	"DUFID7JnNKJGG8CLnpIH6C63t9qG1ujhubDZfdti9m6A5/jucvVOaWtHu6CtrQC1bQhk68G1Hlxblasn",
	"iEjmRQ5DEWVCsXXzSfeNKXWlCqXn3l2T8rr7yWB8iDp0td/U1L3kfn3lnWow+aYfw+pohpuXgJpHMccE",
	"ce4kGLHswwqh3sog6+QEtrf/4/5P+z/v/7L/fP+v+3/7fb8ctyNxEMBRgJLl0rJlezJWIBzdCcQIDBwY",
	"exgRFy2JUp8rvg6QlhYchHCuA9fKwRfIA6M5cGkYQrUXoLsooB7aezGGAUf7bYD29EBbFBrFc+r+Hhfz",
	"IIk9u1eJ4xPZYSQc6LqIczwK0Er3AQEeI3fuBkui5U8F1b+gAlzDCZAlVeRhiFWg1dLaqXAEnCzXwIlk",
	"CsknSPNJYGATdAddAaQ4AIQKEDHEERGAEpBdo7RhI0MUr2WmKsyjhJcKQZyZh1TRdsTQeoxmUCGGBplY",
	"GZQt1IFaK4Nylh7YHDowHDCgDE+wlBSDKIBC9U7+zajnkDhEDLvOhEEVCVmnGrOj7MNxkrrSJ/mQQMl+",
	"i0mOM8aMi6oSjhNA61eGbhGJ1Z8CwdCu1/4uVpr/LVejQK5P1NWfYmHFPIuJixUuZMjXqoc9u5EZKBth",
	"hlzKPMlwFdOZzWbZZOqozqVTac+kISKdR2saS2fRnsTFOVycwvoZrJ3AbP4K01cze9WTVzZ3TVPXMHN6",
	"4rJ5y01bMxLaKBUeRdDdlDOW1gUsVlpCkD8tvHtxQeTZn6FJHJhoNPt7PIALAXwXeLvIpu3ueLtWo0qF",
	"wXrUqo2Qbmbo6VCc56OnQXeB2ztTurOdYUGwkNhY8S1K05bqZweqZ8vh606/XP9UF8TW0+DPMh3giVDe",
	"8TG2zBxo/YBD16NU0JvXMFybtHbaKF7cwshpIwZO3V6Xrfuq7GGNmjbKHGVIaVszpo5MmLbOeKnZbqkr",
	"m6XeWunxnN42YBC16W2l1g6qUxuop2T9tBHLp46snjZr8bRp/q0xdOK7yLZbr6sdbaeutqQRU+cGTL3p",
	"Um+6tBwHL22wtAljpd5MqTdT2sBKsI4f1aL7KsvU3k7pnlY+j9AX2lN8fLoRuZ7xx2aEun1mroYYLa7t",
	"FGXM2ulMApY1cE+5t1jlRuHGjIBNs0uF8GvEHS12WjP0mJGxPehjcYk27SvrxiA3MKZHW7AYKnE0a2o6",
	"gdK6mZ/O0LTOZXxtO+vA1Eol/rdtZeq4XtrsJi/vkKJytOWKSlvQLae0dIS7rZ39e+htK6C3Gm7GYUSZ",
	"GHAXkhzalifnyuTjAAKZFWh8TvIjBZAAdIe5UGyIuDj4Qr6Ql3NwdvriCxkAfeIDEBjIDjyjDMQc5coZ",
	"SOR7uwABr8gETlCIiGyJYw+piTZ5ZdYzRVWBKEg8MMbEU5mxJ5lV/nWNuCpzyeitrgpzgDXv/CHp/gOk",
	"i9D04AKGiG+uE4Z+zdwzHATATZotEv9Hcn0tufuP3C8obS/7UcNpMHiRZZM9dgQWwf/H3rUsN25j0V9B",
	"aZONndJ8wCw8ncrEVamOq+2u2fQUm6Igi2ma0BBgd7zQv8y3zJdNEXw/8KCIC0ogVymnIdxL4NwHzsUj",
	"a/ElfozzAaEBjv0kJOgXfMABQ7+QP0muS0TIN5SeqrFEu/fyS7Ie92iPmR9G9Ocv8eMBxaQlAuV0Km94",
	"x38W+dk/c8A0x6XWPpe6wyg4EopjtPMp3iMS87nmVXwOtH8dcYxSmo1/9rkUvZMUZWiIMMsRwIcXJ8hP",
	"GXnz+ZGK6L0c2np26F05ufkeheIPj5+J/RLv3gspX7N+vPznvPCP/2J/f0lS/LXWZ6gNHwOaKUXQV96+",
	"UjUD0tc93qeVc/FI7NVD8TV3dZQlYcBQqyE6kORLXHzjHv0axvswfqXlvooY/6i+dd/42MxLduNT3slz",
	"4McaJM3EVOKxkjUb61GrYMMBN/xsxwWTSHYJ4qfsn2/63YqVqxVxtSSydN8dx9gQ7CqqTYw943QQifAt",
	"EEEkwrNMTG/fmcQ5PEf+h1ZTncXEmsJPttzn3x9a427HivvIkJRcetAALbx0BwSI1ZCJmZSQiDu2mpR0",
	"1ZgJU3JvpCzP9KBnuEhDI+R7qKWVO9UagZHruX/TsdrmSG9dsyJhQac3bSBlHeC5A6vvWAolGtJM1Hok",
	"geW8CBNIdfzWwpG/6Oxp63L2RGI/+U+6w15IaSqjeZ7Llo+8oVHCR/CyxLVdPXWFt6FQ5rOUXrJnsncB",
	"xSwPK7RRZWmV2sG8bI3aBj3sCrUlC8rDCoVM86+Cbu2uTVtKzIIjmWdVr0rbYDO9Jq30QVwhhxakQ/as",
	"E8OML0ZtDfHWJZsRr0LbswWzBgWcMrgFqI1IoZRlZPEpihtn5zGfqv3TkqG+0Gxou6hsSHdnYi8zAtqd",
	"CGQi6x5FJ/Yo6iKcJX5MQ1VhvGz+UrfW51QO+SYq7/Ll/xVuw7lGeqU95RP7mEDW1CC5Ns6mxq9tK2wO",
	"igaF0zA0izxOLdVKDjMszmA2MyRgRpanVmc+5CmDgD7z08AoMP3joVpDF6mgrnPQDsLQpJCVgd86bG5q",
	"vqgxm1ZII6gptUQggYeoEVLNk0qDAeu8NItJNb3faihrEmednLqdJG40YdVK6CyxVgBWtjJYjjFYYvCz",
	"dOcV9JKMvmLprjzJN+Karzy21APVurh/Y+tRwJX70uKt8HecXPheJD9SewVMVY1SSwbWtB4ZKdUwH1gy",
	"qhaUy4FKYGRypmUu4p7t8k5dPeyjSeim1QRTA2+miaVME1So4hCT1LNkZRw0zhxZGdkthIXM4mkFrFBj",
	"hmDYIKhpgqN/6iEBZnyGBRkheYa6huV1ZoZ3qnA/i0U1PJwhcDwMYKskzJyAlucy2jxLK6+B4lcATGEl",
	"VNwgVCSofqcMv3kUM9alUtoa/SOTxh8BTUiEyHecoGf+W/Rc/PZn9Jli9FO4/wn9jT9h9fT55Q49Pbx8",
	"+O1//60MgvYuTMq7KXtZb96wwzn0Bx0ehm2syYFYLRarhHkePMIk4/nHovJrbyMfb40LcEoulGUkKxf0",
	"DpuYt4TOYW1Vdj6PJS3ZhKzYDpDRLNRaGrGJv09JIvIayo6evzRaXUcWY+bGwI+EId1X4GPCPICX4FFM",
	"GDolmOKYIRLnT6Fqvm5dqAT0RPxV1MCKO2zHZrWLetlf9PD5RQP+HSdUVdW1ksY/nE4PsR+909BSDt90",
	"hZLKYdMXglYOGwMAFFUFEiaF1ME+rdYJGxpYB40osirrg01UGa4P+qeTh/xiRNypD/bMVZm5mC4P2hnY",
	"rROGIawONicIhJAAmyUwNgLe8csFmeAhhsPA2V10pwrns1hQLyuN2bqfxuiWBtspDVBpEMIQ1tKgE6VB",
	"GaYp84rXimT4pSx/AGTEButd4sfBUYcoGvx1GkZ7b3h3tOq3AXl7C5l39OlR9fOKoMhNQXK/AfX8wwEH",
	"DO+lZEUFptEkk/Mbu9vify/4okOIoz3lBYdK9CnBB8yCY04BojCmzI8DnL805O/3iB0JxeWrPaXJCrQr",
	"OxueNhynb5mJDM1yZhybf9+peCjhxnNML2P6GkZZFvQ9P+APHRX/bXVbfsKHzd3m4+Zu82lzt/mc6R2n",
	"UeTvogrduhvmJeKLt5HEByfuWfg24vSETFbx921zd7XrtOXqa4cupe4qjw7K3NVygDLeYQGTEt6hLs+Q",
	"NF0t0Do+RKmABktXAcgwScf1KN6hc4mj69ilKtEyTdEBDKvLMR0yOMxo7xLysUIeCPcIZdVg1CN45JLK",
	"MUE8asYxV3Cdyv3pUuHscAa2dT4D0ycYG9kYEL9oI4FY6cXbpBeliM7GQUEu8lejXdpO5yCwynmyiCmO",
	"HAWLwaEDzmFkUgDjZ7f7ydGz3aHVTUeleMsYGfY68iebK/zALLb5q/vXvxlmpgmTLkX5rAAuRE1PDegy",
	"FND5SKSYWoJ2XNHZSSSnMu+yTAAvImxuHQubijx9RPnfD1jqR15RDhyoFo4rFPqn0KOBH7dfkLwom7+J",
	"jQlDP8fxq/+K3zKojVvmapy9aZy7qQ+a6BzfqJXyvOKXHj+K43m9ZZOxAznjPqg1bmO/Cfp4ytVfADj+",
	"4NY4AMWEedcKos6HjQZS99vgjqit5/dag6OxrysmDFOgvVx/JHuc5HtXdL6eyOuY98Lgd9+KZfeN2HTf",
	"jjX39cad+xaK7yPs8//L/OQVZ2ht/kWZn/BWVc7A/yhu1LxPeWLLf1BvuBEq29K1oWpb01rRlp6Fmi0t",
	"O0o2dSxVrDUsFVTXfm/kOChOgsynZKkk36KxngsdF3hbUDK0m60NSINb5EQvZKv3Eipvv72FHXT2OGcV",
	"3QxPNYPejTssYPK6edbbcGsF7EGkt2zW2jAHsVXOrS1yir1xIET9jVD0Vv2fmJmHY+Vvho+H5+IheHiL",
	"HLxVqIqod7o0hAJC0ygmO2C0TbLPnST4QYBPzEtC+i1n2yXJ5gNv+ylrWuWdDqG5WtFJT//yMcD7bBQq",
	"2PTPYI2Fu1HZSnswKM14bq2lW6ZTrp8fB3hYrflsasw+SdgdkuvOyHVnpC5qD2Gk2hhJf83aLHjV80L4",
	"CFwJ+cN1uc1IPO0OkP3+I/6Rff0fpxnf284UmNtoX3HMmW0vwSeSMFUG98+i+Sfe2sUkTpo18K8ux6CL",
	"HaNLFJWoSfiXdw66nm6Lnhv9vGiqCFkfszaLDll8BK4kZHFdluZ38niVfTqoz5GJMRBvhzq2Gm8zBebx",
	"OIRE7f0DMqdDSPSh1XbELsWUHTN058PTL7OWWzAenh43d5snn9IfJMkw/vz824QrVq5w09ctnnsS1bwz",
	"9FxcMU+T6AqK3l1MW1qv9u1OFl96hgdbHO+KgyK7ZXKmMd/inu1WzLt6zIUshctXF9V7CDRdYc+0Qi21",
	"HCq4C6xdM8oaT/EtjvXWPVsSV+17MwdTwoedPriKvqWwoiPOSK1fEmTOCzGEVMuBLRz/S8+ntsvMp7Rr",
	"pQO5FVThFMx01jqqG3VULbSXJ8eG3rntY/spby1/knYlb671mTMh8TP9gHAJpj9xwC486Xs1JNIQyu2Y",
	"a9caFURSR1FwJqkjDzD3kUianP0I+7bOJ3U0mQ9kyqigxSp1PgeEVio1A3ne9gqopUEPoBuPYdgle0O+",
	"ddO6pCxTR0tAmgl0HkGpJjtxR0+gKbpJHIXOC7KLVM+xreaw5l8uW4Je/jWGherlYqA0FJQtrVSUO1SU",
	"BuxVtx4TEkluPR4a9eZXXUBJrLTVDd21XKDDIqSVdy2XgAVnZiAvjRzofnIOMOddy4V4yxgZ9nVavAqH",
	"EAibAnrb8jwESm2T8hgCw5XcyvXV89iAlAgBvL4aZGpAGQ8L11ebduvCfsEJjXmQnMq8yzIBvIhMZOtw",
	"JjKGYSiyElBewSDkVyrBHSphAMkpxYnH7+UMmBfGByLhET5TnHzImz5mLUe8zx6R4JuH/8JBKqIUdoRE",
	"2I8lF5rjKPJiDr5LKIkDSQLsnYpTVV6CBVBQ6vEasmO687KBG88fOP/w+uA2myOJsebUXfUjr9mcT3ik",
	"nUZ+8I0D58KdPnUHOsgzekUr+xEyhpNJwvnwze99O27Mjv/t+1kJ/9V1tKA0WEcYUA4qkTIpFRX2a5Ub",
	"62gxE5zkYV1JmXVRZ5g5y1RChUooU8kdAk1g3FpJlGk+DWqYXYnNkCHmOtyAkC3sQg+ENAQ1czDu0E4Q",
	"VAszwSSKQ+J5CdhPNZzuoiG/3IRvu7yET5eZ7Cd/QASltfxk5SlvkafUwvkpIYcwwnI0P+WNGvk1qDco",
	"xFkaoWIE+mOjoG9HcLb4zQ+ji5jWMKHMu5Qk0tg6Nvgz6vkBC7/jizjdkHo0PeFExFApO4h8zU9e6eCN",
	"FoVojQm059ZUjB88zQeY6hnN72Zk8exBoee4tQg6CFbOLSJOwb2BEG43sHXNLrilHBQc8XQzXBM8wQTB",
	"KlmkkqxCVUQZ0aUh1NkkYetUkjCG1IFlclbyZiVvBlB7Pv8/AAD//xts6i3oJggA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

